import{g as sC,c as Xo}from"./commonjsHelpers.042e6b4d.js";function rC(Yo,Zo){for(var xa=0;xa<Zo.length;xa++){const hs=Zo[xa];if(typeof hs!="string"&&!Array.isArray(hs)){for(const g in hs)if(g!=="default"&&!(g in Yo)){const ut=Object.getOwnPropertyDescriptor(hs,g);ut&&Object.defineProperty(Yo,g,ut.get?ut:{enumerable:!0,get:()=>hs[g]})}}}return Object.freeze(Object.defineProperty(Yo,Symbol.toStringTag,{value:"Module"}))}var em={exports:{}};(function(Yo,Zo){var xa=Object.defineProperty,hs=(ut,ti,tr)=>ti in ut?xa(ut,ti,{enumerable:!0,configurable:!0,writable:!0,value:tr}):ut[ti]=tr,g=(ut,ti,tr)=>(hs(ut,typeof ti!="symbol"?ti+"":ti,tr),tr);(function(ut,ti){ti(Zo)})(Xo,function(ut){/**
* @license
* Copyright 2010-2022 Three.js Authors
* SPDX-License-Identifier: MIT
*/const ti="141dev",Jo="srgb",Ko="srgb-linear",Qo="300 es";class Ji{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[t]===void 0&&(i[t]=[]),i[t].indexOf(e)===-1&&i[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const i=this._listeners;return i[t]!==void 0&&i[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const s=i.indexOf(e);s!==-1&&i.splice(s,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const e=this._listeners[t.type];if(e!==void 0){t.target=this;const i=e.slice(0);for(let s=0,r=i.length;s<r;s++)i[s].call(this,t);t.target=null}}}const Re=[];for(let n=0;n<256;n++)Re[n]=(n<16?"0":"")+n.toString(16);let im=1234567;const cs=Math.PI/180,ba=180/Math.PI;function ei(){const n=4294967295*Math.random()|0,t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(Re[255&n]+Re[n>>8&255]+Re[n>>16&255]+Re[n>>24&255]+"-"+Re[255&t]+Re[t>>8&255]+"-"+Re[t>>16&15|64]+Re[t>>24&255]+"-"+Re[63&e|128]+Re[e>>8&255]+"-"+Re[e>>16&255]+Re[e>>24&255]+Re[255&i]+Re[i>>8&255]+Re[i>>16&255]+Re[i>>24&255]).toLowerCase()}function de(n,t,e){return Math.max(t,Math.min(e,n))}function Oc(n,t){return(n%t+t)%t}function Ma(n,t,e){return(1-e)*n+e*t}function zc(n){return(n&n-1)==0&&n!==0}function nm(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function $o(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}var Ie=Object.freeze({__proto__:null,DEG2RAD:cs,RAD2DEG:ba,generateUUID:ei,clamp:de,euclideanModulo:Oc,mapLinear:function(n,t,e,i,s){return i+(n-t)*(s-i)/(e-t)},inverseLerp:function(n,t,e){return n!==t?(e-n)/(t-n):0},lerp:Ma,damp:function(n,t,e,i){return Ma(n,t,1-Math.exp(-e*i))},pingpong:function(n,t=1){return t-Math.abs(Oc(n,2*t)-t)},smoothstep:function(n,t,e){return n<=t?0:n>=e?1:(n=(n-t)/(e-t))*n*(3-2*n)},smootherstep:function(n,t,e){return n<=t?0:n>=e?1:(n=(n-t)/(e-t))*n*n*(n*(6*n-15)+10)},randInt:function(n,t){return n+Math.floor(Math.random()*(t-n+1))},randFloat:function(n,t){return n+Math.random()*(t-n)},randFloatSpread:function(n){return n*(.5-Math.random())},seededRandom:function(n){n!==void 0&&(im=n);let t=im+=1831565813;return t=Math.imul(t^t>>>15,1|t),t^=t+Math.imul(t^t>>>7,61|t),((t^t>>>14)>>>0)/4294967296},degToRad:function(n){return n*cs},radToDeg:function(n){return n*ba},isPowerOfTwo:zc,ceilPowerOfTwo:nm,floorPowerOfTwo:$o,setQuaternionFromProperEuler:function(n,t,e,i,s){const r=Math.cos,a=Math.sin,o=r(e/2),l=a(e/2),h=r((t+i)/2),c=a((t+i)/2),u=r((t-i)/2),d=a((t-i)/2),p=r((i-t)/2),m=a((i-t)/2);switch(s){case"XYX":n.set(o*c,l*u,l*d,o*h);break;case"YZY":n.set(l*d,o*c,l*u,o*h);break;case"ZXZ":n.set(l*u,l*d,o*c,o*h);break;case"XZX":n.set(o*c,l*m,l*p,o*h);break;case"YXY":n.set(l*p,o*c,l*m,o*h);break;case"ZYZ":n.set(l*m,l*p,o*c,o*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}},normalize:function(n,t){switch(t.constructor){case Float32Array:return n;case Uint16Array:return Math.round(65535*n);case Uint8Array:return Math.round(255*n);case Int16Array:return Math.round(32767*n);case Int8Array:return Math.round(127*n);default:throw new Error("Invalid component type.")}},denormalize:function(n,t){switch(t.constructor){case Float32Array:return n;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}});class V{constructor(t=0,e=0){this.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,s=t.elements;return this.x=s[0]*e+s[3]*i+s[6],this.y=s[1]*e+s[4]*i+s[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),s=Math.sin(e),r=this.x-t.x,a=this.y-t.y;return this.x=r*i-a*s+t.x,this.y=r*s+a*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class De{constructor(){this.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,i,s,r,a,o,l,h){const c=this.elements;return c[0]=t,c[1]=s,c[2]=o,c[3]=e,c[4]=r,c[5]=l,c[6]=i,c[7]=a,c[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,r=this.elements,a=i[0],o=i[3],l=i[6],h=i[1],c=i[4],u=i[7],d=i[2],p=i[5],m=i[8],f=s[0],v=s[3],_=s[6],y=s[1],x=s[4],b=s[7],w=s[2],M=s[5],T=s[8];return r[0]=a*f+o*y+l*w,r[3]=a*v+o*x+l*M,r[6]=a*_+o*b+l*T,r[1]=h*f+c*y+u*w,r[4]=h*v+c*x+u*M,r[7]=h*_+c*b+u*T,r[2]=d*f+p*y+m*w,r[5]=d*v+p*x+m*M,r[8]=d*_+p*b+m*T,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],s=t[2],r=t[3],a=t[4],o=t[5],l=t[6],h=t[7],c=t[8];return e*a*c-e*o*h-i*r*c+i*o*l+s*r*h-s*a*l}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],r=t[3],a=t[4],o=t[5],l=t[6],h=t[7],c=t[8],u=c*a-o*h,d=o*l-c*r,p=h*r-a*l,m=e*u+i*d+s*p;if(m===0)return this.set(0,0,0,0,0,0,0,0,0);const f=1/m;return t[0]=u*f,t[1]=(s*h-c*i)*f,t[2]=(o*i-s*a)*f,t[3]=d*f,t[4]=(c*e-s*l)*f,t[5]=(s*r-o*e)*f,t[6]=p*f,t[7]=(i*l-h*e)*f,t[8]=(a*e-i*r)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,s,r,a,o){const l=Math.cos(r),h=Math.sin(r);return this.set(i*l,i*h,-i*(l*a+h*o)+a+t,-s*h,s*l,-s*(-h*a+l*o)+o+e,0,0,1),this}scale(t,e){const i=this.elements;return i[0]*=t,i[3]*=t,i[6]*=t,i[1]*=e,i[4]*=e,i[7]*=e,this}rotate(t){const e=Math.cos(t),i=Math.sin(t),s=this.elements,r=s[0],a=s[3],o=s[6],l=s[1],h=s[4],c=s[7];return s[0]=e*r+i*l,s[3]=e*a+i*h,s[6]=e*o+i*c,s[1]=-i*r+e*l,s[4]=-i*a+e*h,s[7]=-i*o+e*c,this}translate(t,e){const i=this.elements;return i[0]+=t*i[2],i[3]+=t*i[5],i[6]+=t*i[8],i[1]+=e*i[2],i[4]+=e*i[5],i[7]+=e*i[8],this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<9;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return new this.constructor().fromArray(this.elements)}}function sm(n){for(let t=n.length-1;t>=0;--t)if(n[t]>65535)return!0;return!1}const e1={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function er(n,t){return new e1[n](t)}function wa(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function us(n){return n<.04045?.0773993808*n:Math.pow(.9478672986*n+.0521327014,2.4)}function tl(n){return n<.0031308?12.92*n:1.055*Math.pow(n,.41666)-.055}const Uc={[Jo]:{[Ko]:us},[Ko]:{[Jo]:tl}},pi={legacyMode:!0,get workingColorSpace(){return Ko},set workingColorSpace(n){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(n,t,e){if(this.legacyMode||t===e||!t||!e)return n;if(Uc[t]&&Uc[t][e]!==void 0){const i=Uc[t][e];return n.r=i(n.r),n.g=i(n.g),n.b=i(n.b),n}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(n,t){return this.convert(n,this.workingColorSpace,t)},toWorkingColorSpace:function(n,t){return this.convert(n,t,this.workingColorSpace)}},rm={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ve={r:0,g:0,b:0},Ri={h:0,s:0,l:0},el={h:0,s:0,l:0};function Fc(n,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?n+6*(t-n)*e:e<.5?t:e<2/3?n+6*(t-n)*(2/3-e):n}function il(n,t){return t.r=n.r,t.g=n.g,t.b=n.b,t}class nt{constructor(t,e,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,e===void 0&&i===void 0?this.set(t):this.setRGB(t,e,i)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e="srgb"){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,pi.toWorkingColorSpace(this,e),this}setRGB(t,e,i,s="srgb-linear"){return this.r=t,this.g=e,this.b=i,pi.toWorkingColorSpace(this,s),this}setHSL(t,e,i,s="srgb-linear"){if(t=Oc(t,1),e=de(e,0,1),i=de(i,0,1),e===0)this.r=this.g=this.b=i;else{const r=i<=.5?i*(1+e):i+e-i*e,a=2*i-r;this.r=Fc(a,r,t+1/3),this.g=Fc(a,r,t),this.b=Fc(a,r,t-1/3)}return pi.toWorkingColorSpace(this,s),this}setStyle(t,e="srgb"){function i(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let s;if(s=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let r;const a=s[1],o=s[2];switch(a){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,pi.toWorkingColorSpace(this,e),i(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,pi.toWorkingColorSpace(this,e),i(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const l=parseFloat(r[1])/360,h=parseInt(r[2],10)/100,c=parseInt(r[3],10)/100;return i(r[4]),this.setHSL(l,h,c,e)}}}else if(s=/^\#([A-Fa-f\d]+)$/.exec(t)){const r=s[1],a=r.length;if(a===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,pi.toWorkingColorSpace(this,e),this;if(a===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,pi.toWorkingColorSpace(this,e),this}return t&&t.length>0?this.setColorName(t,e):this}setColorName(t,e="srgb"){const i=rm[t.toLowerCase()];return i!==void 0?this.setHex(i,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=us(t.r),this.g=us(t.g),this.b=us(t.b),this}copyLinearToSRGB(t){return this.r=tl(t.r),this.g=tl(t.g),this.b=tl(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t="srgb"){return pi.fromWorkingColorSpace(il(this,ve),t),de(255*ve.r,0,255)<<16^de(255*ve.g,0,255)<<8^de(255*ve.b,0,255)<<0}getHexString(t="srgb"){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e="srgb-linear"){pi.fromWorkingColorSpace(il(this,ve),e);const i=ve.r,s=ve.g,r=ve.b,a=Math.max(i,s,r),o=Math.min(i,s,r);let l,h;const c=(o+a)/2;if(o===a)l=0,h=0;else{const u=a-o;switch(h=c<=.5?u/(a+o):u/(2-a-o),a){case i:l=(s-r)/u+(s<r?6:0);break;case s:l=(r-i)/u+2;break;case r:l=(i-s)/u+4}l/=6}return t.h=l,t.s=h,t.l=c,t}getRGB(t,e="srgb-linear"){return pi.fromWorkingColorSpace(il(this,ve),e),t.r=ve.r,t.g=ve.g,t.b=ve.b,t}getStyle(t="srgb"){return pi.fromWorkingColorSpace(il(this,ve),t),t!==Jo?`color(${t} ${ve.r} ${ve.g} ${ve.b})`:`rgb(${255*ve.r|0},${255*ve.g|0},${255*ve.b|0})`}offsetHSL(t,e,i){return this.getHSL(Ri),Ri.h+=t,Ri.s+=e,Ri.l+=i,this.setHSL(Ri.h,Ri.s,Ri.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(Ri),t.getHSL(el);const i=Ma(Ri.h,el.h,e),s=Ma(Ri.s,el.s,e),r=Ma(Ri.l,el.l,e);return this.setHSL(i,s,r),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}let ir;nt.NAMES=rm;class Nc{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{ir===void 0&&(ir=wa("canvas")),ir.width=t.width,ir.height=t.height;const i=ir.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),e=ir}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=wa("canvas");e.width=t.width,e.height=t.height;const i=e.getContext("2d");i.drawImage(t,0,0,t.width,t.height);const s=i.getImageData(0,0,t.width,t.height),r=s.data;for(let a=0;a<r.length;a++)r[a]=255*us(r[a]/255);return i.putImageData(s,0,0),e}if(t.data){const e=t.data.slice(0);for(let i=0;i<e.length;i++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[i]=Math.floor(255*us(e[i]/255)):e[i]=us(e[i]);return{data:e,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}class ds{constructor(t=null){this.isSource=!0,this.uuid=ei(),this.data=t,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const i={uuid:this.uuid,url:""},s=this.data;if(s!==null){let r;if(Array.isArray(s)){r=[];for(let a=0,o=s.length;a<o;a++)s[a].isDataTexture?r.push(kc(s[a].image)):r.push(kc(s[a]))}else r=kc(s);i.url=r}return e||(t.images[this.uuid]=i),i}}function kc(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?Nc.getDataURL(n):n.data?{data:Array.prototype.slice.call(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let i1=0;class Gt extends Ji{constructor(t=Gt.DEFAULT_IMAGE,e=Gt.DEFAULT_MAPPING,i=1001,s=1001,r=1006,a=1008,o=1023,l=1009,h=1,c=3e3){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:i1++}),this.uuid=ei(),this.name="",this.source=new ds(t),this.mipmaps=[],this.mapping=e,this.wrapS=i,this.wrapT=s,this.magFilter=r,this.minFilter=a,this.anisotropy=h,this.format=o,this.internalFormat=null,this.type=l,this.offset=new V(0,0),this.repeat=new V(1,1),this.center=new V(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new De,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==300)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case 1e3:t.x=t.x-Math.floor(t.x);break;case 1001:t.x=t.x<0?0:1;break;case 1002:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case 1e3:t.y=t.y-Math.floor(t.y);break;case 1001:t.y=t.y<0?0:1;break;case 1002:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}}Gt.DEFAULT_IMAGE=null,Gt.DEFAULT_MAPPING=300;class Ot{constructor(t=0,e=0,i=0,s=1){this.isVector4=!0,this.x=t,this.y=e,this.z=i,this.w=s}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,r=this.w,a=t.elements;return this.x=a[0]*e+a[4]*i+a[8]*s+a[12]*r,this.y=a[1]*e+a[5]*i+a[9]*s+a[13]*r,this.z=a[2]*e+a[6]*i+a[10]*s+a[14]*r,this.w=a[3]*e+a[7]*i+a[11]*s+a[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,s,r;const l=t.elements,h=l[0],c=l[4],u=l[8],d=l[1],p=l[5],m=l[9],f=l[2],v=l[6],_=l[10];if(Math.abs(c-d)<.01&&Math.abs(u-f)<.01&&Math.abs(m-v)<.01){if(Math.abs(c+d)<.1&&Math.abs(u+f)<.1&&Math.abs(m+v)<.1&&Math.abs(h+p+_-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const x=(h+1)/2,b=(p+1)/2,w=(_+1)/2,M=(c+d)/4,T=(u+f)/4,R=(m+v)/4;return x>b&&x>w?x<.01?(i=0,s=.707106781,r=.707106781):(i=Math.sqrt(x),s=M/i,r=T/i):b>w?b<.01?(i=.707106781,s=0,r=.707106781):(s=Math.sqrt(b),i=M/s,r=R/s):w<.01?(i=.707106781,s=.707106781,r=0):(r=Math.sqrt(w),i=T/r,s=R/r),this.set(i,s,r,e),this}let y=Math.sqrt((v-m)*(v-m)+(u-f)*(u-f)+(d-c)*(d-c));return Math.abs(y)<.001&&(y=1),this.x=(v-m)/y,this.y=(u-f)/y,this.z=(d-c)/y,this.w=Math.acos((h+p+_-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Yt extends Ji{constructor(t,e,i={}){super(),this.isWebGLRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new Ot(0,0,t,e),this.scissorTest=!1,this.viewport=new Ot(0,0,t,e);const s={width:t,height:e,depth:1};this.texture=new Gt(s,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=i.generateMipmaps!==void 0&&i.generateMipmaps,this.texture.internalFormat=i.internalFormat!==void 0?i.internalFormat:null,this.texture.minFilter=i.minFilter!==void 0?i.minFilter:1006,this.depthBuffer=i.depthBuffer===void 0||i.depthBuffer,this.stencilBuffer=i.stencilBuffer!==void 0&&i.stencilBuffer,this.depthTexture=i.depthTexture!==void 0?i.depthTexture:null,this.samples=i.samples!==void 0?i.samples:0}setSize(t,e,i=1){this.width===t&&this.height===e&&this.depth===i||(this.width=t,this.height=e,this.depth=i,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new ds(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Sa extends Gt{constructor(t=null,e=1,i=1,s=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:i,depth:s},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class nl extends Gt{constructor(t=null,e=1,i=1,s=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:i,depth:s},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class am extends Yt{constructor(t,e,i,s={}){super(t,e,s),this.isWebGLMultipleRenderTargets=!0;const r=this.texture;this.texture=[];for(let a=0;a<i;a++)this.texture[a]=r.clone(),this.texture[a].isRenderTargetTexture=!0}setSize(t,e,i=1){if(this.width!==t||this.height!==e||this.depth!==i){this.width=t,this.height=e,this.depth=i;for(let s=0,r=this.texture.length;s<r;s++)this.texture[s].image.width=t,this.texture[s].image.height=e,this.texture[s].image.depth=i;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.texture.length=0;for(let e=0,i=t.texture.length;e<i;e++)this.texture[e]=t.texture[e].clone(),this.texture[e].isRenderTargetTexture=!0;return this}}class Ft{constructor(t=0,e=0,i=0,s=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=s}static slerp(t,e,i,s){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(t,e,s)}static slerpFlat(t,e,i,s,r,a,o){let l=i[s+0],h=i[s+1],c=i[s+2],u=i[s+3];const d=r[a+0],p=r[a+1],m=r[a+2],f=r[a+3];if(o===0)return t[e+0]=l,t[e+1]=h,t[e+2]=c,void(t[e+3]=u);if(o===1)return t[e+0]=d,t[e+1]=p,t[e+2]=m,void(t[e+3]=f);if(u!==f||l!==d||h!==p||c!==m){let v=1-o;const _=l*d+h*p+c*m+u*f,y=_>=0?1:-1,x=1-_*_;if(x>Number.EPSILON){const w=Math.sqrt(x),M=Math.atan2(w,_*y);v=Math.sin(v*M)/w,o=Math.sin(o*M)/w}const b=o*y;if(l=l*v+d*b,h=h*v+p*b,c=c*v+m*b,u=u*v+f*b,v===1-o){const w=1/Math.sqrt(l*l+h*h+c*c+u*u);l*=w,h*=w,c*=w,u*=w}}t[e]=l,t[e+1]=h,t[e+2]=c,t[e+3]=u}static multiplyQuaternionsFlat(t,e,i,s,r,a){const o=i[s],l=i[s+1],h=i[s+2],c=i[s+3],u=r[a],d=r[a+1],p=r[a+2],m=r[a+3];return t[e]=o*m+c*u+l*p-h*d,t[e+1]=l*m+c*d+h*u-o*p,t[e+2]=h*m+c*p+o*d-l*u,t[e+3]=c*m-o*u-l*d-h*p,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,s){return this._x=t,this._y=e,this._z=i,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=t._x,s=t._y,r=t._z,a=t._order,o=Math.cos,l=Math.sin,h=o(i/2),c=o(s/2),u=o(r/2),d=l(i/2),p=l(s/2),m=l(r/2);switch(a){case"XYZ":this._x=d*c*u+h*p*m,this._y=h*p*u-d*c*m,this._z=h*c*m+d*p*u,this._w=h*c*u-d*p*m;break;case"YXZ":this._x=d*c*u+h*p*m,this._y=h*p*u-d*c*m,this._z=h*c*m-d*p*u,this._w=h*c*u+d*p*m;break;case"ZXY":this._x=d*c*u-h*p*m,this._y=h*p*u+d*c*m,this._z=h*c*m+d*p*u,this._w=h*c*u-d*p*m;break;case"ZYX":this._x=d*c*u-h*p*m,this._y=h*p*u+d*c*m,this._z=h*c*m-d*p*u,this._w=h*c*u+d*p*m;break;case"YZX":this._x=d*c*u+h*p*m,this._y=h*p*u+d*c*m,this._z=h*c*m-d*p*u,this._w=h*c*u-d*p*m;break;case"XZY":this._x=d*c*u-h*p*m,this._y=h*p*u-d*c*m,this._z=h*c*m+d*p*u,this._w=h*c*u+d*p*m;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,s=Math.sin(i);return this._x=t.x*s,this._y=t.y*s,this._z=t.z*s,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],s=e[4],r=e[8],a=e[1],o=e[5],l=e[9],h=e[2],c=e[6],u=e[10],d=i+o+u;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(c-l)*p,this._y=(r-h)*p,this._z=(a-s)*p}else if(i>o&&i>u){const p=2*Math.sqrt(1+i-o-u);this._w=(c-l)/p,this._x=.25*p,this._y=(s+a)/p,this._z=(r+h)/p}else if(o>u){const p=2*Math.sqrt(1+o-i-u);this._w=(r-h)/p,this._x=(s+a)/p,this._y=.25*p,this._z=(l+c)/p}else{const p=2*Math.sqrt(1+u-i-o);this._w=(a-s)/p,this._x=(r+h)/p,this._y=(l+c)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(de(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(i===0)return this;const s=Math.min(1,e/i);return this.slerp(t,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,s=t._y,r=t._z,a=t._w,o=e._x,l=e._y,h=e._z,c=e._w;return this._x=i*c+a*o+s*h-r*l,this._y=s*c+a*l+r*o-i*h,this._z=r*c+a*h+i*l-s*o,this._w=a*c-i*o-s*l-r*h,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const i=this._x,s=this._y,r=this._z,a=this._w;let o=a*t._w+i*t._x+s*t._y+r*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=a,this._x=i,this._y=s,this._z=r,this;const l=1-o*o;if(l<=Number.EPSILON){const p=1-e;return this._w=p*a+e*this._w,this._x=p*i+e*this._x,this._y=p*s+e*this._y,this._z=p*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const h=Math.sqrt(l),c=Math.atan2(h,o),u=Math.sin((1-e)*c)/h,d=Math.sin(e*c)/h;return this._w=a*u+this._w*d,this._x=i*u+this._x*d,this._y=s*u+this._y*d,this._z=r*u+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=Math.random(),e=Math.sqrt(1-t),i=Math.sqrt(t),s=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(s),i*Math.sin(r),i*Math.cos(r),e*Math.sin(s))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class S{constructor(t=0,e=0,i=0){this.isVector3=!0,this.x=t,this.y=e,this.z=i}set(t,e,i){return i===void 0&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(om.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(om.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,s=this.z,r=t.elements;return this.x=r[0]*e+r[3]*i+r[6]*s,this.y=r[1]*e+r[4]*i+r[7]*s,this.z=r[2]*e+r[5]*i+r[8]*s,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,r=t.elements,a=1/(r[3]*e+r[7]*i+r[11]*s+r[15]);return this.x=(r[0]*e+r[4]*i+r[8]*s+r[12])*a,this.y=(r[1]*e+r[5]*i+r[9]*s+r[13])*a,this.z=(r[2]*e+r[6]*i+r[10]*s+r[14])*a,this}applyQuaternion(t){const e=this.x,i=this.y,s=this.z,r=t.x,a=t.y,o=t.z,l=t.w,h=l*e+a*s-o*i,c=l*i+o*e-r*s,u=l*s+r*i-a*e,d=-r*e-a*i-o*s;return this.x=h*l+d*-r+c*-o-u*-a,this.y=c*l+d*-a+u*-r-h*-o,this.z=u*l+d*-o+h*-a-c*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,s=this.z,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*s,this.y=r[1]*e+r[5]*i+r[9]*s,this.z=r[2]*e+r[6]*i+r[10]*s,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,s=t.y,r=t.z,a=e.x,o=e.y,l=e.z;return this.x=s*l-r*o,this.y=r*a-i*l,this.z=i*o-s*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return Bc.copy(this).projectOnVector(t),this.sub(Bc)}reflect(t){return this.sub(Bc.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(de(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,s=this.z-t.z;return e*e+i*i+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const s=Math.sin(e)*t;return this.x=s*Math.sin(i),this.y=Math.cos(e)*t,this.z=s*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),s=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=s,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,i=Math.sqrt(1-t**2);return this.x=i*Math.cos(e),this.y=i*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Bc=new S,om=new Ft;class Ne{constructor(t=new S(1/0,1/0,1/0),e=new S(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,i=1/0,s=1/0,r=-1/0,a=-1/0,o=-1/0;for(let l=0,h=t.length;l<h;l+=3){const c=t[l],u=t[l+1],d=t[l+2];c<e&&(e=c),u<i&&(i=u),d<s&&(s=d),c>r&&(r=c),u>a&&(a=u),d>o&&(o=d)}return this.min.set(e,i,s),this.max.set(r,a,o),this}setFromBufferAttribute(t){let e=1/0,i=1/0,s=1/0,r=-1/0,a=-1/0,o=-1/0;for(let l=0,h=t.count;l<h;l++){const c=t.getX(l),u=t.getY(l),d=t.getZ(l);c<e&&(e=c),u<i&&(i=u),d<s&&(s=d),c>r&&(r=c),u>a&&(a=u),d>o&&(o=d)}return this.min.set(e,i,s),this.max.set(r,a,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=ps.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const i=t.geometry;if(i!==void 0)if(e&&i.attributes!=null&&i.attributes.position!==void 0){const r=i.attributes.position;for(let a=0,o=r.count;a<o;a++)ps.fromBufferAttribute(r,a).applyMatrix4(t.matrixWorld),this.expandByPoint(ps)}else i.boundingBox===null&&i.computeBoundingBox(),Vc.copy(i.boundingBox),Vc.applyMatrix4(t.matrixWorld),this.union(Vc);const s=t.children;for(let r=0,a=s.length;r<a;r++)this.expandByObject(s[r],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,ps),ps.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Ta),sl.subVectors(this.max,Ta),nr.subVectors(t.a,Ta),sr.subVectors(t.b,Ta),rr.subVectors(t.c,Ta),Un.subVectors(sr,nr),Fn.subVectors(rr,sr),ms.subVectors(nr,rr);let e=[0,-Un.z,Un.y,0,-Fn.z,Fn.y,0,-ms.z,ms.y,Un.z,0,-Un.x,Fn.z,0,-Fn.x,ms.z,0,-ms.x,-Un.y,Un.x,0,-Fn.y,Fn.x,0,-ms.y,ms.x,0];return!!Gc(e,nr,sr,rr,sl)&&(e=[1,0,0,0,1,0,0,0,1],!!Gc(e,nr,sr,rr,sl)&&(rl.crossVectors(Un,Fn),e=[rl.x,rl.y,rl.z],Gc(e,nr,sr,rr,sl)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return ps.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(ps).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(vn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),vn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),vn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),vn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),vn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),vn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),vn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),vn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(vn)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const vn=[new S,new S,new S,new S,new S,new S,new S,new S],ps=new S,Vc=new Ne,nr=new S,sr=new S,rr=new S,Un=new S,Fn=new S,ms=new S,Ta=new S,sl=new S,rl=new S,fs=new S;function Gc(n,t,e,i,s){for(let r=0,a=n.length-3;r<=a;r+=3){fs.fromArray(n,r);const o=s.x*Math.abs(fs.x)+s.y*Math.abs(fs.y)+s.z*Math.abs(fs.z),l=t.dot(fs),h=e.dot(fs),c=i.dot(fs);if(Math.max(-Math.max(l,h,c),Math.min(l,h,c))>o)return!1}return!0}const n1=new Ne,lm=new S,al=new S,jc=new S;class ii{constructor(t=new S,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;e!==void 0?i.copy(e):n1.setFromPoints(t).getCenter(i);let s=0;for(let r=0,a=t.length;r<a;r++)s=Math.max(s,i.distanceToSquared(t[r]));return this.radius=Math.sqrt(s),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){jc.subVectors(t,this.center);const e=jc.lengthSq();if(e>this.radius*this.radius){const i=Math.sqrt(e),s=.5*(i-this.radius);this.center.add(jc.multiplyScalar(s/i)),this.radius+=s}return this}union(t){return this.center.equals(t.center)===!0?al.set(0,0,1).multiplyScalar(t.radius):al.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(lm.copy(t.center).add(al)),this.expandByPoint(lm.copy(t.center).sub(al)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const _n=new S,Hc=new S,ol=new S,Nn=new S,Wc=new S,ll=new S,qc=new S;class kn{constructor(t=new S,e=new S(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,_n)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=_n.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(_n.copy(this.direction).multiplyScalar(e).add(this.origin),_n.distanceToSquared(t))}distanceSqToSegment(t,e,i,s){Hc.copy(t).add(e).multiplyScalar(.5),ol.copy(e).sub(t).normalize(),Nn.copy(this.origin).sub(Hc);const r=.5*t.distanceTo(e),a=-this.direction.dot(ol),o=Nn.dot(this.direction),l=-Nn.dot(ol),h=Nn.lengthSq(),c=Math.abs(1-a*a);let u,d,p,m;if(c>0)if(u=a*l-o,d=a*o-l,m=r*c,u>=0)if(d>=-m)if(d<=m){const f=1/c;u*=f,d*=f,p=u*(u+a*d+2*o)+d*(a*u+d+2*l)+h}else d=r,u=Math.max(0,-(a*d+o)),p=-u*u+d*(d+2*l)+h;else d=-r,u=Math.max(0,-(a*d+o)),p=-u*u+d*(d+2*l)+h;else d<=-m?(u=Math.max(0,-(-a*r+o)),d=u>0?-r:Math.min(Math.max(-r,-l),r),p=-u*u+d*(d+2*l)+h):d<=m?(u=0,d=Math.min(Math.max(-r,-l),r),p=d*(d+2*l)+h):(u=Math.max(0,-(a*r+o)),d=u>0?r:Math.min(Math.max(-r,-l),r),p=-u*u+d*(d+2*l)+h);else d=a>0?-r:r,u=Math.max(0,-(a*d+o)),p=-u*u+d*(d+2*l)+h;return i&&i.copy(this.direction).multiplyScalar(u).add(this.origin),s&&s.copy(ol).multiplyScalar(d).add(Hc),p}intersectSphere(t,e){_n.subVectors(t.center,this.origin);const i=_n.dot(this.direction),s=_n.dot(_n)-i*i,r=t.radius*t.radius;if(s>r)return null;const a=Math.sqrt(r-s),o=i-a,l=i+a;return o<0&&l<0?null:o<0?this.at(l,e):this.at(o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return i===null?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0?!0:t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,s,r,a,o,l;const h=1/this.direction.x,c=1/this.direction.y,u=1/this.direction.z,d=this.origin;return h>=0?(i=(t.min.x-d.x)*h,s=(t.max.x-d.x)*h):(i=(t.max.x-d.x)*h,s=(t.min.x-d.x)*h),c>=0?(r=(t.min.y-d.y)*c,a=(t.max.y-d.y)*c):(r=(t.max.y-d.y)*c,a=(t.min.y-d.y)*c),i>a||r>s?null:((r>i||i!=i)&&(i=r),(a<s||s!=s)&&(s=a),u>=0?(o=(t.min.z-d.z)*u,l=(t.max.z-d.z)*u):(o=(t.max.z-d.z)*u,l=(t.min.z-d.z)*u),i>l||o>s?null:((o>i||i!=i)&&(i=o),(l<s||s!=s)&&(s=l),s<0?null:this.at(i>=0?i:s,e)))}intersectsBox(t){return this.intersectBox(t,_n)!==null}intersectTriangle(t,e,i,s,r){Wc.subVectors(e,t),ll.subVectors(i,t),qc.crossVectors(Wc,ll);let a,o=this.direction.dot(qc);if(o>0){if(s)return null;a=1}else{if(!(o<0))return null;a=-1,o=-o}Nn.subVectors(this.origin,t);const l=a*this.direction.dot(ll.crossVectors(Nn,ll));if(l<0)return null;const h=a*this.direction.dot(Wc.cross(Nn));if(h<0||l+h>o)return null;const c=-a*Nn.dot(qc);return c<0?null:this.at(c/o,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class at{constructor(){this.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,i,s,r,a,o,l,h,c,u,d,p,m,f,v){const _=this.elements;return _[0]=t,_[4]=e,_[8]=i,_[12]=s,_[1]=r,_[5]=a,_[9]=o,_[13]=l,_[2]=h,_[6]=c,_[10]=u,_[14]=d,_[3]=p,_[7]=m,_[11]=f,_[15]=v,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new at().fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,s=1/ar.setFromMatrixColumn(t,0).length(),r=1/ar.setFromMatrixColumn(t,1).length(),a=1/ar.setFromMatrixColumn(t,2).length();return e[0]=i[0]*s,e[1]=i[1]*s,e[2]=i[2]*s,e[3]=0,e[4]=i[4]*r,e[5]=i[5]*r,e[6]=i[6]*r,e[7]=0,e[8]=i[8]*a,e[9]=i[9]*a,e[10]=i[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,i=t.x,s=t.y,r=t.z,a=Math.cos(i),o=Math.sin(i),l=Math.cos(s),h=Math.sin(s),c=Math.cos(r),u=Math.sin(r);if(t.order==="XYZ"){const d=a*c,p=a*u,m=o*c,f=o*u;e[0]=l*c,e[4]=-l*u,e[8]=h,e[1]=p+m*h,e[5]=d-f*h,e[9]=-o*l,e[2]=f-d*h,e[6]=m+p*h,e[10]=a*l}else if(t.order==="YXZ"){const d=l*c,p=l*u,m=h*c,f=h*u;e[0]=d+f*o,e[4]=m*o-p,e[8]=a*h,e[1]=a*u,e[5]=a*c,e[9]=-o,e[2]=p*o-m,e[6]=f+d*o,e[10]=a*l}else if(t.order==="ZXY"){const d=l*c,p=l*u,m=h*c,f=h*u;e[0]=d-f*o,e[4]=-a*u,e[8]=m+p*o,e[1]=p+m*o,e[5]=a*c,e[9]=f-d*o,e[2]=-a*h,e[6]=o,e[10]=a*l}else if(t.order==="ZYX"){const d=a*c,p=a*u,m=o*c,f=o*u;e[0]=l*c,e[4]=m*h-p,e[8]=d*h+f,e[1]=l*u,e[5]=f*h+d,e[9]=p*h-m,e[2]=-h,e[6]=o*l,e[10]=a*l}else if(t.order==="YZX"){const d=a*l,p=a*h,m=o*l,f=o*h;e[0]=l*c,e[4]=f-d*u,e[8]=m*u+p,e[1]=u,e[5]=a*c,e[9]=-o*c,e[2]=-h*c,e[6]=p*u+m,e[10]=d-f*u}else if(t.order==="XZY"){const d=a*l,p=a*h,m=o*l,f=o*h;e[0]=l*c,e[4]=-u,e[8]=h*c,e[1]=d*u+f,e[5]=a*c,e[9]=p*u-m,e[2]=m*u-p,e[6]=o*c,e[10]=f*u+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(s1,t,r1)}lookAt(t,e,i){const s=this.elements;return ni.subVectors(t,e),ni.lengthSq()===0&&(ni.z=1),ni.normalize(),Bn.crossVectors(i,ni),Bn.lengthSq()===0&&(Math.abs(i.z)===1?ni.x+=1e-4:ni.z+=1e-4,ni.normalize(),Bn.crossVectors(i,ni)),Bn.normalize(),hl.crossVectors(ni,Bn),s[0]=Bn.x,s[4]=hl.x,s[8]=ni.x,s[1]=Bn.y,s[5]=hl.y,s[9]=ni.y,s[2]=Bn.z,s[6]=hl.z,s[10]=ni.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,r=this.elements,a=i[0],o=i[4],l=i[8],h=i[12],c=i[1],u=i[5],d=i[9],p=i[13],m=i[2],f=i[6],v=i[10],_=i[14],y=i[3],x=i[7],b=i[11],w=i[15],M=s[0],T=s[4],R=s[8],E=s[12],A=s[1],z=s[5],F=s[9],G=s[13],U=s[2],k=s[6],H=s[10],W=s[14],N=s[3],X=s[7],K=s[11],$=s[15];return r[0]=a*M+o*A+l*U+h*N,r[4]=a*T+o*z+l*k+h*X,r[8]=a*R+o*F+l*H+h*K,r[12]=a*E+o*G+l*W+h*$,r[1]=c*M+u*A+d*U+p*N,r[5]=c*T+u*z+d*k+p*X,r[9]=c*R+u*F+d*H+p*K,r[13]=c*E+u*G+d*W+p*$,r[2]=m*M+f*A+v*U+_*N,r[6]=m*T+f*z+v*k+_*X,r[10]=m*R+f*F+v*H+_*K,r[14]=m*E+f*G+v*W+_*$,r[3]=y*M+x*A+b*U+w*N,r[7]=y*T+x*z+b*k+w*X,r[11]=y*R+x*F+b*H+w*K,r[15]=y*E+x*G+b*W+w*$,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],s=t[8],r=t[12],a=t[1],o=t[5],l=t[9],h=t[13],c=t[2],u=t[6],d=t[10],p=t[14];return t[3]*(+r*l*u-s*h*u-r*o*d+i*h*d+s*o*p-i*l*p)+t[7]*(+e*l*p-e*h*d+r*a*d-s*a*p+s*h*c-r*l*c)+t[11]*(+e*h*u-e*o*p-r*a*u+i*a*p+r*o*c-i*h*c)+t[15]*(-s*o*c-e*l*u+e*o*d+s*a*u-i*a*d+i*l*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const s=this.elements;return t.isVector3?(s[12]=t.x,s[13]=t.y,s[14]=t.z):(s[12]=t,s[13]=e,s[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],r=t[3],a=t[4],o=t[5],l=t[6],h=t[7],c=t[8],u=t[9],d=t[10],p=t[11],m=t[12],f=t[13],v=t[14],_=t[15],y=u*v*h-f*d*h+f*l*p-o*v*p-u*l*_+o*d*_,x=m*d*h-c*v*h-m*l*p+a*v*p+c*l*_-a*d*_,b=c*f*h-m*u*h+m*o*p-a*f*p-c*o*_+a*u*_,w=m*u*l-c*f*l-m*o*d+a*f*d+c*o*v-a*u*v,M=e*y+i*x+s*b+r*w;if(M===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/M;return t[0]=y*T,t[1]=(f*d*r-u*v*r-f*s*p+i*v*p+u*s*_-i*d*_)*T,t[2]=(o*v*r-f*l*r+f*s*h-i*v*h-o*s*_+i*l*_)*T,t[3]=(u*l*r-o*d*r-u*s*h+i*d*h+o*s*p-i*l*p)*T,t[4]=x*T,t[5]=(c*v*r-m*d*r+m*s*p-e*v*p-c*s*_+e*d*_)*T,t[6]=(m*l*r-a*v*r-m*s*h+e*v*h+a*s*_-e*l*_)*T,t[7]=(a*d*r-c*l*r+c*s*h-e*d*h-a*s*p+e*l*p)*T,t[8]=b*T,t[9]=(m*u*r-c*f*r-m*i*p+e*f*p+c*i*_-e*u*_)*T,t[10]=(a*f*r-m*o*r+m*i*h-e*f*h-a*i*_+e*o*_)*T,t[11]=(c*o*r-a*u*r-c*i*h+e*u*h+a*i*p-e*o*p)*T,t[12]=w*T,t[13]=(c*f*s-m*u*s+m*i*d-e*f*d-c*i*v+e*u*v)*T,t[14]=(m*o*s-a*f*s-m*i*l+e*f*l+a*i*v-e*o*v)*T,t[15]=(a*u*s-c*o*s+c*i*l-e*u*l-a*i*d+e*o*d)*T,this}scale(t){const e=this.elements,i=t.x,s=t.y,r=t.z;return e[0]*=i,e[4]*=s,e[8]*=r,e[1]*=i,e[5]*=s,e[9]*=r,e[2]*=i,e[6]*=s,e[10]*=r,e[3]*=i,e[7]*=s,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],s=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,s))}makeTranslation(t,e,i){return this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),s=Math.sin(e),r=1-i,a=t.x,o=t.y,l=t.z,h=r*a,c=r*o;return this.set(h*a+i,h*o-s*l,h*l+s*o,0,h*o+s*l,c*o+i,c*l-s*a,0,h*l-s*o,c*l+s*a,r*l*l+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,s,r,a){return this.set(1,i,r,0,t,1,a,0,e,s,1,0,0,0,0,1),this}compose(t,e,i){const s=this.elements,r=e._x,a=e._y,o=e._z,l=e._w,h=r+r,c=a+a,u=o+o,d=r*h,p=r*c,m=r*u,f=a*c,v=a*u,_=o*u,y=l*h,x=l*c,b=l*u,w=i.x,M=i.y,T=i.z;return s[0]=(1-(f+_))*w,s[1]=(p+b)*w,s[2]=(m-x)*w,s[3]=0,s[4]=(p-b)*M,s[5]=(1-(d+_))*M,s[6]=(v+y)*M,s[7]=0,s[8]=(m+x)*T,s[9]=(v-y)*T,s[10]=(1-(d+f))*T,s[11]=0,s[12]=t.x,s[13]=t.y,s[14]=t.z,s[15]=1,this}decompose(t,e,i){const s=this.elements;let r=ar.set(s[0],s[1],s[2]).length();const a=ar.set(s[4],s[5],s[6]).length(),o=ar.set(s[8],s[9],s[10]).length();this.determinant()<0&&(r=-r),t.x=s[12],t.y=s[13],t.z=s[14],Li.copy(this);const l=1/r,h=1/a,c=1/o;return Li.elements[0]*=l,Li.elements[1]*=l,Li.elements[2]*=l,Li.elements[4]*=h,Li.elements[5]*=h,Li.elements[6]*=h,Li.elements[8]*=c,Li.elements[9]*=c,Li.elements[10]*=c,e.setFromRotationMatrix(Li),i.x=r,i.y=a,i.z=o,this}makePerspective(t,e,i,s,r,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,l=2*r/(e-t),h=2*r/(i-s),c=(e+t)/(e-t),u=(i+s)/(i-s),d=-(a+r)/(a-r),p=-2*a*r/(a-r);return o[0]=l,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=h,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=p,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,i,s,r,a){const o=this.elements,l=1/(e-t),h=1/(i-s),c=1/(a-r),u=(e+t)*l,d=(i+s)*h,p=(a+r)*c;return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*h,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-p,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<16;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}const ar=new S,Li=new at,s1=new S(0,0,0),r1=new S(1,1,1),Bn=new S,hl=new S,ni=new S,hm=new at,cm=new Ft;class yn{constructor(t=0,e=0,i=0,s=yn.DefaultOrder){this.isEuler=!0,this._x=t,this._y=e,this._z=i,this._order=s}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,s=this._order){return this._x=t,this._y=e,this._z=i,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const s=t.elements,r=s[0],a=s[4],o=s[8],l=s[1],h=s[5],c=s[9],u=s[2],d=s[6],p=s[10];switch(e){case"XYZ":this._y=Math.asin(de(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,p),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(d,h),this._z=0);break;case"YXZ":this._x=Math.asin(-de(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(o,p),this._z=Math.atan2(l,h)):(this._y=Math.atan2(-u,r),this._z=0);break;case"ZXY":this._x=Math.asin(de(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-u,p),this._z=Math.atan2(-a,h)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-de(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-a,h));break;case"YZX":this._z=Math.asin(de(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-c,h),this._y=Math.atan2(-u,r)):(this._x=0,this._y=Math.atan2(o,p));break;case"XZY":this._z=Math.asin(-de(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(d,h),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-c,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,i===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return hm.makeRotationFromQuaternion(t),this.setFromRotationMatrix(hm,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return cm.setFromEuler(this),this.setFromQuaternion(cm,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}yn.DefaultOrder="XYZ",yn.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class cl{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!=0}isEnabled(t){return(this.mask&(1<<t|0))!=0}}let a1=0;const um=new S,or=new Ft,xn=new at,ul=new S,Ea=new S,o1=new S,l1=new Ft,dm=new S(1,0,0),pm=new S(0,1,0),mm=new S(0,0,1),h1={type:"added"},fm={type:"removed"};class Mt extends Ji{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:a1++}),this.uuid=ei(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Mt.DefaultUp.clone();const t=new S,e=new yn,i=new Ft,s=new S(1,1,1);e._onChange(function(){i.setFromEuler(e,!1)}),i._onChange(function(){e.setFromQuaternion(i,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new at},normalMatrix:{value:new De}}),this.matrix=new at,this.matrixWorld=new at,this.matrixAutoUpdate=Mt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new cl,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return or.setFromAxisAngle(t,e),this.quaternion.multiply(or),this}rotateOnWorldAxis(t,e){return or.setFromAxisAngle(t,e),this.quaternion.premultiply(or),this}rotateX(t){return this.rotateOnAxis(dm,t)}rotateY(t){return this.rotateOnAxis(pm,t)}rotateZ(t){return this.rotateOnAxis(mm,t)}translateOnAxis(t,e){return um.copy(t).applyQuaternion(this.quaternion),this.position.add(um.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(dm,t)}translateY(t){return this.translateOnAxis(pm,t)}translateZ(t){return this.translateOnAxis(mm,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(xn.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?ul.copy(t):ul.set(t,e,i);const s=this.parent;this.updateWorldMatrix(!0,!1),Ea.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?xn.lookAt(Ea,ul,this.up):xn.lookAt(ul,Ea,this.up),this.quaternion.setFromRotationMatrix(xn),s&&(xn.extractRotation(s.matrixWorld),or.setFromRotationMatrix(xn),this.quaternion.premultiply(or.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(h1)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(fm)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(fm)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),xn.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),xn.multiply(t.parent.matrixWorld)),t.applyMatrix4(xn),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,s=this.children.length;i<s;i++){const r=this.children[i].getObjectByProperty(t,e);if(r!==void 0)return r}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ea,t,o1),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ea,l1,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].updateMatrixWorld(t)}updateWorldMatrix(t,e){const i=this.parent;if(t===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const s=this.children;for(let r=0,a=s.length;r<a;r++)s[r].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",i={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const s={};function r(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(t)),l.uuid}if(s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.castShadow===!0&&(s.castShadow=!0),this.receiveShadow===!0&&(s.receiveShadow=!0),this.visible===!1&&(s.visible=!1),this.frustumCulled===!1&&(s.frustumCulled=!1),this.renderOrder!==0&&(s.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(s.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(s.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=r(t.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let h=0,c=l.length;h<c;h++){const u=l[h];r(t.shapes,u)}else r(t.shapes,l)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(t.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,h=this.material.length;l<h;l++)o.push(r(t.materials,this.material[l]));s.material=o}else s.material=r(t.materials,this.material);if(this.children.length>0){s.children=[];for(let o=0;o<this.children.length;o++)s.children.push(this.children[o].toJSON(t).object)}if(this.animations.length>0){s.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];s.animations.push(r(t.animations,l))}}if(e){const o=a(t.geometries),l=a(t.materials),h=a(t.textures),c=a(t.images),u=a(t.shapes),d=a(t.skeletons),p=a(t.animations),m=a(t.nodes);o.length>0&&(i.geometries=o),l.length>0&&(i.materials=l),h.length>0&&(i.textures=h),c.length>0&&(i.images=c),u.length>0&&(i.shapes=u),d.length>0&&(i.skeletons=d),p.length>0&&(i.animations=p),m.length>0&&(i.nodes=m)}return i.object=s,i;function a(o){const l=[];for(const h in o){const c=o[h];delete c.metadata,l.push(c)}return l}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let i=0;i<t.children.length;i++){const s=t.children[i];this.add(s.clone())}return this}}Mt.DefaultUp=new S(0,1,0),Mt.DefaultMatrixAutoUpdate=!0;const Ii=new S,bn=new S,Xc=new S,Mn=new S,lr=new S,hr=new S,gm=new S,Yc=new S,Zc=new S,Jc=new S;class mi{constructor(t=new S,e=new S,i=new S){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,s){s.subVectors(i,e),Ii.subVectors(t,e),s.cross(Ii);const r=s.lengthSq();return r>0?s.multiplyScalar(1/Math.sqrt(r)):s.set(0,0,0)}static getBarycoord(t,e,i,s,r){Ii.subVectors(s,e),bn.subVectors(i,e),Xc.subVectors(t,e);const a=Ii.dot(Ii),o=Ii.dot(bn),l=Ii.dot(Xc),h=bn.dot(bn),c=bn.dot(Xc),u=a*h-o*o;if(u===0)return r.set(-2,-1,-1);const d=1/u,p=(h*l-o*c)*d,m=(a*c-o*l)*d;return r.set(1-p-m,m,p)}static containsPoint(t,e,i,s){return this.getBarycoord(t,e,i,s,Mn),Mn.x>=0&&Mn.y>=0&&Mn.x+Mn.y<=1}static getUV(t,e,i,s,r,a,o,l){return this.getBarycoord(t,e,i,s,Mn),l.set(0,0),l.addScaledVector(r,Mn.x),l.addScaledVector(a,Mn.y),l.addScaledVector(o,Mn.z),l}static isFrontFacing(t,e,i,s){return Ii.subVectors(i,e),bn.subVectors(t,e),Ii.cross(bn).dot(s)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,s){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[s]),this}setFromAttributeAndIndices(t,e,i,s){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,s),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Ii.subVectors(this.c,this.b),bn.subVectors(this.a,this.b),.5*Ii.cross(bn).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return mi.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return mi.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,i,s,r){return mi.getUV(t,this.a,this.b,this.c,e,i,s,r)}containsPoint(t){return mi.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return mi.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const i=this.a,s=this.b,r=this.c;let a,o;lr.subVectors(s,i),hr.subVectors(r,i),Yc.subVectors(t,i);const l=lr.dot(Yc),h=hr.dot(Yc);if(l<=0&&h<=0)return e.copy(i);Zc.subVectors(t,s);const c=lr.dot(Zc),u=hr.dot(Zc);if(c>=0&&u<=c)return e.copy(s);const d=l*u-c*h;if(d<=0&&l>=0&&c<=0)return a=l/(l-c),e.copy(i).addScaledVector(lr,a);Jc.subVectors(t,r);const p=lr.dot(Jc),m=hr.dot(Jc);if(m>=0&&p<=m)return e.copy(r);const f=p*h-l*m;if(f<=0&&h>=0&&m<=0)return o=h/(h-m),e.copy(i).addScaledVector(hr,o);const v=c*m-p*u;if(v<=0&&u-c>=0&&p-m>=0)return gm.subVectors(r,s),o=(u-c)/(u-c+(p-m)),e.copy(s).addScaledVector(gm,o);const _=1/(v+f+d);return a=f*_,o=d*_,e.copy(i).addScaledVector(lr,a).addScaledVector(hr,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let c1=0;class ae extends Ji{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:c1++}),this.uuid=ei(),this.name="",this.type="Material",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const i=t[e];if(i===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===1;continue}const s=this[e];s!==void 0?s&&s.isColor?s.set(i):s&&s.isVector3&&i&&i.isVector3?s.copy(i):this[e]=i:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function s(r){const a=[];for(const o in r){const l=r[o];delete l.metadata,a.push(l)}return a}if(i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==1&&(i.blending=this.blending),this.side!==0&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(i.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=this.flatShading),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),e){const r=s(t.textures),a=s(t.images);r.length>0&&(i.textures=r),a.length>0&&(i.images=a)}return i}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let i=null;if(e!==null){const s=e.length;i=new Array(s);for(let r=0;r!==s;++r)i[r]=e[r].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}get vertexTangents(){return console.warn("THREE."+this.type+": .vertexTangents has been removed."),!1}set vertexTangents(t){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}ae.fromType=function(){return null};class Zt extends ae{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new nt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const ge=new S,dl=new V;class Lt{constructor(t,e,i){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=i===!0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let s=0,r=this.itemSize;s<r;s++)this.array[t+s]=e.array[i+s];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let i=0;for(let s=0,r=t.length;s<r;s++){let a=t[s];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",s),a=new nt),e[i++]=a.r,e[i++]=a.g,e[i++]=a.b}return this}copyVector2sArray(t){const e=this.array;let i=0;for(let s=0,r=t.length;s<r;s++){let a=t[s];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",s),a=new V),e[i++]=a.x,e[i++]=a.y}return this}copyVector3sArray(t){const e=this.array;let i=0;for(let s=0,r=t.length;s<r;s++){let a=t[s];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",s),a=new S),e[i++]=a.x,e[i++]=a.y,e[i++]=a.z}return this}copyVector4sArray(t){const e=this.array;let i=0;for(let s=0,r=t.length;s<r;s++){let a=t[s];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",s),a=new Ot),e[i++]=a.x,e[i++]=a.y,e[i++]=a.z,e[i++]=a.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,i=this.count;e<i;e++)dl.fromBufferAttribute(this,e),dl.applyMatrix3(t),this.setXY(e,dl.x,dl.y);else if(this.itemSize===3)for(let e=0,i=this.count;e<i;e++)ge.fromBufferAttribute(this,e),ge.applyMatrix3(t),this.setXYZ(e,ge.x,ge.y,ge.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)ge.fromBufferAttribute(this,e),ge.applyMatrix4(t),this.setXYZ(e,ge.x,ge.y,ge.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)ge.fromBufferAttribute(this,e),ge.applyNormalMatrix(t),this.setXYZ(e,ge.x,ge.y,ge.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)ge.fromBufferAttribute(this,e),ge.transformDirection(t),this.setXYZ(e,ge.x,ge.y,ge.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this}setXYZW(t,e,i,s,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==35044&&(t.usage=this.usage),this.updateRange.offset===0&&this.updateRange.count===-1||(t.updateRange=this.updateRange),t}}class Kc extends Lt{constructor(t,e,i){super(new Uint16Array(t),e,i)}}class pl extends Lt{constructor(t,e,i){super(new Uint32Array(t),e,i)}}class Z extends Lt{constructor(t,e,i){super(new Float32Array(t),e,i)}}let u1=0;const fi=new at,Qc=new Mt,cr=new S,si=new Ne,Ca=new Ne,be=new S;class gt extends Ji{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:u1++}),this.uuid=ei(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(sm(t)?pl:Kc)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const r=new De().getNormalMatrix(t);i.applyNormalMatrix(r),i.needsUpdate=!0}const s=this.attributes.tangent;return s!==void 0&&(s.transformDirection(t),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return fi.makeRotationFromQuaternion(t),this.applyMatrix4(fi),this}rotateX(t){return fi.makeRotationX(t),this.applyMatrix4(fi),this}rotateY(t){return fi.makeRotationY(t),this.applyMatrix4(fi),this}rotateZ(t){return fi.makeRotationZ(t),this.applyMatrix4(fi),this}translate(t,e,i){return fi.makeTranslation(t,e,i),this.applyMatrix4(fi),this}scale(t,e,i){return fi.makeScale(t,e,i),this.applyMatrix4(fi),this}lookAt(t){return Qc.lookAt(t),Qc.updateMatrix(),this.applyMatrix4(Qc.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(cr).negate(),this.translate(cr.x,cr.y,cr.z),this}setFromPoints(t){const e=[];for(let i=0,s=t.length;i<s;i++){const r=t[i];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Z(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ne);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new S(-1/0,-1/0,-1/0),new S(1/0,1/0,1/0));if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let i=0,s=e.length;i<s;i++){const r=e[i];si.setFromBufferAttribute(r),this.morphTargetsRelative?(be.addVectors(this.boundingBox.min,si.min),this.boundingBox.expandByPoint(be),be.addVectors(this.boundingBox.max,si.max),this.boundingBox.expandByPoint(be)):(this.boundingBox.expandByPoint(si.min),this.boundingBox.expandByPoint(si.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ii);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new S,1/0);if(t){const i=this.boundingSphere.center;if(si.setFromBufferAttribute(t),e)for(let r=0,a=e.length;r<a;r++){const o=e[r];Ca.setFromBufferAttribute(o),this.morphTargetsRelative?(be.addVectors(si.min,Ca.min),si.expandByPoint(be),be.addVectors(si.max,Ca.max),si.expandByPoint(be)):(si.expandByPoint(Ca.min),si.expandByPoint(Ca.max))}si.getCenter(i);let s=0;for(let r=0,a=t.count;r<a;r++)be.fromBufferAttribute(t,r),s=Math.max(s,i.distanceToSquared(be));if(e)for(let r=0,a=e.length;r<a;r++){const o=e[r],l=this.morphTargetsRelative;for(let h=0,c=o.count;h<c;h++)be.fromBufferAttribute(o,h),l&&(cr.fromBufferAttribute(t,h),be.add(cr)),s=Math.max(s,i.distanceToSquared(be))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const i=t.array,s=e.position.array,r=e.normal.array,a=e.uv.array,o=s.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Lt(new Float32Array(4*o),4));const l=this.getAttribute("tangent").array,h=[],c=[];for(let A=0;A<o;A++)h[A]=new S,c[A]=new S;const u=new S,d=new S,p=new S,m=new V,f=new V,v=new V,_=new S,y=new S;function x(A,z,F){u.fromArray(s,3*A),d.fromArray(s,3*z),p.fromArray(s,3*F),m.fromArray(a,2*A),f.fromArray(a,2*z),v.fromArray(a,2*F),d.sub(u),p.sub(u),f.sub(m),v.sub(m);const G=1/(f.x*v.y-v.x*f.y);isFinite(G)&&(_.copy(d).multiplyScalar(v.y).addScaledVector(p,-f.y).multiplyScalar(G),y.copy(p).multiplyScalar(f.x).addScaledVector(d,-v.x).multiplyScalar(G),h[A].add(_),h[z].add(_),h[F].add(_),c[A].add(y),c[z].add(y),c[F].add(y))}let b=this.groups;b.length===0&&(b=[{start:0,count:i.length}]);for(let A=0,z=b.length;A<z;++A){const F=b[A],G=F.start;for(let U=G,k=G+F.count;U<k;U+=3)x(i[U+0],i[U+1],i[U+2])}const w=new S,M=new S,T=new S,R=new S;function E(A){T.fromArray(r,3*A),R.copy(T);const z=h[A];w.copy(z),w.sub(T.multiplyScalar(T.dot(z))).normalize(),M.crossVectors(R,z);const F=M.dot(c[A])<0?-1:1;l[4*A]=w.x,l[4*A+1]=w.y,l[4*A+2]=w.z,l[4*A+3]=F}for(let A=0,z=b.length;A<z;++A){const F=b[A],G=F.start;for(let U=G,k=G+F.count;U<k;U+=3)E(i[U+0]),E(i[U+1]),E(i[U+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new Lt(new Float32Array(3*e.count),3),this.setAttribute("normal",i);else for(let d=0,p=i.count;d<p;d++)i.setXYZ(d,0,0,0);const s=new S,r=new S,a=new S,o=new S,l=new S,h=new S,c=new S,u=new S;if(t)for(let d=0,p=t.count;d<p;d+=3){const m=t.getX(d+0),f=t.getX(d+1),v=t.getX(d+2);s.fromBufferAttribute(e,m),r.fromBufferAttribute(e,f),a.fromBufferAttribute(e,v),c.subVectors(a,r),u.subVectors(s,r),c.cross(u),o.fromBufferAttribute(i,m),l.fromBufferAttribute(i,f),h.fromBufferAttribute(i,v),o.add(c),l.add(c),h.add(c),i.setXYZ(m,o.x,o.y,o.z),i.setXYZ(f,l.x,l.y,l.z),i.setXYZ(v,h.x,h.y,h.z)}else for(let d=0,p=e.count;d<p;d+=3)s.fromBufferAttribute(e,d+0),r.fromBufferAttribute(e,d+1),a.fromBufferAttribute(e,d+2),c.subVectors(a,r),u.subVectors(s,r),c.cross(u),i.setXYZ(d+0,c.x,c.y,c.z),i.setXYZ(d+1,c.x,c.y,c.z),i.setXYZ(d+2,c.x,c.y,c.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const i=this.attributes;for(const s in i){if(t.attributes[s]===void 0)continue;const r=i[s].array,a=t.attributes[s],o=a.array,l=a.itemSize*e,h=Math.min(o.length,r.length-l);for(let c=0,u=l;c<h;c++,u++)r[u]=o[c]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)be.fromBufferAttribute(t,e),be.normalize(),t.setXYZ(e,be.x,be.y,be.z)}toNonIndexed(){function t(o,l){const h=o.array,c=o.itemSize,u=o.normalized,d=new h.constructor(l.length*c);let p=0,m=0;for(let f=0,v=l.length;f<v;f++){p=o.isInterleavedBufferAttribute?l[f]*o.data.stride+o.offset:l[f]*c;for(let _=0;_<c;_++)d[m++]=h[p++]}return new Lt(d,c,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new gt,i=this.index.array,s=this.attributes;for(const o in s){const l=t(s[o],i);e.setAttribute(o,l)}const r=this.morphAttributes;for(const o in r){const l=[],h=r[o];for(let c=0,u=h.length;c<u;c++){const d=t(h[c],i);l.push(d)}e.morphAttributes[o]=l}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,l=a.length;o<l;o++){const h=a[o];e.addGroup(h.start,h.count,h.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const h in l)l[h]!==void 0&&(t[h]=l[h]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const i=this.attributes;for(const l in i){const h=i[l];t.data.attributes[l]=h.toJSON(t.data)}const s={};let r=!1;for(const l in this.morphAttributes){const h=this.morphAttributes[l],c=[];for(let u=0,d=h.length;u<d;u++){const p=h[u];c.push(p.toJSON(t.data))}c.length>0&&(s[l]=c,r=!0)}r&&(t.data.morphAttributes=s,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const i=t.index;i!==null&&this.setIndex(i.clone(e));const s=t.attributes;for(const h in s){const c=s[h];this.setAttribute(h,c.clone(e))}const r=t.morphAttributes;for(const h in r){const c=[],u=r[h];for(let d=0,p=u.length;d<p;d++)c.push(u[d].clone(e));this.morphAttributes[h]=c}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let h=0,c=a.length;h<c;h++){const u=a[h];this.addGroup(u.start,u.count,u.materialIndex)}const o=t.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=t.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,t.parameters!==void 0&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const vm=new at,ur=new kn,$c=new ii,Vn=new S,Gn=new S,jn=new S,tu=new S,eu=new S,iu=new S,ml=new S,fl=new S,gl=new S,vl=new V,_l=new V,yl=new V,nu=new S,xl=new S;class ot extends Mt{constructor(t=new gt,e=new Zt){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,r=i.length;s<r;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}raycast(t,e){const i=this.geometry,s=this.material,r=this.matrixWorld;if(s===void 0||(i.boundingSphere===null&&i.computeBoundingSphere(),$c.copy(i.boundingSphere),$c.applyMatrix4(r),t.ray.intersectsSphere($c)===!1)||(vm.copy(r).invert(),ur.copy(t.ray).applyMatrix4(vm),i.boundingBox!==null&&ur.intersectsBox(i.boundingBox)===!1))return;let a;const o=i.index,l=i.attributes.position,h=i.morphAttributes.position,c=i.morphTargetsRelative,u=i.attributes.uv,d=i.attributes.uv2,p=i.groups,m=i.drawRange;if(o!==null)if(Array.isArray(s))for(let f=0,v=p.length;f<v;f++){const _=p[f],y=s[_.materialIndex];for(let x=Math.max(_.start,m.start),b=Math.min(o.count,Math.min(_.start+_.count,m.start+m.count));x<b;x+=3){const w=o.getX(x),M=o.getX(x+1),T=o.getX(x+2);a=bl(this,y,t,ur,l,h,c,u,d,w,M,T),a&&(a.faceIndex=Math.floor(x/3),a.face.materialIndex=_.materialIndex,e.push(a))}}else for(let f=Math.max(0,m.start),v=Math.min(o.count,m.start+m.count);f<v;f+=3){const _=o.getX(f),y=o.getX(f+1),x=o.getX(f+2);a=bl(this,s,t,ur,l,h,c,u,d,_,y,x),a&&(a.faceIndex=Math.floor(f/3),e.push(a))}else if(l!==void 0)if(Array.isArray(s))for(let f=0,v=p.length;f<v;f++){const _=p[f],y=s[_.materialIndex];for(let x=Math.max(_.start,m.start),b=Math.min(l.count,Math.min(_.start+_.count,m.start+m.count));x<b;x+=3)a=bl(this,y,t,ur,l,h,c,u,d,x,x+1,x+2),a&&(a.faceIndex=Math.floor(x/3),a.face.materialIndex=_.materialIndex,e.push(a))}else for(let f=Math.max(0,m.start),v=Math.min(l.count,m.start+m.count);f<v;f+=3)a=bl(this,s,t,ur,l,h,c,u,d,f,f+1,f+2),a&&(a.faceIndex=Math.floor(f/3),e.push(a))}}function bl(n,t,e,i,s,r,a,o,l,h,c,u){Vn.fromBufferAttribute(s,h),Gn.fromBufferAttribute(s,c),jn.fromBufferAttribute(s,u);const d=n.morphTargetInfluences;if(r&&d){ml.set(0,0,0),fl.set(0,0,0),gl.set(0,0,0);for(let m=0,f=r.length;m<f;m++){const v=d[m],_=r[m];v!==0&&(tu.fromBufferAttribute(_,h),eu.fromBufferAttribute(_,c),iu.fromBufferAttribute(_,u),a?(ml.addScaledVector(tu,v),fl.addScaledVector(eu,v),gl.addScaledVector(iu,v)):(ml.addScaledVector(tu.sub(Vn),v),fl.addScaledVector(eu.sub(Gn),v),gl.addScaledVector(iu.sub(jn),v)))}Vn.add(ml),Gn.add(fl),jn.add(gl)}n.isSkinnedMesh&&(n.boneTransform(h,Vn),n.boneTransform(c,Gn),n.boneTransform(u,jn));const p=function(m,f,v,_,y,x,b,w){let M;if(M=f.side===1?_.intersectTriangle(b,x,y,!0,w):_.intersectTriangle(y,x,b,f.side!==2,w),M===null)return null;xl.copy(w),xl.applyMatrix4(m.matrixWorld);const T=v.ray.origin.distanceTo(xl);return T<v.near||T>v.far?null:{distance:T,point:xl.clone(),object:m}}(n,t,e,i,Vn,Gn,jn,nu);if(p){o&&(vl.fromBufferAttribute(o,h),_l.fromBufferAttribute(o,c),yl.fromBufferAttribute(o,u),p.uv=mi.getUV(nu,Vn,Gn,jn,vl,_l,yl,new V)),l&&(vl.fromBufferAttribute(l,h),_l.fromBufferAttribute(l,c),yl.fromBufferAttribute(l,u),p.uv2=mi.getUV(nu,Vn,Gn,jn,vl,_l,yl,new V));const m={a:h,b:c,c:u,normal:new S,materialIndex:0};mi.getNormal(Vn,Gn,jn,m.normal),p.face=m}return p}class Wt extends gt{constructor(t=1,e=1,i=1,s=1,r=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:s,heightSegments:r,depthSegments:a};const o=this;s=Math.floor(s),r=Math.floor(r),a=Math.floor(a);const l=[],h=[],c=[],u=[];let d=0,p=0;function m(f,v,_,y,x,b,w,M,T,R,E){const A=b/T,z=w/R,F=b/2,G=w/2,U=M/2,k=T+1,H=R+1;let W=0,N=0;const X=new S;for(let K=0;K<H;K++){const $=K*z-G;for(let lt=0;lt<k;lt++){const yt=lt*A-F;X[f]=yt*y,X[v]=$*x,X[_]=U,h.push(X.x,X.y,X.z),X[f]=0,X[v]=0,X[_]=M>0?1:-1,c.push(X.x,X.y,X.z),u.push(lt/T),u.push(1-K/R),W+=1}}for(let K=0;K<R;K++)for(let $=0;$<T;$++){const lt=d+$+k*K,yt=d+$+k*(K+1),mt=d+($+1)+k*(K+1),bt=d+($+1)+k*K;l.push(lt,yt,bt),l.push(yt,mt,bt),N+=6}o.addGroup(p,N,E),p+=N,d+=W}m("z","y","x",-1,-1,i,e,t,a,r,0),m("z","y","x",1,-1,i,e,-t,a,r,1),m("x","z","y",1,1,t,i,e,s,a,2),m("x","z","y",1,-1,t,i,-e,s,a,3),m("x","y","z",1,-1,t,e,i,s,r,4),m("x","y","z",-1,-1,t,e,-i,s,r,5),this.setIndex(l),this.setAttribute("position",new Z(h,3)),this.setAttribute("normal",new Z(c,3)),this.setAttribute("uv",new Z(u,2))}static fromJSON(t){return new Wt(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function dr(n){const t={};for(const e in n){t[e]={};for(const i in n[e]){const s=n[e][i];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?t[e][i]=s.clone():Array.isArray(s)?t[e][i]=s.slice():t[e][i]=s}}return t}function Oe(n){const t={};for(let e=0;e<n.length;e++){const i=dr(n[e]);for(const s in i)t[s]=i[s]}return t}const ft={clone:dr,merge:Oe};class Qt extends ae{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,this.fragmentShader=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&(t.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=dr(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const s in this.uniforms){const r=this.uniforms[s].value;r&&r.isTexture?e.uniforms[s]={type:"t",value:r.toJSON(t).uuid}:r&&r.isColor?e.uniforms[s]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[s]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[s]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[s]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[s]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[s]={type:"m4",value:r.toArray()}:e.uniforms[s]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const i={};for(const s in this.extensions)this.extensions[s]===!0&&(i[s]=!0);return Object.keys(i).length>0&&(e.extensions=i),e}}class Ml extends Mt{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new at,this.projectionMatrix=new at,this.projectionMatrixInverse=new at}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class ee extends Ml{constructor(t=50,e=1,i=.1,s=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=s,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*ba*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*cs*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*ba*Math.atan(Math.tan(.5*cs*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,i,s,r,a){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*cs*this.fov)/this.zoom,i=2*e,s=this.aspect*i,r=-.5*s;const a=this.view;if(this.view!==null&&this.view.enabled){const l=a.fullWidth,h=a.fullHeight;r+=a.offsetX*s/l,e-=a.offsetY*i/h,s*=a.width/l,i*=a.height/h}const o=this.filmOffset;o!==0&&(r+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+s,e,e-i,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const pr=90;class wl extends Mt{constructor(t,e,i){if(super(),this.type="CubeCamera",i.isWebGLCubeRenderTarget!==!0)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=i;const s=new ee(pr,1,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new S(1,0,0)),this.add(s);const r=new ee(pr,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new S(-1,0,0)),this.add(r);const a=new ee(pr,1,t,e);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new S(0,1,0)),this.add(a);const o=new ee(pr,1,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new S(0,-1,0)),this.add(o);const l=new ee(pr,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new S(0,0,1)),this.add(l);const h=new ee(pr,1,t,e);h.layers=this.layers,h.up.set(0,-1,0),h.lookAt(new S(0,0,-1)),this.add(h)}update(t,e){this.parent===null&&this.updateMatrixWorld();const i=this.renderTarget,[s,r,a,o,l,h]=this.children,c=t.getRenderTarget(),u=t.toneMapping,d=t.xr.enabled;t.toneMapping=0,t.xr.enabled=!1;const p=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,t.setRenderTarget(i,0),t.render(e,s),t.setRenderTarget(i,1),t.render(e,r),t.setRenderTarget(i,2),t.render(e,a),t.setRenderTarget(i,3),t.render(e,o),t.setRenderTarget(i,4),t.render(e,l),i.texture.generateMipmaps=p,t.setRenderTarget(i,5),t.render(e,h),t.setRenderTarget(c),t.toneMapping=u,t.xr.enabled=d,i.texture.needsPMREMUpdate=!0}}class mr extends Gt{constructor(t,e,i,s,r,a,o,l,h,c){super(t=t!==void 0?t:[],e=e!==void 0?e:301,i,s,r,a,o,l,h,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class Sl extends Yt{constructor(t,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const i={width:t,height:t,depth:1},s=[i,i,i,i,i,i];this.texture=new mr(s,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0&&e.generateMipmaps,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:1006}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},s=new Wt(5,5,5),r=new Qt({name:"CubemapFromEquirect",uniforms:dr(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:1,blending:0});r.uniforms.tEquirect.value=e;const a=new ot(s,r),o=e.minFilter;return e.minFilter===1008&&(e.minFilter=1006),new wl(1,10,this).update(t,a),e.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,i,s){const r=t.getRenderTarget();for(let a=0;a<6;a++)t.setRenderTarget(this,a),t.clear(e,i,s);t.setRenderTarget(r)}}const su=new S,d1=new S,p1=new De;class ri{constructor(t=new S(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,s){return this.normal.set(t,e,i),this.constant=s,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const s=su.subVectors(i,e).cross(d1.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(s,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const i=t.delta(su),s=this.normal.dot(i);if(s===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/s;return r<0||r>1?null:e.copy(i).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||p1.getNormalMatrix(t),s=this.coplanarPoint(su).applyMatrix4(t),r=this.normal.applyMatrix3(i).normalize();return this.constant=-s.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const fr=new ii,Tl=new S;class gr{constructor(t=new ri,e=new ri,i=new ri,s=new ri,r=new ri,a=new ri){this.planes=[t,e,i,s,r,a]}set(t,e,i,s,r,a){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(i),o[3].copy(s),o[4].copy(r),o[5].copy(a),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t){const e=this.planes,i=t.elements,s=i[0],r=i[1],a=i[2],o=i[3],l=i[4],h=i[5],c=i[6],u=i[7],d=i[8],p=i[9],m=i[10],f=i[11],v=i[12],_=i[13],y=i[14],x=i[15];return e[0].setComponents(o-s,u-l,f-d,x-v).normalize(),e[1].setComponents(o+s,u+l,f+d,x+v).normalize(),e[2].setComponents(o+r,u+h,f+p,x+_).normalize(),e[3].setComponents(o-r,u-h,f-p,x-_).normalize(),e[4].setComponents(o-a,u-c,f-m,x-y).normalize(),e[5].setComponents(o+a,u+c,f+m,x+y).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),fr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(fr)}intersectsSprite(t){return fr.center.set(0,0,0),fr.radius=.7071067811865476,fr.applyMatrix4(t.matrixWorld),this.intersectsSphere(fr)}intersectsSphere(t){const e=this.planes,i=t.center,s=-t.radius;for(let r=0;r<6;r++)if(e[r].distanceToPoint(i)<s)return!1;return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const s=e[i];if(Tl.x=s.normal.x>0?t.max.x:t.min.x,Tl.y=s.normal.y>0?t.max.y:t.min.y,Tl.z=s.normal.z>0?t.max.z:t.min.z,s.distanceToPoint(Tl)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function _m(){let n=null,t=!1,e=null,i=null;function s(r,a){e(r,a),i=n.requestAnimationFrame(s)}return{start:function(){t!==!0&&e!==null&&(i=n.requestAnimationFrame(s),t=!0)},stop:function(){n.cancelAnimationFrame(i),t=!1},setAnimationLoop:function(r){e=r},setContext:function(r){n=r}}}function m1(n,t){const e=t.isWebGL2,i=new WeakMap;return{get:function(s){return s.isInterleavedBufferAttribute&&(s=s.data),i.get(s)},remove:function(s){s.isInterleavedBufferAttribute&&(s=s.data);const r=i.get(s);r&&(n.deleteBuffer(r.buffer),i.delete(s))},update:function(s,r){if(s.isGLBufferAttribute){const o=i.get(s);return void((!o||o.version<s.version)&&i.set(s,{buffer:s.buffer,type:s.type,bytesPerElement:s.elementSize,version:s.version}))}s.isInterleavedBufferAttribute&&(s=s.data);const a=i.get(s);a===void 0?i.set(s,function(o,l){const h=o.array,c=o.usage,u=n.createBuffer();let d;if(n.bindBuffer(l,u),n.bufferData(l,h,c),o.onUploadCallback(),h instanceof Float32Array)d=5126;else if(h instanceof Uint16Array)if(o.isFloat16BufferAttribute){if(!e)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");d=5131}else d=5123;else if(h instanceof Int16Array)d=5122;else if(h instanceof Uint32Array)d=5125;else if(h instanceof Int32Array)d=5124;else if(h instanceof Int8Array)d=5120;else if(h instanceof Uint8Array)d=5121;else{if(!(h instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);d=5121}return{buffer:u,type:d,bytesPerElement:h.BYTES_PER_ELEMENT,version:o.version}}(s,r)):a.version<s.version&&(function(o,l,h){const c=l.array,u=l.updateRange;n.bindBuffer(h,o),u.count===-1?n.bufferSubData(h,0,c):(e?n.bufferSubData(h,u.offset*c.BYTES_PER_ELEMENT,c,u.offset,u.count):n.bufferSubData(h,u.offset*c.BYTES_PER_ELEMENT,c.subarray(u.offset,u.offset+u.count)),u.count=-1)}(a.buffer,s,r),a.version=s.version)}}}class gi extends gt{constructor(t=1,e=1,i=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:s};const r=t/2,a=e/2,o=Math.floor(i),l=Math.floor(s),h=o+1,c=l+1,u=t/o,d=e/l,p=[],m=[],f=[],v=[];for(let _=0;_<c;_++){const y=_*d-a;for(let x=0;x<h;x++){const b=x*u-r;m.push(b,-y,0),f.push(0,0,1),v.push(x/o),v.push(1-_/l)}}for(let _=0;_<l;_++)for(let y=0;y<o;y++){const x=y+h*_,b=y+h*(_+1),w=y+1+h*(_+1),M=y+1+h*_;p.push(x,b,M),p.push(b,w,M)}this.setIndex(p),this.setAttribute("position",new Z(m,3)),this.setAttribute("normal",new Z(f,3)),this.setAttribute("uv",new Z(v,2))}static fromJSON(t){return new gi(t.width,t.height,t.widthSegments,t.heightSegments)}}const _t={alphamap_fragment:`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,alphamap_pars_fragment:`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment:`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,alphatest_pars_fragment:`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,aomap_fragment:`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aomap_pars_fragment:`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs:`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,iridescence_fragment:`#ifdef USE_IRIDESCENCE
const mat3 XYZ_TO_REC709 = mat3(
    3.2404542, -0.9692660,  0.0556434,
   -1.5371385,  1.8760108, -0.2040259,
   -0.4985314,  0.0415560,  1.0572252
);
vec3 Fresnel0ToIor( vec3 fresnel0 ) {
   vec3 sqrtF0 = sqrt( fresnel0 );
   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
}
vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
}
float IorToFresnel0( float transmittedIor, float incidentIor ) {
   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
}
vec3 evalSensitivity( float OPD, vec3 shift ) {
   float phase = 2.0 * PI * OPD * 1.0e-9;
   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );
   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );
   xyz /= 1.0685e-7;
   vec3 srgb = XYZ_TO_REC709 * xyz;
   return srgb;
}
vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
   vec3 I;
   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
   float cosTheta2Sq = 1.0 - sinTheta2Sq;
   if ( cosTheta2Sq < 0.0 ) {
       return vec3( 1.0 );
   }
   float cosTheta2 = sqrt( cosTheta2Sq );
   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
   float R12 = F_Schlick( R0, 1.0, cosTheta1 );
   float R21 = R12;
   float T121 = 1.0 - R12;
   float phi12 = 0.0;
   if ( iridescenceIOR < outsideIOR ) phi12 = PI;
   float phi21 = PI - phi12;
   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
   vec3 phi23 = vec3( 0.0 );
   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;
   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;
   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;
   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
   vec3 phi = vec3( phi21 ) + phi23;
   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
   vec3 r123 = sqrt( R123 );
   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
   vec3 C0 = R12 + Rs;
   I = C0;
   vec3 Cm = Rs - T121;
   for ( int m = 1; m <= 2; ++m ) {
       Cm *= r123;
       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
       I += Cm * Sm;
   }
   return max( I, vec3( 0.0 ) );
}
#endif`,bumpmap_pars_fragment:`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment:`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,clipping_planes_pars_fragment:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex:`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment:`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment:`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex:`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex:`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,common:`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,cube_uv_reflection_fragment:`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex:`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex:`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex:`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment:`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment:`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,envmap_fragment:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment:`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment:`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex:`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_physical_pars_fragment:`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV ) || defined( ENVMAP_TYPE_CUBE )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			#if defined( ENVMAP_TYPE_CUBE_UV )
				vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
				vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );
			#else
				vec4 envMapColor = textureCube( envMap, worldNormal );
			#endif
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV ) || defined( ENVMAP_TYPE_CUBE )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			#if defined( ENVMAP_TYPE_CUBE_UV )
				vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			#else
				vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
				vec4 envMapColor = textureCube( envMap, queryReflectVec );
			#endif
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,envmap_vertex:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex:`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,fog_pars_vertex:`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,fog_fragment:`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment:`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment:`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,lightmap_fragment:`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,lightmap_pars_fragment:`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_vertex:`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,lights_pars_begin:`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,lights_toon_fragment:`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment:`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,lights_phong_fragment:`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment:`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,lights_physical_fragment:`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,lights_physical_pars_fragment:`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin:`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
float dotNVi = saturate( dot( normal, geometry.viewDir ) );
if ( material.iridescenceThickness == 0.0 ) {
	material.iridescence = 0.0;
} else {
	material.iridescence = saturate( material.iridescence );
}
if ( material.iridescence > 0.0 ) {
	material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
	material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps:`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && ( defined( ENVMAP_TYPE_CUBE_UV ) || defined( ENVMAP_TYPE_CUBE ) )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,lights_fragment_end:`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,logdepthbuf_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,logdepthbuf_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,map_fragment:`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,map_pars_fragment:`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment:`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment:`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphcolor_vertex:`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,morphnormal_vertex:`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,morphtarget_pars_vertex:`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,morphtarget_vertex:`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,normal_fragment_begin:`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,normal_fragment_maps:`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normal_pars_fragment:`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_pars_vertex:`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_vertex:`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,normalmap_pars_fragment:`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,clearcoat_normal_fragment_begin:`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,clearcoat_normal_fragment_maps:`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,clearcoat_pars_fragment:`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,iridescence_pars_fragment:`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,output_fragment:`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,packing:`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,premultiplied_alpha_fragment:`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex:`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment:`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment:`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment:`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment:`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,shadowmap_pars_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,shadowmask_pars_fragment:`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex:`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex:`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,skinning_vertex:`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex:`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment:`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment:`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment:`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment:`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmission_fragment:`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,transmission_pars_fragment:`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,uv_pars_fragment:`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,uv_pars_vertex:`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,uv_vertex:`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,uv2_pars_fragment:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,uv2_pars_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,uv2_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,worldpos_vertex:`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,background_vert:`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,background_frag:`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,cube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,cube_frag:`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,depth_vert:`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,depth_frag:`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,distanceRGBA_vert:`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,distanceRGBA_frag:`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,equirect_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,equirect_frag:`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,linedashed_vert:`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,linedashed_frag:`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,meshbasic_vert:`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,meshbasic_frag:`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshlambert_vert:`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshlambert_frag:`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshmatcap_vert:`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,meshmatcap_frag:`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshnormal_vert:`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,meshnormal_frag:`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,meshphong_vert:`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphong_frag:`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphysical_vert:`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,meshphysical_frag:`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshtoon_vert:`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshtoon_frag:`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,points_vert:`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,points_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,shadow_vert:`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,shadow_frag:`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,sprite_vert:`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,sprite_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`},rt={common:{diffuse:{value:new nt(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new De},uv2Transform:{value:new De},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new V(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new nt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new nt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new De}},sprite:{diffuse:{value:new nt(16777215)},opacity:{value:1},center:{value:new V(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new De}}},ai={basic:{uniforms:Oe([rt.common,rt.specularmap,rt.envmap,rt.aomap,rt.lightmap,rt.fog]),vertexShader:_t.meshbasic_vert,fragmentShader:_t.meshbasic_frag},lambert:{uniforms:Oe([rt.common,rt.specularmap,rt.envmap,rt.aomap,rt.lightmap,rt.emissivemap,rt.fog,rt.lights,{emissive:{value:new nt(0)}}]),vertexShader:_t.meshlambert_vert,fragmentShader:_t.meshlambert_frag},phong:{uniforms:Oe([rt.common,rt.specularmap,rt.envmap,rt.aomap,rt.lightmap,rt.emissivemap,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.fog,rt.lights,{emissive:{value:new nt(0)},specular:{value:new nt(1118481)},shininess:{value:30}}]),vertexShader:_t.meshphong_vert,fragmentShader:_t.meshphong_frag},standard:{uniforms:Oe([rt.common,rt.envmap,rt.aomap,rt.lightmap,rt.emissivemap,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.roughnessmap,rt.metalnessmap,rt.fog,rt.lights,{emissive:{value:new nt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:_t.meshphysical_vert,fragmentShader:_t.meshphysical_frag},toon:{uniforms:Oe([rt.common,rt.aomap,rt.lightmap,rt.emissivemap,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.gradientmap,rt.fog,rt.lights,{emissive:{value:new nt(0)}}]),vertexShader:_t.meshtoon_vert,fragmentShader:_t.meshtoon_frag},matcap:{uniforms:Oe([rt.common,rt.bumpmap,rt.normalmap,rt.displacementmap,rt.fog,{matcap:{value:null}}]),vertexShader:_t.meshmatcap_vert,fragmentShader:_t.meshmatcap_frag},points:{uniforms:Oe([rt.points,rt.fog]),vertexShader:_t.points_vert,fragmentShader:_t.points_frag},dashed:{uniforms:Oe([rt.common,rt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:_t.linedashed_vert,fragmentShader:_t.linedashed_frag},depth:{uniforms:Oe([rt.common,rt.displacementmap]),vertexShader:_t.depth_vert,fragmentShader:_t.depth_frag},normal:{uniforms:Oe([rt.common,rt.bumpmap,rt.normalmap,rt.displacementmap,{opacity:{value:1}}]),vertexShader:_t.meshnormal_vert,fragmentShader:_t.meshnormal_frag},sprite:{uniforms:Oe([rt.sprite,rt.fog]),vertexShader:_t.sprite_vert,fragmentShader:_t.sprite_frag},background:{uniforms:{uvTransform:{value:new De},t2D:{value:null}},vertexShader:_t.background_vert,fragmentShader:_t.background_frag},cube:{uniforms:Oe([rt.envmap,{opacity:{value:1}}]),vertexShader:_t.cube_vert,fragmentShader:_t.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:_t.equirect_vert,fragmentShader:_t.equirect_frag},distanceRGBA:{uniforms:Oe([rt.common,rt.displacementmap,{referencePosition:{value:new S},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:_t.distanceRGBA_vert,fragmentShader:_t.distanceRGBA_frag},shadow:{uniforms:Oe([rt.lights,rt.fog,{color:{value:new nt(0)},opacity:{value:1}}]),vertexShader:_t.shadow_vert,fragmentShader:_t.shadow_frag}};function f1(n,t,e,i,s,r){const a=new nt(0);let o,l,h=s===!0?0:1,c=null,u=0,d=null;function p(m,f){e.buffers.color.setClear(m.r,m.g,m.b,f,r)}return{getClearColor:function(){return a},setClearColor:function(m,f=1){a.set(m),h=f,p(a,h)},getClearAlpha:function(){return h},setClearAlpha:function(m){h=m,p(a,h)},render:function(m,f){let v=!1,_=f.isScene===!0?f.background:null;_&&_.isTexture&&(_=t.get(_));const y=n.xr,x=y.getSession&&y.getSession();x&&x.environmentBlendMode==="additive"&&(_=null),_===null?p(a,h):_&&_.isColor&&(p(_,1),v=!0),(n.autoClear||v)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),_&&(_.isCubeTexture||_.mapping===306)?(l===void 0&&(l=new ot(new Wt(1,1,1),new Qt({name:"BackgroundCubeMaterial",uniforms:dr(ai.cube.uniforms),vertexShader:ai.cube.vertexShader,fragmentShader:ai.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(b,w,M){this.matrixWorld.copyPosition(M.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(l)),l.material.uniforms.envMap.value=_,l.material.uniforms.flipEnvMap.value=_.isCubeTexture&&_.isRenderTargetTexture===!1?-1:1,c===_&&u===_.version&&d===n.toneMapping||(l.material.needsUpdate=!0,c=_,u=_.version,d=n.toneMapping),l.layers.enableAll(),m.unshift(l,l.geometry,l.material,0,0,null)):_&&_.isTexture&&(o===void 0&&(o=new ot(new gi(2,2),new Qt({name:"BackgroundMaterial",uniforms:dr(ai.background.uniforms),vertexShader:ai.background.vertexShader,fragmentShader:ai.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(o)),o.material.uniforms.t2D.value=_,_.matrixAutoUpdate===!0&&_.updateMatrix(),o.material.uniforms.uvTransform.value.copy(_.matrix),c===_&&u===_.version&&d===n.toneMapping||(o.material.needsUpdate=!0,c=_,u=_.version,d=n.toneMapping),o.layers.enableAll(),m.unshift(o,o.geometry,o.material,0,0,null))}}}function g1(n,t,e,i){const s=n.getParameter(34921),r=i.isWebGL2?null:t.get("OES_vertex_array_object"),a=i.isWebGL2||r!==null,o={},l=p(null);let h=l,c=!1;function u(w){return i.isWebGL2?n.bindVertexArray(w):r.bindVertexArrayOES(w)}function d(w){return i.isWebGL2?n.deleteVertexArray(w):r.deleteVertexArrayOES(w)}function p(w){const M=[],T=[],R=[];for(let E=0;E<s;E++)M[E]=0,T[E]=0,R[E]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:M,enabledAttributes:T,attributeDivisors:R,object:w,attributes:{},index:null}}function m(){const w=h.newAttributes;for(let M=0,T=w.length;M<T;M++)w[M]=0}function f(w){v(w,0)}function v(w,M){const T=h.newAttributes,R=h.enabledAttributes,E=h.attributeDivisors;T[w]=1,R[w]===0&&(n.enableVertexAttribArray(w),R[w]=1),E[w]!==M&&((i.isWebGL2?n:t.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](w,M),E[w]=M)}function _(){const w=h.newAttributes,M=h.enabledAttributes;for(let T=0,R=M.length;T<R;T++)M[T]!==w[T]&&(n.disableVertexAttribArray(T),M[T]=0)}function y(w,M,T,R,E,A){i.isWebGL2!==!0||T!==5124&&T!==5125?n.vertexAttribPointer(w,M,T,R,E,A):n.vertexAttribIPointer(w,M,T,E,A)}function x(){b(),c=!0,h!==l&&(h=l,u(h.object))}function b(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(w,M,T,R,E){let A=!1;if(a){const z=function(F,G,U){const k=U.wireframe===!0;let H=o[F.id];H===void 0&&(H={},o[F.id]=H);let W=H[G.id];W===void 0&&(W={},H[G.id]=W);let N=W[k];return N===void 0&&(N=p(i.isWebGL2?n.createVertexArray():r.createVertexArrayOES()),W[k]=N),N}(R,T,M);h!==z&&(h=z,u(h.object)),A=function(F,G,U,k){const H=h.attributes,W=G.attributes;let N=0;const X=U.getAttributes();for(const K in X)if(X[K].location>=0){const $=H[K];let lt=W[K];if(lt===void 0&&(K==="instanceMatrix"&&F.instanceMatrix&&(lt=F.instanceMatrix),K==="instanceColor"&&F.instanceColor&&(lt=F.instanceColor)),$===void 0||$.attribute!==lt||lt&&$.data!==lt.data)return!0;N++}return h.attributesNum!==N||h.index!==k}(w,R,T,E),A&&function(F,G,U,k){const H={},W=G.attributes;let N=0;const X=U.getAttributes();for(const K in X)if(X[K].location>=0){let $=W[K];$===void 0&&(K==="instanceMatrix"&&F.instanceMatrix&&($=F.instanceMatrix),K==="instanceColor"&&F.instanceColor&&($=F.instanceColor));const lt={};lt.attribute=$,$&&$.data&&(lt.data=$.data),H[K]=lt,N++}h.attributes=H,h.attributesNum=N,h.index=k}(w,R,T,E)}else{const z=M.wireframe===!0;h.geometry===R.id&&h.program===T.id&&h.wireframe===z||(h.geometry=R.id,h.program=T.id,h.wireframe=z,A=!0)}E!==null&&e.update(E,34963),(A||c)&&(c=!1,function(z,F,G,U){if(i.isWebGL2===!1&&(z.isInstancedMesh||U.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;m();const k=U.attributes,H=G.getAttributes(),W=F.defaultAttributeValues;for(const N in H){const X=H[N];if(X.location>=0){let K=k[N];if(K===void 0&&(N==="instanceMatrix"&&z.instanceMatrix&&(K=z.instanceMatrix),N==="instanceColor"&&z.instanceColor&&(K=z.instanceColor)),K!==void 0){const $=K.normalized,lt=K.itemSize,yt=e.get(K);if(yt===void 0)continue;const mt=yt.buffer,bt=yt.type,I=yt.bytesPerElement;if(K.isInterleavedBufferAttribute){const P=K.data,q=P.stride,B=K.offset;if(P.isInstancedInterleavedBuffer){for(let D=0;D<X.locationSize;D++)v(X.location+D,P.meshPerAttribute);z.isInstancedMesh!==!0&&U._maxInstanceCount===void 0&&(U._maxInstanceCount=P.meshPerAttribute*P.count)}else for(let D=0;D<X.locationSize;D++)f(X.location+D);n.bindBuffer(34962,mt);for(let D=0;D<X.locationSize;D++)y(X.location+D,lt/X.locationSize,bt,$,q*I,(B+lt/X.locationSize*D)*I)}else{if(K.isInstancedBufferAttribute){for(let P=0;P<X.locationSize;P++)v(X.location+P,K.meshPerAttribute);z.isInstancedMesh!==!0&&U._maxInstanceCount===void 0&&(U._maxInstanceCount=K.meshPerAttribute*K.count)}else for(let P=0;P<X.locationSize;P++)f(X.location+P);n.bindBuffer(34962,mt);for(let P=0;P<X.locationSize;P++)y(X.location+P,lt/X.locationSize,bt,$,lt*I,lt/X.locationSize*P*I)}}else if(W!==void 0){const $=W[N];if($!==void 0)switch($.length){case 2:n.vertexAttrib2fv(X.location,$);break;case 3:n.vertexAttrib3fv(X.location,$);break;case 4:n.vertexAttrib4fv(X.location,$);break;default:n.vertexAttrib1fv(X.location,$)}}}}_()}(w,M,T,R),E!==null&&n.bindBuffer(34963,e.get(E).buffer))},reset:x,resetDefaultState:b,dispose:function(){x();for(const w in o){const M=o[w];for(const T in M){const R=M[T];for(const E in R)d(R[E].object),delete R[E];delete M[T]}delete o[w]}},releaseStatesOfGeometry:function(w){if(o[w.id]===void 0)return;const M=o[w.id];for(const T in M){const R=M[T];for(const E in R)d(R[E].object),delete R[E];delete M[T]}delete o[w.id]},releaseStatesOfProgram:function(w){for(const M in o){const T=o[M];if(T[w.id]===void 0)continue;const R=T[w.id];for(const E in R)d(R[E].object),delete R[E];delete T[w.id]}},initAttributes:m,enableAttribute:f,disableUnusedAttributes:_}}function v1(n,t,e,i){const s=i.isWebGL2;let r;this.setMode=function(a){r=a},this.render=function(a,o){n.drawArrays(r,a,o),e.update(o,r,1)},this.renderInstances=function(a,o,l){if(l===0)return;let h,c;if(s)h=n,c="drawArraysInstanced";else if(h=t.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",h===null)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");h[c](r,a,o,l),e.update(o,r,l)}}function _1(n,t,e){let i;function s(b){if(b==="highp"){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";b="mediump"}return b==="mediump"&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const r=typeof WebGL2RenderingContext<"u"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&n instanceof WebGL2ComputeRenderingContext;let a=e.precision!==void 0?e.precision:"highp";const o=s(a);o!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",o,"instead."),a=o);const l=r||t.has("WEBGL_draw_buffers"),h=e.logarithmicDepthBuffer===!0,c=n.getParameter(34930),u=n.getParameter(35660),d=n.getParameter(3379),p=n.getParameter(34076),m=n.getParameter(34921),f=n.getParameter(36347),v=n.getParameter(36348),_=n.getParameter(36349),y=u>0,x=r||t.has("OES_texture_float");return{isWebGL2:r,drawBuffers:l,getMaxAnisotropy:function(){if(i!==void 0)return i;if(t.has("EXT_texture_filter_anisotropic")===!0){const b=t.get("EXT_texture_filter_anisotropic");i=n.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i},getMaxPrecision:s,precision:a,logarithmicDepthBuffer:h,maxTextures:c,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:p,maxAttributes:m,maxVertexUniforms:f,maxVaryings:v,maxFragmentUniforms:_,vertexTextures:y,floatFragmentTextures:x,floatVertexTextures:y&&x,maxSamples:r?n.getParameter(36183):0}}function y1(n){const t=this;let e=null,i=0,s=!1,r=!1;const a=new ri,o=new De,l={value:null,needsUpdate:!1};function h(){l.value!==e&&(l.value=e,l.needsUpdate=i>0),t.numPlanes=i,t.numIntersection=0}function c(u,d,p,m){const f=u!==null?u.length:0;let v=null;if(f!==0){if(v=l.value,m!==!0||v===null){const _=p+4*f,y=d.matrixWorldInverse;o.getNormalMatrix(y),(v===null||v.length<_)&&(v=new Float32Array(_));for(let x=0,b=p;x!==f;++x,b+=4)a.copy(u[x]).applyMatrix4(y,o),a.normal.toArray(v,b),v[b+3]=a.constant}l.value=v,l.needsUpdate=!0}return t.numPlanes=f,t.numIntersection=0,v}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,d,p){const m=u.length!==0||d||i!==0||s;return s=d,e=c(u,p,0),i=u.length,m},this.beginShadows=function(){r=!0,c(null)},this.endShadows=function(){r=!1,h()},this.setState=function(u,d,p){const m=u.clippingPlanes,f=u.clipIntersection,v=u.clipShadows,_=n.get(u);if(!s||m===null||m.length===0||r&&!v)r?c(null):h();else{const y=r?0:i,x=4*y;let b=_.clippingState||null;l.value=b,b=c(m,d,x,p);for(let w=0;w!==x;++w)b[w]=e[w];_.clippingState=b,this.numIntersection=f?this.numPlanes:0,this.numPlanes+=y}}}function x1(n){let t=new WeakMap;function e(s,r){return r===303?s.mapping=301:r===304&&(s.mapping=302),s}function i(s){const r=s.target;r.removeEventListener("dispose",i);const a=t.get(r);a!==void 0&&(t.delete(r),a.dispose())}return{get:function(s){if(s&&s.isTexture&&s.isRenderTargetTexture===!1){const r=s.mapping;if(r===303||r===304){if(t.has(s))return e(t.get(s).texture,s.mapping);{const a=s.image;if(a&&a.height>0){const o=new Sl(a.height/2);return o.fromEquirectangularTexture(n,s),t.set(s,o),s.addEventListener("dispose",i),e(o.texture,s.mapping)}return null}}}return s},dispose:function(){t=new WeakMap}}}ai.physical={uniforms:Oe([ai.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new V(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new nt(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new V},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new nt(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new nt(1,1,1)},specularColorMap:{value:null}}]),vertexShader:_t.meshphysical_vert,fragmentShader:_t.meshphysical_frag};class vr extends Ml{constructor(t=-1,e=1,i=1,s=-1,r=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=s,this.near=r,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,i,s,r,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,s=(this.top+this.bottom)/2;let r=i-t,a=i+t,o=s+e,l=s-e;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=h*this.view.offsetX,a=r+h*this.view.width,o-=c*this.view.offsetY,l=o-c*this.view.height}this.projectionMatrix.makeOrthographic(r,a,o,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}const ym=[.125,.215,.35,.446,.526,.582],Aa=20,ru=new vr,xm=new nt;let Pa=null;const gs=(1+Math.sqrt(5))/2,_r=1/gs,bm=[new S(1,1,1),new S(-1,1,1),new S(1,1,-1),new S(-1,1,-1),new S(0,gs,_r),new S(0,gs,-_r),new S(_r,0,gs),new S(-_r,0,gs),new S(gs,_r,0),new S(-gs,_r,0)];class vs{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,i=.1,s=100,r=null,a=null){return Pa=this._renderer.getRenderTarget(),r||(r=this._allocateTargets()),a&&(this._pingPongRenderTarget=a),this._setSize(256),r.depthBuffer=!0,this._sceneToCubeUV(t,i,s,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}prepareForRenderTarget(t,e=null,i=256){this._setSize(i);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=Mm(s));const r=3*Math.max(this._cubeSize,112),a=4*this._cubeSize;this._blurMaterial=Sm(s,r,a),t.setSize(r,a),e&&e.setSize(r,a)}fromSceneToRenderTarget(t,e,i,s=0,r=.1,a=100){return Pa=this._renderer.getRenderTarget(),this._pingPongRenderTarget=i,this._sceneToCubeUV(t,r,a,e),s>0&&this._blur(e,0,0,s),this._applyPMREM(e),this._renderer.setRenderTarget(Pa),e.scissorTest=!1,Ra(e,0,0,e.width,e.height),e}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=Em(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=Tm(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(Pa),t.scissorTest=!1,Ra(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===301||t.mapping===302?this._setSize(t.image.length===0?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),Pa=this._renderer.getRenderTarget();const i=e||this._allocateTargets();return this._textureToCubeUV(t,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,i={magFilter:1006,minFilter:1006,generateMipmaps:!1,type:1016,format:1023,encoding:3e3,depthBuffer:!1},s=wm(t,e,i);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=wm(t,e,i);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=Mm(r)),this._blurMaterial=Sm(r,t,e)}return s}_compileMaterial(t){const e=new ot(this._lodPlanes[0],t);this._renderer.compile(e,ru)}_sceneToCubeUV(t,e,i,s){const r=new ee(90,1,e,i),a=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],l=this._renderer,h=l.autoClear,c=l.toneMapping;l.getClearColor(xm),l.toneMapping=0,l.autoClear=!1;const u=new Zt({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),d=new ot(new Wt,u);let p=!1;const m=t.background;m?m.isColor&&(u.color.copy(m),t.background=null,p=!0):(u.color.copy(xm),p=!0);for(let f=0;f<6;f++){const v=f%3;v===0?(r.up.set(0,a[f],0),r.lookAt(o[f],0,0)):v===1?(r.up.set(0,0,a[f]),r.lookAt(0,o[f],0)):(r.up.set(0,a[f],0),r.lookAt(0,0,o[f]));const _=this._cubeSize;Ra(s,v*_,f>2?_:0,_,_),l.setRenderTarget(s),p&&l.render(d,r),l.render(t,r)}d.geometry.dispose(),d.material.dispose(),l.toneMapping=c,l.autoClear=h,t.background=m}_textureToCubeUV(t,e){const i=this._renderer,s=t.mapping===301||t.mapping===302;s?(this._cubemapMaterial===null&&(this._cubemapMaterial=Em()),this._cubemapMaterial.uniforms.flipEnvMap.value=t.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=Tm());const r=s?this._cubemapMaterial:this._equirectMaterial,a=new ot(this._lodPlanes[0],r);r.uniforms.envMap.value=t;const o=this._cubeSize;Ra(e,0,0,3*o,2*o),i.setRenderTarget(e),i.render(a,ru)}_applyPMREM(t){const e=this._renderer,i=e.autoClear;e.autoClear=!1;for(let s=1;s<this._lodPlanes.length;s++){const r=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),a=bm[(s-1)%bm.length];this._blur(t,s-1,s,r,a)}e.autoClear=i}_blur(t,e,i,s,r){const a=this._pingPongRenderTarget;this._halfBlur(t,a,e,i,s,"latitudinal",r),this._halfBlur(a,t,i,i,s,"longitudinal",r)}_halfBlur(t,e,i,s,r,a,o){const l=this._renderer,h=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new ot(this._lodPlanes[s],h),u=h.uniforms,d=this._sizeLods[i]-1,p=isFinite(r)?Math.PI/(2*d):2*Math.PI/39,m=r/p,f=isFinite(r)?1+Math.floor(3*m):Aa;f>Aa&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const v=[];let _=0;for(let b=0;b<Aa;++b){const w=b/m,M=Math.exp(-w*w/2);v.push(M),b===0?_+=M:b<f&&(_+=2*M)}for(let b=0;b<v.length;b++)v[b]=v[b]/_;u.envMap.value=t.texture,u.samples.value=f,u.weights.value=v,u.latitudinal.value=a==="latitudinal",o&&(u.poleAxis.value=o);const{_lodMax:y}=this;u.dTheta.value=p,u.mipInt.value=y-i;const x=this._sizeLods[s];Ra(e,3*x*(s>y-4?s-y+4:0),4*(this._cubeSize-x),3*x,2*x),l.setRenderTarget(e),l.render(c,ru)}}function Mm(n){const t=[],e=[],i=[];let s=n;const r=n-4+1+ym.length;for(let a=0;a<r;a++){const o=Math.pow(2,s);e.push(o);let l=1/o;a>n-4?l=ym[a-n+4-1]:a===0&&(l=0),i.push(l);const h=1/(o-2),c=-h,u=1+h,d=[c,c,u,c,u,u,c,c,u,u,c,u],p=6,m=6,f=3,v=2,_=1,y=new Float32Array(f*m*p),x=new Float32Array(v*m*p),b=new Float32Array(_*m*p);for(let M=0;M<p;M++){const T=M%3*2/3-1,R=M>2?0:-1,E=[T,R,0,T+2/3,R,0,T+2/3,R+1,0,T,R,0,T+2/3,R+1,0,T,R+1,0];y.set(E,f*m*M),x.set(d,v*m*M);const A=[M,M,M,M,M,M];b.set(A,_*m*M)}const w=new gt;w.setAttribute("position",new Lt(y,f)),w.setAttribute("uv",new Lt(x,v)),w.setAttribute("faceIndex",new Lt(b,_)),t.push(w),s>4&&s--}return{lodPlanes:t,sizeLods:e,sigmas:i}}function wm(n,t,e){const i=new Yt(n,t,e);return i.texture.mapping=306,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}function Ra(n,t,e,i,s){n.viewport.set(t,e,i,s),n.scissor.set(t,e,i,s)}function Sm(n,t,e){const i=new Float32Array(Aa),s=new S(0,1,0);return new Qt({name:"SphericalGaussianBlur",defines:{n:Aa,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:s}},vertexShader:au(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}function Tm(){return new Qt({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:au(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}function Em(){return new Qt({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:au(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}function au(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		mat3 getRotationMatrix(vec3 axis, float angle) {
			axis = normalize(axis);
			float s = sin(angle);
			float c = cos(angle);
			float oc = 1.0 - c;
		
			return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);
		}
		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}
			mat3 rotationMatrix = getRotationMatrix(vec3(1.0, 0.0, 0.0), 1.57);
			direction = rotationMatrix * direction;
			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function b1(n){let t=new WeakMap,e=null;function i(s){const r=s.target;r.removeEventListener("dispose",i);const a=t.get(r);a!==void 0&&(t.delete(r),a.dispose())}return{get:function(s){if(s&&s.isTexture){const r=s.mapping,a=r===303||r===304,o=r===301||r===302;if(a||o){if(s.isRenderTargetTexture&&s.needsPMREMUpdate===!0){s.needsPMREMUpdate=!1;let l=t.get(s);return e===null&&(e=new vs(n)),l=a?e.fromEquirectangular(s,l):e.fromCubemap(s,l),t.set(s,l),l.texture}if(t.has(s))return t.get(s).texture;{const l=s.image;if(a&&l&&l.height>0||o&&l&&function(h){let c=0;const u=6;for(let d=0;d<u;d++)h[d]!==void 0&&c++;return c===u}(l)){e===null&&(e=new vs(n));const h=a?e.fromEquirectangular(s):e.fromCubemap(s);return t.set(s,h),s.addEventListener("dispose",i),h.texture}return null}}}return s},dispose:function(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}}}function M1(n){const t={};function e(i){if(t[i]!==void 0)return t[i];let s;switch(i){case"WEBGL_depth_texture":s=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=n.getExtension(i)}return t[i]=s,s}return{has:function(i){return e(i)!==null},init:function(i){i.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture")},get:function(i){const s=e(i);return s===null&&console.warn("THREE.WebGLRenderer: "+i+" extension not supported."),s}}}function w1(n,t,e,i){const s={},r=new WeakMap;function a(l){const h=l.target;h.index!==null&&t.remove(h.index);for(const u in h.attributes)t.remove(h.attributes[u]);h.removeEventListener("dispose",a),delete s[h.id];const c=r.get(h);c&&(t.remove(c),r.delete(h)),i.releaseStatesOfGeometry(h),h.isInstancedBufferGeometry===!0&&delete h._maxInstanceCount,e.memory.geometries--}function o(l){const h=[],c=l.index,u=l.attributes.position;let d=0;if(c!==null){const f=c.array;d=c.version;for(let v=0,_=f.length;v<_;v+=3){const y=f[v+0],x=f[v+1],b=f[v+2];h.push(y,x,x,b,b,y)}}else{const f=u.array;d=u.version;for(let v=0,_=f.length/3-1;v<_;v+=3){const y=v+0,x=v+1,b=v+2;h.push(y,x,x,b,b,y)}}const p=new(sm(h)?pl:Kc)(h,1);p.version=d;const m=r.get(l);m&&t.remove(m),r.set(l,p)}return{get:function(l,h){return s[h.id]===!0||(h.addEventListener("dispose",a),s[h.id]=!0,e.memory.geometries++),h},update:function(l){const h=l.attributes;for(const u in h)t.update(h[u],34962);const c=l.morphAttributes;for(const u in c){const d=c[u];for(let p=0,m=d.length;p<m;p++)t.update(d[p],34962)}},getWireframeAttribute:function(l){const h=r.get(l);if(h){const c=l.index;c!==null&&h.version<c.version&&o(l)}else o(l);return r.get(l)}}}function S1(n,t,e,i){const s=i.isWebGL2;let r,a,o;this.setMode=function(l){r=l},this.setIndex=function(l){a=l.type,o=l.bytesPerElement},this.render=function(l,h){n.drawElements(r,h,a,l*o),e.update(h,r,1)},this.renderInstances=function(l,h,c){if(c===0)return;let u,d;if(s)u=n,d="drawElementsInstanced";else if(u=t.get("ANGLE_instanced_arrays"),d="drawElementsInstancedANGLE",u===null)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[d](r,h,a,l*o,c),e.update(h,r,c)}}function T1(n){const t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(e,i,s){switch(t.calls++,i){case 4:t.triangles+=s*(e/3);break;case 1:t.lines+=s*(e/2);break;case 3:t.lines+=s*(e-1);break;case 2:t.lines+=s*e;break;case 0:t.points+=s*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",i)}}}}function E1(n,t){return n[0]-t[0]}function C1(n,t){return Math.abs(t[1])-Math.abs(n[1])}function ou(n,t){let e=1;const i=t.isInterleavedBufferAttribute?t.data.array:t.array;i instanceof Int8Array?e=127:i instanceof Int16Array?e=32767:i instanceof Int32Array?e=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",i),n.divideScalar(e)}function A1(n,t,e){const i={},s=new Float32Array(8),r=new WeakMap,a=new Ot,o=[];for(let l=0;l<8;l++)o[l]=[l,0];return{update:function(l,h,c,u){const d=l.morphTargetInfluences;if(t.isWebGL2===!0){const p=h.morphAttributes.position||h.morphAttributes.normal||h.morphAttributes.color,m=p!==void 0?p.length:0;let f=r.get(h);if(f===void 0||f.count!==m){let y=function(){G.dispose(),r.delete(h),h.removeEventListener("dispose",y)};f!==void 0&&f.texture.dispose();const x=h.morphAttributes.position!==void 0,b=h.morphAttributes.normal!==void 0,w=h.morphAttributes.color!==void 0,M=h.morphAttributes.position||[],T=h.morphAttributes.normal||[],R=h.morphAttributes.color||[];let E=0;x===!0&&(E=1),b===!0&&(E=2),w===!0&&(E=3);let A=h.attributes.position.count*E,z=1;A>t.maxTextureSize&&(z=Math.ceil(A/t.maxTextureSize),A=t.maxTextureSize);const F=new Float32Array(A*z*4*m),G=new Sa(F,A,z,m);G.type=1015,G.needsUpdate=!0;const U=4*E;for(let k=0;k<m;k++){const H=M[k],W=T[k],N=R[k],X=A*z*4*k;for(let K=0;K<H.count;K++){const $=K*U;x===!0&&(a.fromBufferAttribute(H,K),H.normalized===!0&&ou(a,H),F[X+$+0]=a.x,F[X+$+1]=a.y,F[X+$+2]=a.z,F[X+$+3]=0),b===!0&&(a.fromBufferAttribute(W,K),W.normalized===!0&&ou(a,W),F[X+$+4]=a.x,F[X+$+5]=a.y,F[X+$+6]=a.z,F[X+$+7]=0),w===!0&&(a.fromBufferAttribute(N,K),N.normalized===!0&&ou(a,N),F[X+$+8]=a.x,F[X+$+9]=a.y,F[X+$+10]=a.z,F[X+$+11]=N.itemSize===4?a.w:1)}}f={count:m,texture:G,size:new V(A,z)},r.set(h,f),h.addEventListener("dispose",y)}let v=0;for(let y=0;y<d.length;y++)v+=d[y];const _=h.morphTargetsRelative?1:1-v;u.getUniforms().setValue(n,"morphTargetBaseInfluence",_),u.getUniforms().setValue(n,"morphTargetInfluences",d),u.getUniforms().setValue(n,"morphTargetsTexture",f.texture,e),u.getUniforms().setValue(n,"morphTargetsTextureSize",f.size)}else{const p=d===void 0?0:d.length;let m=i[h.id];if(m===void 0||m.length!==p){m=[];for(let x=0;x<p;x++)m[x]=[x,0];i[h.id]=m}for(let x=0;x<p;x++){const b=m[x];b[0]=x,b[1]=d[x]}m.sort(C1);for(let x=0;x<8;x++)x<p&&m[x][1]?(o[x][0]=m[x][0],o[x][1]=m[x][1]):(o[x][0]=Number.MAX_SAFE_INTEGER,o[x][1]=0);o.sort(E1);const f=h.morphAttributes.position,v=h.morphAttributes.normal;let _=0;for(let x=0;x<8;x++){const b=o[x],w=b[0],M=b[1];w!==Number.MAX_SAFE_INTEGER&&M?(f&&h.getAttribute("morphTarget"+x)!==f[w]&&h.setAttribute("morphTarget"+x,f[w]),v&&h.getAttribute("morphNormal"+x)!==v[w]&&h.setAttribute("morphNormal"+x,v[w]),s[x]=M,_+=M):(f&&h.hasAttribute("morphTarget"+x)===!0&&h.deleteAttribute("morphTarget"+x),v&&h.hasAttribute("morphNormal"+x)===!0&&h.deleteAttribute("morphNormal"+x),s[x]=0)}const y=h.morphTargetsRelative?1:1-_;u.getUniforms().setValue(n,"morphTargetBaseInfluence",y),u.getUniforms().setValue(n,"morphTargetInfluences",s)}}}}function P1(n,t,e,i){let s=new WeakMap;function r(a){const o=a.target;o.removeEventListener("dispose",r),e.remove(o.instanceMatrix),o.instanceColor!==null&&e.remove(o.instanceColor)}return{update:function(a){const o=i.render.frame,l=a.geometry,h=t.get(a,l);return s.get(h)!==o&&(t.update(h),s.set(h,o)),a.isInstancedMesh&&(a.hasEventListener("dispose",r)===!1&&a.addEventListener("dispose",r),e.update(a.instanceMatrix,34962),a.instanceColor!==null&&e.update(a.instanceColor,34962)),h},dispose:function(){s=new WeakMap}}}const Cm=new Gt,Am=new Sa,Pm=new nl,Rm=new mr,Lm=[],Im=[],Dm=new Float32Array(16),Om=new Float32Array(9),zm=new Float32Array(4);function yr(n,t,e){const i=n[0];if(i<=0||i>0)return n;const s=t*e;let r=Lm[s];if(r===void 0&&(r=new Float32Array(s),Lm[s]=r),t!==0){i.toArray(r,0);for(let a=1,o=0;a!==t;++a)o+=e,n[a].toArray(r,o)}return r}function ke(n,t){if(n.length!==t.length)return!1;for(let e=0,i=n.length;e<i;e++)if(n[e]!==t[e])return!1;return!0}function Be(n,t){for(let e=0,i=t.length;e<i;e++)n[e]=t[e]}function El(n,t){let e=Im[t];e===void 0&&(e=new Int32Array(t),Im[t]=e);for(let i=0;i!==t;++i)e[i]=n.allocateTextureUnit();return e}function R1(n,t){const e=this.cache;e[0]!==t&&(n.uniform1f(this.addr,t),e[0]=t)}function L1(n,t){const e=this.cache;if(t.x!==void 0)e[0]===t.x&&e[1]===t.y||(n.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(ke(e,t))return;n.uniform2fv(this.addr,t),Be(e,t)}}function I1(n,t){const e=this.cache;if(t.x!==void 0)e[0]===t.x&&e[1]===t.y&&e[2]===t.z||(n.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)e[0]===t.r&&e[1]===t.g&&e[2]===t.b||(n.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(ke(e,t))return;n.uniform3fv(this.addr,t),Be(e,t)}}function D1(n,t){const e=this.cache;if(t.x!==void 0)e[0]===t.x&&e[1]===t.y&&e[2]===t.z&&e[3]===t.w||(n.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(ke(e,t))return;n.uniform4fv(this.addr,t),Be(e,t)}}function O1(n,t){const e=this.cache,i=t.elements;if(i===void 0){if(ke(e,t))return;n.uniformMatrix2fv(this.addr,!1,t),Be(e,t)}else{if(ke(e,i))return;zm.set(i),n.uniformMatrix2fv(this.addr,!1,zm),Be(e,i)}}function z1(n,t){const e=this.cache,i=t.elements;if(i===void 0){if(ke(e,t))return;n.uniformMatrix3fv(this.addr,!1,t),Be(e,t)}else{if(ke(e,i))return;Om.set(i),n.uniformMatrix3fv(this.addr,!1,Om),Be(e,i)}}function U1(n,t){const e=this.cache,i=t.elements;if(i===void 0){if(ke(e,t))return;n.uniformMatrix4fv(this.addr,!1,t),Be(e,t)}else{if(ke(e,i))return;Dm.set(i),n.uniformMatrix4fv(this.addr,!1,Dm),Be(e,i)}}function F1(n,t){const e=this.cache;e[0]!==t&&(n.uniform1i(this.addr,t),e[0]=t)}function N1(n,t){const e=this.cache;ke(e,t)||(n.uniform2iv(this.addr,t),Be(e,t))}function k1(n,t){const e=this.cache;ke(e,t)||(n.uniform3iv(this.addr,t),Be(e,t))}function B1(n,t){const e=this.cache;ke(e,t)||(n.uniform4iv(this.addr,t),Be(e,t))}function V1(n,t){const e=this.cache;e[0]!==t&&(n.uniform1ui(this.addr,t),e[0]=t)}function G1(n,t){const e=this.cache;ke(e,t)||(n.uniform2uiv(this.addr,t),Be(e,t))}function j1(n,t){const e=this.cache;ke(e,t)||(n.uniform3uiv(this.addr,t),Be(e,t))}function H1(n,t){const e=this.cache;ke(e,t)||(n.uniform4uiv(this.addr,t),Be(e,t))}function W1(n,t,e){const i=this.cache,s=e.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),e.setTexture2D(t||Cm,s)}function q1(n,t,e){const i=this.cache,s=e.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),e.setTexture3D(t||Pm,s)}function X1(n,t,e){const i=this.cache,s=e.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),e.setTextureCube(t||Rm,s)}function Y1(n,t,e){const i=this.cache,s=e.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),e.setTexture2DArray(t||Am,s)}function Z1(n,t){n.uniform1fv(this.addr,t)}function J1(n,t){const e=yr(t,this.size,2);n.uniform2fv(this.addr,e)}function K1(n,t){const e=yr(t,this.size,3);n.uniform3fv(this.addr,e)}function Q1(n,t){const e=yr(t,this.size,4);n.uniform4fv(this.addr,e)}function $1(n,t){const e=yr(t,this.size,4);n.uniformMatrix2fv(this.addr,!1,e)}function tx(n,t){const e=yr(t,this.size,9);n.uniformMatrix3fv(this.addr,!1,e)}function ex(n,t){const e=yr(t,this.size,16);n.uniformMatrix4fv(this.addr,!1,e)}function ix(n,t){n.uniform1iv(this.addr,t)}function nx(n,t){n.uniform2iv(this.addr,t)}function sx(n,t){n.uniform3iv(this.addr,t)}function rx(n,t){n.uniform4iv(this.addr,t)}function ax(n,t){n.uniform1uiv(this.addr,t)}function ox(n,t){n.uniform2uiv(this.addr,t)}function lx(n,t){n.uniform3uiv(this.addr,t)}function hx(n,t){n.uniform4uiv(this.addr,t)}function cx(n,t,e){const i=t.length,s=El(e,i);n.uniform1iv(this.addr,s);for(let r=0;r!==i;++r)e.setTexture2D(t[r]||Cm,s[r])}function ux(n,t,e){const i=t.length,s=El(e,i);n.uniform1iv(this.addr,s);for(let r=0;r!==i;++r)e.setTexture3D(t[r]||Pm,s[r])}function dx(n,t,e){const i=t.length,s=El(e,i);n.uniform1iv(this.addr,s);for(let r=0;r!==i;++r)e.setTextureCube(t[r]||Rm,s[r])}function px(n,t,e){const i=t.length,s=El(e,i);n.uniform1iv(this.addr,s);for(let r=0;r!==i;++r)e.setTexture2DArray(t[r]||Am,s[r])}class mx{constructor(t,e,i){this.id=t,this.addr=i,this.cache=[],this.setValue=function(s){switch(s){case 5126:return R1;case 35664:return L1;case 35665:return I1;case 35666:return D1;case 35674:return O1;case 35675:return z1;case 35676:return U1;case 5124:case 35670:return F1;case 35667:case 35671:return N1;case 35668:case 35672:return k1;case 35669:case 35673:return B1;case 5125:return V1;case 36294:return G1;case 36295:return j1;case 36296:return H1;case 35678:case 36198:case 36298:case 36306:case 35682:return W1;case 35679:case 36299:case 36307:return q1;case 35680:case 36300:case 36308:case 36293:return X1;case 36289:case 36303:case 36311:case 36292:return Y1}}(e.type)}}class fx{constructor(t,e,i){this.id=t,this.addr=i,this.cache=[],this.size=e.size,this.setValue=function(s){switch(s){case 5126:return Z1;case 35664:return J1;case 35665:return K1;case 35666:return Q1;case 35674:return $1;case 35675:return tx;case 35676:return ex;case 5124:case 35670:return ix;case 35667:case 35671:return nx;case 35668:case 35672:return sx;case 35669:case 35673:return rx;case 5125:return ax;case 36294:return ox;case 36295:return lx;case 36296:return hx;case 35678:case 36198:case 36298:case 36306:case 35682:return cx;case 35679:case 36299:case 36307:return ux;case 35680:case 36300:case 36308:case 36293:return dx;case 36289:case 36303:case 36311:case 36292:return px}}(e.type)}}class gx{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,i){const s=this.seq;for(let r=0,a=s.length;r!==a;++r){const o=s[r];o.setValue(t,e[o.id],i)}}}const lu=/(\w+)(\])?(\[|\.)?/g;function Um(n,t){n.seq.push(t),n.map[t.id]=t}function vx(n,t,e){const i=n.name,s=i.length;for(lu.lastIndex=0;;){const r=lu.exec(i),a=lu.lastIndex;let o=r[1];const l=r[2]==="]",h=r[3];if(l&&(o|=0),h===void 0||h==="["&&a+2===s){Um(e,h===void 0?new mx(o,n,t):new fx(o,n,t));break}{let c=e.map[o];c===void 0&&(c=new gx(o),Um(e,c)),e=c}}}class Cl{constructor(t,e){this.seq=[],this.map={};const i=t.getProgramParameter(e,35718);for(let s=0;s<i;++s){const r=t.getActiveUniform(e,s);vx(r,t.getUniformLocation(e,r.name),this)}}setValue(t,e,i,s){const r=this.map[e];r!==void 0&&r.setValue(t,i,s)}setOptional(t,e,i){const s=e[i];s!==void 0&&this.setValue(t,i,s)}static upload(t,e,i,s){for(let r=0,a=e.length;r!==a;++r){const o=e[r],l=i[o.id];l.needsUpdate!==!1&&o.setValue(t,l.value,s)}}static seqWithValue(t,e){const i=[];for(let s=0,r=t.length;s!==r;++s){const a=t[s];a.id in e&&i.push(a)}return i}}function Fm(n,t,e){const i=n.createShader(t);return n.shaderSource(i,e),n.compileShader(i),i}let _x=0;function Nm(n,t,e){const i=n.getShaderParameter(t,35713),s=n.getShaderInfoLog(t).trim();if(i&&s==="")return"";const r=/ERROR: 0:(\d+)/.exec(s);if(r){const a=parseInt(r[1]);return e.toUpperCase()+`

`+s+`

`+function(o,l){const h=o.split(`
`),c=[],u=Math.max(l-6,0),d=Math.min(l+6,h.length);for(let p=u;p<d;p++){const m=p+1;c.push(`${m===l?">":" "} ${m}: ${h[p]}`)}return c.join(`
`)}(n.getShaderSource(t),a)}return s}function yx(n,t){const e=function(i){switch(i){case 3e3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",i),["Linear","( value )"]}}(t);return"vec4 "+n+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function xx(n,t){let e;switch(t){case 1:e="Linear";break;case 2:e="Reinhard";break;case 3:e="OptimizedCineon";break;case 4:e="ACESFilmic";break;case 5:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+n+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function La(n){return n!==""}function km(n,t){return n.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Bm(n,t){return n.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const bx=/^[ \t]*#include +<([\w\d./]+)>/gm;function hu(n){return n.replace(bx,Mx)}function Mx(n,t){const e=_t[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return hu(e)}const wx=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Sx=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Vm(n){return n.replace(Sx,Gm).replace(wx,Tx)}function Tx(n,t,e,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Gm(n,t,e,i)}function Gm(n,t,e,i){let s="";for(let r=parseInt(t);r<parseInt(e);r++)s+=i.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return s}function jm(n){let t="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?t+=`
#define HIGH_PRECISION`:n.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function Ex(n,t,e,i){const s=n.getContext(),r=e.defines;let a=e.vertexShader,o=e.fragmentShader;const l=function(E){let A="SHADOWMAP_TYPE_BASIC";return E.shadowMapType===1?A="SHADOWMAP_TYPE_PCF":E.shadowMapType===2?A="SHADOWMAP_TYPE_PCF_SOFT":E.shadowMapType===3&&(A="SHADOWMAP_TYPE_VSM"),A}(e),h=function(E){let A="ENVMAP_TYPE_CUBE";if(E.envMap)switch(E.envMapMode){case 301:case 302:A="ENVMAP_TYPE_CUBE";break;case 306:A="ENVMAP_TYPE_CUBE_UV"}return A}(e),c=function(E){let A="ENVMAP_MODE_REFLECTION";return E.envMap&&E.envMapMode===302&&(A="ENVMAP_MODE_REFRACTION"),A}(e),u=function(E){let A="ENVMAP_BLENDING_NONE";if(E.envMap)switch(E.combine){case 0:A="ENVMAP_BLENDING_MULTIPLY";break;case 1:A="ENVMAP_BLENDING_MIX";break;case 2:A="ENVMAP_BLENDING_ADD"}return A}(e),d=function(E){const A=E.envMapCubeUVHeight;if(A===null)return null;const z=Math.log2(A)-2,F=1/A;return{texelWidth:1/(3*Math.max(Math.pow(2,z),112)),texelHeight:F,maxMip:z}}(e),p=e.isWebGL2?"":function(E){return[E.extensionDerivatives||E.envMapCubeUVHeight||E.bumpMap||E.tangentSpaceNormalMap||E.clearcoatNormalMap||E.flatShading||E.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(E.extensionFragDepth||E.logarithmicDepthBuffer)&&E.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",E.extensionDrawBuffers&&E.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(E.extensionShaderTextureLOD||E.envMap||E.transmission)&&E.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(La).join(`
`)}(e),m=function(E){const A=[];for(const z in E){const F=E[z];F!==!1&&A.push("#define "+z+" "+F)}return A.join(`
`)}(r),f=s.createProgram();let v,_,y=e.glslVersion?"#version "+e.glslVersion+`
`:"";if(e.isRawShaderMaterial?(v=[m].filter(La).join(`
`),v.length>0&&(v+=`
`),_=[p,m].filter(La).join(`
`),_.length>0&&(_+=`
`)):(v=[jm(e),"#define SHADER_NAME "+e.shaderName,m,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"",e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+c:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphColors&&e.isWebGL2?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(La).join(`
`),_=[p,jm(e),"#define SHADER_NAME "+e.shaderName,m,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+h:"",e.envMap?"#define "+c:"",e.envMap?"#define "+u:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescence?"#define USE_IRIDESCENCE":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==0?"#define TONE_MAPPING":"",e.toneMapping!==0?_t.tonemapping_pars_fragment:"",e.toneMapping!==0?xx("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",_t.encodings_pars_fragment,yx("linearToOutputTexel",e.outputEncoding),e.useDepthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(La).join(`
`)),n.onShaderBeforeResolve){const E=n.onShaderBeforeResolve(a,o,e);a=E.vertexShader,o=E.fragmentShader}a=hu(a),a=km(a,e),a=Bm(a,e),o=hu(o),o=km(o,e),o=Bm(o,e),a=Vm(a),o=Vm(o),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(y=`#version 300 es
`,v=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+v,_=["#define varying in",e.glslVersion===Qo?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===Qo?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+_);let x=y+v+a,b=y+_+o;if(n.onShaderBeforeCompile){const E=n.onShaderBeforeCompile(x,b,e);x=E.vertexShader,b=E.fragmentShader}const w=Fm(s,35633,x),M=Fm(s,35632,b);if(s.attachShader(f,w),s.attachShader(f,M),e.index0AttributeName!==void 0?s.bindAttribLocation(f,0,e.index0AttributeName):e.morphTargets===!0&&s.bindAttribLocation(f,0,"position"),s.linkProgram(f),n.debug.checkShaderErrors){const E=s.getProgramInfoLog(f).trim(),A=s.getShaderInfoLog(w).trim(),z=s.getShaderInfoLog(M).trim();let F=!0,G=!0;if(s.getProgramParameter(f,35714)===!1){F=!1;const U=Nm(s,w,"vertex"),k=Nm(s,M,"fragment");console.error("THREE.WebGLProgram: Shader Error "+s.getError()+" - VALIDATE_STATUS "+s.getProgramParameter(f,35715)+`

Program Info Log: `+E+`
`+U+`
`+k)}else E!==""?console.warn("THREE.WebGLProgram: Program Info Log:",E):A!==""&&z!==""||(G=!1);G&&(this.diagnostics={runnable:F,programLog:E,vertexShader:{log:A,prefix:v},fragmentShader:{log:z,prefix:_}})}let T,R;return s.deleteShader(w),s.deleteShader(M),this.getUniforms=function(){return T===void 0&&(T=new Cl(s,f)),T},this.getAttributes=function(){return R===void 0&&(R=function(E,A){const z={},F=E.getProgramParameter(A,35721);for(let G=0;G<F;G++){const U=E.getActiveAttrib(A,G),k=U.name;let H=1;U.type===35674&&(H=2),U.type===35675&&(H=3),U.type===35676&&(H=4),z[k]={type:U.type,location:E.getAttribLocation(A,k),locationSize:H}}return z}(s,f)),R},this.destroy=function(){i.releaseStatesOfProgram(this),s.deleteProgram(f),this.program=void 0},this.name=e.shaderName,this.id=_x++,this.cacheKey=t,this.usedTimes=1,this.program=f,this.vertexShader=w,this.fragmentShader=M,this}let Cx=0;class Ax{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,i=t.fragmentShader,s=this._getShaderStage(e),r=this._getShaderStage(i),a=this._getShaderCacheForMaterial(t);return a.has(s)===!1&&(a.add(s),s.usedTimes++),a.has(r)===!1&&(a.add(r),r.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const i of e)i.usedTimes--,i.usedTimes===0&&this.shaderCache.delete(i.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;return e.has(t)===!1&&e.set(t,new Set),e.get(t)}_getShaderStage(t){const e=this.shaderCache;if(e.has(t)===!1){const i=new Px(t);e.set(t,i)}return e.get(t)}}class Px{constructor(t){this.id=Cx++,this.code=t,this.usedTimes=0}}function Rx(n,t,e,i,s,r,a){const o=new cl,l=new Ax,h=[],c=s.isWebGL2,u=s.logarithmicDepthBuffer,d=s.vertexTextures;let p=s.precision;const m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(f,v,_,y,x){const b=y.fog,w=x.geometry,M=f.isMeshStandardMaterial?y.environment:null,T=(f.isMeshStandardMaterial?e:t).get(f.envMap||M),R=T&&T.mapping===306?T.image.height:null,E=m[f.type];f.precision!==null&&(p=s.getMaxPrecision(f.precision),p!==f.precision&&console.warn("THREE.WebGLProgram.getParameters:",f.precision,"not supported, using",p,"instead."));const A=w.morphAttributes.position||w.morphAttributes.normal||w.morphAttributes.color,z=A!==void 0?A.length:0;let F,G,U,k,H=0;if(w.morphAttributes.position!==void 0&&(H=1),w.morphAttributes.normal!==void 0&&(H=2),w.morphAttributes.color!==void 0&&(H=3),E){const $=ai[E];F=$.vertexShader,G=$.fragmentShader}else F=f.vertexShader,G=f.fragmentShader,l.update(f),U=l.getVertexShaderID(f),k=l.getFragmentShaderID(f);const W=n.getRenderTarget(),N=f.alphaTest>0,X=f.clearcoat>0,K=f.iridescence>0;return{isWebGL2:c,shaderID:E,shaderName:f.type,vertexShader:F,fragmentShader:G,defines:f.defines,customVertexShaderID:U,customFragmentShaderID:k,isRawShaderMaterial:f.isRawShaderMaterial===!0,glslVersion:f.glslVersion,precision:p,instancing:x.isInstancedMesh===!0,instancingColor:x.isInstancedMesh===!0&&x.instanceColor!==null,supportsVertexTextures:d,outputEncoding:W===null?n.outputEncoding:W.isXRRenderTarget===!0?W.texture.encoding:3e3,map:!!f.map,matcap:!!f.matcap,envMap:!!T,envMapMode:T&&T.mapping,envMapCubeUVHeight:R,lightMap:!!f.lightMap,aoMap:!!f.aoMap,emissiveMap:!!f.emissiveMap,bumpMap:!!f.bumpMap,normalMap:!!f.normalMap,objectSpaceNormalMap:f.normalMapType===1,tangentSpaceNormalMap:f.normalMapType===0,decodeVideoTexture:!!f.map&&f.map.isVideoTexture===!0&&f.map.encoding===3001,clearcoat:X,clearcoatMap:X&&!!f.clearcoatMap,clearcoatRoughnessMap:X&&!!f.clearcoatRoughnessMap,clearcoatNormalMap:X&&!!f.clearcoatNormalMap,iridescence:K,iridescenceMap:K&&!!f.iridescenceMap,iridescenceThicknessMap:K&&!!f.iridescenceThicknessMap,displacementMap:!!f.displacementMap,roughnessMap:!!f.roughnessMap,metalnessMap:!!f.metalnessMap,specularMap:!!f.specularMap,specularIntensityMap:!!f.specularIntensityMap,specularColorMap:!!f.specularColorMap,opaque:f.transparent===!1&&f.blending===1,alphaMap:!!f.alphaMap,alphaTest:N,gradientMap:!!f.gradientMap,sheen:f.sheen>0,sheenColorMap:!!f.sheenColorMap,sheenRoughnessMap:!!f.sheenRoughnessMap,transmission:f.transmission>0,transmissionMap:!!f.transmissionMap,thicknessMap:!!f.thicknessMap,combine:f.combine,vertexTangents:!!f.normalMap&&!!w.attributes.tangent,vertexColors:f.vertexColors,vertexAlphas:f.vertexColors===!0&&!!w.attributes.color&&w.attributes.color.itemSize===4,vertexUvs:!!(f.map||f.bumpMap||f.normalMap||f.specularMap||f.alphaMap||f.emissiveMap||f.roughnessMap||f.metalnessMap||f.clearcoatMap||f.clearcoatRoughnessMap||f.clearcoatNormalMap||f.iridescenceMap||f.iridescenceThicknessMap||f.displacementMap||f.transmissionMap||f.thicknessMap||f.specularIntensityMap||f.specularColorMap||f.sheenColorMap||f.sheenRoughnessMap),uvsVertexOnly:!(f.map||f.bumpMap||f.normalMap||f.specularMap||f.alphaMap||f.emissiveMap||f.roughnessMap||f.metalnessMap||f.clearcoatNormalMap||f.iridescenceMap||f.iridescenceThicknessMap||f.transmission>0||f.transmissionMap||f.thicknessMap||f.specularIntensityMap||f.specularColorMap||f.sheen>0||f.sheenColorMap||f.sheenRoughnessMap||!f.displacementMap),fog:!!b,useFog:f.fog===!0,fogExp2:b&&b.isFogExp2,flatShading:!!f.flatShading,sizeAttenuation:f.sizeAttenuation,logarithmicDepthBuffer:u,skinning:x.isSkinnedMesh===!0,morphTargets:w.morphAttributes.position!==void 0,morphNormals:w.morphAttributes.normal!==void 0,morphColors:w.morphAttributes.color!==void 0,morphTargetsCount:z,morphTextureStride:H,numDirLights:v.directional.length,numPointLights:v.point.length,numSpotLights:v.spot.length,numRectAreaLights:v.rectArea.length,numHemiLights:v.hemi.length,numDirLightShadows:v.directionalShadowMap.length,numPointLightShadows:v.pointShadowMap.length,numSpotLightShadows:v.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:f.dithering,shadowMapEnabled:n.shadowMap.enabled&&_.length>0,shadowMapType:n.shadowMap.type,toneMapping:f.toneMapped?n.toneMapping:0,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:f.premultipliedAlpha,doubleSided:f.side===2,flipSided:f.side===1,useDepthPacking:!!f.depthPacking,depthPacking:f.depthPacking||0,index0AttributeName:f.index0AttributeName,extensionDerivatives:f.extensions&&f.extensions.derivatives,extensionFragDepth:f.extensions&&f.extensions.fragDepth,extensionDrawBuffers:f.extensions&&f.extensions.drawBuffers,extensionShaderTextureLOD:f.extensions&&f.extensions.shaderTextureLOD,rendererExtensionFragDepth:c||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:c||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:c||i.has("EXT_shader_texture_lod"),customProgramCacheKey:f.customProgramCacheKey(),extraProgramCacheKey:n.extraProgramCacheKey}},getProgramCacheKey:function(f){const v=[];if(f.shaderID?v.push(f.shaderID):(v.push(f.customVertexShaderID),v.push(f.customFragmentShaderID)),f.defines!==void 0)for(const _ in f.defines)v.push(_),v.push(f.defines[_]);return f.isRawShaderMaterial===!1&&(function(_,y){_.push(y.precision),_.push(y.outputEncoding),_.push(y.envMapMode),_.push(y.envMapCubeUVHeight),_.push(y.combine),_.push(y.vertexUvs),_.push(y.fogExp2),_.push(y.sizeAttenuation),_.push(y.morphTargetsCount),_.push(y.morphAttributeCount),_.push(y.numDirLights),_.push(y.numPointLights),_.push(y.numSpotLights),_.push(y.numHemiLights),_.push(y.numRectAreaLights),_.push(y.numDirLightShadows),_.push(y.numPointLightShadows),_.push(y.numSpotLightShadows),_.push(y.shadowMapType),_.push(y.toneMapping),_.push(y.numClippingPlanes),_.push(y.numClipIntersection),_.push(y.depthPacking)}(v,f),function(_,y){o.disableAll(),y.isWebGL2&&o.enable(0),y.supportsVertexTextures&&o.enable(1),y.instancing&&o.enable(2),y.instancingColor&&o.enable(3),y.map&&o.enable(4),y.matcap&&o.enable(5),y.envMap&&o.enable(6),y.lightMap&&o.enable(7),y.aoMap&&o.enable(8),y.emissiveMap&&o.enable(9),y.bumpMap&&o.enable(10),y.normalMap&&o.enable(11),y.objectSpaceNormalMap&&o.enable(12),y.tangentSpaceNormalMap&&o.enable(13),y.clearcoat&&o.enable(14),y.clearcoatMap&&o.enable(15),y.clearcoatRoughnessMap&&o.enable(16),y.clearcoatNormalMap&&o.enable(17),y.iridescence&&o.enable(18),y.iridescenceMap&&o.enable(19),y.iridescenceThicknessMap&&o.enable(20),y.displacementMap&&o.enable(21),y.specularMap&&o.enable(22),y.roughnessMap&&o.enable(23),y.metalnessMap&&o.enable(24),y.gradientMap&&o.enable(25),y.alphaMap&&o.enable(26),y.alphaTest&&o.enable(27),y.vertexColors&&o.enable(28),y.vertexAlphas&&o.enable(29),y.vertexUvs&&o.enable(30),y.vertexTangents&&o.enable(31),y.uvsVertexOnly&&o.enable(32),y.fog&&o.enable(33),_.push(o.mask),o.disableAll(),y.useFog&&o.enable(0),y.flatShading&&o.enable(1),y.logarithmicDepthBuffer&&o.enable(2),y.skinning&&o.enable(3),y.morphTargets&&o.enable(4),y.morphNormals&&o.enable(5),y.morphColors&&o.enable(6),y.premultipliedAlpha&&o.enable(7),y.shadowMapEnabled&&o.enable(8),y.physicallyCorrectLights&&o.enable(9),y.doubleSided&&o.enable(10),y.flipSided&&o.enable(11),y.useDepthPacking&&o.enable(12),y.dithering&&o.enable(13),y.specularIntensityMap&&o.enable(14),y.specularColorMap&&o.enable(15),y.transmission&&o.enable(16),y.transmissionMap&&o.enable(17),y.thicknessMap&&o.enable(18),y.sheen&&o.enable(19),y.sheenColorMap&&o.enable(20),y.sheenRoughnessMap&&o.enable(21),y.decodeVideoTexture&&o.enable(22),y.opaque&&o.enable(23),_.push(o.mask)}(v,f),v.push(n.outputEncoding)),v.push(f.customProgramCacheKey),n.extraProgramCacheKey&&v.push(n.extraProgramCacheKey),v.join()},getUniforms:function(f){const v=m[f.type];let _;if(v){const y=ai[v];_=ft.clone(y.uniforms)}else _=f.uniforms;return _},acquireProgram:function(f,v){let _;for(let y=0,x=h.length;y<x;y++){const b=h[y];if(b.cacheKey===v){_=b,++_.usedTimes;break}}return _===void 0&&(_=new Ex(n,v,f,r),h.push(_)),_},releaseProgram:function(f){if(--f.usedTimes==0){const v=h.indexOf(f);h[v]=h[h.length-1],h.pop(),f.destroy()}},releaseShaderCache:function(f){l.remove(f)},programs:h,dispose:function(){l.dispose()}}}function Lx(){let n=new WeakMap;return{get:function(t){let e=n.get(t);return e===void 0&&(e={},n.set(t,e)),e},remove:function(t){n.delete(t)},update:function(t,e,i){n.get(t)[e]=i},dispose:function(){n=new WeakMap}}}function Ix(n,t){return n.groupOrder!==t.groupOrder?n.groupOrder-t.groupOrder:n.renderOrder!==t.renderOrder?n.renderOrder-t.renderOrder:n.material.id!==t.material.id?n.material.id-t.material.id:n.z!==t.z?n.z-t.z:n.id-t.id}function Hm(n,t){return n.groupOrder!==t.groupOrder?n.groupOrder-t.groupOrder:n.renderOrder!==t.renderOrder?n.renderOrder-t.renderOrder:n.z!==t.z?t.z-n.z:n.id-t.id}function Wm(){const n=[];let t=0;const e=[],i=[],s=[];function r(a,o,l,h,c,u){let d=n[t];return d===void 0?(d={id:a.id,object:a,geometry:o,material:l,groupOrder:h,renderOrder:a.renderOrder,z:c,group:u},n[t]=d):(d.id=a.id,d.object=a,d.geometry=o,d.material=l,d.groupOrder=h,d.renderOrder=a.renderOrder,d.z=c,d.group=u),t++,d}return{opaque:e,transmissive:i,transparent:s,init:function(){t=0,e.length=0,i.length=0,s.length=0},push:function(a,o,l,h,c,u){const d=r(a,o,l,h,c,u);l.transmission>0?i.push(d):l.transparent===!0?s.push(d):e.push(d)},unshift:function(a,o,l,h,c,u){const d=r(a,o,l,h,c,u);l.transmission>0?i.unshift(d):l.transparent===!0?s.unshift(d):e.unshift(d)},finish:function(){for(let a=t,o=n.length;a<o;a++){const l=n[a];if(l.id===null)break;l.id=null,l.object=null,l.geometry=null,l.material=null,l.group=null}},sort:function(a,o){e.length>1&&e.sort(a||Ix),i.length>1&&i.sort(o||Hm),s.length>1&&s.sort(o||Hm)}}}function Dx(){let n=new WeakMap;return{get:function(t,e){let i;return n.has(t)===!1?(i=new Wm,n.set(t,[i])):e>=n.get(t).length?(i=new Wm,n.get(t).push(i)):i=n.get(t)[e],i},dispose:function(){n=new WeakMap}}}function Ox(){const n={};return{get:function(t){if(n[t.id]!==void 0)return n[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new S,color:new nt};break;case"SpotLight":e={position:new S,direction:new S,color:new nt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new S,color:new nt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new S,skyColor:new nt,groundColor:new nt};break;case"RectAreaLight":e={color:new nt,position:new S,halfWidth:new S,halfHeight:new S}}return n[t.id]=e,e}}}let zx=0;function Ux(n,t){return(t.castShadow?1:0)-(n.castShadow?1:0)}function Fx(n,t){const e=new Ox,i=function(){const l={};return{get:function(h){if(l[h.id]!==void 0)return l[h.id];let c;switch(h.type){case"DirectionalLight":case"SpotLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new V};break;case"PointLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new V,shadowCameraNear:1,shadowCameraFar:1e3}}return l[h.id]=c,c}}}(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let l=0;l<9;l++)s.probe.push(new S);const r=new S,a=new at,o=new at;return{setup:function(l,h){let c=0,u=0,d=0;for(let T=0;T<9;T++)s.probe[T].set(0,0,0);let p=0,m=0,f=0,v=0,_=0,y=0,x=0,b=0;l.sort(Ux);const w=h!==!0?Math.PI:1;for(let T=0,R=l.length;T<R;T++){const E=l[T],A=E.color,z=E.intensity,F=E.distance,G=E.shadow&&E.shadow.map?E.shadow.map.texture:null;if(E.isAmbientLight)c+=A.r*z*w,u+=A.g*z*w,d+=A.b*z*w;else if(E.isLightProbe)for(let U=0;U<9;U++)s.probe[U].addScaledVector(E.sh.coefficients[U],z);else if(E.isDirectionalLight){const U=e.get(E);if(U.color.copy(E.color).multiplyScalar(E.intensity*w),E.castShadow){const k=E.shadow,H=i.get(E);H.shadowBias=k.bias,H.shadowNormalBias=k.normalBias,H.shadowRadius=k.radius,H.shadowMapSize=k.mapSize,s.directionalShadow[p]=H,s.directionalShadowMap[p]=G,s.directionalShadowMatrix[p]=E.shadow.matrix,y++}s.directional[p]=U,p++}else if(E.isSpotLight){const U=e.get(E);if(U.position.setFromMatrixPosition(E.matrixWorld),U.color.copy(A).multiplyScalar(z*w),U.distance=F,U.coneCos=Math.cos(E.angle),U.penumbraCos=Math.cos(E.angle*(1-E.penumbra)),U.decay=E.decay,E.castShadow){const k=E.shadow,H=i.get(E);H.shadowBias=k.bias,H.shadowNormalBias=k.normalBias,H.shadowRadius=k.radius,H.shadowMapSize=k.mapSize,s.spotShadow[f]=H,s.spotShadowMap[f]=G,s.spotShadowMatrix[f]=E.shadow.matrix,b++}s.spot[f]=U,f++}else if(E.isRectAreaLight){const U=e.get(E);U.color.copy(A).multiplyScalar(z),U.halfWidth.set(.5*E.width,0,0),U.halfHeight.set(0,.5*E.height,0),s.rectArea[v]=U,v++}else if(E.isPointLight){const U=e.get(E);if(U.color.copy(E.color).multiplyScalar(E.intensity*w),U.distance=E.distance,U.decay=E.decay,E.castShadow){const k=E.shadow,H=i.get(E);H.shadowBias=k.bias,H.shadowNormalBias=k.normalBias,H.shadowRadius=k.radius,H.shadowMapSize=k.mapSize,H.shadowCameraNear=k.camera.near,H.shadowCameraFar=k.camera.far,s.pointShadow[m]=H,s.pointShadowMap[m]=G,s.pointShadowMatrix[m]=E.shadow.matrix,x++}s.point[m]=U,m++}else if(E.isHemisphereLight){const U=e.get(E);U.skyColor.copy(E.color).multiplyScalar(z*w),U.groundColor.copy(E.groundColor).multiplyScalar(z*w),s.hemi[_]=U,_++}}v>0&&(t.isWebGL2||n.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=rt.LTC_FLOAT_1,s.rectAreaLTC2=rt.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(s.rectAreaLTC1=rt.LTC_HALF_1,s.rectAreaLTC2=rt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),s.ambient[0]=c,s.ambient[1]=u,s.ambient[2]=d;const M=s.hash;M.directionalLength===p&&M.pointLength===m&&M.spotLength===f&&M.rectAreaLength===v&&M.hemiLength===_&&M.numDirectionalShadows===y&&M.numPointShadows===x&&M.numSpotShadows===b||(s.directional.length=p,s.spot.length=f,s.rectArea.length=v,s.point.length=m,s.hemi.length=_,s.directionalShadow.length=y,s.directionalShadowMap.length=y,s.pointShadow.length=x,s.pointShadowMap.length=x,s.spotShadow.length=b,s.spotShadowMap.length=b,s.directionalShadowMatrix.length=y,s.pointShadowMatrix.length=x,s.spotShadowMatrix.length=b,M.directionalLength=p,M.pointLength=m,M.spotLength=f,M.rectAreaLength=v,M.hemiLength=_,M.numDirectionalShadows=y,M.numPointShadows=x,M.numSpotShadows=b,s.version=zx++)},setupView:function(l,h){let c=0,u=0,d=0,p=0,m=0;const f=h.matrixWorldInverse;for(let v=0,_=l.length;v<_;v++){const y=l[v];if(y.isDirectionalLight){const x=s.directional[c];x.direction.setFromMatrixPosition(y.matrixWorld),r.setFromMatrixPosition(y.target.matrixWorld),x.direction.sub(r),x.direction.transformDirection(f),c++}else if(y.isSpotLight){const x=s.spot[d];x.position.setFromMatrixPosition(y.matrixWorld),x.position.applyMatrix4(f),x.direction.setFromMatrixPosition(y.matrixWorld),r.setFromMatrixPosition(y.target.matrixWorld),x.direction.sub(r),x.direction.transformDirection(f),d++}else if(y.isRectAreaLight){const x=s.rectArea[p];x.position.setFromMatrixPosition(y.matrixWorld),x.position.applyMatrix4(f),o.identity(),a.copy(y.matrixWorld),a.premultiply(f),o.extractRotation(a),x.halfWidth.set(.5*y.width,0,0),x.halfHeight.set(0,.5*y.height,0),x.halfWidth.applyMatrix4(o),x.halfHeight.applyMatrix4(o),p++}else if(y.isPointLight){const x=s.point[u];x.position.setFromMatrixPosition(y.matrixWorld),x.position.applyMatrix4(f),u++}else if(y.isHemisphereLight){const x=s.hemi[m];x.direction.setFromMatrixPosition(y.matrixWorld),x.direction.transformDirection(f),m++}}},state:s}}function qm(n,t){const e=new Fx(n,t),i=[],s=[];return{init:function(){i.length=0,s.length=0},state:{lightsArray:i,shadowsArray:s,lights:e},setupLights:function(r){e.setup(i,r)},setupLightsView:function(r){e.setupView(i,r)},pushLight:function(r){i.push(r)},pushShadow:function(r){s.push(r)}}}function Nx(n,t){let e=new WeakMap;return{get:function(i,s=0){let r;return e.has(i)===!1?(r=new qm(n,t),e.set(i,[r])):s>=e.get(i).length?(r=new qm(n,t),e.get(i).push(r)):r=e.get(i)[s],r},dispose:function(){e=new WeakMap}}}class cu extends ae{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class uu extends ae{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new S,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}function kx(n,t,e){let i=new gr;const s=new V,r=new V,a=new Ot,o=new cu({depthPacking:3201}),l=new uu,h={},c=e.maxTextureSize,u={0:1,1:0,2:2},d=new Qt({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new V},radius:{value:4}},vertexShader:`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragmentShader:`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const m=new gt;m.setAttribute("position",new Lt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const f=new ot(m,d),v=this;function _(b,w){const M=t.update(f);d.defines.VSM_SAMPLES!==b.blurSamples&&(d.defines.VSM_SAMPLES=b.blurSamples,p.defines.VSM_SAMPLES=b.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),d.uniforms.shadow_pass.value=b.map.texture,d.uniforms.resolution.value=b.mapSize,d.uniforms.radius.value=b.radius,n.setRenderTarget(b.mapPass),n.clear(),n.renderBufferDirect(w,null,M,d,f,null),p.uniforms.shadow_pass.value=b.mapPass.texture,p.uniforms.resolution.value=b.mapSize,p.uniforms.radius.value=b.radius,n.setRenderTarget(b.map),n.clear(),n.renderBufferDirect(w,null,M,p,f,null)}function y(b,w,M,T,R,E){let A=null;const z=M.isPointLight===!0?b.customDistanceMaterial:b.customDepthMaterial;if(A=z!==void 0?z:M.isPointLight===!0?l:o,n.localClippingEnabled&&w.clipShadows===!0&&w.clippingPlanes.length!==0||w.displacementMap&&w.displacementScale!==0||w.alphaMap&&w.alphaTest>0){const F=A.uuid,G=w.uuid;let U=h[F];U===void 0&&(U={},h[F]=U);let k=U[G];k===void 0&&(k=A.clone(),U[G]=k),A=k}return A.visible=w.visible,A.wireframe=w.wireframe,A.side=E===3?w.shadowSide!==null?w.shadowSide:w.side:w.shadowSide!==null?w.shadowSide:u[w.side],A.alphaMap=w.alphaMap,A.alphaTest=w.alphaTest,A.clipShadows=w.clipShadows,A.clippingPlanes=w.clippingPlanes,A.clipIntersection=w.clipIntersection,A.displacementMap=w.displacementMap,A.displacementScale=w.displacementScale,A.displacementBias=w.displacementBias,A.wireframeLinewidth=w.wireframeLinewidth,A.linewidth=w.linewidth,M.isPointLight===!0&&A.isMeshDistanceMaterial===!0&&(A.referencePosition.setFromMatrixPosition(M.matrixWorld),A.nearDistance=T,A.farDistance=R),A}function x(b,w,M,T,R){if(b.visible===!1)return;if(b.layers.test(w.layers)&&(b.isMesh||b.isLine||b.isPoints)&&(b.castShadow||b.receiveShadow&&R===3)&&(!b.frustumCulled||i.intersectsObject(b))){b.modelViewMatrix.multiplyMatrices(M.matrixWorldInverse,b.matrixWorld);const A=t.update(b),z=b.material;if(Array.isArray(z)){const F=A.groups;for(let G=0,U=F.length;G<U;G++){const k=F[G],H=z[k.materialIndex];if(H&&H.visible){const W=y(b,H,T,M.near,M.far,R);n.renderBufferDirect(M,null,A,W,b,k)}}}else if(z.visible){const F=y(b,z,T,M.near,M.far,R);n.renderBufferDirect(M,null,A,F,b,null)}}const E=b.children;for(let A=0,z=E.length;A<z;A++)x(E[A],w,M,T,R)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(b,w,M){if(v.enabled===!1||v.autoUpdate===!1&&v.needsUpdate===!1||b.length===0)return;const T=n.getRenderTarget(),R=n.getActiveCubeFace(),E=n.getActiveMipmapLevel(),A=n.state;A.setBlending(0),A.buffers.color.setClear(1,1,1,1),A.buffers.depth.setTest(!0),A.setScissorTest(!1);for(let z=0,F=b.length;z<F;z++){const G=b[z],U=G.shadow;if(U===void 0){console.warn("THREE.WebGLShadowMap:",G,"has no shadow.");continue}if(U.autoUpdate===!1&&U.needsUpdate===!1)continue;s.copy(U.mapSize);const k=U.getFrameExtents();if(s.multiply(k),r.copy(U.mapSize),(s.x>c||s.y>c)&&(s.x>c&&(r.x=Math.floor(c/k.x),s.x=r.x*k.x,U.mapSize.x=r.x),s.y>c&&(r.y=Math.floor(c/k.y),s.y=r.y*k.y,U.mapSize.y=r.y)),U.map!==null||U.isPointLightShadow||this.type!==3||(U.map=new Yt(s.x,s.y),U.map.texture.name=G.name+".shadowMap",U.mapPass=new Yt(s.x,s.y),U.camera.updateProjectionMatrix()),U.map===null){const W={minFilter:1003,magFilter:1003,format:1023};U.map=new Yt(s.x,s.y,W),U.map.texture.name=G.name+".shadowMap",U.camera.updateProjectionMatrix()}n.setRenderTarget(U.map),n.clear();const H=U.getViewportCount();for(let W=0;W<H;W++){const N=U.getViewport(W);a.set(r.x*N.x,r.y*N.y,r.x*N.z,r.y*N.w),A.viewport(a),U.updateMatrices(G,W),i=U.getFrustum(),x(w,M,U.camera,G,this.type)}U.isPointLightShadow||this.type!==3||_(U,M),U.needsUpdate=!1}v.needsUpdate=!1,n.setRenderTarget(T,R,E)}}function Bx(n,t,e){const i=e.isWebGL2,s=new function(){let C=!1;const j=new Ot;let L=null;const et=new Ot(0,0,0,0);return{setMask:function(Y){L===Y||C||(n.colorMask(Y,Y,Y,Y),L=Y)},setLocked:function(Y){C=Y},setClear:function(Y,it,ct,pt,wt){wt===!0&&(Y*=pt,it*=pt,ct*=pt),j.set(Y,it,ct,pt),et.equals(j)===!1&&(n.clearColor(Y,it,ct,pt),et.copy(j))},reset:function(){C=!1,L=null,et.set(-1,0,0,0)}}},r=new function(){let C=!1,j=null,L=null,et=null;return{setTest:function(Y){Y?lt(2929):yt(2929)},setMask:function(Y){j===Y||C||(n.depthMask(Y),j=Y)},setFunc:function(Y){if(L!==Y){if(Y)switch(Y){case 0:n.depthFunc(512);break;case 1:n.depthFunc(519);break;case 2:n.depthFunc(513);break;case 3:default:n.depthFunc(515);break;case 4:n.depthFunc(514);break;case 5:n.depthFunc(518);break;case 6:n.depthFunc(516);break;case 7:n.depthFunc(517)}else n.depthFunc(515);L=Y}},setLocked:function(Y){C=Y},setClear:function(Y){et!==Y&&(n.clearDepth(Y),et=Y)},reset:function(){C=!1,j=null,L=null,et=null}}},a=new function(){let C=!1,j=null,L=null,et=null,Y=null,it=null,ct=null,pt=null,wt=null;return{setTest:function(xt){C||(xt?lt(2960):yt(2960))},setMask:function(xt){j===xt||C||(n.stencilMask(xt),j=xt)},setFunc:function(xt,St,Ct){L===xt&&et===St&&Y===Ct||(n.stencilFunc(xt,St,Ct),L=xt,et=St,Y=Ct)},setOp:function(xt,St,Ct){it===xt&&ct===St&&pt===Ct||(n.stencilOp(xt,St,Ct),it=xt,ct=St,pt=Ct)},setLocked:function(xt){C=xt},setClear:function(xt){wt!==xt&&(n.clearStencil(xt),wt=xt)},reset:function(){C=!1,j=null,L=null,et=null,Y=null,it=null,ct=null,pt=null,wt=null}}};let o={},l={},h=new WeakMap,c=[],u=null,d=!1,p=null,m=null,f=null,v=null,_=null,y=null,x=null,b=!1,w=null,M=null,T=null,R=null,E=null;const A=n.getParameter(35661);let z=!1,F=0;const G=n.getParameter(7938);G.indexOf("WebGL")!==-1?(F=parseFloat(/^WebGL (\d)/.exec(G)[1]),z=F>=1):G.indexOf("OpenGL ES")!==-1&&(F=parseFloat(/^OpenGL ES (\d)/.exec(G)[1]),z=F>=2);let U=null,k={};const H=n.getParameter(3088),W=n.getParameter(2978),N=new Ot().fromArray(H),X=new Ot().fromArray(W);function K(C,j,L){const et=new Uint8Array(4),Y=n.createTexture();n.bindTexture(C,Y),n.texParameteri(C,10241,9728),n.texParameteri(C,10240,9728);for(let it=0;it<L;it++)n.texImage2D(j+it,0,6408,1,1,0,6408,5121,et);return Y}const $={};function lt(C){o[C]!==!0&&(n.enable(C),o[C]=!0)}function yt(C){o[C]!==!1&&(n.disable(C),o[C]=!1)}$[3553]=K(3553,3553,1),$[34067]=K(34067,34069,6),s.setClear(0,0,0,1),r.setClear(1),a.setClear(0),lt(2929),r.setFunc(3),P(!1),q(1),lt(2884),I(0);const mt={[100]:32774,101:32778,102:32779};if(i)mt[103]=32775,mt[104]=32776;else{const C=t.get("EXT_blend_minmax");C!==null&&(mt[103]=C.MIN_EXT,mt[104]=C.MAX_EXT)}const bt={200:0,[201]:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function I(C,j,L,et,Y,it,ct,pt){if(C!==0){if(d===!1&&(lt(3042),d=!0),C===5)Y=Y||j,it=it||L,ct=ct||et,j===m&&Y===_||(n.blendEquationSeparate(mt[j],mt[Y]),m=j,_=Y),L===f&&et===v&&it===y&&ct===x||(n.blendFuncSeparate(bt[L],bt[et],bt[it],bt[ct]),f=L,v=et,y=it,x=ct),p=C,b=null;else if(C!==p||pt!==b){if(m===100&&_===100||(n.blendEquation(32774),m=100,_=100),pt)switch(C){case 1:n.blendFuncSeparate(1,771,1,771);break;case 2:n.blendFunc(1,1);break;case 3:n.blendFuncSeparate(0,769,0,1);break;case 4:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",C)}else switch(C){case 1:n.blendFuncSeparate(770,771,1,771);break;case 2:n.blendFunc(770,1);break;case 3:n.blendFuncSeparate(0,769,0,1);break;case 4:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",C)}f=null,v=null,y=null,x=null,p=C,b=pt}}else d===!0&&(yt(3042),d=!1)}function P(C){w!==C&&(C?n.frontFace(2304):n.frontFace(2305),w=C)}function q(C){C!==0?(lt(2884),C!==M&&(C===1?n.cullFace(1029):C===2?n.cullFace(1028):n.cullFace(1032))):yt(2884),M=C}function B(C,j,L){C?(lt(32823),R===j&&E===L||(n.polygonOffset(j,L),R=j,E=L)):yt(32823)}function D(C){C===void 0&&(C=33984+A-1),U!==C&&(n.activeTexture(C),U=C)}return{buffers:{color:s,depth:r,stencil:a},enable:lt,disable:yt,bindFramebuffer:function(C,j){return l[C]!==j&&(n.bindFramebuffer(C,j),l[C]=j,i&&(C===36009&&(l[36160]=j),C===36160&&(l[36009]=j)),!0)},drawBuffers:function(C,j){let L=c,et=!1;if(C)if(L=h.get(j),L===void 0&&(L=[],h.set(j,L)),C.isWebGLMultipleRenderTargets){const Y=C.texture;if(L.length!==Y.length||L[0]!==36064){for(let it=0,ct=Y.length;it<ct;it++)L[it]=36064+it;L.length=Y.length,et=!0}}else L[0]!==36064&&(L[0]=36064,et=!0);else L[0]!==1029&&(L[0]=1029,et=!0);et&&(e.isWebGL2?n.drawBuffers(L):t.get("WEBGL_draw_buffers").drawBuffersWEBGL(L))},useProgram:function(C){return u!==C&&(n.useProgram(C),u=C,!0)},setBlending:I,setMaterial:function(C,j){C.side===2?yt(2884):lt(2884);let L=C.side===1;j&&(L=!L),P(L),C.blending===1&&C.transparent===!1?I(0):I(C.blending,C.blendEquation,C.blendSrc,C.blendDst,C.blendEquationAlpha,C.blendSrcAlpha,C.blendDstAlpha,C.premultipliedAlpha),r.setFunc(C.depthFunc),r.setTest(C.depthTest),r.setMask(C.depthWrite),s.setMask(C.colorWrite);const et=C.stencilWrite;a.setTest(et),et&&(a.setMask(C.stencilWriteMask),a.setFunc(C.stencilFunc,C.stencilRef,C.stencilFuncMask),a.setOp(C.stencilFail,C.stencilZFail,C.stencilZPass)),B(C.polygonOffset,C.polygonOffsetFactor,C.polygonOffsetUnits),C.alphaToCoverage===!0?lt(32926):yt(32926)},setFlipSided:P,setCullFace:q,setLineWidth:function(C){C!==T&&(z&&n.lineWidth(C),T=C)},setPolygonOffset:B,setScissorTest:function(C){C?lt(3089):yt(3089)},activeTexture:D,bindTexture:function(C,j){U===null&&D();let L=k[U];L===void 0&&(L={type:void 0,texture:void 0},k[U]=L),L.type===C&&L.texture===j||(n.bindTexture(C,j||$[C]),L.type=C,L.texture=j)},unbindTexture:function(){const C=k[U];C!==void 0&&C.type!==void 0&&(n.bindTexture(C.type,null),C.type=void 0,C.texture=void 0)},compressedTexImage2D:function(){try{n.compressedTexImage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},texImage2D:function(){try{n.texImage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},texImage3D:function(){try{n.texImage3D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},texStorage2D:function(){try{n.texStorage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},texStorage3D:function(){try{n.texStorage3D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},texSubImage2D:function(){try{n.texSubImage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},texSubImage3D:function(){try{n.texSubImage3D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},compressedTexSubImage2D:function(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}},scissor:function(C){N.equals(C)===!1&&(n.scissor(C.x,C.y,C.z,C.w),N.copy(C))},viewport:function(C){X.equals(C)===!1&&(n.viewport(C.x,C.y,C.z,C.w),X.copy(C))},reset:function(){n.disable(3042),n.disable(2884),n.disable(2929),n.disable(32823),n.disable(3089),n.disable(2960),n.disable(32926),n.blendEquation(32774),n.blendFunc(1,0),n.blendFuncSeparate(1,0,1,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(513),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(519,0,4294967295),n.stencilOp(7680,7680,7680),n.clearStencil(0),n.cullFace(1029),n.frontFace(2305),n.polygonOffset(0,0),n.activeTexture(33984),n.bindFramebuffer(36160,null),i===!0&&(n.bindFramebuffer(36009,null),n.bindFramebuffer(36008,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),o={},U=null,k={},l={},h=new WeakMap,c=[],u=null,d=!1,p=null,m=null,f=null,v=null,_=null,y=null,x=null,b=!1,w=null,M=null,T=null,R=null,E=null,N.set(0,0,n.canvas.width,n.canvas.height),X.set(0,0,n.canvas.width,n.canvas.height),s.reset(),r.reset(),a.reset()}}}function Vx(n,t,e,i,s,r,a){const o=s.isWebGL2,l=s.maxTextures,h=s.maxCubemapSize,c=s.maxTextureSize,u=s.maxSamples,d=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,p=/OculusBrowser/g.test(navigator.userAgent),m=new WeakMap;let f;const v=new WeakMap;let _=!1;try{_=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function y(I,P){return _?new OffscreenCanvas(I,P):wa("canvas")}function x(I,P,q,B){let D=1;if((I.width>B||I.height>B)&&(D=B/Math.max(I.width,I.height)),D<1||P===!0){if(typeof HTMLImageElement<"u"&&I instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&I instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&I instanceof ImageBitmap){const C=P?$o:Math.floor,j=C(D*I.width),L=C(D*I.height);f===void 0&&(f=y(j,L));const et=q?y(j,L):f;return et.width=j,et.height=L,et.getContext("2d").drawImage(I,0,0,j,L),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+I.width+"x"+I.height+") to ("+j+"x"+L+")."),et}return"data"in I&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+I.width+"x"+I.height+")."),I}return I}function b(I){return zc(I.width)&&zc(I.height)}function w(I,P){return I.generateMipmaps&&P&&I.minFilter!==1003&&I.minFilter!==1006}function M(I){n.generateMipmap(I)}function T(I,P,q,B,D=!1){if(o===!1)return P;if(I!==null){if(n[I]!==void 0)return n[I];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+I+"'")}let C=P;return P===6403&&(q===5126&&(C=33326),q===5131&&(C=33325),q===5121&&(C=33321)),P===33319&&(q===5126&&(C=33328),q===5131&&(C=33327),q===5121&&(C=33323)),P===6408&&(q===5126&&(C=34836),q===5131&&(C=34842),q===5121&&(C=B===3001&&D===!1?35907:32856),q===32819&&(C=32854),q===32820&&(C=32855)),C!==33325&&C!==33326&&C!==33327&&C!==33328&&C!==34842&&C!==34836||t.get("EXT_color_buffer_float"),C}function R(I,P,q){return w(I,q)===!0||I.isFramebufferTexture&&I.minFilter!==1003&&I.minFilter!==1006?Math.log2(Math.max(P.width,P.height))+1:I.mipmaps!==void 0&&I.mipmaps.length>0?I.mipmaps.length:I.isCompressedTexture&&Array.isArray(I.image)?P.mipmaps.length:1}function E(I){return I===1003||I===1004||I===1005?9728:9729}function A(I){const P=I.target;P.removeEventListener("dispose",A),function(q){const B=i.get(q);if(B.__webglInit===void 0)return;const D=q.source,C=v.get(D);if(C){const j=C[B.__cacheKey];j.usedTimes--,j.usedTimes===0&&F(q),Object.keys(C).length===0&&v.delete(D)}i.remove(q)}(P),P.isVideoTexture&&m.delete(P)}function z(I){const P=I.target;P.removeEventListener("dispose",z),function(q){const B=q.texture,D=i.get(q),C=i.get(B);if(C.__webglTexture!==void 0&&(n.deleteTexture(C.__webglTexture),a.memory.textures--),q.depthTexture&&q.depthTexture.dispose(),q.isWebGLCubeRenderTarget)for(let j=0;j<6;j++)n.deleteFramebuffer(D.__webglFramebuffer[j]),D.__webglDepthbuffer&&n.deleteRenderbuffer(D.__webglDepthbuffer[j]);else{if(n.deleteFramebuffer(D.__webglFramebuffer),D.__webglDepthbuffer&&n.deleteRenderbuffer(D.__webglDepthbuffer),D.__webglMultisampledFramebuffer&&n.deleteFramebuffer(D.__webglMultisampledFramebuffer),D.__webglColorRenderbuffer)for(let j=0;j<D.__webglColorRenderbuffer.length;j++)D.__webglColorRenderbuffer[j]&&n.deleteRenderbuffer(D.__webglColorRenderbuffer[j]);D.__webglDepthRenderbuffer&&n.deleteRenderbuffer(D.__webglDepthRenderbuffer)}if(q.isWebGLMultipleRenderTargets)for(let j=0,L=B.length;j<L;j++){const et=i.get(B[j]);et.__webglTexture&&(n.deleteTexture(et.__webglTexture),a.memory.textures--),i.remove(B[j])}i.remove(B),i.remove(q)}(P)}function F(I){const P=i.get(I);n.deleteTexture(P.__webglTexture);const q=I.source;delete v.get(q)[P.__cacheKey],a.memory.textures--}let G=0;function U(I,P){const q=i.get(I);if(I.isVideoTexture&&function(B){const D=a.render.frame;m.get(B)!==D&&(m.set(B,D),B.update())}(I),I.isRenderTargetTexture===!1&&I.version>0&&q.__version!==I.version){const B=I.image;if(B===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(B.complete!==!1)return void X(q,I,P);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}e.activeTexture(33984+P),e.bindTexture(3553,q.__webglTexture)}const k={[1e3]:10497,[1001]:33071,[1002]:33648},H={[1003]:9728,[1004]:9984,[1005]:9986,[1006]:9729,[1007]:9985,[1008]:9987};function W(I,P,q){if(q?(n.texParameteri(I,10242,k[P.wrapS]),n.texParameteri(I,10243,k[P.wrapT]),I!==32879&&I!==35866||n.texParameteri(I,32882,k[P.wrapR]),n.texParameteri(I,10240,H[P.magFilter]),n.texParameteri(I,10241,H[P.minFilter])):(n.texParameteri(I,10242,33071),n.texParameteri(I,10243,33071),I!==32879&&I!==35866||n.texParameteri(I,32882,33071),P.wrapS===1001&&P.wrapT===1001||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(I,10240,E(P.magFilter)),n.texParameteri(I,10241,E(P.minFilter)),P.minFilter!==1003&&P.minFilter!==1006&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const B=t.get("EXT_texture_filter_anisotropic");if(P.type===1015&&t.has("OES_texture_float_linear")===!1||o===!1&&P.type===1016&&t.has("OES_texture_half_float_linear")===!1)return;(P.anisotropy>1||i.get(P).__currentAnisotropy)&&(n.texParameterf(I,B.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(P.anisotropy,s.getMaxAnisotropy())),i.get(P).__currentAnisotropy=P.anisotropy)}}function N(I,P){let q=!1;I.__webglInit===void 0&&(I.__webglInit=!0,P.addEventListener("dispose",A));const B=P.source;let D=v.get(B);D===void 0&&(D={},v.set(B,D));const C=function(j){const L=[];return L.push(j.wrapS),L.push(j.wrapT),L.push(j.magFilter),L.push(j.minFilter),L.push(j.anisotropy),L.push(j.internalFormat),L.push(j.format),L.push(j.type),L.push(j.generateMipmaps),L.push(j.premultiplyAlpha),L.push(j.flipY),L.push(j.unpackAlignment),L.push(j.encoding),L.join()}(P);if(C!==I.__cacheKey){D[C]===void 0&&(D[C]={texture:n.createTexture(),usedTimes:0},a.memory.textures++,q=!0),D[C].usedTimes++;const j=D[I.__cacheKey];j!==void 0&&(D[I.__cacheKey].usedTimes--,j.usedTimes===0&&F(P)),I.__cacheKey=C,I.__webglTexture=D[C].texture}return q}function X(I,P,q){let B=3553;P.isDataArrayTexture&&(B=35866),P.isData3DTexture&&(B=32879);const D=N(I,P),C=P.source;if(e.activeTexture(33984+q),e.bindTexture(B,I.__webglTexture),C.version!==C.__currentVersion||D===!0){n.pixelStorei(37440,P.flipY),n.pixelStorei(37441,P.premultiplyAlpha),n.pixelStorei(3317,P.unpackAlignment),n.pixelStorei(37443,0);const j=function(At){return!o&&(At.wrapS!==1001||At.wrapT!==1001||At.minFilter!==1003&&At.minFilter!==1006)}(P)&&b(P.image)===!1;let L=x(P.image,j,!1,c);L=bt(P,L);const et=b(L)||o,Y=r.convert(P.format,P.encoding);let it,ct=r.convert(P.type),pt=T(P.internalFormat,Y,ct,P.encoding,P.isVideoTexture);W(B,P,et);const wt=P.mipmaps,xt=o&&P.isVideoTexture!==!0,St=C.__currentVersion===void 0||D===!0,Ct=R(P,L,et);if(P.isDepthTexture)pt=6402,o?pt=P.type===1015?36012:P.type===1014?33190:P.type===1020?35056:33189:P.type===1015&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),P.format===1026&&pt===6402&&P.type!==1012&&P.type!==1014&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),P.type=1014,ct=r.convert(P.type)),P.format===1027&&pt===6402&&(pt=34041,P.type!==1020&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),P.type=1020,ct=r.convert(P.type))),St&&(xt?e.texStorage2D(3553,1,pt,L.width,L.height):e.texImage2D(3553,0,pt,L.width,L.height,0,Y,ct,null));else if(P.isDataTexture)if(wt.length>0&&et){xt&&St&&e.texStorage2D(3553,Ct,pt,wt[0].width,wt[0].height);for(let At=0,ne=wt.length;At<ne;At++)it=wt[At],xt?e.texSubImage2D(3553,At,0,0,it.width,it.height,Y,ct,it.data):e.texImage2D(3553,At,pt,it.width,it.height,0,Y,ct,it.data);P.generateMipmaps=!1}else xt?(St&&e.texStorage2D(3553,Ct,pt,L.width,L.height),e.texSubImage2D(3553,0,0,0,L.width,L.height,Y,ct,L.data)):e.texImage2D(3553,0,pt,L.width,L.height,0,Y,ct,L.data);else if(P.isCompressedTexture){xt&&St&&e.texStorage2D(3553,Ct,pt,wt[0].width,wt[0].height);for(let At=0,ne=wt.length;At<ne;At++)it=wt[At],P.format!==1023?Y!==null?xt?e.compressedTexSubImage2D(3553,At,0,0,it.width,it.height,Y,it.data):e.compressedTexImage2D(3553,At,pt,it.width,it.height,0,it.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):xt?e.texSubImage2D(3553,At,0,0,it.width,it.height,Y,ct,it.data):e.texImage2D(3553,At,pt,it.width,it.height,0,Y,ct,it.data)}else if(P.isDataArrayTexture)xt?(St&&e.texStorage3D(35866,Ct,pt,L.width,L.height,L.depth),e.texSubImage3D(35866,0,0,0,0,L.width,L.height,L.depth,Y,ct,L.data)):e.texImage3D(35866,0,pt,L.width,L.height,L.depth,0,Y,ct,L.data);else if(P.isData3DTexture)xt?(St&&e.texStorage3D(32879,Ct,pt,L.width,L.height,L.depth),e.texSubImage3D(32879,0,0,0,0,L.width,L.height,L.depth,Y,ct,L.data)):e.texImage3D(32879,0,pt,L.width,L.height,L.depth,0,Y,ct,L.data);else if(P.isFramebufferTexture){if(St)if(xt)e.texStorage2D(3553,Ct,pt,L.width,L.height);else{let At=L.width,ne=L.height;for(let ui=0;ui<Ct;ui++)e.texImage2D(3553,ui,pt,At,ne,0,Y,ct,null),At>>=1,ne>>=1}}else if(wt.length>0&&et){xt&&St&&e.texStorage2D(3553,Ct,pt,wt[0].width,wt[0].height);for(let At=0,ne=wt.length;At<ne;At++)it=wt[At],xt?e.texSubImage2D(3553,At,0,0,Y,ct,it):e.texImage2D(3553,At,pt,Y,ct,it);P.generateMipmaps=!1}else xt?(St&&e.texStorage2D(3553,Ct,pt,L.width,L.height),e.texSubImage2D(3553,0,0,0,Y,ct,L)):e.texImage2D(3553,0,pt,Y,ct,L);w(P,et)&&M(B),C.__currentVersion=C.version,P.onUpdate&&P.onUpdate(P)}I.__version=P.version}function K(I,P,q,B,D){const C=r.convert(q.format,q.encoding),j=r.convert(q.type),L=T(q.internalFormat,C,j,q.encoding);i.get(P).__hasExternalTextures||(D===32879||D===35866?e.texImage3D(D,0,L,P.width,P.height,P.depth,0,C,j,null):e.texImage2D(D,0,L,P.width,P.height,0,C,j,null)),e.bindFramebuffer(36160,I),mt(P)?d.framebufferTexture2DMultisampleEXT(36160,B,D,i.get(q).__webglTexture,0,yt(P)):n.framebufferTexture2D(36160,B,D,i.get(q).__webglTexture,0),e.bindFramebuffer(36160,null)}function $(I,P,q){if(n.bindRenderbuffer(36161,I),P.depthBuffer&&!P.stencilBuffer){let B=33189;if(q||mt(P)){const D=P.depthTexture;D&&D.isDepthTexture&&(D.type===1015?B=36012:D.type===1014&&(B=33190));const C=yt(P);mt(P)?d.renderbufferStorageMultisampleEXT(36161,C,B,P.width,P.height):n.renderbufferStorageMultisample(36161,C,B,P.width,P.height)}else n.renderbufferStorage(36161,B,P.width,P.height);n.framebufferRenderbuffer(36160,36096,36161,I)}else if(P.depthBuffer&&P.stencilBuffer){const B=yt(P);q&&mt(P)===!1?n.renderbufferStorageMultisample(36161,B,35056,P.width,P.height):mt(P)?d.renderbufferStorageMultisampleEXT(36161,B,35056,P.width,P.height):n.renderbufferStorage(36161,34041,P.width,P.height),n.framebufferRenderbuffer(36160,33306,36161,I)}else{const B=P.isWebGLMultipleRenderTargets===!0?P.texture:[P.texture];for(let D=0;D<B.length;D++){const C=B[D],j=r.convert(C.format,C.encoding),L=r.convert(C.type),et=T(C.internalFormat,j,L,C.encoding),Y=yt(P);q&&mt(P)===!1?n.renderbufferStorageMultisample(36161,Y,et,P.width,P.height):mt(P)?d.renderbufferStorageMultisampleEXT(36161,Y,et,P.width,P.height):n.renderbufferStorage(36161,et,P.width,P.height)}}n.bindRenderbuffer(36161,null)}function lt(I){const P=i.get(I),q=I.isWebGLCubeRenderTarget===!0;if(I.depthTexture&&!P.__autoAllocateDepthBuffer){if(q)throw new Error("target.depthTexture not supported in Cube render targets");(function(B,D){if(D&&D.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,B),!D.depthTexture||!D.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");i.get(D.depthTexture).__webglTexture&&D.depthTexture.image.width===D.width&&D.depthTexture.image.height===D.height||(D.depthTexture.image.width=D.width,D.depthTexture.image.height=D.height,D.depthTexture.needsUpdate=!0),U(D.depthTexture,0);const C=i.get(D.depthTexture).__webglTexture,j=yt(D);if(D.depthTexture.format===1026)mt(D)?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,C,0,j):n.framebufferTexture2D(36160,36096,3553,C,0);else{if(D.depthTexture.format!==1027)throw new Error("Unknown depthTexture format");mt(D)?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,C,0,j):n.framebufferTexture2D(36160,33306,3553,C,0)}})(P.__webglFramebuffer,I)}else if(q){P.__webglDepthbuffer=[];for(let B=0;B<6;B++)e.bindFramebuffer(36160,P.__webglFramebuffer[B]),P.__webglDepthbuffer[B]=n.createRenderbuffer(),$(P.__webglDepthbuffer[B],I,!1)}else e.bindFramebuffer(36160,P.__webglFramebuffer),P.__webglDepthbuffer=n.createRenderbuffer(),$(P.__webglDepthbuffer,I,!1);e.bindFramebuffer(36160,null)}function yt(I){return Math.min(u,I.samples)}function mt(I){const P=i.get(I);return o&&I.samples>0&&t.has("WEBGL_multisampled_render_to_texture")===!0&&P.__useRenderToTexture!==!1}function bt(I,P){const q=I.encoding,B=I.format,D=I.type;return I.isCompressedTexture===!0||I.isVideoTexture===!0||I.format===1035||q!==3e3&&(q===3001?o===!1?t.has("EXT_sRGB")===!0&&B===1023?(I.format=1035,I.minFilter=1006,I.generateMipmaps=!1):P=Nc.sRGBToLinear(P):B===1023&&D===1009||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",q)),P}this.allocateTextureUnit=function(){const I=G;return I>=l&&console.warn("THREE.WebGLTextures: Trying to use "+I+" texture units while this GPU supports only "+l),G+=1,I},this.resetTextureUnits=function(){G=0},this.setTexture2D=U,this.setTexture2DArray=function(I,P){const q=i.get(I);I.version>0&&q.__version!==I.version?X(q,I,P):(e.activeTexture(33984+P),e.bindTexture(35866,q.__webglTexture))},this.setTexture3D=function(I,P){const q=i.get(I);I.version>0&&q.__version!==I.version?X(q,I,P):(e.activeTexture(33984+P),e.bindTexture(32879,q.__webglTexture))},this.setTextureCube=function(I,P){const q=i.get(I);I.version>0&&q.__version!==I.version?function(B,D,C){if(D.image.length!==6)return;const j=N(B,D),L=D.source;if(e.activeTexture(33984+C),e.bindTexture(34067,B.__webglTexture),L.version!==L.__currentVersion||j===!0){n.pixelStorei(37440,D.flipY),n.pixelStorei(37441,D.premultiplyAlpha),n.pixelStorei(3317,D.unpackAlignment),n.pixelStorei(37443,0);const et=D.isCompressedTexture||D.image[0].isCompressedTexture,Y=D.image[0]&&D.image[0].isDataTexture,it=[];for(let Et=0;Et<6;Et++)it[Et]=et||Y?Y?D.image[Et].image:D.image[Et]:x(D.image[Et],!1,!0,h),it[Et]=bt(D,it[Et]);const ct=it[0],pt=b(ct)||o,wt=r.convert(D.format,D.encoding),xt=r.convert(D.type),St=T(D.internalFormat,wt,xt,D.encoding),Ct=o&&D.isVideoTexture!==!0,At=L.__currentVersion===void 0||j===!0;let ne,ui=R(D,ct,pt);if(W(34067,D,pt),et){Ct&&At&&e.texStorage2D(34067,ui,St,ct.width,ct.height);for(let Et=0;Et<6;Et++){ne=it[Et].mipmaps;for(let jt=0;jt<ne.length;jt++){const Ht=ne[jt];D.format!==1023?wt!==null?Ct?e.compressedTexSubImage2D(34069+Et,jt,0,0,Ht.width,Ht.height,wt,Ht.data):e.compressedTexImage2D(34069+Et,jt,St,Ht.width,Ht.height,0,Ht.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Ct?e.texSubImage2D(34069+Et,jt,0,0,Ht.width,Ht.height,wt,xt,Ht.data):e.texImage2D(34069+Et,jt,St,Ht.width,Ht.height,0,wt,xt,Ht.data)}}}else{ne=D.mipmaps,Ct&&At&&(ne.length>0&&ui++,e.texStorage2D(34067,ui,St,it[0].width,it[0].height));for(let Et=0;Et<6;Et++)if(Y){Ct?e.texSubImage2D(34069+Et,0,0,0,it[Et].width,it[Et].height,wt,xt,it[Et].data):e.texImage2D(34069+Et,0,St,it[Et].width,it[Et].height,0,wt,xt,it[Et].data);for(let jt=0;jt<ne.length;jt++){const Ht=ne[jt].image[Et].image;Ct?e.texSubImage2D(34069+Et,jt+1,0,0,Ht.width,Ht.height,wt,xt,Ht.data):e.texImage2D(34069+Et,jt+1,St,Ht.width,Ht.height,0,wt,xt,Ht.data)}}else{Ct?e.texSubImage2D(34069+Et,0,0,0,wt,xt,it[Et]):e.texImage2D(34069+Et,0,St,wt,xt,it[Et]);for(let jt=0;jt<ne.length;jt++){const Ht=ne[jt];Ct?e.texSubImage2D(34069+Et,jt+1,0,0,wt,xt,Ht.image[Et]):e.texImage2D(34069+Et,jt+1,St,wt,xt,Ht.image[Et])}}}w(D,pt)&&M(34067),L.__currentVersion=L.version,D.onUpdate&&D.onUpdate(D)}B.__version=D.version}(q,I,P):(e.activeTexture(33984+P),e.bindTexture(34067,q.__webglTexture))},this.rebindTextures=function(I,P,q){const B=i.get(I);P!==void 0&&K(B.__webglFramebuffer,I,I.texture,36064,3553),q!==void 0&&lt(I)},this.setupRenderTarget=function(I){const P=I.texture,q=i.get(I),B=i.get(P);I.addEventListener("dispose",z),I.isWebGLMultipleRenderTargets!==!0&&(B.__webglTexture===void 0&&(B.__webglTexture=n.createTexture()),B.__version=P.version,a.memory.textures++);const D=I.isWebGLCubeRenderTarget===!0,C=I.isWebGLMultipleRenderTargets===!0,j=b(I)||o;if(D){q.__webglFramebuffer=[];for(let L=0;L<6;L++)q.__webglFramebuffer[L]=n.createFramebuffer()}else{if(q.__webglFramebuffer=n.createFramebuffer(),C)if(s.drawBuffers){const L=I.texture;for(let et=0,Y=L.length;et<Y;et++){const it=i.get(L[et]);it.__webglTexture===void 0&&(it.__webglTexture=n.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(o&&I.samples>0&&mt(I)===!1){const L=C?P:[P];q.__webglMultisampledFramebuffer=n.createFramebuffer(),q.__webglColorRenderbuffer=[],e.bindFramebuffer(36160,q.__webglMultisampledFramebuffer);for(let et=0;et<L.length;et++){const Y=L[et];q.__webglColorRenderbuffer[et]=n.createRenderbuffer(),n.bindRenderbuffer(36161,q.__webglColorRenderbuffer[et]);const it=r.convert(Y.format,Y.encoding),ct=r.convert(Y.type),pt=T(Y.internalFormat,it,ct,Y.encoding),wt=yt(I);n.renderbufferStorageMultisample(36161,wt,pt,I.width,I.height),n.framebufferRenderbuffer(36160,36064+et,36161,q.__webglColorRenderbuffer[et])}n.bindRenderbuffer(36161,null),I.depthBuffer&&(q.__webglDepthRenderbuffer=n.createRenderbuffer(),$(q.__webglDepthRenderbuffer,I,!0)),e.bindFramebuffer(36160,null)}}if(D){e.bindTexture(34067,B.__webglTexture),W(34067,P,j);for(let L=0;L<6;L++)K(q.__webglFramebuffer[L],I,P,36064,34069+L);w(P,j)&&M(34067),e.unbindTexture()}else if(C){const L=I.texture;for(let et=0,Y=L.length;et<Y;et++){const it=L[et],ct=i.get(it);e.bindTexture(3553,ct.__webglTexture),W(3553,it,j),K(q.__webglFramebuffer,I,it,36064+et,3553),w(it,j)&&M(3553)}e.unbindTexture()}else{let L=3553;(I.isWebGL3DRenderTarget||I.isWebGLArrayRenderTarget)&&(o?L=I.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),e.bindTexture(L,B.__webglTexture),W(L,P,j),K(q.__webglFramebuffer,I,P,36064,L),w(P,j)&&M(L),e.unbindTexture()}I.depthBuffer&&lt(I)},this.updateRenderTargetMipmap=function(I){const P=b(I)||o,q=I.isWebGLMultipleRenderTargets===!0?I.texture:[I.texture];for(let B=0,D=q.length;B<D;B++){const C=q[B];if(w(C,P)){const j=I.isWebGLCubeRenderTarget?34067:3553,L=i.get(C).__webglTexture;e.bindTexture(j,L),M(j),e.unbindTexture()}}},this.updateMultisampleRenderTarget=function(I){if(o&&I.samples>0&&mt(I)===!1){const P=I.isWebGLMultipleRenderTargets?I.texture:[I.texture],q=I.width,B=I.height;let D=16384;const C=[],j=I.stencilBuffer?33306:36096,L=i.get(I),et=I.isWebGLMultipleRenderTargets===!0;if(et)for(let Y=0;Y<P.length;Y++)e.bindFramebuffer(36160,L.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064+Y,36161,null),e.bindFramebuffer(36160,L.__webglFramebuffer),n.framebufferTexture2D(36009,36064+Y,3553,null,0);e.bindFramebuffer(36008,L.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,L.__webglFramebuffer);for(let Y=0;Y<P.length;Y++){C.push(36064+Y),I.depthBuffer&&C.push(j);const it=L.__ignoreDepthValues!==void 0&&L.__ignoreDepthValues;if(it===!1&&(I.depthBuffer&&(D|=256),I.stencilBuffer&&(D|=1024)),et&&n.framebufferRenderbuffer(36008,36064,36161,L.__webglColorRenderbuffer[Y]),it===!0&&(n.invalidateFramebuffer(36008,[j]),n.invalidateFramebuffer(36009,[j])),et){const ct=i.get(P[Y]).__webglTexture;n.framebufferTexture2D(36009,36064,3553,ct,0)}n.blitFramebuffer(0,0,q,B,0,0,q,B,D,9728),p&&n.invalidateFramebuffer(36008,C)}if(e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,null),et)for(let Y=0;Y<P.length;Y++){e.bindFramebuffer(36160,L.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064+Y,36161,L.__webglColorRenderbuffer[Y]);const it=i.get(P[Y]).__webglTexture;e.bindFramebuffer(36160,L.__webglFramebuffer),n.framebufferTexture2D(36009,36064+Y,3553,it,0)}e.bindFramebuffer(36009,L.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=lt,this.setupFrameBufferTexture=K,this.useMultisampledRTT=mt}function Xm(n,t,e){const i=e.isWebGL2;return{convert:function(s,r=null){let a;if(s===1009)return 5121;if(s===1017)return 32819;if(s===1018)return 32820;if(s===1010)return 5120;if(s===1011)return 5122;if(s===1012)return 5123;if(s===1013)return 5124;if(s===1014)return 5125;if(s===1015)return 5126;if(s===1016)return i?5131:(a=t.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===1021)return 6406;if(s===1023)return 6408;if(s===1024)return 6409;if(s===1025)return 6410;if(s===1026)return 6402;if(s===1027)return 34041;if(s===1028)return 6403;if(s===1022)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(s===1035)return a=t.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(s===1029)return 36244;if(s===1030)return 33319;if(s===1031)return 33320;if(s===1033)return 36249;if(s===33776||s===33777||s===33778||s===33779)if(r===3001){if(a=t.get("WEBGL_compressed_texture_s3tc_srgb"),a===null)return null;if(s===33776)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===33777)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===33778)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===33779)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(a=t.get("WEBGL_compressed_texture_s3tc"),a===null)return null;if(s===33776)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===33777)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===33778)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===33779)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(s===35840||s===35841||s===35842||s===35843){if(a=t.get("WEBGL_compressed_texture_pvrtc"),a===null)return null;if(s===35840)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===35841)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===35842)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===35843)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(s===36196)return a=t.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(s===37492||s===37496){if(a=t.get("WEBGL_compressed_texture_etc"),a===null)return null;if(s===37492)return r===3001?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(s===37496)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}if(s===37808||s===37809||s===37810||s===37811||s===37812||s===37813||s===37814||s===37815||s===37816||s===37817||s===37818||s===37819||s===37820||s===37821){if(a=t.get("WEBGL_compressed_texture_astc"),a===null)return null;if(s===37808)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===37809)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===37810)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===37811)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===37812)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===37813)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===37814)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===37815)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===37816)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===37817)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===37818)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===37819)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===37820)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===37821)return r===3001?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}if(s===36492){if(a=t.get("EXT_texture_compression_bptc"),a===null)return null;if(s===36492)return r===3001?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT}return s===1020?i?34042:(a=t.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):n[s]!==void 0?n[s]:null}}}class Ym extends ee{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}class Me extends Mt{constructor(){super(),this.isGroup=!0,this.type="Group"}}const Gx={type:"move"};class du{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Me,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Me,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new S,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new S),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Me,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new S,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new S),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,i){let s=null,r=null,a=null;const o=this._targetRay,l=this._grip,h=this._hand;if(t&&e.session.visibilityState!=="visible-blurred")if(o!==null&&(s=e.getPose(t.targetRaySpace,i),s!==null&&(o.matrix.fromArray(s.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),s.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(s.linearVelocity)):o.hasLinearVelocity=!1,s.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(s.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(Gx))),h&&t.hand){a=!0;for(const f of t.hand.values()){const v=e.getJointPose(f,i);if(h.joints[f.jointName]===void 0){const y=new Me;y.matrixAutoUpdate=!1,y.visible=!1,h.joints[f.jointName]=y,h.add(y)}const _=h.joints[f.jointName];v!==null&&(_.matrix.fromArray(v.transform.matrix),_.matrix.decompose(_.position,_.rotation,_.scale),_.jointRadius=v.radius),_.visible=v!==null}const c=h.joints["index-finger-tip"],u=h.joints["thumb-tip"],d=c.position.distanceTo(u.position),p=.02,m=.005;h.inputState.pinching&&d>p+m?(h.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!h.inputState.pinching&&d<=p-m&&(h.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else l!==null&&t.gripSpace&&(r=e.getPose(t.gripSpace,i),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));return o!==null&&(o.visible=s!==null),l!==null&&(l.visible=r!==null),h!==null&&(h.visible=a!==null),this}}class pu extends Gt{constructor(t,e,i,s,r,a,o,l,h,c){if((c=c!==void 0?c:1026)!==1026&&c!==1027)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");i===void 0&&c===1026&&(i=1014),i===void 0&&c===1027&&(i=1020),super(null,s,r,a,o,l,c,i,h),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=o!==void 0?o:1003,this.minFilter=l!==void 0?l:1003,this.flipY=!1,this.generateMipmaps=!1}}class jx extends Ji{constructor(t,e){super();const i=this;let s=null,r=1,a=null,o="local-floor",l=null,h=null,c=null,u=null,d=null,p=null;const m=e.getContextAttributes();let f=null,v=null;const _=[],y=new Map,x=new ee;x.layers.enable(1),x.viewport=new Ot;const b=new ee;b.layers.enable(2),b.viewport=new Ot;const w=[x,b],M=new Ym;M.layers.enable(1),M.layers.enable(2);let T=null,R=null;function E(W){const N=y.get(W.inputSource);N!==void 0&&N.dispatchEvent({type:W.type,data:W.inputSource})}function A(){s.removeEventListener("select",E),s.removeEventListener("selectstart",E),s.removeEventListener("selectend",E),s.removeEventListener("squeeze",E),s.removeEventListener("squeezestart",E),s.removeEventListener("squeezeend",E),s.removeEventListener("end",A),s.removeEventListener("inputsourceschange",z),y.forEach(function(W,N){W!==void 0&&W.disconnect(N)}),y.clear(),T=null,R=null,t.setRenderTarget(f),d=null,u=null,c=null,s=null,v=null,H.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}function z(W){const N=s.inputSources;for(let X=0;X<N.length;X++){const K=N[X].handedness==="right"?1:0;y.set(N[X],_[K])}for(let X=0;X<W.removed.length;X++){const K=W.removed[X],$=y.get(K);$&&($.dispatchEvent({type:"disconnected",data:K}),y.delete(K))}for(let X=0;X<W.added.length;X++){const K=W.added[X],$=y.get(K);$&&$.dispatchEvent({type:"connected",data:K})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(W){let N=_[W];return N===void 0&&(N=new du,_[W]=N),N.getTargetRaySpace()},this.getControllerGrip=function(W){let N=_[W];return N===void 0&&(N=new du,_[W]=N),N.getGripSpace()},this.getHand=function(W){let N=_[W];return N===void 0&&(N=new du,_[W]=N),N.getHandSpace()},this.setFramebufferScaleFactor=function(W){r=W,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(W){o=W,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||a},this.setReferenceSpace=function(W){l=W},this.getBaseLayer=function(){return u!==null?u:d},this.getBinding=function(){return c},this.getFrame=function(){return p},this.getSession=function(){return s},this.setSession=async function(W){if(s=W,s!==null){if(f=t.getRenderTarget(),s.addEventListener("select",E),s.addEventListener("selectstart",E),s.addEventListener("selectend",E),s.addEventListener("squeeze",E),s.addEventListener("squeezestart",E),s.addEventListener("squeezeend",E),s.addEventListener("end",A),s.addEventListener("inputsourceschange",z),m.xrCompatible!==!0&&await e.makeXRCompatible(),s.renderState.layers===void 0||t.capabilities.isWebGL2===!1){const N={antialias:s.renderState.layers!==void 0||m.antialias,alpha:m.alpha,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:r};d=new XRWebGLLayer(s,e,N),s.updateRenderState({baseLayer:d}),v=new Yt(d.framebufferWidth,d.framebufferHeight,{format:1023,type:1009,encoding:t.outputEncoding})}else{let N=null,X=null,K=null;m.depth&&(K=m.stencil?35056:33190,N=m.stencil?1027:1026,X=m.stencil?1020:1014);const $={colorFormat:t.outputEncoding===3001?35907:32856,depthFormat:K,scaleFactor:r};c=new XRWebGLBinding(s,e),u=c.createProjectionLayer($),s.updateRenderState({layers:[u]}),v=new Yt(u.textureWidth,u.textureHeight,{format:1023,type:1009,depthTexture:new pu(u.textureWidth,u.textureHeight,X,void 0,void 0,void 0,void 0,void 0,void 0,N),stencilBuffer:m.stencil,encoding:t.outputEncoding,samples:m.antialias?4:0}),t.properties.get(v).__ignoreDepthValues=u.ignoreDepthValues}v.isXRRenderTarget=!0,this.setFoveation(1),l=null,a=await s.requestReferenceSpace(o),H.setContext(s),H.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}};const F=new S,G=new S;function U(W,N){N===null?W.matrixWorld.copy(W.matrix):W.matrixWorld.multiplyMatrices(N.matrixWorld,W.matrix),W.matrixWorldInverse.copy(W.matrixWorld).invert()}this.updateCamera=function(W){if(s===null)return;M.near=b.near=x.near=W.near,M.far=b.far=x.far=W.far,T===M.near&&R===M.far||(s.updateRenderState({depthNear:M.near,depthFar:M.far}),T=M.near,R=M.far);const N=W.parent,X=M.cameras;U(M,N);for(let $=0;$<X.length;$++)U(X[$],N);M.matrixWorld.decompose(M.position,M.quaternion,M.scale),W.position.copy(M.position),W.quaternion.copy(M.quaternion),W.scale.copy(M.scale),W.matrix.copy(M.matrix),W.matrixWorld.copy(M.matrixWorld);const K=W.children;for(let $=0,lt=K.length;$<lt;$++)K[$].updateMatrixWorld(!0);X.length===2?function($,lt,yt){F.setFromMatrixPosition(lt.matrixWorld),G.setFromMatrixPosition(yt.matrixWorld);const mt=F.distanceTo(G),bt=lt.projectionMatrix.elements,I=yt.projectionMatrix.elements,P=bt[14]/(bt[10]-1),q=bt[14]/(bt[10]+1),B=(bt[9]+1)/bt[5],D=(bt[9]-1)/bt[5],C=(bt[8]-1)/bt[0],j=(I[8]+1)/I[0],L=P*C,et=P*j,Y=mt/(-C+j),it=Y*-C;lt.matrixWorld.decompose($.position,$.quaternion,$.scale),$.translateX(it),$.translateZ(Y),$.matrixWorld.compose($.position,$.quaternion,$.scale),$.matrixWorldInverse.copy($.matrixWorld).invert();const ct=P+Y,pt=q+Y,wt=L-it,xt=et+(mt-it),St=B*q/pt*ct,Ct=D*q/pt*ct;$.projectionMatrix.makePerspective(wt,xt,St,Ct,ct,pt)}(M,x,b):M.projectionMatrix.copy(x.projectionMatrix)},this.getCamera=function(){return M},this.getFoveation=function(){return u!==null?u.fixedFoveation:d!==null?d.fixedFoveation:void 0},this.setFoveation=function(W){u!==null&&(u.fixedFoveation=W),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=W)};let k=null;const H=new _m;H.setAnimationLoop(function(W,N){if(h=N.getViewerPose(l||a),p=N,h!==null){const K=h.views;d!==null&&(t.setRenderTargetFramebuffer(v,d.framebuffer),t.setRenderTarget(v));let $=!1;K.length!==M.cameras.length&&(M.cameras.length=0,$=!0);for(let lt=0;lt<K.length;lt++){const yt=K[lt];let mt=null;if(d!==null)mt=d.getViewport(yt);else{const I=c.getViewSubImage(u,yt);mt=I.viewport,lt===0&&(t.setRenderTargetTextures(v,I.colorTexture,u.ignoreDepthValues?void 0:I.depthStencilTexture),t.setRenderTarget(v))}let bt=w[lt];bt===void 0&&(bt=new ee,bt.layers.enable(lt),bt.viewport=new Ot,w[lt]=bt),bt.matrix.fromArray(yt.transform.matrix),bt.projectionMatrix.fromArray(yt.projectionMatrix),bt.viewport.set(mt.x,mt.y,mt.width,mt.height),lt===0&&M.matrix.copy(bt.matrix),$===!0&&M.cameras.push(bt)}}const X=s.inputSources;for(let K=0;K<_.length;K++){const $=X[K],lt=y.get($);lt!==void 0&&lt.update($,N,l||a)}k&&k(W,N),p=null}),this.setAnimationLoop=function(W){k=W},this.dispose=function(){}}}function Hx(n,t){function e(i,s){i.opacity.value=s.opacity,s.color&&i.diffuse.value.copy(s.color),s.emissive&&i.emissive.value.copy(s.emissive).multiplyScalar(s.emissiveIntensity),s.map&&(i.map.value=s.map),s.alphaMap&&(i.alphaMap.value=s.alphaMap),s.bumpMap&&(i.bumpMap.value=s.bumpMap,i.bumpScale.value=s.bumpScale,s.side===1&&(i.bumpScale.value*=-1)),s.displacementMap&&(i.displacementMap.value=s.displacementMap,i.displacementScale.value=s.displacementScale,i.displacementBias.value=s.displacementBias),s.emissiveMap&&(i.emissiveMap.value=s.emissiveMap),s.normalMap&&(i.normalMap.value=s.normalMap,i.normalScale.value.copy(s.normalScale),s.side===1&&i.normalScale.value.negate()),s.specularMap&&(i.specularMap.value=s.specularMap),s.alphaTest>0&&(i.alphaTest.value=s.alphaTest);const r=t.get(s).envMap;if(r&&(i.envMap.value=r,i.flipEnvMap.value=r.isCubeTexture&&r.isRenderTargetTexture===!1?-1:1,i.reflectivity.value=s.reflectivity,i.ior.value=s.ior,i.refractionRatio.value=s.refractionRatio),s.lightMap){i.lightMap.value=s.lightMap;const l=n.physicallyCorrectLights!==!0?Math.PI:1;i.lightMapIntensity.value=s.lightMapIntensity*l}let a,o;s.aoMap&&(i.aoMap.value=s.aoMap,i.aoMapIntensity.value=s.aoMapIntensity),s.map?a=s.map:s.specularMap?a=s.specularMap:s.displacementMap?a=s.displacementMap:s.normalMap?a=s.normalMap:s.bumpMap?a=s.bumpMap:s.roughnessMap?a=s.roughnessMap:s.metalnessMap?a=s.metalnessMap:s.alphaMap?a=s.alphaMap:s.emissiveMap?a=s.emissiveMap:s.clearcoatMap?a=s.clearcoatMap:s.clearcoatNormalMap?a=s.clearcoatNormalMap:s.clearcoatRoughnessMap?a=s.clearcoatRoughnessMap:s.iridescenceMap?a=s.iridescenceMap:s.iridescenceThicknessMap?a=s.iridescenceThicknessMap:s.specularIntensityMap?a=s.specularIntensityMap:s.specularColorMap?a=s.specularColorMap:s.transmissionMap?a=s.transmissionMap:s.thicknessMap?a=s.thicknessMap:s.sheenColorMap?a=s.sheenColorMap:s.sheenRoughnessMap&&(a=s.sheenRoughnessMap),a!==void 0&&(a.isWebGLRenderTarget&&(a=a.texture),a.matrixAutoUpdate===!0&&a.updateMatrix(),i.uvTransform.value.copy(a.matrix)),s.aoMap?o=s.aoMap:s.lightMap&&(o=s.lightMap),o!==void 0&&(o.isWebGLRenderTarget&&(o=o.texture),o.matrixAutoUpdate===!0&&o.updateMatrix(),i.uv2Transform.value.copy(o.matrix))}return{refreshFogUniforms:function(i,s){i.fogColor.value.copy(s.color),s.isFog?(i.fogNear.value=s.near,i.fogFar.value=s.far):s.isFogExp2&&(i.fogDensity.value=s.density)},refreshMaterialUniforms:function(i,s,r,a,o){s.isMeshBasicMaterial||s.isMeshLambertMaterial?e(i,s):s.isMeshToonMaterial?(e(i,s),function(l,h){h.gradientMap&&(l.gradientMap.value=h.gradientMap)}(i,s)):s.isMeshPhongMaterial?(e(i,s),function(l,h){l.specular.value.copy(h.specular),l.shininess.value=Math.max(h.shininess,1e-4)}(i,s)):s.isMeshStandardMaterial?(e(i,s),function(l,h){l.roughness.value=h.roughness,l.metalness.value=h.metalness,h.roughnessMap&&(l.roughnessMap.value=h.roughnessMap),h.metalnessMap&&(l.metalnessMap.value=h.metalnessMap),t.get(h).envMap&&(l.envMapIntensity.value=h.envMapIntensity)}(i,s),s.isMeshPhysicalMaterial&&function(l,h,c){l.ior.value=h.ior,h.sheen>0&&(l.sheenColor.value.copy(h.sheenColor).multiplyScalar(h.sheen),l.sheenRoughness.value=h.sheenRoughness,h.sheenColorMap&&(l.sheenColorMap.value=h.sheenColorMap),h.sheenRoughnessMap&&(l.sheenRoughnessMap.value=h.sheenRoughnessMap)),h.clearcoat>0&&(l.clearcoat.value=h.clearcoat,l.clearcoatRoughness.value=h.clearcoatRoughness,h.clearcoatMap&&(l.clearcoatMap.value=h.clearcoatMap),h.clearcoatRoughnessMap&&(l.clearcoatRoughnessMap.value=h.clearcoatRoughnessMap),h.clearcoatNormalMap&&(l.clearcoatNormalScale.value.copy(h.clearcoatNormalScale),l.clearcoatNormalMap.value=h.clearcoatNormalMap,h.side===1&&l.clearcoatNormalScale.value.negate())),h.iridescence>0&&(l.iridescence.value=h.iridescence,l.iridescenceIOR.value=h.iridescenceIOR,l.iridescenceThicknessMinimum.value=h.iridescenceThicknessRange[0],l.iridescenceThicknessMaximum.value=h.iridescenceThicknessRange[1],h.iridescenceMap&&(l.iridescenceMap.value=h.iridescenceMap),h.iridescenceThicknessMap&&(l.iridescenceThicknessMap.value=h.iridescenceThicknessMap)),h.transmission>0&&(l.transmission.value=h.transmission,l.transmissionSamplerMap.value=c.texture,l.transmissionSamplerSize.value.set(c.width,c.height),h.transmissionMap&&(l.transmissionMap.value=h.transmissionMap),l.thickness.value=h.thickness,h.thicknessMap&&(l.thicknessMap.value=h.thicknessMap),l.attenuationDistance.value=h.attenuationDistance,l.attenuationColor.value.copy(h.attenuationColor)),l.specularIntensity.value=h.specularIntensity,l.specularColor.value.copy(h.specularColor),h.specularIntensityMap&&(l.specularIntensityMap.value=h.specularIntensityMap),h.specularColorMap&&(l.specularColorMap.value=h.specularColorMap)}(i,s,o)):s.isMeshMatcapMaterial?(e(i,s),function(l,h){h.matcap&&(l.matcap.value=h.matcap)}(i,s)):s.isMeshDepthMaterial?e(i,s):s.isMeshDistanceMaterial?(e(i,s),function(l,h){l.referencePosition.value.copy(h.referencePosition),l.nearDistance.value=h.nearDistance,l.farDistance.value=h.farDistance}(i,s)):s.isMeshNormalMaterial?e(i,s):s.isLineBasicMaterial?(function(l,h){l.diffuse.value.copy(h.color),l.opacity.value=h.opacity}(i,s),s.isLineDashedMaterial&&function(l,h){l.dashSize.value=h.dashSize,l.totalSize.value=h.dashSize+h.gapSize,l.scale.value=h.scale}(i,s)):s.isPointsMaterial?function(l,h,c,u){l.diffuse.value.copy(h.color),l.opacity.value=h.opacity,l.size.value=h.size*c,l.scale.value=.5*u,h.map&&(l.map.value=h.map),h.alphaMap&&(l.alphaMap.value=h.alphaMap),h.alphaTest>0&&(l.alphaTest.value=h.alphaTest);let d;h.map?d=h.map:h.alphaMap&&(d=h.alphaMap),d!==void 0&&(d.matrixAutoUpdate===!0&&d.updateMatrix(),l.uvTransform.value.copy(d.matrix))}(i,s,r,a):s.isSpriteMaterial?function(l,h){l.diffuse.value.copy(h.color),l.opacity.value=h.opacity,l.rotation.value=h.rotation,h.map&&(l.map.value=h.map),h.alphaMap&&(l.alphaMap.value=h.alphaMap),h.alphaTest>0&&(l.alphaTest.value=h.alphaTest);let c;h.map?c=h.map:h.alphaMap&&(c=h.alphaMap),c!==void 0&&(c.matrixAutoUpdate===!0&&c.updateMatrix(),l.uvTransform.value.copy(c.matrix))}(i,s):s.isShadowMaterial?(i.color.value.copy(s.color),i.opacity.value=s.opacity):s.isShaderMaterial&&(s.uniformsNeedUpdate=!1)}}}function mu(n={}){this.isWebGLRenderer=!0;const t=n.canvas!==void 0?n.canvas:function(){const O=wa("canvas");return O.style.display="block",O}(),e=n.context!==void 0?n.context:null,i=n.depth===void 0||n.depth,s=n.stencil===void 0||n.stencil,r=n.antialias!==void 0&&n.antialias,a=n.premultipliedAlpha===void 0||n.premultipliedAlpha,o=n.preserveDrawingBuffer!==void 0&&n.preserveDrawingBuffer,l=n.powerPreference!==void 0?n.powerPreference:"default",h=n.failIfMajorPerformanceCaveat!==void 0&&n.failIfMajorPerformanceCaveat;let c;c=e!==null?e.getContextAttributes().alpha:n.alpha!==void 0&&n.alpha;let u=null,d=null;const p=[],m=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=3e3,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});const f=this;let v=!1,_=0,y=0,x=null,b=-1,w=null;const M=new Ot,T=new Ot;let R=null,E=t.width,A=t.height,z=1,F=null,G=null;const U=new Ot(0,0,E,A),k=new Ot(0,0,E,A);let H=!1;const W=new gr;let N=!1,X=!1,K=null;const $=new at,lt=new V,yt=new S,mt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function bt(){return x===null?z:1}let I,P,q,B,D,C,j,L,et,Y,it,ct,pt,wt,xt,St,Ct,At,ne,ui,Et,jt,Ht,dt=e;function Vy(O,Q){for(let tt=0;tt<O.length;tt++){const st=O[tt],ht=t.getContext(st,Q);if(ht!==null)return ht}return null}try{const O={alpha:!0,depth:i,stencil:s,antialias:r,premultipliedAlpha:a,preserveDrawingBuffer:o,powerPreference:l,failIfMajorPerformanceCaveat:h};if("setAttribute"in t&&t.setAttribute("data-engine","three.js r141dev"),t.addEventListener("webglcontextlost",jy,!1),t.addEventListener("webglcontextrestored",Hy,!1),t.addEventListener("webglcontextcreationerror",Wy,!1),dt===null){const Q=["webgl2","webgl","experimental-webgl"];if(f.isWebGL1Renderer===!0&&Q.shift(),dt=Vy(Q,O),dt===null)throw Vy(Q)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}dt.getShaderPrecisionFormat===void 0&&(dt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(O){throw console.error("THREE.WebGLRenderer: "+O.message),O}function Gy(){I=new M1(dt),P=new _1(dt,I,n),I.init(P),jt=new Xm(dt,I,P),q=new Bx(dt,I,P),B=new T1,D=new Lx,C=new Vx(dt,I,q,D,P,jt,B),j=new x1(f),L=new b1(f),et=new m1(dt,P),Ht=new g1(dt,I,et,P),Y=new w1(dt,et,B,Ht),it=new P1(dt,Y,et,B),ne=new A1(dt,P,C),St=new y1(D),ct=new Rx(f,j,L,I,P,Ht,St),pt=new Hx(f,D),wt=new Dx,xt=new Nx(I,P),At=new f1(f,j,q,it,c,a),Ct=new kx(f,it,P),ui=new v1(dt,I,B,P),Et=new S1(dt,I,B,P),B.programs=ct.programs,f.capabilities=P,f.extensions=I,f.properties=D,f.renderLists=wt,f.shadowMap=Ct,f.state=q,f.info=B}Gy();const di=new jx(f,dt);function jy(O){O.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),v=!0}function Hy(){console.log("THREE.WebGLRenderer: Context Restored."),v=!1;const O=B.autoReset,Q=Ct.enabled,tt=Ct.autoUpdate,st=Ct.needsUpdate,ht=Ct.type;Gy(),B.autoReset=O,Ct.enabled=Q,Ct.autoUpdate=tt,Ct.needsUpdate=st,Ct.type=ht}function Wy(O){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",O.statusMessage)}function qy(O){const Q=O.target;Q.removeEventListener("dispose",qy),function(tt){(function(st){const ht=D.get(st).programs;ht!==void 0&&(ht.forEach(function(Tt){ct.releaseProgram(Tt)}),st.isShaderMaterial&&ct.releaseShaderCache(st))})(tt),D.remove(tt)}(Q)}this.xr=di,this.getContext=function(){return dt},this.getContextAttributes=function(){return dt.getContextAttributes()},this.forceContextLoss=function(){const O=I.get("WEBGL_lose_context");O&&O.loseContext()},this.forceContextRestore=function(){const O=I.get("WEBGL_lose_context");O&&O.restoreContext()},this.getPixelRatio=function(){return z},this.setPixelRatio=function(O){O!==void 0&&(z=O,this.setSize(E,A,!1))},this.getSize=function(O){return O.set(E,A)},this.setSize=function(O,Q,tt){di.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(E=O,A=Q,t.width=Math.floor(O*z),t.height=Math.floor(Q*z),tt!==!1&&(t.style.width=O+"px",t.style.height=Q+"px"),this.setViewport(0,0,O,Q))},this.getDrawingBufferSize=function(O){return O.set(E*z,A*z).floor()},this.setDrawingBufferSize=function(O,Q,tt){E=O,A=Q,z=tt,t.width=Math.floor(O*tt),t.height=Math.floor(Q*tt),this.setViewport(0,0,O,Q)},this.getCurrentViewport=function(O){return O.copy(M)},this.getViewport=function(O){return O.copy(U)},this.setViewport=function(O,Q,tt,st){O.isVector4?U.set(O.x,O.y,O.z,O.w):U.set(O,Q,tt,st),q.viewport(M.copy(U).multiplyScalar(z).floor())},this.getScissor=function(O){return O.copy(k)},this.setScissor=function(O,Q,tt,st){O.isVector4?k.set(O.x,O.y,O.z,O.w):k.set(O,Q,tt,st),q.scissor(T.copy(k).multiplyScalar(z).floor())},this.getScissorTest=function(){return H},this.setScissorTest=function(O){q.setScissorTest(H=O)},this.setOpaqueSort=function(O){F=O},this.setTransparentSort=function(O){G=O},this.getClearColor=function(O){return O.copy(At.getClearColor())},this.setClearColor=function(){At.setClearColor.apply(At,arguments)},this.getClearAlpha=function(){return At.getClearAlpha()},this.setClearAlpha=function(){At.setClearAlpha.apply(At,arguments)},this.clear=function(O=!0,Q=!0,tt=!0){let st=0;O&&(st|=16384),Q&&(st|=256),tt&&(st|=1024),dt.clear(st)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",jy,!1),t.removeEventListener("webglcontextrestored",Hy,!1),t.removeEventListener("webglcontextcreationerror",Wy,!1),wt.dispose(),xt.dispose(),D.dispose(),j.dispose(),L.dispose(),it.dispose(),Ht.dispose(),ct.dispose(),di.dispose(),di.removeEventListener("sessionstart",Xy),di.removeEventListener("sessionend",Yy),K&&(K.dispose(),K=null),$s.stop()},this.renderBufferDirect=function(O,Q,tt,st,ht,Tt){Q===null&&(Q=mt);const It=ht.isMesh&&ht.matrixWorld.determinant()<0,Pt=function(Le,jo,Yi,Rt,Pe){jo.isScene!==!0&&(jo=mt),C.resetTextureUnits();const Qp=jo.fog,qE=Rt.isMeshStandardMaterial?jo.environment:null,XE=x===null?f.outputEncoding:x.isXRRenderTarget===!0?x.texture.encoding:3e3,YE=(Rt.isMeshStandardMaterial?L:j).get(Rt.envMap||qE),ZE=Rt.vertexColors===!0&&!!Yi.attributes.color&&Yi.attributes.color.itemSize===4,JE=!!Rt.normalMap&&!!Yi.attributes.tangent,KE=!!Yi.morphAttributes.position,QE=!!Yi.morphAttributes.normal,$E=!!Yi.morphAttributes.color,tC=Rt.toneMapped?f.toneMapping:0,Qy=Yi.morphAttributes.position||Yi.morphAttributes.normal||Yi.morphAttributes.color,eC=Qy!==void 0?Qy.length:0,Xt=D.get(Rt),iC=d.state.lights,nC=f.extraProgramCacheKey;if(N===!0&&(X===!0||Le!==w)){const gn=Le===w&&Rt.id===b;St.setState(Rt,Le,gn)}let zn=!1;Rt.version===Xt.__version?Xt.needsLights&&Xt.lightsStateVersion!==iC.state.version||Xt.outputEncoding!==XE||Pe.isInstancedMesh&&Xt.instancing===!1?zn=!0:Pe.isInstancedMesh||Xt.instancing!==!0?Pe.isSkinnedMesh&&Xt.skinning===!1?zn=!0:Pe.isSkinnedMesh||Xt.skinning!==!0?Xt.envMap!==YE||Rt.fog===!0&&Xt.fog!==Qp?zn=!0:Xt.numClippingPlanes===void 0||Xt.numClippingPlanes===St.numPlanes&&Xt.numIntersection===St.numIntersection?(Xt.vertexAlphas!==ZE||Xt.vertexTangents!==JE||Xt.morphTargets!==KE||Xt.morphNormals!==QE||Xt.morphColors!==$E||Xt.toneMapping!==tC||P.isWebGL2===!0&&Xt.morphTargetsCount!==eC||nC!==Xt.extraProgramCacheKey)&&(zn=!0):zn=!0:zn=!0:zn=!0:(zn=!0,Xt.__version=Rt.version);let Ho=Xt.currentProgram;zn===!0&&(Ho=Jp(Rt,jo,Pe));let $y=!1,Wo=!1,$p=!1;const We=Ho.getUniforms(),qo=Xt.uniforms;if(q.useProgram(Ho.program)&&($y=!0,Wo=!0,$p=!0),Rt.id!==b&&(b=Rt.id,Wo=!0),$y||w!==Le){if(We.setValue(dt,"projectionMatrix",Le.projectionMatrix),P.logarithmicDepthBuffer&&We.setValue(dt,"logDepthBufFC",2/(Math.log(Le.far+1)/Math.LN2)),w!==Le&&(w=Le,Wo=!0,$p=!0),Rt.isShaderMaterial||Rt.isMeshPhongMaterial||Rt.isMeshToonMaterial||Rt.isMeshStandardMaterial||Rt.envMap){const gn=We.map.cameraPosition;gn!==void 0&&gn.setValue(dt,yt.setFromMatrixPosition(Le.matrixWorld))}(Rt.isMeshPhongMaterial||Rt.isMeshToonMaterial||Rt.isMeshLambertMaterial||Rt.isMeshBasicMaterial||Rt.isMeshStandardMaterial||Rt.isShaderMaterial)&&We.setValue(dt,"isOrthographic",Le.isOrthographicCamera===!0),(Rt.isMeshPhongMaterial||Rt.isMeshToonMaterial||Rt.isMeshLambertMaterial||Rt.isMeshBasicMaterial||Rt.isMeshStandardMaterial||Rt.isShaderMaterial||Rt.isShadowMaterial||Pe.isSkinnedMesh)&&We.setValue(dt,"viewMatrix",Le.matrixWorldInverse)}if(Pe.isSkinnedMesh){We.setOptional(dt,Pe,"bindMatrix"),We.setOptional(dt,Pe,"bindMatrixInverse");const gn=Pe.skeleton;gn&&(P.floatVertexTextures?(gn.boneTexture===null&&gn.computeBoneTexture(),We.setValue(dt,"boneTexture",gn.boneTexture,C),We.setValue(dt,"boneTextureSize",gn.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const tm=Yi.morphAttributes;(tm.position!==void 0||tm.normal!==void 0||tm.color!==void 0&&P.isWebGL2===!0)&&ne.update(Pe,Yi,Rt,Ho),(Wo||Xt.receiveShadow!==Pe.receiveShadow)&&(Xt.receiveShadow=Pe.receiveShadow,We.setValue(dt,"receiveShadow",Pe.receiveShadow)),Wo&&(We.setValue(dt,"toneMappingExposure",f.toneMappingExposure),Xt.needsLights&&(Zi=$p,(fn=qo).ambientLightColor.needsUpdate=Zi,fn.lightProbe.needsUpdate=Zi,fn.directionalLights.needsUpdate=Zi,fn.directionalLightShadows.needsUpdate=Zi,fn.pointLights.needsUpdate=Zi,fn.pointLightShadows.needsUpdate=Zi,fn.spotLights.needsUpdate=Zi,fn.spotLightShadows.needsUpdate=Zi,fn.rectAreaLights.needsUpdate=Zi,fn.hemisphereLights.needsUpdate=Zi),Qp&&Rt.fog===!0&&pt.refreshFogUniforms(qo,Qp),pt.refreshMaterialUniforms(qo,Rt,z,A,K),Cl.upload(dt,Xt.uniformsList,qo,C));var fn,Zi;return Rt.isShaderMaterial&&Rt.uniformsNeedUpdate===!0&&(Cl.upload(dt,Xt.uniformsList,qo,C),Rt.uniformsNeedUpdate=!1),Rt.isSpriteMaterial&&We.setValue(dt,"center",Pe.center),We.setValue(dt,"modelViewMatrix",Pe.modelViewMatrix),We.setValue(dt,"normalMatrix",Pe.normalMatrix),We.setValue(dt,"modelMatrix",Pe.matrixWorld),Ho}(O,Q,tt,st,ht);q.setMaterial(st,It);let Bt=tt.index;const ue=tt.attributes.position;if(Bt===null){if(ue===void 0||ue.count===0)return}else if(Bt.count===0)return;let Vt,Ut=1;st.wireframe===!0&&(Bt=Y.getWireframeAttribute(tt),Ut=2),Ht.setup(ht,st,Pt,tt,Bt);let Ae=ui;Bt!==null&&(Vt=et.get(Bt),Ae=Et,Ae.setIndex(Vt));const Go=Bt!==null?Bt.count:ue.count,Pi=tt.drawRange.start*Ut,Kp=tt.drawRange.count*Ut,ls=Tt!==null?Tt.start*Ut:0,HE=Tt!==null?Tt.count*Ut:1/0,Ic=Math.max(Pi,ls),WE=Math.min(Go,Pi+Kp,ls+HE)-1,Dc=Math.max(0,WE-Ic+1);if(Dc!==0){if(ht.isMesh)st.wireframe===!0?(q.setLineWidth(st.wireframeLinewidth*bt()),Ae.setMode(1)):Ae.setMode(4);else if(ht.isLine){let Le=st.linewidth;Le===void 0&&(Le=1),q.setLineWidth(Le*bt()),ht.isLineSegments?Ae.setMode(1):ht.isLineLoop?Ae.setMode(2):Ae.setMode(3)}else ht.isPoints?Ae.setMode(0):ht.isSprite&&Ae.setMode(4);if(ht.isInstancedMesh)Ae.renderInstances(Ic,Dc,ht.count);else if(tt.isInstancedBufferGeometry){const Le=Math.min(tt.instanceCount,tt._maxInstanceCount);Ae.renderInstances(Ic,Dc,Le)}else Ae.render(Ic,Dc)}},this.compile=function(O,Q){d=xt.get(O),d.init(),m.push(d),O.traverseVisible(function(tt){tt.isLight&&tt.layers.test(Q.layers)&&(d.pushLight(tt),tt.castShadow&&d.pushShadow(tt))}),d.setupLights(f.physicallyCorrectLights),O.traverse(function(tt){const st=tt.material;if(st)if(Array.isArray(st))for(let ht=0;ht<st.length;ht++)Jp(st[ht],O,tt);else Jp(st,O,tt)}),m.pop(),d=null};let Zp=null;function Xy(){$s.stop()}function Yy(){$s.start()}const $s=new _m;function Zy(O,Q,tt,st){if(O.visible===!1)return;if(O.layers.test(Q.layers)){if(O.isGroup)tt=O.renderOrder;else if(O.isLOD)O.autoUpdate===!0&&O.update(Q);else if(O.isLight)d.pushLight(O),O.castShadow&&d.pushShadow(O);else if(O.isSprite){if(!O.frustumCulled||W.intersectsSprite(O)){st&&yt.setFromMatrixPosition(O.matrixWorld).applyMatrix4($);const Tt=it.update(O),It=O.material;It.visible&&u.push(O,Tt,It,tt,yt.z,null)}}else if((O.isMesh||O.isLine||O.isPoints)&&(O.isSkinnedMesh&&O.skeleton.frame!==B.render.frame&&(O.skeleton.update(),O.skeleton.frame=B.render.frame),!O.frustumCulled||W.intersectsObject(O))){st&&yt.setFromMatrixPosition(O.matrixWorld).applyMatrix4($);const Tt=it.update(O),It=O.material;if(Array.isArray(It)){const Pt=Tt.groups;for(let Bt=0,ue=Pt.length;Bt<ue;Bt++){const Vt=Pt[Bt],Ut=It[Vt.materialIndex];Ut&&Ut.visible&&u.push(O,Tt,Ut,tt,yt.z,Vt)}}else It.visible&&u.push(O,Tt,It,tt,yt.z,null)}}const ht=O.children;for(let Tt=0,It=ht.length;Tt<It;Tt++)Zy(ht[Tt],Q,tt,st)}function Jy(O,Q,tt,st){const ht=O.opaque,Tt=O.transmissive,It=O.transparent;d.setupLightsView(tt),Tt.length>0&&function(Pt,Bt,ue){const Vt=P.isWebGL2;K===null&&(K=new Yt(1,1,{generateMipmaps:!0,type:I.has("EXT_color_buffer_half_float")?1016:1009,minFilter:1008,samples:Vt&&r===!0?4:0})),f.getDrawingBufferSize(lt),Vt?K.setSize(lt.x,lt.y):K.setSize($o(lt.x),$o(lt.y));const Ut=f.getRenderTarget();f.setRenderTarget(K),f.clear();const Ae=f.toneMapping;f.toneMapping=0,Lc(Pt,Bt,ue),f.toneMapping=Ae,C.updateMultisampleRenderTarget(K),C.updateRenderTargetMipmap(K),f.setRenderTarget(Ut)}(ht,Q,tt),st&&q.viewport(M.copy(st)),ht.length>0&&Lc(ht,Q,tt),Tt.length>0&&Lc(Tt,Q,tt),It.length>0&&Lc(It,Q,tt),q.buffers.depth.setTest(!0),q.buffers.depth.setMask(!0),q.buffers.color.setMask(!0),q.setPolygonOffset(!1)}function Lc(O,Q,tt){const st=Q.isScene===!0?Q.overrideMaterial:null;for(let ht=0,Tt=O.length;ht<Tt;ht++){const It=O[ht],Pt=It.object,Bt=It.geometry,ue=st===null?It.material:st,Vt=It.group;Pt.layers.test(tt.layers)&&jE(Pt,Q,tt,Bt,ue,Vt)}}function jE(O,Q,tt,st,ht,Tt){O.onBeforeRender(f,Q,tt,st,ht,Tt),O.modelViewMatrix.multiplyMatrices(tt.matrixWorldInverse,O.matrixWorld),O.normalMatrix.getNormalMatrix(O.modelViewMatrix),ht.onBeforeRender(f,Q,tt,st,O,Tt),ht.transparent===!0&&ht.side===2?(ht.side=1,ht.needsUpdate=!0,f.renderBufferDirect(tt,Q,st,ht,O,Tt),ht.side=0,ht.needsUpdate=!0,f.renderBufferDirect(tt,Q,st,ht,O,Tt),ht.side=2):f.renderBufferDirect(tt,Q,st,ht,O,Tt),O.onAfterRender(f,Q,tt,st,ht,Tt)}function Jp(O,Q,tt){Q.isScene!==!0&&(Q=mt);const st=D.get(O),ht=d.state.lights,Tt=d.state.shadowsArray,It=ht.state.version,Pt=ct.getParameters(O,ht.state,Tt,Q,tt),Bt=ct.getProgramCacheKey(Pt);let ue=st.programs;st.environment=O.isMeshStandardMaterial?Q.environment:null,st.fog=Q.fog,st.envMap=(O.isMeshStandardMaterial?L:j).get(O.envMap||st.environment),ue===void 0&&(O.addEventListener("dispose",qy),ue=new Map,st.programs=ue);let Vt=ue.get(Bt);if(Vt!==void 0){if(st.currentProgram===Vt&&st.lightsStateVersion===It)return Ky(O,Pt),Vt}else Pt.uniforms=ct.getUniforms(O),O.onBuild(tt,Pt,f),O.onBeforeCompile(Pt,f),Vt=ct.acquireProgram(Pt,Bt),ue.set(Bt,Vt),st.uniforms=Pt.uniforms;const Ut=st.uniforms;(O.isShaderMaterial||O.isRawShaderMaterial)&&O.clipping!==!0||(Ut.clippingPlanes=St.uniform),Ky(O,Pt),st.needsLights=function(Pi){return Pi.isMeshLambertMaterial||Pi.isMeshToonMaterial||Pi.isMeshPhongMaterial||Pi.isMeshStandardMaterial||Pi.isShadowMaterial||Pi.isShaderMaterial&&Pi.lights===!0}(O),st.lightsStateVersion=It,st.needsLights&&(Ut.ambientLightColor.value=ht.state.ambient,Ut.lightProbe.value=ht.state.probe,Ut.directionalLights.value=ht.state.directional,Ut.directionalLightShadows.value=ht.state.directionalShadow,Ut.spotLights.value=ht.state.spot,Ut.spotLightShadows.value=ht.state.spotShadow,Ut.rectAreaLights.value=ht.state.rectArea,Ut.ltc_1.value=ht.state.rectAreaLTC1,Ut.ltc_2.value=ht.state.rectAreaLTC2,Ut.pointLights.value=ht.state.point,Ut.pointLightShadows.value=ht.state.pointShadow,Ut.hemisphereLights.value=ht.state.hemi,Ut.directionalShadowMap.value=ht.state.directionalShadowMap,Ut.directionalShadowMatrix.value=ht.state.directionalShadowMatrix,Ut.spotShadowMap.value=ht.state.spotShadowMap,Ut.spotShadowMatrix.value=ht.state.spotShadowMatrix,Ut.pointShadowMap.value=ht.state.pointShadowMap,Ut.pointShadowMatrix.value=ht.state.pointShadowMatrix);const Ae=Vt.getUniforms(),Go=Cl.seqWithValue(Ae.seq,Ut);return st.currentProgram=Vt,st.uniformsList=Go,Vt}function Ky(O,Q){const tt=D.get(O);tt.outputEncoding=Q.outputEncoding,tt.instancing=Q.instancing,tt.skinning=Q.skinning,tt.morphTargets=Q.morphTargets,tt.morphNormals=Q.morphNormals,tt.morphColors=Q.morphColors,tt.morphTargetsCount=Q.morphTargetsCount,tt.numClippingPlanes=Q.numClippingPlanes,tt.numIntersection=Q.numClipIntersection,tt.vertexAlphas=Q.vertexAlphas,tt.vertexTangents=Q.vertexTangents,tt.toneMapping=Q.toneMapping,tt.extraProgramCacheKey=Q.extraProgramCacheKey}$s.setAnimationLoop(function(O){Zp&&Zp(O)}),typeof self<"u"&&$s.setContext(self),this.setAnimationLoop=function(O){Zp=O,di.setAnimationLoop(O),O===null?$s.stop():$s.start()},di.addEventListener("sessionstart",Xy),di.addEventListener("sessionend",Yy),this.render=function(O,Q){if(Q!==void 0&&Q.isCamera!==!0)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(v===!0)return;O.autoUpdate===!0&&O.updateMatrixWorld(),Q.parent===null&&Q.updateMatrixWorld(),di.enabled===!0&&di.isPresenting===!0&&(di.cameraAutoUpdate===!0&&di.updateCamera(Q),Q=di.getCamera()),O.isScene===!0&&O.onBeforeRender(f,O,Q,x),d=xt.get(O,m.length),d.init(),m.push(d),$.multiplyMatrices(Q.projectionMatrix,Q.matrixWorldInverse),W.setFromProjectionMatrix($),X=this.localClippingEnabled,N=St.init(this.clippingPlanes,X,Q),u=wt.get(O,p.length),u.init(),p.push(u),Zy(O,Q,0,f.sortObjects),u.finish(),f.sortObjects===!0&&u.sort(F,G),N===!0&&St.beginShadows();const tt=d.state.shadowsArray;if(Ct.render(tt,O,Q),N===!0&&St.endShadows(),this.info.autoReset===!0&&this.info.reset(),At.render(u,O),d.setupLights(f.physicallyCorrectLights),Q.isArrayCamera){const st=Q.cameras;for(let ht=0,Tt=st.length;ht<Tt;ht++){const It=st[ht];Jy(u,O,It,It.viewport)}}else Jy(u,O,Q);x!==null&&(C.updateMultisampleRenderTarget(x),C.updateRenderTargetMipmap(x)),O.isScene===!0&&O.onAfterRender(f,O,Q),Ht.resetDefaultState(),b=-1,w=null,m.pop(),d=m.length>0?m[m.length-1]:null,p.pop(),u=p.length>0?p[p.length-1]:null},this.getActiveCubeFace=function(){return _},this.getActiveMipmapLevel=function(){return y},this.getRenderTarget=function(){return x},this.setRenderTargetTextures=function(O,Q,tt){D.get(O.texture).__webglTexture=Q,D.get(O.depthTexture).__webglTexture=tt;const st=D.get(O);st.__hasExternalTextures=!0,st.__hasExternalTextures&&(st.__autoAllocateDepthBuffer=tt===void 0,st.__autoAllocateDepthBuffer||I.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),st.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(O,Q){const tt=D.get(O);tt.__webglFramebuffer=Q,tt.__useDefaultFramebuffer=Q===void 0},this.setRenderTarget=function(O,Q=0,tt=0){x=O,_=Q,y=tt;let st=!0;if(O){const Pt=D.get(O);Pt.__useDefaultFramebuffer!==void 0?(q.bindFramebuffer(36160,null),st=!1):Pt.__webglFramebuffer===void 0?C.setupRenderTarget(O):Pt.__hasExternalTextures&&C.rebindTextures(O,D.get(O.texture).__webglTexture,D.get(O.depthTexture).__webglTexture)}let ht=null,Tt=!1,It=!1;if(O){const Pt=O.texture;(Pt.isData3DTexture||Pt.isDataArrayTexture)&&(It=!0);const Bt=D.get(O).__webglFramebuffer;O.isWebGLCubeRenderTarget?(ht=Bt[Q],Tt=!0):ht=P.isWebGL2&&O.samples>0&&C.useMultisampledRTT(O)===!1?D.get(O).__webglMultisampledFramebuffer:Bt,M.copy(O.viewport),T.copy(O.scissor),R=O.scissorTest}else M.copy(U).multiplyScalar(z).floor(),T.copy(k).multiplyScalar(z).floor(),R=H;if(q.bindFramebuffer(36160,ht)&&P.drawBuffers&&st&&q.drawBuffers(O,ht),q.viewport(M),q.scissor(T),q.setScissorTest(R),Tt){const Pt=D.get(O.texture);dt.framebufferTexture2D(36160,36064,34069+Q,Pt.__webglTexture,tt)}else if(It){const Pt=D.get(O.texture),Bt=Q||0;dt.framebufferTextureLayer(36160,36064,Pt.__webglTexture,tt||0,Bt)}b=-1},this.readRenderTargetPixels=function(O,Q,tt,st,ht,Tt,It){if(!O||!O.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let Pt=D.get(O).__webglFramebuffer;if(O.isWebGLCubeRenderTarget&&It!==void 0&&(Pt=Pt[It]),Pt){q.bindFramebuffer(36160,Pt);try{const Bt=O.texture,ue=Bt.format,Vt=Bt.type;if(ue!==1023&&jt.convert(ue)!==dt.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const Ut=Vt===1016&&(I.has("EXT_color_buffer_half_float")||P.isWebGL2&&I.has("EXT_color_buffer_float"));if(!(Vt===1009||jt.convert(Vt)===dt.getParameter(35738)||Vt===1015&&(P.isWebGL2||I.has("OES_texture_float")||I.has("WEBGL_color_buffer_float"))||Ut))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");Q>=0&&Q<=O.width-st&&tt>=0&&tt<=O.height-ht&&dt.readPixels(Q,tt,st,ht,jt.convert(ue),jt.convert(Vt),Tt)}finally{const Bt=x!==null?D.get(x).__webglFramebuffer:null;q.bindFramebuffer(36160,Bt)}}},this.copyFramebufferToTexture=function(O,Q,tt=0){const st=Math.pow(2,-tt),ht=Math.floor(Q.image.width*st),Tt=Math.floor(Q.image.height*st);C.setTexture2D(Q,0),dt.copyTexSubImage2D(3553,tt,0,0,O.x,O.y,ht,Tt),q.unbindTexture()},this.copyTextureToTexture=function(O,Q,tt,st=0){const ht=Q.image.width,Tt=Q.image.height,It=jt.convert(tt.format),Pt=jt.convert(tt.type);C.setTexture2D(tt,0),dt.pixelStorei(37440,tt.flipY),dt.pixelStorei(37441,tt.premultiplyAlpha),dt.pixelStorei(3317,tt.unpackAlignment),Q.isDataTexture?dt.texSubImage2D(3553,st,O.x,O.y,ht,Tt,It,Pt,Q.image.data):Q.isCompressedTexture?dt.compressedTexSubImage2D(3553,st,O.x,O.y,Q.mipmaps[0].width,Q.mipmaps[0].height,It,Q.mipmaps[0].data):dt.texSubImage2D(3553,st,O.x,O.y,It,Pt,Q.image),st===0&&tt.generateMipmaps&&dt.generateMipmap(3553),q.unbindTexture()},this.copyTextureToTexture3D=function(O,Q,tt,st,ht=0){if(f.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const Tt=O.max.x-O.min.x+1,It=O.max.y-O.min.y+1,Pt=O.max.z-O.min.z+1,Bt=jt.convert(st.format),ue=jt.convert(st.type);let Vt;if(st.isData3DTexture)C.setTexture3D(st,0),Vt=32879;else{if(!st.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");C.setTexture2DArray(st,0),Vt=35866}dt.pixelStorei(37440,st.flipY),dt.pixelStorei(37441,st.premultiplyAlpha),dt.pixelStorei(3317,st.unpackAlignment);const Ut=dt.getParameter(3314),Ae=dt.getParameter(32878),Go=dt.getParameter(3316),Pi=dt.getParameter(3315),Kp=dt.getParameter(32877),ls=tt.isCompressedTexture?tt.mipmaps[0]:tt.image;dt.pixelStorei(3314,ls.width),dt.pixelStorei(32878,ls.height),dt.pixelStorei(3316,O.min.x),dt.pixelStorei(3315,O.min.y),dt.pixelStorei(32877,O.min.z),tt.isDataTexture||tt.isData3DTexture?dt.texSubImage3D(Vt,ht,Q.x,Q.y,Q.z,Tt,It,Pt,Bt,ue,ls.data):tt.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),dt.compressedTexSubImage3D(Vt,ht,Q.x,Q.y,Q.z,Tt,It,Pt,Bt,ls.data)):dt.texSubImage3D(Vt,ht,Q.x,Q.y,Q.z,Tt,It,Pt,Bt,ue,ls),dt.pixelStorei(3314,Ut),dt.pixelStorei(32878,Ae),dt.pixelStorei(3316,Go),dt.pixelStorei(3315,Pi),dt.pixelStorei(32877,Kp),ht===0&&st.generateMipmaps&&dt.generateMipmap(Vt),q.unbindTexture()},this.initTexture=function(O){C.setTexture2D(O,0),q.unbindTexture()},this.resetState=function(){_=0,y=0,x=null,q.reset(),Ht.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class Zm extends mu{}Zm.prototype.isWebGL1Renderer=!0;class Al{constructor(t,e=25e-5){this.isFogExp2=!0,this.name="",this.color=new nt(t),this.density=e}clone(){return new Al(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class Ia{constructor(t,e=1,i=1e3){this.isFog=!0,this.name="",this.color=new nt(t),this.near=e,this.far=i}clone(){return new Ia(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class Pl extends Mt{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}class xr{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=ei()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let s=0,r=this.stride;s<r;s++)this.array[t+s]=e.array[i+s];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=ei()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=ei()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Ve=new S;class Ki{constructor(t,e,i,s=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=s===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)Ve.fromBufferAttribute(this,e),Ve.applyMatrix4(t),this.setXYZ(e,Ve.x,Ve.y,Ve.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)Ve.fromBufferAttribute(this,e),Ve.applyNormalMatrix(t),this.setXYZ(e,Ve.x,Ve.y,Ve.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)Ve.fromBufferAttribute(this,e),Ve.transformDirection(t),this.setXYZ(e,Ve.x,Ve.y,Ve.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,s){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this}setXYZW(t,e,i,s,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this.data.array[t+3]=r,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[s+r])}return new Lt(new this.array.constructor(e),this.itemSize,this.normalized)}return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Ki(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[s+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class Da extends ae{constructor(t){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new nt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}let br;const Oa=new S,Mr=new S,wr=new S,Sr=new V,za=new V,Jm=new at,Rl=new S,Ua=new S,Ll=new S,Km=new V,fu=new V,Qm=new V;class Il extends Mt{constructor(t){if(super(),this.isSprite=!0,this.type="Sprite",br===void 0){br=new gt;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),i=new xr(e,5);br.setIndex([0,1,2,0,2,3]),br.setAttribute("position",new Ki(i,3,0,!1)),br.setAttribute("uv",new Ki(i,2,3,!1))}this.geometry=br,this.material=t!==void 0?t:new Da,this.center=new V(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Mr.setFromMatrixScale(this.matrixWorld),Jm.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),wr.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Mr.multiplyScalar(-wr.z);const i=this.material.rotation;let s,r;i!==0&&(r=Math.cos(i),s=Math.sin(i));const a=this.center;Dl(Rl.set(-.5,-.5,0),wr,a,Mr,s,r),Dl(Ua.set(.5,-.5,0),wr,a,Mr,s,r),Dl(Ll.set(.5,.5,0),wr,a,Mr,s,r),Km.set(0,0),fu.set(1,0),Qm.set(1,1);let o=t.ray.intersectTriangle(Rl,Ua,Ll,!1,Oa);if(o===null&&(Dl(Ua.set(-.5,.5,0),wr,a,Mr,s,r),fu.set(0,1),o=t.ray.intersectTriangle(Rl,Ll,Ua,!1,Oa),o===null))return;const l=t.ray.origin.distanceTo(Oa);l<t.near||l>t.far||e.push({distance:l,point:Oa.clone(),uv:mi.getUV(Oa,Rl,Ua,Ll,Km,fu,Qm,new V),face:null,object:this})}copy(t,e){return super.copy(t,e),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}function Dl(n,t,e,i,s,r){Sr.subVectors(n,e).addScalar(.5).multiply(i),s!==void 0?(za.x=r*Sr.x-s*Sr.y,za.y=s*Sr.x+r*Sr.y):za.copy(Sr),n.copy(t),n.x+=za.x,n.y+=za.y,n.applyMatrix4(Jm)}const Ol=new S,$m=new S;class tf extends Mt{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let i=0,s=e.length;i<s;i++){const r=e[i];this.addLevel(r.object.clone(),r.distance)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0){e=Math.abs(e);const i=this.levels;let s;for(s=0;s<i.length&&!(e<i[s].distance);s++);return i.splice(s,0,{distance:e,object:t}),this.add(t),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let i,s;for(i=1,s=e.length;i<s&&!(t<e[i].distance);i++);return e[i-1].object}return null}raycast(t,e){if(this.levels.length>0){Ol.setFromMatrixPosition(this.matrixWorld);const i=t.ray.origin.distanceTo(Ol);this.getObjectForDistance(i).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){Ol.setFromMatrixPosition(t.matrixWorld),$m.setFromMatrixPosition(this.matrixWorld);const i=Ol.distanceTo($m)/t.zoom;let s,r;for(e[0].object.visible=!0,s=1,r=e.length;s<r&&i>=e[s].distance;s++)e[s-1].object.visible=!1,e[s].object.visible=!0;for(this._currentLevel=s-1;s<r;s++)e[s].object.visible=!1}}toJSON(t){const e=super.toJSON(t);this.autoUpdate===!1&&(e.object.autoUpdate=!1),e.object.levels=[];const i=this.levels;for(let s=0,r=i.length;s<r;s++){const a=i[s];e.object.levels.push({object:a.object.uuid,distance:a.distance})}return e}}const ef=new S,nf=new Ot,sf=new Ot,Wx=new S,rf=new at;class gu extends ot{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new at,this.bindMatrixInverse=new at}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new Ot,e=this.geometry.attributes.skinWeight;for(let i=0,s=e.count;i<s;i++){t.fromBufferAttribute(e,i);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(i,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const i=this.skeleton,s=this.geometry;nf.fromBufferAttribute(s.attributes.skinIndex,t),sf.fromBufferAttribute(s.attributes.skinWeight,t),ef.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let r=0;r<4;r++){const a=sf.getComponent(r);if(a!==0){const o=nf.getComponent(r);rf.multiplyMatrices(i.bones[o].matrixWorld,i.boneInverses[o]),e.addScaledVector(Wx.copy(ef).applyMatrix4(rf),a)}}return e.applyMatrix4(this.bindMatrixInverse)}}class zl extends Mt{constructor(){super(),this.isBone=!0,this.type="Bone"}}class _s extends Gt{constructor(t=null,e=1,i=1,s,r,a,o,l,h=1003,c=1003,u,d){super(null,a,o,l,h,c,s,r,u,d),this.isDataTexture=!0,this.image={data:t,width:e,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const af=new at,qx=new at;class Fa{constructor(t=[],e=[]){this.uuid=ei(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),e.length===0)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i=0,s=this.bones.length;i<s;i++)this.boneInverses.push(new at)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const i=new at;this.bones[t]&&i.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(i)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const i=this.bones[t];i&&i.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const i=this.bones[t];i&&(i.parent&&i.parent.isBone?(i.matrix.copy(i.parent.matrixWorld).invert(),i.matrix.multiply(i.matrixWorld)):i.matrix.copy(i.matrixWorld),i.matrix.decompose(i.position,i.quaternion,i.scale))}}update(){const t=this.bones,e=this.boneInverses,i=this.boneMatrices,s=this.boneTexture;for(let r=0,a=t.length;r<a;r++){const o=t[r]?t[r].matrixWorld:qx;af.multiplyMatrices(o,e[r]),af.toArray(i,16*r)}s!==null&&(s.needsUpdate=!0)}clone(){return new Fa(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=nm(t),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const i=new _s(e,t,t,1023,1015);return i.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=i,this.boneTextureSize=t,this}getBoneByName(t){for(let e=0,i=this.bones.length;e<i;e++){const s=this.bones[e];if(s.name===t)return s}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let i=0,s=t.bones.length;i<s;i++){const r=t.bones[i];let a=e[r];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),a=new zl),this.bones.push(a),this.boneInverses.push(new at().fromArray(t.boneInverses[i]))}return this.init(),this}toJSON(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,i=this.boneInverses;for(let s=0,r=e.length;s<r;s++){const a=e[s];t.bones.push(a.uuid);const o=i[s];t.boneInverses.push(o.toArray())}return t}}class Di extends Lt{constructor(t,e,i,s=1){typeof i=="number"&&(s=i,i=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=s}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const of=new at,lf=new at,Ul=[],Na=new ot;class Fl extends ot{constructor(t,e,i){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new Di(new Float32Array(16*i),16),this.instanceColor=null,this.count=i,this.frustumCulled=!1}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){const i=this.matrixWorld,s=this.count;if(Na.geometry=this.geometry,Na.material=this.material,Na.material!==void 0)for(let r=0;r<s;r++){this.getMatrixAt(r,of),lf.multiplyMatrices(i,of),Na.matrixWorld=lf,Na.raycast(t,Ul);for(let a=0,o=Ul.length;a<o;a++){const l=Ul[a];l.instanceId=r,l.object=this,e.push(l)}Ul.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new Di(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class _e extends ae{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new nt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const hf=new S,cf=new S,uf=new at,vu=new kn,Nl=new ii;class we extends Mt{constructor(t=new gt,e=new _e){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,i=[0];for(let s=1,r=e.count;s<r;s++)hf.fromBufferAttribute(e,s-1),cf.fromBufferAttribute(e,s),i[s]=i[s-1],i[s]+=hf.distanceTo(cf);t.setAttribute("lineDistance",new Z(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const i=this.geometry,s=this.matrixWorld,r=t.params.Line.threshold,a=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),Nl.copy(i.boundingSphere),Nl.applyMatrix4(s),Nl.radius+=r,t.ray.intersectsSphere(Nl)===!1)return;uf.copy(s).invert(),vu.copy(t.ray).applyMatrix4(uf);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,h=new S,c=new S,u=new S,d=new S,p=this.isLineSegments?2:1,m=i.index,f=i.attributes.position;if(m!==null)for(let v=Math.max(0,a.start),_=Math.min(m.count,a.start+a.count)-1;v<_;v+=p){const y=m.getX(v),x=m.getX(v+1);if(h.fromBufferAttribute(f,y),c.fromBufferAttribute(f,x),vu.distanceSqToSegment(h,c,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const b=t.ray.origin.distanceTo(d);b<t.near||b>t.far||e.push({distance:b,point:u.clone().applyMatrix4(this.matrixWorld),index:v,face:null,faceIndex:null,object:this})}else for(let v=Math.max(0,a.start),_=Math.min(f.count,a.start+a.count)-1;v<_;v+=p){if(h.fromBufferAttribute(f,v),c.fromBufferAttribute(f,v+1),vu.distanceSqToSegment(h,c,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const y=t.ray.origin.distanceTo(d);y<t.near||y>t.far||e.push({distance:y,point:u.clone().applyMatrix4(this.matrixWorld),index:v,face:null,faceIndex:null,object:this})}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,r=i.length;s<r;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}const df=new S,pf=new S;class vi extends we{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,i=[];for(let s=0,r=e.count;s<r;s+=2)df.fromBufferAttribute(e,s),pf.fromBufferAttribute(e,s+1),i[s]=s===0?0:i[s-1],i[s+1]=i[s]+df.distanceTo(pf);t.setAttribute("lineDistance",new Z(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class _u extends we{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class Tr extends ae{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new nt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const mf=new at,yu=new kn,kl=new ii,Bl=new S;class ka extends Mt{constructor(t=new gt,e=new Tr){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const i=this.geometry,s=this.matrixWorld,r=t.params.Points.threshold,a=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),kl.copy(i.boundingSphere),kl.applyMatrix4(s),kl.radius+=r,t.ray.intersectsSphere(kl)===!1)return;mf.copy(s).invert(),yu.copy(t.ray).applyMatrix4(mf);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,h=i.index,c=i.attributes.position;if(h!==null)for(let u=Math.max(0,a.start),d=Math.min(h.count,a.start+a.count);u<d;u++){const p=h.getX(u);Bl.fromBufferAttribute(c,p),ff(Bl,p,l,s,t,e,this)}else for(let u=Math.max(0,a.start),d=Math.min(c.count,a.start+a.count);u<d;u++)Bl.fromBufferAttribute(c,u),ff(Bl,u,l,s,t,e,this)}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,r=i.length;s<r;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}function ff(n,t,e,i,s,r,a){const o=yu.distanceSqToPoint(n);if(o<e){const l=new S;yu.closestPointToPoint(n,l),l.applyMatrix4(i);const h=s.ray.origin.distanceTo(l);if(h<s.near||h>s.far)return;r.push({distance:h,distanceToRay:Math.sqrt(o),point:l,index:t,face:null,object:a})}}class xu extends Gt{constructor(t,e,i){super({width:t,height:e}),this.isFramebufferTexture=!0,this.format=i,this.magFilter=1003,this.minFilter=1003,this.generateMipmaps=!1,this.needsUpdate=!0}}class gf extends Gt{constructor(t,e,i,s,r,a,o,l,h,c,u,d){super(null,a,o,l,h,c,s,r,u,d),this.isCompressedTexture=!0,this.image={width:e,height:i},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}class Se extends Gt{constructor(t,e,i,s,r,a,o,l,h){super(t,e,i,s,r,a,o,l,h),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Oi{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const i=this.getUtoTmapping(t);return this.getPoint(i,e)}getPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return e}getSpacedPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPointAt(i/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let i,s=this.getPoint(0),r=0;e.push(0);for(let a=1;a<=t;a++)i=this.getPoint(a/t),r+=i.distanceTo(s),e.push(r),s=i;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const i=this.getLengths();let s=0;const r=i.length;let a;a=e||t*i[r-1];let o,l=0,h=r-1;for(;l<=h;)if(s=Math.floor(l+(h-l)/2),o=i[s]-a,o<0)l=s+1;else{if(!(o>0)){h=s;break}h=s-1}if(s=h,i[s]===a)return s/(r-1);const c=i[s];return(s+(a-c)/(i[s+1]-c))/(r-1)}getTangent(t,e){let s=t-1e-4,r=t+1e-4;s<0&&(s=0),r>1&&(r=1);const a=this.getPoint(s),o=this.getPoint(r),l=e||(a.isVector2?new V:new S);return l.copy(o).sub(a).normalize(),l}getTangentAt(t,e){const i=this.getUtoTmapping(t);return this.getTangent(i,e)}computeFrenetFrames(t,e){const i=new S,s=[],r=[],a=[],o=new S,l=new at;for(let p=0;p<=t;p++){const m=p/t;s[p]=this.getTangentAt(m,new S)}r[0]=new S,a[0]=new S;let h=Number.MAX_VALUE;const c=Math.abs(s[0].x),u=Math.abs(s[0].y),d=Math.abs(s[0].z);c<=h&&(h=c,i.set(1,0,0)),u<=h&&(h=u,i.set(0,1,0)),d<=h&&i.set(0,0,1),o.crossVectors(s[0],i).normalize(),r[0].crossVectors(s[0],o),a[0].crossVectors(s[0],r[0]);for(let p=1;p<=t;p++){if(r[p]=r[p-1].clone(),a[p]=a[p-1].clone(),o.crossVectors(s[p-1],s[p]),o.length()>Number.EPSILON){o.normalize();const m=Math.acos(de(s[p-1].dot(s[p]),-1,1));r[p].applyMatrix4(l.makeRotationAxis(o,m))}a[p].crossVectors(s[p],r[p])}if(e===!0){let p=Math.acos(de(r[0].dot(r[t]),-1,1));p/=t,s[0].dot(o.crossVectors(r[0],r[t]))>0&&(p=-p);for(let m=1;m<=t;m++)r[m].applyMatrix4(l.makeRotationAxis(s[m],p*m)),a[m].crossVectors(s[m],r[m])}return{tangents:s,normals:r,binormals:a}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class Vl extends Oi{constructor(t=0,e=0,i=1,s=1,r=0,a=2*Math.PI,o=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=i,this.yRadius=s,this.aStartAngle=r,this.aEndAngle=a,this.aClockwise=o,this.aRotation=l}getPoint(t,e){const i=e||new V,s=2*Math.PI;let r=this.aEndAngle-this.aStartAngle;const a=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=s;for(;r>s;)r-=s;r<Number.EPSILON&&(r=a?0:s),this.aClockwise!==!0||a||(r===s?r=-s:r-=s);const o=this.aStartAngle+t*r;let l=this.aX+this.xRadius*Math.cos(o),h=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const c=Math.cos(this.aRotation),u=Math.sin(this.aRotation),d=l-this.aX,p=h-this.aY;l=d*c-p*u+this.aX,h=d*u+p*c+this.aY}return i.set(l,h)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}class vf extends Vl{constructor(t,e,i,s,r,a){super(t,e,i,i,s,r,a),this.isArcCurve=!0,this.type="ArcCurve"}}function bu(){let n=0,t=0,e=0,i=0;function s(r,a,o,l){n=r,t=o,e=-3*r+3*a-2*o-l,i=2*r-2*a+o+l}return{initCatmullRom:function(r,a,o,l,h){s(a,o,h*(o-r),h*(l-a))},initNonuniformCatmullRom:function(r,a,o,l,h,c,u){let d=(a-r)/h-(o-r)/(h+c)+(o-a)/c,p=(o-a)/c-(l-a)/(c+u)+(l-o)/u;d*=c,p*=c,s(a,o,d,p)},calc:function(r){const a=r*r;return n+t*r+e*a+i*(a*r)}}}const Gl=new S,Mu=new bu,wu=new bu,Su=new bu;class _f extends Oi{constructor(t=[],e=!1,i="centripetal",s=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=i,this.tension=s}getPoint(t,e=new S){const i=e,s=this.points,r=s.length,a=(r-(this.closed?0:1))*t;let o,l,h=Math.floor(a),c=a-h;this.closed?h+=h>0?0:(Math.floor(Math.abs(h)/r)+1)*r:c===0&&h===r-1&&(h=r-2,c=1),this.closed||h>0?o=s[(h-1)%r]:(Gl.subVectors(s[0],s[1]).add(s[0]),o=Gl);const u=s[h%r],d=s[(h+1)%r];if(this.closed||h+2<r?l=s[(h+2)%r]:(Gl.subVectors(s[r-1],s[r-2]).add(s[r-1]),l=Gl),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let m=Math.pow(o.distanceToSquared(u),p),f=Math.pow(u.distanceToSquared(d),p),v=Math.pow(d.distanceToSquared(l),p);f<1e-4&&(f=1),m<1e-4&&(m=f),v<1e-4&&(v=f),Mu.initNonuniformCatmullRom(o.x,u.x,d.x,l.x,m,f,v),wu.initNonuniformCatmullRom(o.y,u.y,d.y,l.y,m,f,v),Su.initNonuniformCatmullRom(o.z,u.z,d.z,l.z,m,f,v)}else this.curveType==="catmullrom"&&(Mu.initCatmullRom(o.x,u.x,d.x,l.x,this.tension),wu.initCatmullRom(o.y,u.y,d.y,l.y,this.tension),Su.initCatmullRom(o.z,u.z,d.z,l.z,this.tension));return i.set(Mu.calc(c),wu.calc(c),Su.calc(c)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const s=t.points[e];this.points.push(s.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const s=this.points[e];t.points.push(s.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const s=t.points[e];this.points.push(new S().fromArray(s))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function yf(n,t,e,i,s){const r=.5*(i-t),a=.5*(s-e),o=n*n;return(2*e-2*i+r+a)*(n*o)+(-3*e+3*i-2*r-a)*o+r*n+e}function Ba(n,t,e,i){return function(s,r){const a=1-s;return a*a*r}(n,t)+function(s,r){return 2*(1-s)*s*r}(n,e)+function(s,r){return s*s*r}(n,i)}function Va(n,t,e,i,s){return function(r,a){const o=1-r;return o*o*o*a}(n,t)+function(r,a){const o=1-r;return 3*o*o*r*a}(n,e)+function(r,a){return 3*(1-r)*r*r*a}(n,i)+function(r,a){return r*r*r*a}(n,s)}class Tu extends Oi{constructor(t=new V,e=new V,i=new V,s=new V){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=i,this.v3=s}getPoint(t,e=new V){const i=e,s=this.v0,r=this.v1,a=this.v2,o=this.v3;return i.set(Va(t,s.x,r.x,a.x,o.x),Va(t,s.y,r.y,a.y,o.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class xf extends Oi{constructor(t=new S,e=new S,i=new S,s=new S){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=i,this.v3=s}getPoint(t,e=new S){const i=e,s=this.v0,r=this.v1,a=this.v2,o=this.v3;return i.set(Va(t,s.x,r.x,a.x,o.x),Va(t,s.y,r.y,a.y,o.y),Va(t,s.z,r.z,a.z,o.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class jl extends Oi{constructor(t=new V,e=new V){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new V){const i=e;return t===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const i=e||new V;return i.copy(this.v2).sub(this.v1).normalize(),i}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class bf extends Oi{constructor(t=new S,e=new S){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new S){const i=e;return t===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Eu extends Oi{constructor(t=new V,e=new V,i=new V){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new V){const i=e,s=this.v0,r=this.v1,a=this.v2;return i.set(Ba(t,s.x,r.x,a.x),Ba(t,s.y,r.y,a.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Cu extends Oi{constructor(t=new S,e=new S,i=new S){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new S){const i=e,s=this.v0,r=this.v1,a=this.v2;return i.set(Ba(t,s.x,r.x,a.x),Ba(t,s.y,r.y,a.y),Ba(t,s.z,r.z,a.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Au extends Oi{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new V){const i=e,s=this.points,r=(s.length-1)*t,a=Math.floor(r),o=r-a,l=s[a===0?a:a-1],h=s[a],c=s[a>s.length-2?s.length-1:a+1],u=s[a>s.length-3?s.length-1:a+2];return i.set(yf(o,l.x,h.x,c.x,u.x),yf(o,l.y,h.y,c.y,u.y)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const s=t.points[e];this.points.push(s.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const s=this.points[e];t.points.push(s.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const s=t.points[e];this.points.push(new V().fromArray(s))}return this}}var Pu=Object.freeze({__proto__:null,ArcCurve:vf,CatmullRomCurve3:_f,CubicBezierCurve:Tu,CubicBezierCurve3:xf,EllipseCurve:Vl,LineCurve:jl,LineCurve3:bf,QuadraticBezierCurve:Eu,QuadraticBezierCurve3:Cu,SplineCurve:Au});class Mf extends Oi{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new jl(e,t))}getPoint(t,e){const i=t*this.getLength(),s=this.getCurveLengths();let r=0;for(;r<s.length;){if(s[r]>=i){const a=s[r]-i,o=this.curves[r],l=o.getLength(),h=l===0?0:1-a/l;return o.getPointAt(h,e)}r++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let i=0,s=this.curves.length;i<s;i++)e+=this.curves[i].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let i;for(let s=0,r=this.curves;s<r.length;s++){const a=r[s],o=a.isEllipseCurve?2*t:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?t*a.points.length:t,l=a.getPoints(o);for(let h=0;h<l.length;h++){const c=l[h];i&&i.equals(c)||(e.push(c),i=c)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const s=t.curves[e];this.curves.push(s.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,i=this.curves.length;e<i;e++){const s=this.curves[e];t.curves.push(s.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const s=t.curves[e];this.curves.push(new Pu[s.type]().fromJSON(s))}return this}}class Ga extends Mf{constructor(t){super(),this.type="Path",this.currentPoint=new V,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,i=t.length;e<i;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const i=new jl(this.currentPoint.clone(),new V(t,e));return this.curves.push(i),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,i,s){const r=new Eu(this.currentPoint.clone(),new V(t,e),new V(i,s));return this.curves.push(r),this.currentPoint.set(i,s),this}bezierCurveTo(t,e,i,s,r,a){const o=new Tu(this.currentPoint.clone(),new V(t,e),new V(i,s),new V(r,a));return this.curves.push(o),this.currentPoint.set(r,a),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),i=new Au(e);return this.curves.push(i),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,i,s,r,a){const o=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(t+o,e+l,i,s,r,a),this}absarc(t,e,i,s,r,a){return this.absellipse(t,e,i,i,s,r,a),this}ellipse(t,e,i,s,r,a,o,l){const h=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(t+h,e+c,i,s,r,a,o,l),this}absellipse(t,e,i,s,r,a,o,l){const h=new Vl(t,e,i,s,r,a,o,l);if(this.curves.length>0){const u=h.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(h);const c=h.getPoint(1);return this.currentPoint.copy(c),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class ys extends gt{constructor(t=[new V(0,.5),new V(.5,0),new V(0,-.5)],e=12,i=0,s=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:i,phiLength:s},e=Math.floor(e),s=de(s,0,2*Math.PI);const r=[],a=[],o=[],l=[],h=[],c=1/e,u=new S,d=new V,p=new S,m=new S,f=new S;let v=0,_=0;for(let y=0;y<=t.length-1;y++)switch(y){case 0:v=t[y+1].x-t[y].x,_=t[y+1].y-t[y].y,p.x=1*_,p.y=-v,p.z=0*_,f.copy(p),p.normalize(),l.push(p.x,p.y,p.z);break;case t.length-1:l.push(f.x,f.y,f.z);break;default:v=t[y+1].x-t[y].x,_=t[y+1].y-t[y].y,p.x=1*_,p.y=-v,p.z=0*_,m.copy(p),p.x+=f.x,p.y+=f.y,p.z+=f.z,p.normalize(),l.push(p.x,p.y,p.z),f.copy(m)}for(let y=0;y<=e;y++){const x=i+y*c*s,b=Math.sin(x),w=Math.cos(x);for(let M=0;M<=t.length-1;M++){u.x=t[M].x*b,u.y=t[M].y,u.z=t[M].x*w,a.push(u.x,u.y,u.z),d.x=y/e,d.y=M/(t.length-1),o.push(d.x,d.y);const T=l[3*M+0]*b,R=l[3*M+1],E=l[3*M+0]*w;h.push(T,R,E)}}for(let y=0;y<e;y++)for(let x=0;x<t.length-1;x++){const b=x+y*t.length,w=b,M=b+t.length,T=b+t.length+1,R=b+1;r.push(w,M,R),r.push(T,R,M)}this.setIndex(r),this.setAttribute("position",new Z(a,3)),this.setAttribute("uv",new Z(o,2)),this.setAttribute("normal",new Z(h,3))}static fromJSON(t){return new ys(t.points,t.segments,t.phiStart,t.phiLength)}}class Er extends ys{constructor(t=1,e=1,i=4,s=8){const r=new Ga;r.absarc(0,-e/2,t,1.5*Math.PI,0),r.absarc(0,e/2,t,0,.5*Math.PI),super(r.getPoints(i),s),this.type="CapsuleGeometry",this.parameters={radius:t,height:e,capSegments:i,radialSegments:s}}static fromJSON(t){return new Er(t.radius,t.length,t.capSegments,t.radialSegments)}}class Cr extends gt{constructor(t=1,e=8,i=0,s=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:i,thetaLength:s},e=Math.max(3,e);const r=[],a=[],o=[],l=[],h=new S,c=new V;a.push(0,0,0),o.push(0,0,1),l.push(.5,.5);for(let u=0,d=3;u<=e;u++,d+=3){const p=i+u/e*s;h.x=t*Math.cos(p),h.y=t*Math.sin(p),a.push(h.x,h.y,h.z),o.push(0,0,1),c.x=(a[d]/t+1)/2,c.y=(a[d+1]/t+1)/2,l.push(c.x,c.y)}for(let u=1;u<=e;u++)r.push(u,u+1,0);this.setIndex(r),this.setAttribute("position",new Z(a,3)),this.setAttribute("normal",new Z(o,3)),this.setAttribute("uv",new Z(l,2))}static fromJSON(t){return new Cr(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class oe extends gt{constructor(t=1,e=1,i=1,s=8,r=1,a=!1,o=0,l=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:i,radialSegments:s,heightSegments:r,openEnded:a,thetaStart:o,thetaLength:l};const h=this;s=Math.floor(s),r=Math.floor(r);const c=[],u=[],d=[],p=[];let m=0;const f=[],v=i/2;let _=0;function y(x){const b=m,w=new V,M=new S;let T=0;const R=x===!0?t:e,E=x===!0?1:-1;for(let z=1;z<=s;z++)u.push(0,v*E,0),d.push(0,E,0),p.push(.5,.5),m++;const A=m;for(let z=0;z<=s;z++){const F=z/s*l+o,G=Math.cos(F),U=Math.sin(F);M.x=R*U,M.y=v*E,M.z=R*G,u.push(M.x,M.y,M.z),d.push(0,E,0),w.x=.5*G+.5,w.y=.5*U*E+.5,p.push(w.x,w.y),m++}for(let z=0;z<s;z++){const F=b+z,G=A+z;x===!0?c.push(G,G+1,F):c.push(G+1,G,F),T+=3}h.addGroup(_,T,x===!0?1:2),_+=T}(function(){const x=new S,b=new S;let w=0;const M=(e-t)/i;for(let T=0;T<=r;T++){const R=[],E=T/r,A=E*(e-t)+t;for(let z=0;z<=s;z++){const F=z/s,G=F*l+o,U=Math.sin(G),k=Math.cos(G);b.x=A*U,b.y=-E*i+v,b.z=A*k,u.push(b.x,b.y,b.z),x.set(U,M,k).normalize(),d.push(x.x,x.y,x.z),p.push(F,1-E),R.push(m++)}f.push(R)}for(let T=0;T<s;T++)for(let R=0;R<r;R++){const E=f[R][T],A=f[R+1][T],z=f[R+1][T+1],F=f[R][T+1];c.push(E,A,F),c.push(A,z,F),w+=6}h.addGroup(_,w,0),_+=w})(),a===!1&&(t>0&&y(!0),e>0&&y(!1)),this.setIndex(c),this.setAttribute("position",new Z(u,3)),this.setAttribute("normal",new Z(d,3)),this.setAttribute("uv",new Z(p,2))}static fromJSON(t){return new oe(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Ar extends oe{constructor(t=1,e=1,i=8,s=1,r=!1,a=0,o=2*Math.PI){super(0,t,e,i,s,r,a,o),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:i,heightSegments:s,openEnded:r,thetaStart:a,thetaLength:o}}static fromJSON(t){return new Ar(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Qi extends gt{constructor(t=[],e=[],i=1,s=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:i,detail:s};const r=[],a=[];function o(d,p,m,f){const v=f+1,_=[];for(let y=0;y<=v;y++){_[y]=[];const x=d.clone().lerp(m,y/v),b=p.clone().lerp(m,y/v),w=v-y;for(let M=0;M<=w;M++)_[y][M]=M===0&&y===v?x:x.clone().lerp(b,M/w)}for(let y=0;y<v;y++)for(let x=0;x<2*(v-y)-1;x++){const b=Math.floor(x/2);x%2==0?(l(_[y][b+1]),l(_[y+1][b]),l(_[y][b])):(l(_[y][b+1]),l(_[y+1][b+1]),l(_[y+1][b]))}}function l(d){r.push(d.x,d.y,d.z)}function h(d,p){const m=3*d;p.x=t[m+0],p.y=t[m+1],p.z=t[m+2]}function c(d,p,m,f){f<0&&d.x===1&&(a[p]=d.x-1),m.x===0&&m.z===0&&(a[p]=f/2/Math.PI+.5)}function u(d){return Math.atan2(d.z,-d.x)}(function(d){const p=new S,m=new S,f=new S;for(let v=0;v<e.length;v+=3)h(e[v+0],p),h(e[v+1],m),h(e[v+2],f),o(p,m,f,d)})(s),function(d){const p=new S;for(let m=0;m<r.length;m+=3)p.x=r[m+0],p.y=r[m+1],p.z=r[m+2],p.normalize().multiplyScalar(d),r[m+0]=p.x,r[m+1]=p.y,r[m+2]=p.z}(i),function(){const d=new S;for(let m=0;m<r.length;m+=3){d.x=r[m+0],d.y=r[m+1],d.z=r[m+2];const f=u(d)/2/Math.PI+.5,v=(p=d,Math.atan2(-p.y,Math.sqrt(p.x*p.x+p.z*p.z))/Math.PI+.5);a.push(f,1-v)}var p;(function(){const m=new S,f=new S,v=new S,_=new S,y=new V,x=new V,b=new V;for(let w=0,M=0;w<r.length;w+=9,M+=6){m.set(r[w+0],r[w+1],r[w+2]),f.set(r[w+3],r[w+4],r[w+5]),v.set(r[w+6],r[w+7],r[w+8]),y.set(a[M+0],a[M+1]),x.set(a[M+2],a[M+3]),b.set(a[M+4],a[M+5]),_.copy(m).add(f).add(v).divideScalar(3);const T=u(_);c(y,M+0,m,T),c(x,M+2,f,T),c(b,M+4,v,T)}})(),function(){for(let m=0;m<a.length;m+=6){const f=a[m+0],v=a[m+2],_=a[m+4],y=Math.max(f,v,_),x=Math.min(f,v,_);y>.9&&x<.1&&(f<.2&&(a[m+0]+=1),v<.2&&(a[m+2]+=1),_<.2&&(a[m+4]+=1))}}()}(),this.setAttribute("position",new Z(r,3)),this.setAttribute("normal",new Z(r.slice(),3)),this.setAttribute("uv",new Z(a,2)),s===0?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(t){return new Qi(t.vertices,t.indices,t.radius,t.details)}}class Pr extends Qi{constructor(t=1,e=0){const i=(1+Math.sqrt(5))/2,s=1/i;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-s,-i,0,-s,i,0,s,-i,0,s,i,-s,-i,0,-s,i,0,s,-i,0,s,i,0,-i,0,-s,i,0,-s,-i,0,s,i,0,s],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Pr(t.radius,t.detail)}}const Hl=new S,Wl=new S,Ru=new S,ql=new mi;class wf extends gt{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},t!==null){const s=Math.pow(10,4),r=Math.cos(cs*e),a=t.getIndex(),o=t.getAttribute("position"),l=a?a.count:o.count,h=[0,0,0],c=["a","b","c"],u=new Array(3),d={},p=[];for(let m=0;m<l;m+=3){a?(h[0]=a.getX(m),h[1]=a.getX(m+1),h[2]=a.getX(m+2)):(h[0]=m,h[1]=m+1,h[2]=m+2);const{a:f,b:v,c:_}=ql;if(f.fromBufferAttribute(o,h[0]),v.fromBufferAttribute(o,h[1]),_.fromBufferAttribute(o,h[2]),ql.getNormal(Ru),u[0]=`${Math.round(f.x*s)},${Math.round(f.y*s)},${Math.round(f.z*s)}`,u[1]=`${Math.round(v.x*s)},${Math.round(v.y*s)},${Math.round(v.z*s)}`,u[2]=`${Math.round(_.x*s)},${Math.round(_.y*s)},${Math.round(_.z*s)}`,u[0]!==u[1]&&u[1]!==u[2]&&u[2]!==u[0])for(let y=0;y<3;y++){const x=(y+1)%3,b=u[y],w=u[x],M=ql[c[y]],T=ql[c[x]],R=`${b}_${w}`,E=`${w}_${b}`;E in d&&d[E]?(Ru.dot(d[E].normal)<=r&&(p.push(M.x,M.y,M.z),p.push(T.x,T.y,T.z)),d[E]=null):R in d||(d[R]={index0:h[y],index1:h[x],normal:Ru.clone()})}}for(const m in d)if(d[m]){const{index0:f,index1:v}=d[m];Hl.fromBufferAttribute(o,f),Wl.fromBufferAttribute(o,v),p.push(Hl.x,Hl.y,Hl.z),p.push(Wl.x,Wl.y,Wl.z)}this.setAttribute("position",new Z(p,3))}}}class xs extends Ga{constructor(t){super(t),this.uuid=ei(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let i=0,s=this.holes.length;i<s;i++)e[i]=this.holes[i].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const s=t.holes[e];this.holes.push(s.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,i=this.holes.length;e<i;e++){const s=this.holes[e];t.holes.push(s.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const s=t.holes[e];this.holes.push(new Ga().fromJSON(s))}return this}}const Xx=function(n,t,e=2){const i=t&&t.length,s=i?t[0]*e:n.length;let r=Sf(n,0,s,e,!0);const a=[];if(!r||r.next===r.prev)return a;let o,l,h,c,u,d,p;if(i&&(r=function(m,f,v,_){const y=[];let x,b,w,M,T;for(x=0,b=f.length;x<b;x++)w=f[x]*_,M=x<b-1?f[x+1]*_:m.length,T=Sf(m,w,M,_,!1),T===T.next&&(T.steiner=!0),y.push(eb(T));for(y.sort(Qx),x=0;x<y.length;x++)$x(y[x],v),v=Hn(v,v.next);return v}(n,t,r,e)),n.length>80*e){o=h=n[0],l=c=n[1];for(let m=e;m<s;m+=e)u=n[m],d=n[m+1],u<o&&(o=u),d<l&&(l=d),u>h&&(h=u),d>c&&(c=d);p=Math.max(h-o,c-l),p=p!==0?1/p:0}return ja(r,a,e,o,l,p),a};function Sf(n,t,e,i,s){let r,a;if(s===function(o,l,h,c){let u=0;for(let d=l,p=h-c;d<h;d+=c)u+=(o[p]-o[d])*(o[d+1]+o[p+1]),p=d;return u}(n,t,e,i)>0)for(r=t;r<e;r+=i)a=Cf(r,n[r],n[r+1],a);else for(r=e-i;r>=t;r-=i)a=Cf(r,n[r],n[r+1],a);return a&&Xl(a,a.next)&&(Wa(a),a=a.next),a}function Hn(n,t){if(!n)return n;t||(t=n);let e,i=n;do if(e=!1,i.steiner||!Xl(i,i.next)&&se(i.prev,i,i.next)!==0)i=i.next;else{if(Wa(i),i=t=i.prev,i===i.next)break;e=!0}while(e||i!==t);return t}function ja(n,t,e,i,s,r,a){if(!n)return;!a&&r&&function(c,u,d,p){let m=c;do m.z===null&&(m.z=Lu(m.x,m.y,u,d,p)),m.prevZ=m.prev,m.nextZ=m.next,m=m.next;while(m!==c);m.prevZ.nextZ=null,m.prevZ=null,function(f){let v,_,y,x,b,w,M,T,R=1;do{for(_=f,f=null,b=null,w=0;_;){for(w++,y=_,M=0,v=0;v<R&&(M++,y=y.nextZ,y);v++);for(T=R;M>0||T>0&&y;)M!==0&&(T===0||!y||_.z<=y.z)?(x=_,_=_.nextZ,M--):(x=y,y=y.nextZ,T--),b?b.nextZ=x:f=x,x.prevZ=b,b=x;_=y}b.nextZ=null,R*=2}while(w>1)}(m)}(n,i,s,r);let o,l,h=n;for(;n.prev!==n.next;)if(o=n.prev,l=n.next,r?Zx(n,i,s,r):Yx(n))t.push(o.i/e),t.push(n.i/e),t.push(l.i/e),Wa(n),n=l.next,h=l.next;else if((n=l)===h){a?a===1?ja(n=Jx(Hn(n),t,e),t,e,i,s,r,2):a===2&&Kx(n,t,e,i,s,r):ja(Hn(n),t,e,i,s,r,1);break}}function Yx(n){const t=n.prev,e=n,i=n.next;if(se(t,e,i)>=0)return!1;let s=n.next.next;for(;s!==n.prev;){if(Rr(t.x,t.y,e.x,e.y,i.x,i.y,s.x,s.y)&&se(s.prev,s,s.next)>=0)return!1;s=s.next}return!0}function Zx(n,t,e,i){const s=n.prev,r=n,a=n.next;if(se(s,r,a)>=0)return!1;const o=s.x<r.x?s.x<a.x?s.x:a.x:r.x<a.x?r.x:a.x,l=s.y<r.y?s.y<a.y?s.y:a.y:r.y<a.y?r.y:a.y,h=s.x>r.x?s.x>a.x?s.x:a.x:r.x>a.x?r.x:a.x,c=s.y>r.y?s.y>a.y?s.y:a.y:r.y>a.y?r.y:a.y,u=Lu(o,l,t,e,i),d=Lu(h,c,t,e,i);let p=n.prevZ,m=n.nextZ;for(;p&&p.z>=u&&m&&m.z<=d;){if(p!==n.prev&&p!==n.next&&Rr(s.x,s.y,r.x,r.y,a.x,a.y,p.x,p.y)&&se(p.prev,p,p.next)>=0||(p=p.prevZ,m!==n.prev&&m!==n.next&&Rr(s.x,s.y,r.x,r.y,a.x,a.y,m.x,m.y)&&se(m.prev,m,m.next)>=0))return!1;m=m.nextZ}for(;p&&p.z>=u;){if(p!==n.prev&&p!==n.next&&Rr(s.x,s.y,r.x,r.y,a.x,a.y,p.x,p.y)&&se(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;m&&m.z<=d;){if(m!==n.prev&&m!==n.next&&Rr(s.x,s.y,r.x,r.y,a.x,a.y,m.x,m.y)&&se(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function Jx(n,t,e){let i=n;do{const s=i.prev,r=i.next.next;!Xl(s,r)&&Tf(s,i,i.next,r)&&Ha(s,r)&&Ha(r,s)&&(t.push(s.i/e),t.push(i.i/e),t.push(r.i/e),Wa(i),Wa(i.next),i=n=r),i=i.next}while(i!==n);return Hn(i)}function Kx(n,t,e,i,s,r){let a=n;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&ib(a,o)){let l=Ef(a,o);return a=Hn(a,a.next),l=Hn(l,l.next),ja(a,t,e,i,s,r),void ja(l,t,e,i,s,r)}o=o.next}a=a.next}while(a!==n)}function Qx(n,t){return n.x-t.x}function $x(n,t){if(t=function(e,i){let s=i;const r=e.x,a=e.y;let o,l=-1/0;do{if(a<=s.y&&a>=s.next.y&&s.next.y!==s.y){const m=s.x+(a-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(m<=r&&m>l){if(l=m,m===r){if(a===s.y)return s;if(a===s.next.y)return s.next}o=s.x<s.next.x?s:s.next}}s=s.next}while(s!==i);if(!o)return null;if(r===l)return o;const h=o,c=o.x,u=o.y;let d,p=1/0;s=o;do r>=s.x&&s.x>=c&&r!==s.x&&Rr(a<u?r:l,a,c,u,a<u?l:r,a,s.x,s.y)&&(d=Math.abs(a-s.y)/(r-s.x),Ha(s,e)&&(d<p||d===p&&(s.x>o.x||s.x===o.x&&tb(o,s)))&&(o=s,p=d)),s=s.next;while(s!==h);return o}(n,t),t){const e=Ef(t,n);Hn(t,t.next),Hn(e,e.next)}}function tb(n,t){return se(n.prev,n,t.prev)<0&&se(t.next,n,n.next)<0}function Lu(n,t,e,i,s){return(n=1431655765&((n=858993459&((n=252645135&((n=16711935&((n=32767*(n-e)*s)|n<<8))|n<<4))|n<<2))|n<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*s)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function eb(n){let t=n,e=n;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==n);return e}function Rr(n,t,e,i,s,r,a,o){return(s-a)*(t-o)-(n-a)*(r-o)>=0&&(n-a)*(i-o)-(e-a)*(t-o)>=0&&(e-a)*(r-o)-(s-a)*(i-o)>=0}function ib(n,t){return n.next.i!==t.i&&n.prev.i!==t.i&&!function(e,i){let s=e;do{if(s.i!==e.i&&s.next.i!==e.i&&s.i!==i.i&&s.next.i!==i.i&&Tf(s,s.next,e,i))return!0;s=s.next}while(s!==e);return!1}(n,t)&&(Ha(n,t)&&Ha(t,n)&&function(e,i){let s=e,r=!1;const a=(e.x+i.x)/2,o=(e.y+i.y)/2;do s.y>o!=s.next.y>o&&s.next.y!==s.y&&a<(s.next.x-s.x)*(o-s.y)/(s.next.y-s.y)+s.x&&(r=!r),s=s.next;while(s!==e);return r}(n,t)&&(se(n.prev,n,t.prev)||se(n,t.prev,t))||Xl(n,t)&&se(n.prev,n,n.next)>0&&se(t.prev,t,t.next)>0)}function se(n,t,e){return(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y)}function Xl(n,t){return n.x===t.x&&n.y===t.y}function Tf(n,t,e,i){const s=Zl(se(n,t,e)),r=Zl(se(n,t,i)),a=Zl(se(e,i,n)),o=Zl(se(e,i,t));return s!==r&&a!==o||!(s!==0||!Yl(n,e,t))||!(r!==0||!Yl(n,i,t))||!(a!==0||!Yl(e,n,i))||!(o!==0||!Yl(e,t,i))}function Yl(n,t,e){return t.x<=Math.max(n.x,e.x)&&t.x>=Math.min(n.x,e.x)&&t.y<=Math.max(n.y,e.y)&&t.y>=Math.min(n.y,e.y)}function Zl(n){return n>0?1:n<0?-1:0}function Ha(n,t){return se(n.prev,n,n.next)<0?se(n,t,n.next)>=0&&se(n,n.prev,t)>=0:se(n,t,n.prev)<0||se(n,n.next,t)<0}function Ef(n,t){const e=new Iu(n.i,n.x,n.y),i=new Iu(t.i,t.x,t.y),s=n.next,r=t.prev;return n.next=t,t.prev=n,e.next=s,s.prev=e,i.next=e,e.prev=i,r.next=i,i.prev=r,i}function Cf(n,t,e,i){const s=new Iu(n,t,e);return i?(s.next=i.next,s.prev=i,i.next.prev=s,i.next=s):(s.prev=s,s.next=s),s}function Wa(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function Iu(n,t,e){this.i=n,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}class $i{static area(t){const e=t.length;let i=0;for(let s=e-1,r=0;r<e;s=r++)i+=t[s].x*t[r].y-t[r].x*t[s].y;return .5*i}static isClockWise(t){return $i.area(t)<0}static triangulateShape(t,e){const i=[],s=[],r=[];Af(t),Pf(i,t);let a=t.length;e.forEach(Af);for(let l=0;l<e.length;l++)s.push(a),a+=e[l].length,Pf(i,e[l]);const o=Xx(i,s);for(let l=0;l<o.length;l+=3)r.push(o.slice(l,l+3));return r}}function Af(n){const t=n.length;t>2&&n[t-1].equals(n[0])&&n.pop()}function Pf(n,t){for(let e=0;e<t.length;e++)n.push(t[e].x),n.push(t[e].y)}class Lr extends gt{constructor(t=new xs([new V(.5,.5),new V(-.5,.5),new V(-.5,-.5),new V(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const i=this,s=[],r=[];for(let o=0,l=t.length;o<l;o++)a(t[o]);function a(o){const l=[],h=e.curveSegments!==void 0?e.curveSegments:12,c=e.steps!==void 0?e.steps:1;let u=e.depth!==void 0?e.depth:1,d=e.bevelEnabled===void 0||e.bevelEnabled,p=e.bevelThickness!==void 0?e.bevelThickness:.2,m=e.bevelSize!==void 0?e.bevelSize:p-.1,f=e.bevelOffset!==void 0?e.bevelOffset:0,v=e.bevelSegments!==void 0?e.bevelSegments:3;const _=e.extrudePath,y=e.UVGenerator!==void 0?e.UVGenerator:nb;e.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),u=e.amount);let x,b,w,M,T,R=!1;_&&(x=_.getSpacedPoints(c),R=!0,d=!1,b=_.computeFrenetFrames(c,!1),w=new S,M=new S,T=new S),d||(v=0,p=0,m=0,f=0);const E=o.extractPoints(h);let A=E.shape;const z=E.holes;if(!$i.isClockWise(A)){A=A.reverse();for(let B=0,D=z.length;B<D;B++){const C=z[B];$i.isClockWise(C)&&(z[B]=C.reverse())}}const F=$i.triangulateShape(A,z),G=A;for(let B=0,D=z.length;B<D;B++){const C=z[B];A=A.concat(C)}function U(B,D,C){return D||console.error("THREE.ExtrudeGeometry: vec does not exist"),D.clone().multiplyScalar(C).add(B)}const k=A.length,H=F.length;function W(B,D,C){let j,L,et;const Y=B.x-D.x,it=B.y-D.y,ct=C.x-B.x,pt=C.y-B.y,wt=Y*Y+it*it,xt=Y*pt-it*ct;if(Math.abs(xt)>Number.EPSILON){const St=Math.sqrt(wt),Ct=Math.sqrt(ct*ct+pt*pt),At=D.x-it/St,ne=D.y+Y/St,ui=((C.x-pt/Ct-At)*pt-(C.y+ct/Ct-ne)*ct)/(Y*pt-it*ct);j=At+Y*ui-B.x,L=ne+it*ui-B.y;const Et=j*j+L*L;if(Et<=2)return new V(j,L);et=Math.sqrt(Et/2)}else{let St=!1;Y>Number.EPSILON?ct>Number.EPSILON&&(St=!0):Y<-Number.EPSILON?ct<-Number.EPSILON&&(St=!0):Math.sign(it)===Math.sign(pt)&&(St=!0),St?(j=-it,L=Y,et=Math.sqrt(wt)):(j=Y,L=it,et=Math.sqrt(wt/2))}return new V(j/et,L/et)}const N=[];for(let B=0,D=G.length,C=D-1,j=B+1;B<D;B++,C++,j++)C===D&&(C=0),j===D&&(j=0),N[B]=W(G[B],G[C],G[j]);const X=[];let K,$=N.concat();for(let B=0,D=z.length;B<D;B++){const C=z[B];K=[];for(let j=0,L=C.length,et=L-1,Y=j+1;j<L;j++,et++,Y++)et===L&&(et=0),Y===L&&(Y=0),K[j]=W(C[j],C[et],C[Y]);X.push(K),$=$.concat(K)}for(let B=0;B<v;B++){const D=B/v,C=p*Math.cos(D*Math.PI/2),j=m*Math.sin(D*Math.PI/2)+f;for(let L=0,et=G.length;L<et;L++){const Y=U(G[L],N[L],j);mt(Y.x,Y.y,-C)}for(let L=0,et=z.length;L<et;L++){const Y=z[L];K=X[L];for(let it=0,ct=Y.length;it<ct;it++){const pt=U(Y[it],K[it],j);mt(pt.x,pt.y,-C)}}}const lt=m+f;for(let B=0;B<k;B++){const D=d?U(A[B],$[B],lt):A[B];R?(M.copy(b.normals[0]).multiplyScalar(D.x),w.copy(b.binormals[0]).multiplyScalar(D.y),T.copy(x[0]).add(M).add(w),mt(T.x,T.y,T.z)):mt(D.x,D.y,0)}for(let B=1;B<=c;B++)for(let D=0;D<k;D++){const C=d?U(A[D],$[D],lt):A[D];R?(M.copy(b.normals[B]).multiplyScalar(C.x),w.copy(b.binormals[B]).multiplyScalar(C.y),T.copy(x[B]).add(M).add(w),mt(T.x,T.y,T.z)):mt(C.x,C.y,u/c*B)}for(let B=v-1;B>=0;B--){const D=B/v,C=p*Math.cos(D*Math.PI/2),j=m*Math.sin(D*Math.PI/2)+f;for(let L=0,et=G.length;L<et;L++){const Y=U(G[L],N[L],j);mt(Y.x,Y.y,u+C)}for(let L=0,et=z.length;L<et;L++){const Y=z[L];K=X[L];for(let it=0,ct=Y.length;it<ct;it++){const pt=U(Y[it],K[it],j);R?mt(pt.x,pt.y+x[c-1].y,x[c-1].x+C):mt(pt.x,pt.y,u+C)}}}function yt(B,D){let C=B.length;for(;--C>=0;){const j=C;let L=C-1;L<0&&(L=B.length-1);for(let et=0,Y=c+2*v;et<Y;et++){const it=k*et,ct=k*(et+1);I(D+j+it,D+L+it,D+L+ct,D+j+ct)}}}function mt(B,D,C){l.push(B),l.push(D),l.push(C)}function bt(B,D,C){P(B),P(D),P(C);const j=s.length/3,L=y.generateTopUV(i,s,j-3,j-2,j-1);q(L[0]),q(L[1]),q(L[2])}function I(B,D,C,j){P(B),P(D),P(j),P(D),P(C),P(j);const L=s.length/3,et=y.generateSideWallUV(i,s,L-6,L-3,L-2,L-1);q(et[0]),q(et[1]),q(et[3]),q(et[1]),q(et[2]),q(et[3])}function P(B){s.push(l[3*B+0]),s.push(l[3*B+1]),s.push(l[3*B+2])}function q(B){r.push(B.x),r.push(B.y)}(function(){const B=s.length/3;if(d){let D=0,C=k*D;for(let j=0;j<H;j++){const L=F[j];bt(L[2]+C,L[1]+C,L[0]+C)}D=c+2*v,C=k*D;for(let j=0;j<H;j++){const L=F[j];bt(L[0]+C,L[1]+C,L[2]+C)}}else{for(let D=0;D<H;D++){const C=F[D];bt(C[2],C[1],C[0])}for(let D=0;D<H;D++){const C=F[D];bt(C[0]+k*c,C[1]+k*c,C[2]+k*c)}}i.addGroup(B,s.length/3-B,0)})(),function(){const B=s.length/3;let D=0;yt(G,D),D+=G.length;for(let C=0,j=z.length;C<j;C++){const L=z[C];yt(L,D),D+=L.length}i.addGroup(B,s.length/3-B,1)}()}this.setAttribute("position",new Z(s,3)),this.setAttribute("uv",new Z(r,2)),this.computeVertexNormals()}toJSON(){const t=super.toJSON();return function(e,i,s){if(s.shapes=[],Array.isArray(e))for(let r=0,a=e.length;r<a;r++){const o=e[r];s.shapes.push(o.uuid)}else s.shapes.push(e.uuid);return s.options=Object.assign({},i),i.extrudePath!==void 0&&(s.options.extrudePath=i.extrudePath.toJSON()),s}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const i=[];for(let r=0,a=t.shapes.length;r<a;r++){const o=e[t.shapes[r]];i.push(o)}const s=t.options.extrudePath;return s!==void 0&&(t.options.extrudePath=new Pu[s.type]().fromJSON(s)),new Lr(i,t.options)}}const nb={generateTopUV:function(n,t,e,i,s){const r=t[3*e],a=t[3*e+1],o=t[3*i],l=t[3*i+1],h=t[3*s],c=t[3*s+1];return[new V(r,a),new V(o,l),new V(h,c)]},generateSideWallUV:function(n,t,e,i,s,r){const a=t[3*e],o=t[3*e+1],l=t[3*e+2],h=t[3*i],c=t[3*i+1],u=t[3*i+2],d=t[3*s],p=t[3*s+1],m=t[3*s+2],f=t[3*r],v=t[3*r+1],_=t[3*r+2];return Math.abs(o-c)<Math.abs(a-h)?[new V(a,1-l),new V(h,1-u),new V(d,1-m),new V(f,1-_)]:[new V(o,1-l),new V(c,1-u),new V(p,1-m),new V(v,1-_)]}};class Ir extends Qi{constructor(t=1,e=0){const i=(1+Math.sqrt(5))/2;super([-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Ir(t.radius,t.detail)}}class zi extends Qi{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new zi(t.radius,t.detail)}}class Dr extends gt{constructor(t=.5,e=1,i=8,s=1,r=0,a=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:i,phiSegments:s,thetaStart:r,thetaLength:a},i=Math.max(3,i);const o=[],l=[],h=[],c=[];let u=t;const d=(e-t)/(s=Math.max(1,s)),p=new S,m=new V;for(let f=0;f<=s;f++){for(let v=0;v<=i;v++){const _=r+v/i*a;p.x=u*Math.cos(_),p.y=u*Math.sin(_),l.push(p.x,p.y,p.z),h.push(0,0,1),m.x=(p.x/e+1)/2,m.y=(p.y/e+1)/2,c.push(m.x,m.y)}u+=d}for(let f=0;f<s;f++){const v=f*(i+1);for(let _=0;_<i;_++){const y=_+v,x=y,b=y+i+1,w=y+i+2,M=y+1;o.push(x,b,M),o.push(b,w,M)}}this.setIndex(o),this.setAttribute("position",new Z(l,3)),this.setAttribute("normal",new Z(h,3)),this.setAttribute("uv",new Z(c,2))}static fromJSON(t){return new Dr(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class Or extends gt{constructor(t=new xs([new V(0,.5),new V(-.5,-.5),new V(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const i=[],s=[],r=[],a=[];let o=0,l=0;if(Array.isArray(t)===!1)h(t);else for(let c=0;c<t.length;c++)h(t[c]),this.addGroup(o,l,c),o+=l,l=0;function h(c){const u=s.length/3,d=c.extractPoints(e);let p=d.shape;const m=d.holes;$i.isClockWise(p)===!1&&(p=p.reverse());for(let v=0,_=m.length;v<_;v++){const y=m[v];$i.isClockWise(y)===!0&&(m[v]=y.reverse())}const f=$i.triangulateShape(p,m);for(let v=0,_=m.length;v<_;v++){const y=m[v];p=p.concat(y)}for(let v=0,_=p.length;v<_;v++){const y=p[v];s.push(y.x,y.y,0),r.push(0,0,1),a.push(y.x,y.y)}for(let v=0,_=f.length;v<_;v++){const y=f[v],x=y[0]+u,b=y[1]+u,w=y[2]+u;i.push(x,b,w),l+=3}}this.setIndex(i),this.setAttribute("position",new Z(s,3)),this.setAttribute("normal",new Z(r,3)),this.setAttribute("uv",new Z(a,2))}toJSON(){const t=super.toJSON();return function(e,i){if(i.shapes=[],Array.isArray(e))for(let s=0,r=e.length;s<r;s++){const a=e[s];i.shapes.push(a.uuid)}else i.shapes.push(e.uuid);return i}(this.parameters.shapes,t)}static fromJSON(t,e){const i=[];for(let s=0,r=t.shapes.length;s<r;s++){const a=e[t.shapes[s]];i.push(a)}return new Or(i,t.curveSegments)}}class tn extends gt{constructor(t=1,e=32,i=16,s=0,r=2*Math.PI,a=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:i,phiStart:s,phiLength:r,thetaStart:a,thetaLength:o},e=Math.max(3,Math.floor(e)),i=Math.max(2,Math.floor(i));const l=Math.min(a+o,Math.PI);let h=0;const c=[],u=new S,d=new S,p=[],m=[],f=[],v=[];for(let _=0;_<=i;_++){const y=[],x=_/i;let b=0;_==0&&a==0?b=.5/e:_==i&&l==Math.PI&&(b=-.5/e);for(let w=0;w<=e;w++){const M=w/e;u.x=-t*Math.cos(s+M*r)*Math.sin(a+x*o),u.y=t*Math.cos(a+x*o),u.z=t*Math.sin(s+M*r)*Math.sin(a+x*o),m.push(u.x,u.y,u.z),d.copy(u).normalize(),f.push(d.x,d.y,d.z),v.push(M+b,1-x),y.push(h++)}c.push(y)}for(let _=0;_<i;_++)for(let y=0;y<e;y++){const x=c[_][y+1],b=c[_][y],w=c[_+1][y],M=c[_+1][y+1];(_!==0||a>0)&&p.push(x,b,M),(_!==i-1||l<Math.PI)&&p.push(b,w,M)}this.setIndex(p),this.setAttribute("position",new Z(m,3)),this.setAttribute("normal",new Z(f,3)),this.setAttribute("uv",new Z(v,2))}static fromJSON(t){return new tn(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class zr extends Qi{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new zr(t.radius,t.detail)}}class Ui extends gt{constructor(t=1,e=.4,i=8,s=6,r=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:i,tubularSegments:s,arc:r},i=Math.floor(i),s=Math.floor(s);const a=[],o=[],l=[],h=[],c=new S,u=new S,d=new S;for(let p=0;p<=i;p++)for(let m=0;m<=s;m++){const f=m/s*r,v=p/i*Math.PI*2;u.x=(t+e*Math.cos(v))*Math.cos(f),u.y=(t+e*Math.cos(v))*Math.sin(f),u.z=e*Math.sin(v),o.push(u.x,u.y,u.z),c.x=t*Math.cos(f),c.y=t*Math.sin(f),d.subVectors(u,c).normalize(),l.push(d.x,d.y,d.z),h.push(m/s),h.push(p/i)}for(let p=1;p<=i;p++)for(let m=1;m<=s;m++){const f=(s+1)*p+m-1,v=(s+1)*(p-1)+m-1,_=(s+1)*(p-1)+m,y=(s+1)*p+m;a.push(f,v,y),a.push(v,_,y)}this.setIndex(a),this.setAttribute("position",new Z(o,3)),this.setAttribute("normal",new Z(l,3)),this.setAttribute("uv",new Z(h,2))}static fromJSON(t){return new Ui(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class Ur extends gt{constructor(t=1,e=.4,i=64,s=8,r=2,a=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:i,radialSegments:s,p:r,q:a},i=Math.floor(i),s=Math.floor(s);const o=[],l=[],h=[],c=[],u=new S,d=new S,p=new S,m=new S,f=new S,v=new S,_=new S;for(let x=0;x<=i;++x){const b=x/i*r*Math.PI*2;y(b,r,a,t,p),y(b+.01,r,a,t,m),v.subVectors(m,p),_.addVectors(m,p),f.crossVectors(v,_),_.crossVectors(f,v),f.normalize(),_.normalize();for(let w=0;w<=s;++w){const M=w/s*Math.PI*2,T=-e*Math.cos(M),R=e*Math.sin(M);u.x=p.x+(T*_.x+R*f.x),u.y=p.y+(T*_.y+R*f.y),u.z=p.z+(T*_.z+R*f.z),l.push(u.x,u.y,u.z),d.subVectors(u,p).normalize(),h.push(d.x,d.y,d.z),c.push(x/i),c.push(w/s)}}for(let x=1;x<=i;x++)for(let b=1;b<=s;b++){const w=(s+1)*(x-1)+(b-1),M=(s+1)*x+(b-1),T=(s+1)*x+b,R=(s+1)*(x-1)+b;o.push(w,M,R),o.push(M,T,R)}function y(x,b,w,M,T){const R=Math.cos(x),E=Math.sin(x),A=w/b*x,z=Math.cos(A);T.x=M*(2+z)*.5*R,T.y=M*(2+z)*E*.5,T.z=M*Math.sin(A)*.5}this.setIndex(o),this.setAttribute("position",new Z(l,3)),this.setAttribute("normal",new Z(h,3)),this.setAttribute("uv",new Z(c,2))}static fromJSON(t){return new Ur(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class Fr extends gt{constructor(t=new Cu(new S(-1,-1,0),new S(-1,1,0),new S(1,1,0)),e=64,i=1,s=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:i,radialSegments:s,closed:r};const a=t.computeFrenetFrames(e,r);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals;const o=new S,l=new S,h=new V;let c=new S;const u=[],d=[],p=[],m=[];function f(v){c=t.getPointAt(v/e,c);const _=a.normals[v],y=a.binormals[v];for(let x=0;x<=s;x++){const b=x/s*Math.PI*2,w=Math.sin(b),M=-Math.cos(b);l.x=M*_.x+w*y.x,l.y=M*_.y+w*y.y,l.z=M*_.z+w*y.z,l.normalize(),d.push(l.x,l.y,l.z),o.x=c.x+i*l.x,o.y=c.y+i*l.y,o.z=c.z+i*l.z,u.push(o.x,o.y,o.z)}}(function(){for(let v=0;v<e;v++)f(v);f(r===!1?e:0),function(){for(let v=0;v<=e;v++)for(let _=0;_<=s;_++)h.x=v/e,h.y=_/s,p.push(h.x,h.y)}(),function(){for(let v=1;v<=e;v++)for(let _=1;_<=s;_++){const y=(s+1)*(v-1)+(_-1),x=(s+1)*v+(_-1),b=(s+1)*v+_,w=(s+1)*(v-1)+_;m.push(y,x,w),m.push(x,b,w)}}()})(),this.setIndex(m),this.setAttribute("position",new Z(u,3)),this.setAttribute("normal",new Z(d,3)),this.setAttribute("uv",new Z(p,2))}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new Fr(new Pu[t.path.type]().fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class Rf extends gt{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},t!==null){const e=[],i=new Set,s=new S,r=new S;if(t.index!==null){const a=t.attributes.position,o=t.index;let l=t.groups;l.length===0&&(l=[{start:0,count:o.count,materialIndex:0}]);for(let h=0,c=l.length;h<c;++h){const u=l[h],d=u.start;for(let p=d,m=d+u.count;p<m;p+=3)for(let f=0;f<3;f++){const v=o.getX(p+f),_=o.getX(p+(f+1)%3);s.fromBufferAttribute(a,v),r.fromBufferAttribute(a,_),Lf(s,r,i)===!0&&(e.push(s.x,s.y,s.z),e.push(r.x,r.y,r.z))}}}else{const a=t.attributes.position;for(let o=0,l=a.count/3;o<l;o++)for(let h=0;h<3;h++){const c=3*o+h,u=3*o+(h+1)%3;s.fromBufferAttribute(a,c),r.fromBufferAttribute(a,u),Lf(s,r,i)===!0&&(e.push(s.x,s.y,s.z),e.push(r.x,r.y,r.z))}}this.setAttribute("position",new Z(e,3))}}}function Lf(n,t,e){const i=`${n.x},${n.y},${n.z}-${t.x},${t.y},${t.z}`,s=`${t.x},${t.y},${t.z}-${n.x},${n.y},${n.z}`;return e.has(i)!==!0&&e.has(s)!==!0&&(e.add(i),e.add(s),!0)}var If=Object.freeze({__proto__:null,BoxGeometry:Wt,BoxBufferGeometry:Wt,CapsuleGeometry:Er,CapsuleBufferGeometry:Er,CircleGeometry:Cr,CircleBufferGeometry:Cr,ConeGeometry:Ar,ConeBufferGeometry:Ar,CylinderGeometry:oe,CylinderBufferGeometry:oe,DodecahedronGeometry:Pr,DodecahedronBufferGeometry:Pr,EdgesGeometry:wf,ExtrudeGeometry:Lr,ExtrudeBufferGeometry:Lr,IcosahedronGeometry:Ir,IcosahedronBufferGeometry:Ir,LatheGeometry:ys,LatheBufferGeometry:ys,OctahedronGeometry:zi,OctahedronBufferGeometry:zi,PlaneGeometry:gi,PlaneBufferGeometry:gi,PolyhedronGeometry:Qi,PolyhedronBufferGeometry:Qi,RingGeometry:Dr,RingBufferGeometry:Dr,ShapeGeometry:Or,ShapeBufferGeometry:Or,SphereGeometry:tn,SphereBufferGeometry:tn,TetrahedronGeometry:zr,TetrahedronBufferGeometry:zr,TorusGeometry:Ui,TorusBufferGeometry:Ui,TorusKnotGeometry:Ur,TorusKnotBufferGeometry:Ur,TubeGeometry:Fr,TubeBufferGeometry:Fr,WireframeGeometry:Rf});class Df extends ae{constructor(t){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new nt(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}class qa extends Qt{constructor(t){super(t),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class en extends ae{constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new nt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new V(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class wn extends en{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new V(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return de(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new nt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new nt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new nt(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class Jl extends ae{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new nt(16777215),this.specular=new nt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new V(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Of extends ae{constructor(t){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new nt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new V(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class zf extends ae{constructor(t){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new V(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class Uf extends ae{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new nt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class Ff extends ae{constructor(t){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new nt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new V(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Nf extends _e{constructor(t){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}const sb={ShadowMaterial:Df,SpriteMaterial:Da,RawShaderMaterial:qa,ShaderMaterial:Qt,PointsMaterial:Tr,MeshPhysicalMaterial:wn,MeshStandardMaterial:en,MeshPhongMaterial:Jl,MeshToonMaterial:Of,MeshNormalMaterial:zf,MeshLambertMaterial:Uf,MeshDepthMaterial:cu,MeshDistanceMaterial:uu,MeshBasicMaterial:Zt,MeshMatcapMaterial:Ff,LineDashedMaterial:Nf,LineBasicMaterial:_e,Material:ae};ae.fromType=function(n){return new sb[n]};const $t={arraySlice:function(n,t,e){return $t.isTypedArray(n)?new n.constructor(n.subarray(t,e!==void 0?e:n.length)):n.slice(t,e)},convertArray:function(n,t,e){return!n||!e&&n.constructor===t?n:typeof t.BYTES_PER_ELEMENT=="number"?new t(n):Array.prototype.slice.call(n)},isTypedArray:function(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)},getKeyframeOrder:function(n){const t=n.length,e=new Array(t);for(let i=0;i!==t;++i)e[i]=i;return e.sort(function(i,s){return n[i]-n[s]}),e},sortedArray:function(n,t,e){const i=n.length,s=new n.constructor(i);for(let r=0,a=0;a!==i;++r){const o=e[r]*t;for(let l=0;l!==t;++l)s[a++]=n[o+l]}return s},flattenJSON:function(n,t,e,i){let s=1,r=n[0];for(;r!==void 0&&r[i]===void 0;)r=n[s++];if(r===void 0)return;let a=r[i];if(a!==void 0)if(Array.isArray(a))do a=r[i],a!==void 0&&(t.push(r.time),e.push.apply(e,a)),r=n[s++];while(r!==void 0);else if(a.toArray!==void 0)do a=r[i],a!==void 0&&(t.push(r.time),a.toArray(e,e.length)),r=n[s++];while(r!==void 0);else do a=r[i],a!==void 0&&(t.push(r.time),e.push(a)),r=n[s++];while(r!==void 0)},subclip:function(n,t,e,i,s=30){const r=n.clone();r.name=t;const a=[];for(let l=0;l<r.tracks.length;++l){const h=r.tracks[l],c=h.getValueSize(),u=[],d=[];for(let p=0;p<h.times.length;++p){const m=h.times[p]*s;if(!(m<e||m>=i)){u.push(h.times[p]);for(let f=0;f<c;++f)d.push(h.values[p*c+f])}}u.length!==0&&(h.times=$t.convertArray(u,h.times.constructor),h.values=$t.convertArray(d,h.values.constructor),a.push(h))}r.tracks=a;let o=1/0;for(let l=0;l<r.tracks.length;++l)o>r.tracks[l].times[0]&&(o=r.tracks[l].times[0]);for(let l=0;l<r.tracks.length;++l)r.tracks[l].shift(-1*o);return r.resetDuration(),r},makeClipAdditive:function(n,t=0,e=n,i=30){i<=0&&(i=30);const s=e.tracks.length,r=t/i;for(let a=0;a<s;++a){const o=e.tracks[a],l=o.ValueTypeName;if(l==="bool"||l==="string")continue;const h=n.tracks.find(function(_){return _.name===o.name&&_.ValueTypeName===l});if(h===void 0)continue;let c=0;const u=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=u/3);let d=0;const p=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=p/3);const m=o.times.length-1;let f;if(r<=o.times[0]){const _=c,y=u-c;f=$t.arraySlice(o.values,_,y)}else if(r>=o.times[m]){const _=m*u+c,y=_+u-c;f=$t.arraySlice(o.values,_,y)}else{const _=o.createInterpolant(),y=c,x=u-c;_.evaluate(r),f=$t.arraySlice(_.resultBuffer,y,x)}l==="quaternion"&&new Ft().fromArray(f).normalize().conjugate().toArray(f);const v=h.times.length;for(let _=0;_<v;++_){const y=_*p+d;if(l==="quaternion")Ft.multiplyQuaternionsFlat(h.values,y,f,0,h.values,y);else{const x=p-2*d;for(let b=0;b<x;++b)h.values[y+b]-=f[b]}}}return n.blendMode=2501,n}};class Nr{constructor(t,e,i,s){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=s!==void 0?s:new e.constructor(i),this.sampleValues=e,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let i=this._cachedIndex,s=e[i],r=e[i-1];t:{e:{let a;i:{n:if(!(t<s)){for(let o=i+2;;){if(s===void 0){if(t<r)break n;return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===o)break;if(r=s,s=e[++i],t<s)break e}a=e.length;break i}if(t>=r)break t;{const o=e[1];t<o&&(i=2,r=o);for(let l=i-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===l)break;if(s=r,r=e[--i-1],t>=r)break e}a=i,i=0}}for(;i<a;){const o=i+a>>>1;t<e[o]?a=o:i=o+1}if(s=e[i],r=e[i-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===void 0)return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,r,s)}return this.interpolate_(i,r,t,s)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,s=this.valueSize,r=t*s;for(let a=0;a!==s;++a)e[a]=i[r+a];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class kf extends Nr{constructor(t,e,i,s){super(t,e,i,s),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(t,e,i){const s=this.parameterPositions;let r=t-2,a=t+1,o=s[r],l=s[a];if(o===void 0)switch(this.getSettings_().endingStart){case 2401:r=t,o=2*e-i;break;case 2402:r=s.length-2,o=e+s[r]-s[r+1];break;default:r=t,o=i}if(l===void 0)switch(this.getSettings_().endingEnd){case 2401:a=t,l=2*i-e;break;case 2402:a=1,l=i+s[1]-s[0];break;default:a=t-1,l=e}const h=.5*(i-e),c=this.valueSize;this._weightPrev=h/(e-o),this._weightNext=h/(l-i),this._offsetPrev=r*c,this._offsetNext=a*c}interpolate_(t,e,i,s){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=t*o,h=l-o,c=this._offsetPrev,u=this._offsetNext,d=this._weightPrev,p=this._weightNext,m=(i-e)/(s-e),f=m*m,v=f*m,_=-d*v+2*d*f-d*m,y=(1+d)*v+(-1.5-2*d)*f+(-.5+d)*m+1,x=(-1-p)*v+(1.5+p)*f+.5*m,b=p*v-p*f;for(let w=0;w!==o;++w)r[w]=_*a[c+w]+y*a[h+w]+x*a[l+w]+b*a[u+w];return r}}class Du extends Nr{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=t*o,h=l-o,c=(i-e)/(s-e),u=1-c;for(let d=0;d!==o;++d)r[d]=a[h+d]*u+a[l+d]*c;return r}}class Bf extends Nr{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t){return this.copySampleValue_(t-1)}}class Fi{constructor(t,e,i,s){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=$t.convertArray(e,this.TimeBufferType),this.values=$t.convertArray(i,this.ValueBufferType),this.setInterpolation(s||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let i;if(e.toJSON!==this.toJSON)i=e.toJSON(t);else{i={name:t.name,times:$t.convertArray(t.times,Array),values:$t.convertArray(t.values,Array)};const s=t.getInterpolation();s!==t.DefaultInterpolation&&(i.interpolation=s)}return i.type=t.ValueTypeName,i}InterpolantFactoryMethodDiscrete(t){return new Bf(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Du(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new kf(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case 2300:e=this.InterpolantFactoryMethodDiscrete;break;case 2301:e=this.InterpolantFactoryMethodLinear;break;case 2302:e=this.InterpolantFactoryMethodSmooth}if(e===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0){if(t===this.DefaultInterpolation)throw new Error(i);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]*=t}return this}trim(t,e){const i=this.times,s=i.length;let r=0,a=s-1;for(;r!==s&&i[r]<t;)++r;for(;a!==-1&&i[a]>e;)--a;if(++a,r!==0||a!==s){r>=a&&(a=Math.max(a,1),r=a-1);const o=this.getValueSize();this.times=$t.arraySlice(i,r,a),this.values=$t.arraySlice(this.values,r*o,a*o)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const i=this.times,s=this.values,r=i.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let a=null;for(let o=0;o!==r;o++){const l=i[o];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,l),t=!1;break}if(a!==null&&a>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,l,a),t=!1;break}a=l}if(s!==void 0&&$t.isTypedArray(s))for(let o=0,l=s.length;o!==l;++o){const h=s[o];if(isNaN(h)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,h),t=!1;break}}return t}optimize(){const t=$t.arraySlice(this.times),e=$t.arraySlice(this.values),i=this.getValueSize(),s=this.getInterpolation()===2302,r=t.length-1;let a=1;for(let o=1;o<r;++o){let l=!1;const h=t[o];if(h!==t[o+1]&&(o!==1||h!==t[0]))if(s)l=!0;else{const c=o*i,u=c-i,d=c+i;for(let p=0;p!==i;++p){const m=e[c+p];if(m!==e[u+p]||m!==e[d+p]){l=!0;break}}}if(l){if(o!==a){t[a]=t[o];const c=o*i,u=a*i;for(let d=0;d!==i;++d)e[u+d]=e[c+d]}++a}}if(r>0){t[a]=t[r];for(let o=r*i,l=a*i,h=0;h!==i;++h)e[l+h]=e[o+h];++a}return a!==t.length?(this.times=$t.arraySlice(t,0,a),this.values=$t.arraySlice(e,0,a*i)):(this.times=t,this.values=e),this}clone(){const t=$t.arraySlice(this.times,0),e=$t.arraySlice(this.values,0),i=new this.constructor(this.name,t,e);return i.createInterpolant=this.createInterpolant,i}}Fi.prototype.TimeBufferType=Float32Array,Fi.prototype.ValueBufferType=Float32Array,Fi.prototype.DefaultInterpolation=2301;class bs extends Fi{}bs.prototype.ValueTypeName="bool",bs.prototype.ValueBufferType=Array,bs.prototype.DefaultInterpolation=2300,bs.prototype.InterpolantFactoryMethodLinear=void 0,bs.prototype.InterpolantFactoryMethodSmooth=void 0;class Ou extends Fi{}Ou.prototype.ValueTypeName="color";class kr extends Fi{}kr.prototype.ValueTypeName="number";class Vf extends Nr{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=(i-e)/(s-e);let h=t*o;for(let c=h+o;h!==c;h+=4)Ft.slerpFlat(r,0,a,h-o,a,h,l);return r}}class Wn extends Fi{InterpolantFactoryMethodLinear(t){return new Vf(this.times,this.values,this.getValueSize(),t)}}Wn.prototype.ValueTypeName="quaternion",Wn.prototype.DefaultInterpolation=2301,Wn.prototype.InterpolantFactoryMethodSmooth=void 0;class Ms extends Fi{}Ms.prototype.ValueTypeName="string",Ms.prototype.ValueBufferType=Array,Ms.prototype.DefaultInterpolation=2300,Ms.prototype.InterpolantFactoryMethodLinear=void 0,Ms.prototype.InterpolantFactoryMethodSmooth=void 0;class Br extends Fi{}Br.prototype.ValueTypeName="vector";class Vr{constructor(t,e=-1,i,s=2500){this.name=t,this.tracks=i,this.duration=e,this.blendMode=s,this.uuid=ei(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],i=t.tracks,s=1/(t.fps||1);for(let a=0,o=i.length;a!==o;++a)e.push(rb(i[a]).scale(s));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r}static toJSON(t){const e=[],i=t.tracks,s={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let r=0,a=i.length;r!==a;++r)e.push(Fi.toJSON(i[r]));return s}static CreateFromMorphTargetSequence(t,e,i,s){const r=e.length,a=[];for(let o=0;o<r;o++){let l=[],h=[];l.push((o+r-1)%r,o,(o+1)%r),h.push(0,1,0);const c=$t.getKeyframeOrder(l);l=$t.sortedArray(l,1,c),h=$t.sortedArray(h,1,c),s||l[0]!==0||(l.push(r),h.push(h[0])),a.push(new kr(".morphTargetInfluences["+e[o].name+"]",l,h).scale(1/i))}return new this(t,-1,a)}static findByName(t,e){let i=t;if(!Array.isArray(t)){const s=t;i=s.geometry&&s.geometry.animations||s.animations}for(let s=0;s<i.length;s++)if(i[s].name===e)return i[s];return null}static CreateClipsFromMorphTargetSequences(t,e,i){const s={},r=/^([\w-]*?)([\d]+)$/;for(let o=0,l=t.length;o<l;o++){const h=t[o],c=h.name.match(r);if(c&&c.length>1){const u=c[1];let d=s[u];d||(s[u]=d=[]),d.push(h)}}const a=[];for(const o in s)a.push(this.CreateFromMorphTargetSequence(o,s[o],e,i));return a}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(c,u,d,p,m){if(d.length!==0){const f=[],v=[];$t.flattenJSON(d,f,v,p),f.length!==0&&m.push(new c(u,f,v))}},s=[],r=t.name||"default",a=t.fps||30,o=t.blendMode;let l=t.length||-1;const h=t.hierarchy||[];for(let c=0;c<h.length;c++){const u=h[c].keys;if(u&&u.length!==0)if(u[0].morphTargets){const d={};let p;for(p=0;p<u.length;p++)if(u[p].morphTargets)for(let m=0;m<u[p].morphTargets.length;m++)d[u[p].morphTargets[m]]=-1;for(const m in d){const f=[],v=[];for(let _=0;_!==u[p].morphTargets.length;++_){const y=u[p];f.push(y.time),v.push(y.morphTarget===m?1:0)}s.push(new kr(".morphTargetInfluence["+m+"]",f,v))}l=d.length*a}else{const d=".bones["+e[c].name+"]";i(Br,d+".position",u,"pos",s),i(Wn,d+".quaternion",u,"rot",s),i(Br,d+".scale",u,"scl",s)}}return s.length===0?null:new this(r,l,s,o)}resetDuration(){let t=0;for(let e=0,i=this.tracks.length;e!==i;++e){const s=this.tracks[e];t=Math.max(t,s.times[s.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function rb(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=function(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return kr;case"vector":case"vector2":case"vector3":case"vector4":return Br;case"color":return Ou;case"quaternion":return Wn;case"bool":case"boolean":return bs;case"string":return Ms}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}(n.type);if(n.times===void 0){const e=[],i=[];$t.flattenJSON(n.keys,e,i,"value"),n.times=e,n.values=i}return t.parse!==void 0?t.parse(n):new t(n.name,n.times,n.values,n.interpolation)}const ws={enabled:!1,files:{},add:function(n,t){this.enabled!==!1&&(this.files[n]=t)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class Kl{constructor(t,e,i){const s=this;let r,a=!1,o=0,l=0;const h=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this.itemStart=function(c){l++,a===!1&&s.onStart!==void 0&&s.onStart(c,o,l),a=!0},this.itemEnd=function(c){o++,s.onProgress!==void 0&&s.onProgress(c,o,l),o===l&&(a=!1,s.onLoad!==void 0&&s.onLoad())},this.itemError=function(c){s.onError!==void 0&&s.onError(c)},this.resolveURL=function(c){return r?r(c):c},this.setURLModifier=function(c){return r=c,this},this.addHandler=function(c,u){return h.push(c,u),this},this.removeHandler=function(c){const u=h.indexOf(c);return u!==-1&&h.splice(u,2),this},this.getHandler=function(c){for(let u=0,d=h.length;u<d;u+=2){const p=h[u],m=h[u+1];if(p.global&&(p.lastIndex=0),p.test(c))return m}return null}}}const Ss=new Kl;class Ge{constructor(t){this.manager=t!==void 0?t:Ss,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const i=this;return new Promise(function(s,r){i.load(t,s,e,r)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const Sn={};class _i extends Ge{constructor(t){super(t)}load(t,e,i,s){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=ws.get(t);if(r!==void 0)return this.manager.itemStart(t),setTimeout(()=>{e&&e(r),this.manager.itemEnd(t)},0),r;if(Sn[t]!==void 0)return void Sn[t].push({onLoad:e,onProgress:i,onError:s});Sn[t]=[],Sn[t].push({onLoad:e,onProgress:i,onError:s});const a=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,l=this.responseType;fetch(a).then(h=>{if(h.status===200||h.status===0){if(h.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||h.body===void 0||h.body.getReader===void 0)return h;const c=Sn[t],u=h.body.getReader(),d=h.headers.get("Content-Length"),p=d?parseInt(d):0,m=p!==0;let f=0;const v=new ReadableStream({start(_){(function y(){u.read().then(({done:x,value:b})=>{if(x)_.close();else{f+=b.byteLength;const w=new ProgressEvent("progress",{lengthComputable:m,loaded:f,total:p});for(let M=0,T=c.length;M<T;M++){const R=c[M];R.onProgress&&R.onProgress(w)}_.enqueue(b),y()}})})()}});return new Response(v)}throw Error(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`)}).then(h=>{switch(l){case"arraybuffer":return h.arrayBuffer();case"blob":return h.blob();case"document":return h.text().then(c=>new DOMParser().parseFromString(c,o));case"json":return h.json();default:if(o===void 0)return h.text();{const c=/charset="?([^;"\s]*)"?/i.exec(o),u=c&&c[1]?c[1].toLowerCase():void 0,d=new TextDecoder(u);return h.arrayBuffer().then(p=>d.decode(p))}}}).then(h=>{ws.add(t,h);const c=Sn[t];delete Sn[t];for(let u=0,d=c.length;u<d;u++){const p=c[u];p.onLoad&&p.onLoad(h)}}).catch(h=>{const c=Sn[t];if(c===void 0)throw this.manager.itemError(t),h;delete Sn[t];for(let u=0,d=c.length;u<d;u++){const p=c[u];p.onError&&p.onError(h)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Xa extends Ge{constructor(t){super(t)}load(t,e,i,s){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,a=ws.get(t);if(a!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(a),r.manager.itemEnd(t)},0),a;const o=wa("img");function l(){c(),ws.add(t,this),e&&e(this),r.manager.itemEnd(t)}function h(u){c(),s&&s(u),r.manager.itemError(t),r.manager.itemEnd(t)}function c(){o.removeEventListener("load",l,!1),o.removeEventListener("error",h,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",h,!1),t.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(t),o.src=t,o}}class zu extends Ge{constructor(t){super(t)}load(t,e,i,s){const r=new mr,a=new Xa(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function l(h){a.load(t[h],function(c){r.images[h]=c,o++,o===6&&(r.needsUpdate=!0,e&&e(r))},void 0,s)}for(let h=0;h<t.length;++h)l(h);return r}}class Gf extends Ge{constructor(t){super(t)}load(t,e,i,s){const r=this,a=new _s,o=new _i(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(t,function(l){const h=r.parse(l);h&&(h.image!==void 0?a.image=h.image:h.data!==void 0&&(a.image.width=h.width,a.image.height=h.height,a.image.data=h.data),a.wrapS=h.wrapS!==void 0?h.wrapS:1001,a.wrapT=h.wrapT!==void 0?h.wrapT:1001,a.magFilter=h.magFilter!==void 0?h.magFilter:1006,a.minFilter=h.minFilter!==void 0?h.minFilter:1006,a.anisotropy=h.anisotropy!==void 0?h.anisotropy:1,h.encoding!==void 0&&(a.encoding=h.encoding),h.flipY!==void 0&&(a.flipY=h.flipY),h.format!==void 0&&(a.format=h.format),h.type!==void 0&&(a.type=h.type),h.mipmaps!==void 0&&(a.mipmaps=h.mipmaps,a.minFilter=1008),h.mipmapCount===1&&(a.minFilter=1006),h.generateMipmaps!==void 0&&(a.generateMipmaps=h.generateMipmaps),a.needsUpdate=!0,e&&e(a,h))},i,s),a}}class Te extends Ge{constructor(t){super(t)}load(t,e,i,s){const r=new Gt,a=new Xa(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(t,function(o){r.image=o,r.needsUpdate=!0,e!==void 0&&e(r)},i,s),r}}class qn extends Mt{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new nt(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}class Uu extends qn{constructor(t,e,i){super(t,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Mt.DefaultUp),this.updateMatrix(),this.groundColor=new nt(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}}const jf=new at,Hf=new S,Wf=new S;class Fu{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new V(512,512),this.map=null,this.mapPass=null,this.matrix=new at,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new gr,this._frameExtents=new V(1,1),this._viewportCount=1,this._viewports=[new Ot(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;Hf.setFromMatrixPosition(t.matrixWorld),e.position.copy(Hf),Wf.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Wf),e.updateMatrixWorld(),jf.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(jf),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(e.projectionMatrix),i.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),this.mapSize.x===512&&this.mapSize.y===512||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class ab extends Fu{constructor(){super(new ee(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,i=2*ba*t.angle*this.focus,s=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;i===e.fov&&s===e.aspect&&r===e.far||(e.fov=i,e.aspect=s,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class Nu extends qn{constructor(t,e,i=0,s=Math.PI/3,r=0,a=1){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Mt.DefaultUp),this.updateMatrix(),this.target=new Mt,this.distance=i,this.angle=s,this.penumbra=r,this.decay=a,this.shadow=new ab}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const qf=new at,Ya=new S,ku=new S;class ob extends Fu{constructor(){super(new ee(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new V(4,2),this._viewportCount=6,this._viewports=[new Ot(2,1,1,1),new Ot(0,1,1,1),new Ot(3,1,1,1),new Ot(1,1,1,1),new Ot(3,0,1,1),new Ot(1,0,1,1)],this._cubeDirections=[new S(1,0,0),new S(-1,0,0),new S(0,0,1),new S(0,0,-1),new S(0,1,0),new S(0,-1,0)],this._cubeUps=[new S(0,1,0),new S(0,1,0),new S(0,1,0),new S(0,1,0),new S(0,0,1),new S(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,s=this.matrix,r=t.distance||i.far;r!==i.far&&(i.far=r,i.updateProjectionMatrix()),Ya.setFromMatrixPosition(t.matrixWorld),i.position.copy(Ya),ku.copy(i.position),ku.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(ku),i.updateMatrixWorld(),s.makeTranslation(-Ya.x,-Ya.y,-Ya.z),qf.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(qf)}}class Bu extends qn{constructor(t,e,i=0,s=1){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=s,this.shadow=new ob}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class lb extends Fu{constructor(){super(new vr(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class Ql extends qn{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Mt.DefaultUp),this.updateMatrix(),this.target=new Mt,this.shadow=new lb}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class Xf extends qn{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class Yf extends qn{constructor(t,e,i=10,s=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=i,this.height=s}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}class Zf{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new S)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const i=t.x,s=t.y,r=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.282095),e.addScaledVector(a[1],.488603*s),e.addScaledVector(a[2],.488603*r),e.addScaledVector(a[3],.488603*i),e.addScaledVector(a[4],i*s*1.092548),e.addScaledVector(a[5],s*r*1.092548),e.addScaledVector(a[6],.315392*(3*r*r-1)),e.addScaledVector(a[7],i*r*1.092548),e.addScaledVector(a[8],.546274*(i*i-s*s)),e}getIrradianceAt(t,e){const i=t.x,s=t.y,r=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.886227),e.addScaledVector(a[1],1.023328*s),e.addScaledVector(a[2],1.023328*r),e.addScaledVector(a[3],1.023328*i),e.addScaledVector(a[4],.858086*i*s),e.addScaledVector(a[5],.858086*s*r),e.addScaledVector(a[6],.743125*r*r-.247708),e.addScaledVector(a[7],.858086*i*r),e.addScaledVector(a[8],.429043*(i*i-s*s)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(t.coefficients[i],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let i=0;i<9;i++)this.coefficients[i].lerp(t.coefficients[i],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const i=this.coefficients;for(let s=0;s<9;s++)i[s].fromArray(t,e+3*s);return this}toArray(t=[],e=0){const i=this.coefficients;for(let s=0;s<9;s++)i[s].toArray(t,e+3*s);return t}static getBasisAt(t,e){const i=t.x,s=t.y,r=t.z;e[0]=.282095,e[1]=.488603*s,e[2]=.488603*r,e[3]=.488603*i,e[4]=1.092548*i*s,e[5]=1.092548*s*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*i*r,e[8]=.546274*(i*i-s*s)}}class $l extends qn{constructor(t=new Zf,e=1){super(void 0,e),this.isLightProbe=!0,this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}class Jf extends Ge{constructor(t){super(t),this.textures={}}load(t,e,i,s){const r=this,a=new _i(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(t,function(o){try{e(r.parse(JSON.parse(o)))}catch(l){s?s(l):console.error(l),r.manager.itemError(t)}},i,s)}parse(t){const e=this.textures;function i(r){return e[r]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",r),e[r]}const s=ae.fromType(t.type);if(t.uuid!==void 0&&(s.uuid=t.uuid),t.name!==void 0&&(s.name=t.name),t.color!==void 0&&s.color!==void 0&&s.color.setHex(t.color),t.roughness!==void 0&&(s.roughness=t.roughness),t.metalness!==void 0&&(s.metalness=t.metalness),t.sheen!==void 0&&(s.sheen=t.sheen),t.sheenColor!==void 0&&(s.sheenColor=new nt().setHex(t.sheenColor)),t.sheenRoughness!==void 0&&(s.sheenRoughness=t.sheenRoughness),t.emissive!==void 0&&s.emissive!==void 0&&s.emissive.setHex(t.emissive),t.specular!==void 0&&s.specular!==void 0&&s.specular.setHex(t.specular),t.specularIntensity!==void 0&&(s.specularIntensity=t.specularIntensity),t.specularColor!==void 0&&s.specularColor!==void 0&&s.specularColor.setHex(t.specularColor),t.shininess!==void 0&&(s.shininess=t.shininess),t.clearcoat!==void 0&&(s.clearcoat=t.clearcoat),t.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=t.clearcoatRoughness),t.iridescence!==void 0&&(s.iridescence=t.iridescence),t.iridescenceIOR!==void 0&&(s.iridescenceIOR=t.iridescenceIOR),t.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=t.iridescenceThicknessRange),t.transmission!==void 0&&(s.transmission=t.transmission),t.thickness!==void 0&&(s.thickness=t.thickness),t.attenuationDistance!==void 0&&(s.attenuationDistance=t.attenuationDistance),t.attenuationColor!==void 0&&s.attenuationColor!==void 0&&s.attenuationColor.setHex(t.attenuationColor),t.fog!==void 0&&(s.fog=t.fog),t.flatShading!==void 0&&(s.flatShading=t.flatShading),t.blending!==void 0&&(s.blending=t.blending),t.combine!==void 0&&(s.combine=t.combine),t.side!==void 0&&(s.side=t.side),t.shadowSide!==void 0&&(s.shadowSide=t.shadowSide),t.opacity!==void 0&&(s.opacity=t.opacity),t.transparent!==void 0&&(s.transparent=t.transparent),t.alphaTest!==void 0&&(s.alphaTest=t.alphaTest),t.depthTest!==void 0&&(s.depthTest=t.depthTest),t.depthWrite!==void 0&&(s.depthWrite=t.depthWrite),t.colorWrite!==void 0&&(s.colorWrite=t.colorWrite),t.stencilWrite!==void 0&&(s.stencilWrite=t.stencilWrite),t.stencilWriteMask!==void 0&&(s.stencilWriteMask=t.stencilWriteMask),t.stencilFunc!==void 0&&(s.stencilFunc=t.stencilFunc),t.stencilRef!==void 0&&(s.stencilRef=t.stencilRef),t.stencilFuncMask!==void 0&&(s.stencilFuncMask=t.stencilFuncMask),t.stencilFail!==void 0&&(s.stencilFail=t.stencilFail),t.stencilZFail!==void 0&&(s.stencilZFail=t.stencilZFail),t.stencilZPass!==void 0&&(s.stencilZPass=t.stencilZPass),t.wireframe!==void 0&&(s.wireframe=t.wireframe),t.wireframeLinewidth!==void 0&&(s.wireframeLinewidth=t.wireframeLinewidth),t.wireframeLinecap!==void 0&&(s.wireframeLinecap=t.wireframeLinecap),t.wireframeLinejoin!==void 0&&(s.wireframeLinejoin=t.wireframeLinejoin),t.rotation!==void 0&&(s.rotation=t.rotation),t.linewidth!==1&&(s.linewidth=t.linewidth),t.dashSize!==void 0&&(s.dashSize=t.dashSize),t.gapSize!==void 0&&(s.gapSize=t.gapSize),t.scale!==void 0&&(s.scale=t.scale),t.polygonOffset!==void 0&&(s.polygonOffset=t.polygonOffset),t.polygonOffsetFactor!==void 0&&(s.polygonOffsetFactor=t.polygonOffsetFactor),t.polygonOffsetUnits!==void 0&&(s.polygonOffsetUnits=t.polygonOffsetUnits),t.dithering!==void 0&&(s.dithering=t.dithering),t.alphaToCoverage!==void 0&&(s.alphaToCoverage=t.alphaToCoverage),t.premultipliedAlpha!==void 0&&(s.premultipliedAlpha=t.premultipliedAlpha),t.visible!==void 0&&(s.visible=t.visible),t.toneMapped!==void 0&&(s.toneMapped=t.toneMapped),t.userData!==void 0&&(s.userData=t.userData),t.vertexColors!==void 0&&(typeof t.vertexColors=="number"?s.vertexColors=t.vertexColors>0:s.vertexColors=t.vertexColors),t.uniforms!==void 0)for(const r in t.uniforms){const a=t.uniforms[r];switch(s.uniforms[r]={},a.type){case"t":s.uniforms[r].value=i(a.value);break;case"c":s.uniforms[r].value=new nt().setHex(a.value);break;case"v2":s.uniforms[r].value=new V().fromArray(a.value);break;case"v3":s.uniforms[r].value=new S().fromArray(a.value);break;case"v4":s.uniforms[r].value=new Ot().fromArray(a.value);break;case"m3":s.uniforms[r].value=new De().fromArray(a.value);break;case"m4":s.uniforms[r].value=new at().fromArray(a.value);break;default:s.uniforms[r].value=a.value}}if(t.defines!==void 0&&(s.defines=t.defines),t.vertexShader!==void 0&&(s.vertexShader=t.vertexShader),t.fragmentShader!==void 0&&(s.fragmentShader=t.fragmentShader),t.extensions!==void 0)for(const r in t.extensions)s.extensions[r]=t.extensions[r];if(t.shading!==void 0&&(s.flatShading=t.shading===1),t.size!==void 0&&(s.size=t.size),t.sizeAttenuation!==void 0&&(s.sizeAttenuation=t.sizeAttenuation),t.map!==void 0&&(s.map=i(t.map)),t.matcap!==void 0&&(s.matcap=i(t.matcap)),t.alphaMap!==void 0&&(s.alphaMap=i(t.alphaMap)),t.bumpMap!==void 0&&(s.bumpMap=i(t.bumpMap)),t.bumpScale!==void 0&&(s.bumpScale=t.bumpScale),t.normalMap!==void 0&&(s.normalMap=i(t.normalMap)),t.normalMapType!==void 0&&(s.normalMapType=t.normalMapType),t.normalScale!==void 0){let r=t.normalScale;Array.isArray(r)===!1&&(r=[r,r]),s.normalScale=new V().fromArray(r)}return t.displacementMap!==void 0&&(s.displacementMap=i(t.displacementMap)),t.displacementScale!==void 0&&(s.displacementScale=t.displacementScale),t.displacementBias!==void 0&&(s.displacementBias=t.displacementBias),t.roughnessMap!==void 0&&(s.roughnessMap=i(t.roughnessMap)),t.metalnessMap!==void 0&&(s.metalnessMap=i(t.metalnessMap)),t.emissiveMap!==void 0&&(s.emissiveMap=i(t.emissiveMap)),t.emissiveIntensity!==void 0&&(s.emissiveIntensity=t.emissiveIntensity),t.specularMap!==void 0&&(s.specularMap=i(t.specularMap)),t.specularIntensityMap!==void 0&&(s.specularIntensityMap=i(t.specularIntensityMap)),t.specularColorMap!==void 0&&(s.specularColorMap=i(t.specularColorMap)),t.envMap!==void 0&&(s.envMap=i(t.envMap)),t.envMapIntensity!==void 0&&(s.envMapIntensity=t.envMapIntensity),t.reflectivity!==void 0&&(s.reflectivity=t.reflectivity),t.refractionRatio!==void 0&&(s.refractionRatio=t.refractionRatio),t.lightMap!==void 0&&(s.lightMap=i(t.lightMap)),t.lightMapIntensity!==void 0&&(s.lightMapIntensity=t.lightMapIntensity),t.aoMap!==void 0&&(s.aoMap=i(t.aoMap)),t.aoMapIntensity!==void 0&&(s.aoMapIntensity=t.aoMapIntensity),t.gradientMap!==void 0&&(s.gradientMap=i(t.gradientMap)),t.clearcoatMap!==void 0&&(s.clearcoatMap=i(t.clearcoatMap)),t.clearcoatRoughnessMap!==void 0&&(s.clearcoatRoughnessMap=i(t.clearcoatRoughnessMap)),t.clearcoatNormalMap!==void 0&&(s.clearcoatNormalMap=i(t.clearcoatNormalMap)),t.clearcoatNormalScale!==void 0&&(s.clearcoatNormalScale=new V().fromArray(t.clearcoatNormalScale)),t.iridescenceMap!==void 0&&(s.iridescenceMap=i(t.iridescenceMap)),t.iridescenceThicknessMap!==void 0&&(s.iridescenceThicknessMap=i(t.iridescenceThicknessMap)),t.transmissionMap!==void 0&&(s.transmissionMap=i(t.transmissionMap)),t.thicknessMap!==void 0&&(s.thicknessMap=i(t.thicknessMap)),t.sheenColorMap!==void 0&&(s.sheenColorMap=i(t.sheenColorMap)),t.sheenRoughnessMap!==void 0&&(s.sheenRoughnessMap=i(t.sheenRoughnessMap)),s}setTextures(t){return this.textures=t,this}}class nn{static decodeText(t){if(typeof TextDecoder<"u")return new TextDecoder().decode(t);let e="";for(let i=0,s=t.length;i<s;i++)e+=String.fromCharCode(t[i]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.slice(0,e+1)}static resolveURL(t,e){return typeof t!="string"||t===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class th extends gt{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}class Kf extends Ge{constructor(t){super(t)}load(t,e,i,s){const r=this,a=new _i(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(t,function(o){try{e(r.parse(JSON.parse(o)))}catch(l){s?s(l):console.error(l),r.manager.itemError(t)}},i,s)}parse(t){const e={},i={};function s(u,d){if(e[d]!==void 0)return e[d];const p=u.interleavedBuffers[d],m=function(_,y){if(i[y]!==void 0)return i[y];const x=_.arrayBuffers[y],b=new Uint32Array(x).buffer;return i[y]=b,b}(u,p.buffer),f=er(p.type,m),v=new xr(f,p.stride);return v.uuid=p.uuid,e[d]=v,v}const r=t.isInstancedBufferGeometry?new th:new gt,a=t.data.index;if(a!==void 0){const u=er(a.type,a.array);r.setIndex(new Lt(u,1))}const o=t.data.attributes;for(const u in o){const d=o[u];let p;if(d.isInterleavedBufferAttribute){const m=s(t.data,d.data);p=new Ki(m,d.itemSize,d.offset,d.normalized)}else{const m=er(d.type,d.array);p=new(d.isInstancedBufferAttribute?Di:Lt)(m,d.itemSize,d.normalized)}d.name!==void 0&&(p.name=d.name),d.usage!==void 0&&p.setUsage(d.usage),d.updateRange!==void 0&&(p.updateRange.offset=d.updateRange.offset,p.updateRange.count=d.updateRange.count),r.setAttribute(u,p)}const l=t.data.morphAttributes;if(l)for(const u in l){const d=l[u],p=[];for(let m=0,f=d.length;m<f;m++){const v=d[m];let _;if(v.isInterleavedBufferAttribute){const y=s(t.data,v.data);_=new Ki(y,v.itemSize,v.offset,v.normalized)}else{const y=er(v.type,v.array);_=new Lt(y,v.itemSize,v.normalized)}v.name!==void 0&&(_.name=v.name),p.push(_)}r.morphAttributes[u]=p}t.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);const h=t.data.groups||t.data.drawcalls||t.data.offsets;if(h!==void 0)for(let u=0,d=h.length;u!==d;++u){const p=h[u];r.addGroup(p.start,p.count,p.materialIndex)}const c=t.data.boundingSphere;if(c!==void 0){const u=new S;c.center!==void 0&&u.fromArray(c.center),r.boundingSphere=new ii(u,c.radius)}return t.name&&(r.name=t.name),t.userData&&(r.userData=t.userData),r}}const hb={UVMapping:300,CubeReflectionMapping:301,CubeRefractionMapping:302,EquirectangularReflectionMapping:303,EquirectangularRefractionMapping:304,CubeUVReflectionMapping:306},Qf={RepeatWrapping:1e3,ClampToEdgeWrapping:1001,MirroredRepeatWrapping:1002},$f={NearestFilter:1003,NearestMipmapNearestFilter:1004,NearestMipmapLinearFilter:1005,LinearFilter:1006,LinearMipmapNearestFilter:1007,LinearMipmapLinearFilter:1008};class tg extends Ge{constructor(t){super(t),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,i,s){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,a=ws.get(t);if(a!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(a),r.manager.itemEnd(t)},0),a;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,fetch(t,o).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(l){ws.add(t,l),e&&e(l),r.manager.itemEnd(t)}).catch(function(l){s&&s(l),r.manager.itemError(t),r.manager.itemEnd(t)}),r.manager.itemStart(t)}}let eh;const Vu={getContext:function(){return eh===void 0&&(eh=new(window.AudioContext||window.webkitAudioContext)),eh},setContext:function(n){eh=n}},eg=new at,ig=new at,Ts=new at;class ng{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=sg(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=sg();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function sg(){return(typeof performance>"u"?Date:performance).now()}const Es=new S,rg=new Ft,cb=new S,Cs=new S;class ag extends Mt{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0)return void console.warn("THREE.Audio: Audio is already playing.");if(this.hasPlaybackControl===!1)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl!==!1)return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(this.hasPlaybackControl!==!1)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl!==!1)return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl!==!1)return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}const As=new S,og=new Ft,ub=new S,Ps=new S;class lg{constructor(t,e,i){let s,r,a;switch(this.binding=t,this.valueSize=i,e){case"quaternion":s=this._slerp,r=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*i),this._workIndex=5;break;case"string":case"bool":s=this._select,r=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(5*i);break;default:s=this._lerp,r=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*i)}this._mixBufferRegion=s,this._mixBufferRegionAdditive=r,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const i=this.buffer,s=this.valueSize,r=t*s+s;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==s;++o)i[r+o]=i[o];a=e}else{a+=e;const o=e/a;this._mixBufferRegion(i,r,0,o,s)}this.cumulativeWeight=a}accumulateAdditive(t){const e=this.buffer,i=this.valueSize,s=i*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,s,0,t,i),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,i=this.buffer,s=t*e+e,r=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const l=e*this._origIndex;this._mixBufferRegion(i,s,l,1-r,e)}a>0&&this._mixBufferRegionAdditive(i,s,this._addIndex*e,1,e);for(let l=e,h=e+e;l!==h;++l)if(i[l]!==i[l+e]){o.setValue(i,s);break}}saveOriginalState(){const t=this.binding,e=this.buffer,i=this.valueSize,s=i*this._origIndex;t.getValue(e,s);for(let r=i,a=s;r!==a;++r)e[r]=e[s+r%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let i=t;i<e;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[e+i]=this.buffer[t+i]}_select(t,e,i,s,r){if(s>=.5)for(let a=0;a!==r;++a)t[e+a]=t[i+a]}_slerp(t,e,i,s){Ft.slerpFlat(t,e,t,e,t,i,s)}_slerpAdditive(t,e,i,s,r){const a=this._workIndex*r;Ft.multiplyQuaternionsFlat(t,a,t,e,t,i),Ft.slerpFlat(t,e,t,e,t,a,s)}_lerp(t,e,i,s,r){const a=1-s;for(let o=0;o!==r;++o){const l=e+o;t[l]=t[l]*a+t[i+o]*s}}_lerpAdditive(t,e,i,s,r){for(let a=0;a!==r;++a){const o=e+a;t[o]=t[o]+t[i+a]*s}}}const db="\\[\\]\\.:\\/",pb=new RegExp("[\\[\\]\\.:\\/]","g"),Gu="[^\\[\\]\\.:\\/]",mb="[^"+db.replace("\\.","")+"]",fb=/((?:WC+[\/:])*)/.source.replace("WC",Gu),gb=/(WCOD+)?/.source.replace("WCOD",mb),vb=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Gu),_b=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Gu),yb=new RegExp("^"+fb+gb+vb+_b+"$"),xb=["material","materials","bones"];class Nt{constructor(t,e,i){this.path=e,this.parsedPath=i||Nt.parseTrackName(e),this.node=Nt.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,i){return t&&t.isAnimationObjectGroup?new Nt.Composite(t,e,i):new Nt(t,e,i)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(pb,"")}static parseTrackName(t){const e=yb.exec(t);if(e===null)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const i={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},s=i.nodeName&&i.nodeName.lastIndexOf(".");if(s!==void 0&&s!==-1){const r=i.nodeName.substring(s+1);xb.indexOf(r)!==-1&&(i.nodeName=i.nodeName.substring(0,s),i.objectName=r)}if(i.propertyName===null||i.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return i}static findNode(t,e){if(e===void 0||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const i=t.skeleton.getBoneByName(e);if(i!==void 0)return i}if(t.children){const i=function(r){for(let a=0;a<r.length;a++){const o=r[a];if(o.name===e||o.uuid===e)return o;const l=i(o.children);if(l)return l}return null},s=i(t.children);if(s)return s}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)t[e++]=i[s]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)i[s]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)i[s]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)i[s]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,i=e.objectName,s=e.propertyName;let r=e.propertyIndex;if(t||(t=Nt.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(i){let h=e.objectIndex;switch(i){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let c=0;c<t.length;c++)if(t[c].name===h){h=c;break}break;default:if(t[i]===void 0)return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[i]}if(h!==void 0){if(t[h]===void 0)return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[h]}}const a=t[s];if(a===void 0){const h=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+h+"."+s+" but it wasn't found.",t)}let o=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(s==="morphTargetInfluences"){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);t.morphTargetDictionary[r]!==void 0&&(r=t.morphTargetDictionary[r])}l=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=r}else a.fromArray!==void 0&&a.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(l=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=s;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Nt.Composite=class{constructor(n,t,e){const i=e||Nt.parseTrackName(t);this._targetGroup=n,this._bindings=n.subscribe_(t,i)}getValue(n,t){this.bind();const e=this._targetGroup.nCachedObjects_,i=this._bindings[e];i!==void 0&&i.getValue(n,t)}setValue(n,t){const e=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=e.length;i!==s;++i)e[i].setValue(n,t)}bind(){const n=this._bindings;for(let t=this._targetGroup.nCachedObjects_,e=n.length;t!==e;++t)n[t].bind()}unbind(){const n=this._bindings;for(let t=this._targetGroup.nCachedObjects_,e=n.length;t!==e;++t)n[t].unbind()}},Nt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Nt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Nt.prototype.GetterByBindingType=[Nt.prototype._getValue_direct,Nt.prototype._getValue_array,Nt.prototype._getValue_arrayElement,Nt.prototype._getValue_toArray],Nt.prototype.SetterByBindingTypeAndVersioning=[[Nt.prototype._setValue_direct,Nt.prototype._setValue_direct_setNeedsUpdate,Nt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Nt.prototype._setValue_array,Nt.prototype._setValue_array_setNeedsUpdate,Nt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Nt.prototype._setValue_arrayElement,Nt.prototype._setValue_arrayElement_setNeedsUpdate,Nt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Nt.prototype._setValue_fromArray,Nt.prototype._setValue_fromArray_setNeedsUpdate,Nt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class bb{constructor(t,e,i=null,s=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=i,this.blendMode=s;const r=e.tracks,a=r.length,o=new Array(a),l={endingStart:2400,endingEnd:2400};for(let h=0;h!==a;++h){const c=r[h].createInterpolant(null);o[h]=c,c.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,i){if(t.fadeOut(e),this.fadeIn(e),i){const s=this._clip.duration,r=t._clip.duration,a=r/s,o=s/r;t.warp(1,a,e),this.warp(o,1,e)}return this}crossFadeTo(t,e,i){return t.crossFadeFrom(this,e,i)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,i){const s=this._mixer,r=s.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=s._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,h=o.sampleValues;return l[0]=r,l[1]=r+i,h[0]=t/a,h[1]=e/a,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,i,s){if(!this.enabled)return void this._updateWeight(t);const r=this._startTime;if(r!==null){const l=(t-r)*i;if(l<0||i===0)return;this._startTime=null,e=i*l}e*=this._updateTimeScale(t);const a=this._updateTime(e),o=this._updateWeight(t);if(o>0){const l=this._interpolants,h=this._propertyBindings;if(this.blendMode===2501)for(let c=0,u=l.length;c!==u;++c)l[c].evaluate(a),h[c].accumulateAdditive(o);else for(let c=0,u=l.length;c!==u;++c)l[c].evaluate(a),h[c].accumulate(s,o)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const i=this._weightInterpolant;if(i!==null){const s=i.evaluate(t)[0];e*=s,t>i.parameterPositions[1]&&(this.stopFading(),s===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const i=this._timeScaleInterpolant;i!==null&&(e*=i.evaluate(t)[0],t>i.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,i=this.loop;let s=this.time+t,r=this._loopCount;const a=i===2202;if(t===0)return r===-1?s:a&&(1&r)==1?e-s:s;if(i===2200){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(s>=e)s=e;else{if(!(s<0)){this.time=s;break t}s=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(r===-1&&(t>=0?(r=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),s>=e||s<0){const o=Math.floor(s/e);s-=e*o,r+=Math.abs(o);const l=this.repetitions-r;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,s=t>0?e:0,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(l===1){const h=t<0;this._setEndings(h,!h,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this.time=s,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=s;if(a&&(1&r)==1)return e-s}return s}_setEndings(t,e,i){const s=this._interpolantSettings;i?(s.endingStart=2401,s.endingEnd=2401):(s.endingStart=t?this.zeroSlopeAtStart?2401:2400:2402,s.endingEnd=e?this.zeroSlopeAtEnd?2401:2400:2402)}_scheduleFading(t,e,i){const s=this._mixer,r=s.time;let a=this._weightInterpolant;a===null&&(a=s._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=r,l[0]=e,o[1]=r+t,l[1]=i,this}}const Mb=new Float32Array(1);class ju{constructor(t){typeof t=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new ju(this.value.clone===void 0?this.value:this.value.clone())}}class Rs{constructor(t,e,i=0,s=1/0){this.ray=new kn(t,e),this.near=i,this.far=s,this.camera=null,this.layers=new cl,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!0,i=[]){return Hu(t,this,i,e),i.sort(hg),i}intersectObjects(t,e=!0,i=[]){for(let s=0,r=t.length;s<r;s++)Hu(t[s],this,i,e);return i.sort(hg),i}}function hg(n,t){return n.distance-t.distance}function Hu(n,t,e,i){if(n.layers.test(t.layers)&&n.raycast(t,e),i===!0){const s=n.children;for(let r=0,a=s.length;r<a;r++)Hu(s[r],t,e,!0)}}const cg=new V;class ug{constructor(t=new V(1/0,1/0),e=new V(-1/0,-1/0)){this.isBox2=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=cg.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return cg.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const dg=new S,ih=new S,pg=new S,Xn=new S,nh=new at,Wu=new at;function mg(n){const t=[];n.isBone===!0&&t.push(n);for(let e=0;e<n.children.length;e++)t.push.apply(t,mg(n.children[e]));return t}const wb=new S,fg=new nt,gg=new nt,vg=new S,sh=new S,_g=new S,rh=new S,le=new Ml;function pe(n,t,e,i,s,r,a){rh.set(s,r,a).unproject(i);const o=t[n];if(o!==void 0){const l=e.getAttribute("position");for(let h=0,c=o.length;h<c;h++)l.setXYZ(o[h],rh.x,rh.y,rh.z)}}const ah=new Ne;class yg extends vi{constructor(t,e=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=new gt;s.setIndex(new Lt(i,1)),s.setAttribute("position",new Z([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(s,new _e({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}}const xg=new S;let oh,qu;class Za{static toHalfFloat(t){Math.abs(t)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),t=de(t,-65504,65504),Mg[0]=t;const e=wg[0],i=e>>23&511;return Ni[i]+((8388607&e)>>ki[i])}static fromHalfFloat(t){const e=t>>10;return wg[0]=Xu[Sg[e]+(1023&t)]+Gr[e],Mg[0]}}const bg=new ArrayBuffer(4),Mg=new Float32Array(bg),wg=new Uint32Array(bg),Ni=new Uint32Array(512),ki=new Uint32Array(512);for(let n=0;n<256;++n){const t=n-127;t<-27?(Ni[n]=0,Ni[256|n]=32768,ki[n]=24,ki[256|n]=24):t<-14?(Ni[n]=1024>>-t-14,Ni[256|n]=1024>>-t-14|32768,ki[n]=-t-1,ki[256|n]=-t-1):t<=15?(Ni[n]=t+15<<10,Ni[256|n]=t+15<<10|32768,ki[n]=13,ki[256|n]=13):t<128?(Ni[n]=31744,Ni[256|n]=64512,ki[n]=24,ki[256|n]=24):(Ni[n]=31744,Ni[256|n]=64512,ki[n]=13,ki[256|n]=13)}const Xu=new Uint32Array(2048),Gr=new Uint32Array(64),Sg=new Uint32Array(64);for(let n=1;n<1024;++n){let t=n<<13,e=0;for(;!(8388608&t);)t<<=1,e-=8388608;t&=-8388609,e+=947912704,Xu[n]=t|e}for(let n=1024;n<2048;++n)Xu[n]=939524096+(n-1024<<13);for(let n=1;n<31;++n)Gr[n]=n<<23;Gr[31]=1199570944,Gr[32]=2147483648;for(let n=33;n<63;++n)Gr[n]=2147483648+(n-32<<23);Gr[63]=3347054592;for(let n=1;n<64;++n)n!==32&&(Sg[n]=1024);typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:ti}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=ti);const Tg=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:4,AddEquation:100,AddOperation:2,AdditiveAnimationBlendMode:2501,AdditiveBlending:2,AlphaFormat:1021,AlwaysDepth:1,AlwaysStencilFunc:519,AmbientLight:Xf,AmbientLightProbe:class extends $l{constructor(n,t=1){super(void 0,t),this.isAmbientLightProbe=!0;const e=new nt().set(n);this.sh.coefficients[0].set(e.r,e.g,e.b).multiplyScalar(2*Math.sqrt(Math.PI))}},AnimationClip:Vr,AnimationLoader:class extends Ge{constructor(n){super(n)}load(n,t,e,i){const s=this,r=new _i(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(n,function(a){try{t(s.parse(JSON.parse(a)))}catch(o){i?i(o):console.error(o),s.manager.itemError(n)}},e,i)}parse(n){const t=[];for(let e=0;e<n.length;e++){const i=Vr.parse(n[e]);t.push(i)}return t}},AnimationMixer:class extends Ji{constructor(n){super(),this._root=n,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(n,t){const e=n._localRoot||this._root,i=n._clip.tracks,s=i.length,r=n._propertyBindings,a=n._interpolants,o=e.uuid,l=this._bindingsByRootAndName;let h=l[o];h===void 0&&(h={},l[o]=h);for(let c=0;c!==s;++c){const u=i[c],d=u.name;let p=h[d];if(p!==void 0)++p.referenceCount,r[c]=p;else{if(p=r[c],p!==void 0){p._cacheIndex===null&&(++p.referenceCount,this._addInactiveBinding(p,o,d));continue}const m=t&&t._propertyBindings[c].binding.parsedPath;p=new lg(Nt.create(e,d,m),u.ValueTypeName,u.getValueSize()),++p.referenceCount,this._addInactiveBinding(p,o,d),r[c]=p}a[c].resultBuffer=p.buffer}}_activateAction(n){if(!this._isActiveAction(n)){if(n._cacheIndex===null){const e=(n._localRoot||this._root).uuid,i=n._clip.uuid,s=this._actionsByClip[i];this._bindAction(n,s&&s.knownActions[0]),this._addInactiveAction(n,i,e)}const t=n._propertyBindings;for(let e=0,i=t.length;e!==i;++e){const s=t[e];s.useCount++==0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(n)}}_deactivateAction(n){if(this._isActiveAction(n)){const t=n._propertyBindings;for(let e=0,i=t.length;e!==i;++e){const s=t[e];--s.useCount==0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(n)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const n=this;this.stats={actions:{get total(){return n._actions.length},get inUse(){return n._nActiveActions}},bindings:{get total(){return n._bindings.length},get inUse(){return n._nActiveBindings}},controlInterpolants:{get total(){return n._controlInterpolants.length},get inUse(){return n._nActiveControlInterpolants}}}}_isActiveAction(n){const t=n._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(n,t,e){const i=this._actions,s=this._actionsByClip;let r=s[t];if(r===void 0)r={knownActions:[n],actionByRoot:{}},n._byClipCacheIndex=0,s[t]=r;else{const a=r.knownActions;n._byClipCacheIndex=a.length,a.push(n)}n._cacheIndex=i.length,i.push(n),r.actionByRoot[e]=n}_removeInactiveAction(n){const t=this._actions,e=t[t.length-1],i=n._cacheIndex;e._cacheIndex=i,t[i]=e,t.pop(),n._cacheIndex=null;const s=n._clip.uuid,r=this._actionsByClip,a=r[s],o=a.knownActions,l=o[o.length-1],h=n._byClipCacheIndex;l._byClipCacheIndex=h,o[h]=l,o.pop(),n._byClipCacheIndex=null,delete a.actionByRoot[(n._localRoot||this._root).uuid],o.length===0&&delete r[s],this._removeInactiveBindingsForAction(n)}_removeInactiveBindingsForAction(n){const t=n._propertyBindings;for(let e=0,i=t.length;e!==i;++e){const s=t[e];--s.referenceCount==0&&this._removeInactiveBinding(s)}}_lendAction(n){const t=this._actions,e=n._cacheIndex,i=this._nActiveActions++,s=t[i];n._cacheIndex=i,t[i]=n,s._cacheIndex=e,t[e]=s}_takeBackAction(n){const t=this._actions,e=n._cacheIndex,i=--this._nActiveActions,s=t[i];n._cacheIndex=i,t[i]=n,s._cacheIndex=e,t[e]=s}_addInactiveBinding(n,t,e){const i=this._bindingsByRootAndName,s=this._bindings;let r=i[t];r===void 0&&(r={},i[t]=r),r[e]=n,n._cacheIndex=s.length,s.push(n)}_removeInactiveBinding(n){const t=this._bindings,e=n.binding,i=e.rootNode.uuid,s=e.path,r=this._bindingsByRootAndName,a=r[i],o=t[t.length-1],l=n._cacheIndex;o._cacheIndex=l,t[l]=o,t.pop(),delete a[s],Object.keys(a).length===0&&delete r[i]}_lendBinding(n){const t=this._bindings,e=n._cacheIndex,i=this._nActiveBindings++,s=t[i];n._cacheIndex=i,t[i]=n,s._cacheIndex=e,t[e]=s}_takeBackBinding(n){const t=this._bindings,e=n._cacheIndex,i=--this._nActiveBindings,s=t[i];n._cacheIndex=i,t[i]=n,s._cacheIndex=e,t[e]=s}_lendControlInterpolant(){const n=this._controlInterpolants,t=this._nActiveControlInterpolants++;let e=n[t];return e===void 0&&(e=new Du(new Float32Array(2),new Float32Array(2),1,Mb),e.__cacheIndex=t,n[t]=e),e}_takeBackControlInterpolant(n){const t=this._controlInterpolants,e=n.__cacheIndex,i=--this._nActiveControlInterpolants,s=t[i];n.__cacheIndex=i,t[i]=n,s.__cacheIndex=e,t[e]=s}clipAction(n,t,e){const i=t||this._root,s=i.uuid;let r=typeof n=="string"?Vr.findByName(i,n):n;const a=r!==null?r.uuid:n,o=this._actionsByClip[a];let l=null;if(e===void 0&&(e=r!==null?r.blendMode:2500),o!==void 0){const c=o.actionByRoot[s];if(c!==void 0&&c.blendMode===e)return c;l=o.knownActions[0],r===null&&(r=l._clip)}if(r===null)return null;const h=new bb(this,r,t,e);return this._bindAction(h,l),this._addInactiveAction(h,a,s),h}existingAction(n,t){const e=t||this._root,i=e.uuid,s=typeof n=="string"?Vr.findByName(e,n):n,r=s?s.uuid:n,a=this._actionsByClip[r];return a!==void 0&&a.actionByRoot[i]||null}stopAllAction(){const n=this._actions;for(let t=this._nActiveActions-1;t>=0;--t)n[t].stop();return this}update(n){n*=this.timeScale;const t=this._actions,e=this._nActiveActions,i=this.time+=n,s=Math.sign(n),r=this._accuIndex^=1;for(let l=0;l!==e;++l)t[l]._update(i,n,s,r);const a=this._bindings,o=this._nActiveBindings;for(let l=0;l!==o;++l)a[l].apply(r);return this}setTime(n){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(n)}getRoot(){return this._root}uncacheClip(n){const t=this._actions,e=n.uuid,i=this._actionsByClip,s=i[e];if(s!==void 0){const r=s.knownActions;for(let a=0,o=r.length;a!==o;++a){const l=r[a];this._deactivateAction(l);const h=l._cacheIndex,c=t[t.length-1];l._cacheIndex=null,l._byClipCacheIndex=null,c._cacheIndex=h,t[h]=c,t.pop(),this._removeInactiveBindingsForAction(l)}delete i[e]}}uncacheRoot(n){const t=n.uuid,e=this._actionsByClip;for(const s in e){const r=e[s].actionByRoot[t];r!==void 0&&(this._deactivateAction(r),this._removeInactiveAction(r))}const i=this._bindingsByRootAndName[t];if(i!==void 0)for(const s in i){const r=i[s];r.restoreOriginalState(),this._removeInactiveBinding(r)}}uncacheAction(n,t){const e=this.existingAction(n,t);e!==null&&(this._deactivateAction(e),this._removeInactiveAction(e))}},AnimationObjectGroup:class{constructor(){this.isAnimationObjectGroup=!0,this.uuid=ei(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const n={};this._indicesByUUID=n;for(let e=0,i=arguments.length;e!==i;++e)n[arguments[e].uuid]=e;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const n=this._objects,t=this._indicesByUUID,e=this._paths,i=this._parsedPaths,s=this._bindings,r=s.length;let a,o=n.length,l=this.nCachedObjects_;for(let h=0,c=arguments.length;h!==c;++h){const u=arguments[h],d=u.uuid;let p=t[d];if(p===void 0){p=o++,t[d]=p,n.push(u);for(let m=0,f=r;m!==f;++m)s[m].push(new Nt(u,e[m],i[m]))}else if(p<l){a=n[p];const m=--l,f=n[m];t[f.uuid]=p,n[p]=f,t[d]=m,n[m]=u;for(let v=0,_=r;v!==_;++v){const y=s[v],x=y[m];let b=y[p];y[p]=x,b===void 0&&(b=new Nt(u,e[v],i[v])),y[m]=b}}else n[p]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const n=this._objects,t=this._indicesByUUID,e=this._bindings,i=e.length;let s=this.nCachedObjects_;for(let r=0,a=arguments.length;r!==a;++r){const o=arguments[r],l=o.uuid,h=t[l];if(h!==void 0&&h>=s){const c=s++,u=n[c];t[u.uuid]=h,n[h]=u,t[l]=c,n[c]=o;for(let d=0,p=i;d!==p;++d){const m=e[d],f=m[c],v=m[h];m[h]=f,m[c]=v}}}this.nCachedObjects_=s}uncache(){const n=this._objects,t=this._indicesByUUID,e=this._bindings,i=e.length;let s=this.nCachedObjects_,r=n.length;for(let a=0,o=arguments.length;a!==o;++a){const l=arguments[a].uuid,h=t[l];if(h!==void 0)if(delete t[l],h<s){const c=--s,u=n[c],d=--r,p=n[d];t[u.uuid]=h,n[h]=u,t[p.uuid]=c,n[c]=p,n.pop();for(let m=0,f=i;m!==f;++m){const v=e[m],_=v[c],y=v[d];v[h]=_,v[c]=y,v.pop()}}else{const c=--r,u=n[c];c>0&&(t[u.uuid]=h),n[h]=u,n.pop();for(let d=0,p=i;d!==p;++d){const m=e[d];m[h]=m[c],m.pop()}}}this.nCachedObjects_=s}subscribe_(n,t){const e=this._bindingsIndicesByPath;let i=e[n];const s=this._bindings;if(i!==void 0)return s[i];const r=this._paths,a=this._parsedPaths,o=this._objects,l=o.length,h=this.nCachedObjects_,c=new Array(l);i=s.length,e[n]=i,r.push(n),a.push(t),s.push(c);for(let u=h,d=o.length;u!==d;++u){const p=o[u];c[u]=new Nt(p,n,t)}return c}unsubscribe_(n){const t=this._bindingsIndicesByPath,e=t[n];if(e!==void 0){const i=this._paths,s=this._parsedPaths,r=this._bindings,a=r.length-1,o=r[a];t[n[a]]=e,r[e]=o,r.pop(),s[e]=s[a],s.pop(),i[e]=i[a],i.pop()}}},AnimationUtils:$t,ArcCurve:vf,ArrayCamera:Ym,ArrowHelper:class extends Mt{constructor(n=new S(0,0,1),t=new S(0,0,0),e=1,i=16776960,s=.2*e,r=.2*s){super(),this.type="ArrowHelper",oh===void 0&&(oh=new gt,oh.setAttribute("position",new Z([0,0,0,0,1,0],3)),qu=new oe(0,.5,1,5,1),qu.translate(0,-.5,0)),this.position.copy(t),this.line=new we(oh,new _e({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new ot(qu,new Zt({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(n),this.setLength(e,s,r)}setDirection(n){if(n.y>.99999)this.quaternion.set(0,0,0,1);else if(n.y<-.99999)this.quaternion.set(1,0,0,0);else{xg.set(n.z,0,-n.x).normalize();const t=Math.acos(n.y);this.quaternion.setFromAxisAngle(xg,t)}}setLength(n,t=.2*n,e=.2*t){this.line.scale.set(1,Math.max(1e-4,n-t),1),this.line.updateMatrix(),this.cone.scale.set(e,t,e),this.cone.position.y=n,this.cone.updateMatrix()}setColor(n){this.line.material.color.set(n),this.cone.material.color.set(n)}copy(n){return super.copy(n,!1),this.line.copy(n.line),this.cone.copy(n.cone),this}},Audio:ag,AudioAnalyser:class{constructor(n,t=2048){this.analyser=n.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),n.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let n=0;const t=this.getFrequencyData();for(let e=0;e<t.length;e++)n+=t[e];return n/t.length}},AudioContext:Vu,AudioListener:class extends Mt{constructor(){super(),this.type="AudioListener",this.context=Vu.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new ng}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(n){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=n,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(n){return this.gain.gain.setTargetAtTime(n,this.context.currentTime,.01),this}updateMatrixWorld(n){super.updateMatrixWorld(n);const t=this.context.listener,e=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Es,rg,cb),Cs.set(0,0,-1).applyQuaternion(rg),t.positionX){const i=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Es.x,i),t.positionY.linearRampToValueAtTime(Es.y,i),t.positionZ.linearRampToValueAtTime(Es.z,i),t.forwardX.linearRampToValueAtTime(Cs.x,i),t.forwardY.linearRampToValueAtTime(Cs.y,i),t.forwardZ.linearRampToValueAtTime(Cs.z,i),t.upX.linearRampToValueAtTime(e.x,i),t.upY.linearRampToValueAtTime(e.y,i),t.upZ.linearRampToValueAtTime(e.z,i)}else t.setPosition(Es.x,Es.y,Es.z),t.setOrientation(Cs.x,Cs.y,Cs.z,e.x,e.y,e.z)}},AudioLoader:class extends Ge{constructor(n){super(n)}load(n,t,e,i){const s=this,r=new _i(this.manager);r.setResponseType("arraybuffer"),r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(n,function(a){try{const o=a.slice(0);Vu.getContext().decodeAudioData(o,function(l){t(l)})}catch(o){i?i(o):console.error(o),s.manager.itemError(n)}},e,i)}},AxesHelper:class extends vi{constructor(n=1){const t=[0,0,0,n,0,0,0,0,0,0,n,0,0,0,0,0,0,n],e=new gt;e.setAttribute("position",new Z(t,3)),e.setAttribute("color",new Z([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(e,new _e({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(n,t,e){const i=new nt,s=this.geometry.attributes.color.array;return i.set(n),i.toArray(s,0),i.toArray(s,3),i.set(t),i.toArray(s,6),i.toArray(s,9),i.set(e),i.toArray(s,12),i.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}},BackSide:1,BasicDepthPacking:3200,BasicShadowMap:0,Bone:zl,BooleanKeyframeTrack:bs,Box2:ug,Box3:Ne,Box3Helper:yg,BoxBufferGeometry:Wt,BoxGeometry:Wt,BoxHelper:class extends vi{constructor(n,t=16776960){const e=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),s=new gt;s.setIndex(new Lt(e,1)),s.setAttribute("position",new Lt(i,3)),super(s,new _e({color:t,toneMapped:!1})),this.object=n,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(n){if(n!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&ah.setFromObject(this.object),ah.isEmpty())return;const t=ah.min,e=ah.max,i=this.geometry.attributes.position,s=i.array;s[0]=e.x,s[1]=e.y,s[2]=e.z,s[3]=t.x,s[4]=e.y,s[5]=e.z,s[6]=t.x,s[7]=t.y,s[8]=e.z,s[9]=e.x,s[10]=t.y,s[11]=e.z,s[12]=e.x,s[13]=e.y,s[14]=t.z,s[15]=t.x,s[16]=e.y,s[17]=t.z,s[18]=t.x,s[19]=t.y,s[20]=t.z,s[21]=e.x,s[22]=t.y,s[23]=t.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(n){return this.object=n,this.update(),this}copy(n,t){return super.copy(n,t),this.object=n.object,this}},BufferAttribute:Lt,BufferGeometry:gt,BufferGeometryLoader:Kf,ByteType:1010,Cache:ws,Camera:Ml,CameraHelper:class extends vi{constructor(n){const t=new gt,e=new _e({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],s=[],r={},a=new nt(16755200),o=new nt(16711680),l=new nt(43775),h=new nt(16777215),c=new nt(3355443);function u(p,m,f){d(p,f),d(m,f)}function d(p,m){i.push(0,0,0),s.push(m.r,m.g,m.b),r[p]===void 0&&(r[p]=[]),r[p].push(i.length/3-1)}u("n1","n2",a),u("n2","n4",a),u("n4","n3",a),u("n3","n1",a),u("f1","f2",a),u("f2","f4",a),u("f4","f3",a),u("f3","f1",a),u("n1","f1",a),u("n2","f2",a),u("n3","f3",a),u("n4","f4",a),u("p","n1",o),u("p","n2",o),u("p","n3",o),u("p","n4",o),u("u1","u2",l),u("u2","u3",l),u("u3","u1",l),u("c","t",h),u("p","c",c),u("cn1","cn2",c),u("cn3","cn4",c),u("cf1","cf2",c),u("cf3","cf4",c),t.setAttribute("position",new Z(i,3)),t.setAttribute("color",new Z(s,3)),super(t,e),this.type="CameraHelper",this.camera=n,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=n.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=r,this.update()}update(){const n=this.geometry,t=this.pointMap;le.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),pe("c",t,n,le,0,0,-1),pe("t",t,n,le,0,0,1),pe("n1",t,n,le,-1,-1,-1),pe("n2",t,n,le,1,-1,-1),pe("n3",t,n,le,-1,1,-1),pe("n4",t,n,le,1,1,-1),pe("f1",t,n,le,-1,-1,1),pe("f2",t,n,le,1,-1,1),pe("f3",t,n,le,-1,1,1),pe("f4",t,n,le,1,1,1),pe("u1",t,n,le,.7,1.1,-1),pe("u2",t,n,le,-.7,1.1,-1),pe("u3",t,n,le,0,2,-1),pe("cf1",t,n,le,-1,0,1),pe("cf2",t,n,le,1,0,1),pe("cf3",t,n,le,0,-1,1),pe("cf4",t,n,le,0,1,1),pe("cn1",t,n,le,-1,0,-1),pe("cn2",t,n,le,1,0,-1),pe("cn3",t,n,le,0,-1,-1),pe("cn4",t,n,le,0,1,-1),n.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}},CanvasTexture:Se,CapsuleBufferGeometry:Er,CapsuleGeometry:Er,CatmullRomCurve3:_f,CineonToneMapping:3,CircleBufferGeometry:Cr,CircleGeometry:Cr,ClampToEdgeWrapping:1001,Clock:ng,Color:nt,ColorKeyframeTrack:Ou,ColorManagement:pi,CompressedTexture:gf,CompressedTextureLoader:class extends Ge{constructor(n){super(n)}load(n,t,e,i){const s=this,r=[],a=new gf,o=new _i(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(s.withCredentials);let l=0;function h(c){o.load(n[c],function(u){const d=s.parse(u,!0);r[c]={width:d.width,height:d.height,format:d.format,mipmaps:d.mipmaps},l+=1,l===6&&(d.mipmapCount===1&&(a.minFilter=1006),a.image=r,a.format=d.format,a.needsUpdate=!0,t&&t(a))},e,i)}if(Array.isArray(n))for(let c=0,u=n.length;c<u;++c)h(c);else o.load(n,function(c){const u=s.parse(c,!0);if(u.isCubemap){const d=u.mipmaps.length/u.mipmapCount;for(let p=0;p<d;p++){r[p]={mipmaps:[]};for(let m=0;m<u.mipmapCount;m++)r[p].mipmaps.push(u.mipmaps[p*u.mipmapCount+m]),r[p].format=u.format,r[p].width=u.width,r[p].height=u.height}a.image=r}else a.image.width=u.width,a.image.height=u.height,a.mipmaps=u.mipmaps;u.mipmapCount===1&&(a.minFilter=1006),a.format=u.format,a.needsUpdate=!0,t&&t(a)},e,i);return a}},ConeBufferGeometry:Ar,ConeGeometry:Ar,CubeCamera:wl,CubeReflectionMapping:301,CubeRefractionMapping:302,CubeTexture:mr,CubeTextureLoader:zu,CubeUVReflectionMapping:306,CubicBezierCurve:Tu,CubicBezierCurve3:xf,CubicInterpolant:kf,CullFaceBack:1,CullFaceFront:2,CullFaceFrontBack:3,CullFaceNone:0,Curve:Oi,CurvePath:Mf,CustomBlending:5,CustomToneMapping:5,CylinderBufferGeometry:oe,CylinderGeometry:oe,Cylindrical:class{constructor(n=1,t=0,e=0){return this.radius=n,this.theta=t,this.y=e,this}set(n,t,e){return this.radius=n,this.theta=t,this.y=e,this}copy(n){return this.radius=n.radius,this.theta=n.theta,this.y=n.y,this}setFromVector3(n){return this.setFromCartesianCoords(n.x,n.y,n.z)}setFromCartesianCoords(n,t,e){return this.radius=Math.sqrt(n*n+e*e),this.theta=Math.atan2(n,e),this.y=t,this}clone(){return new this.constructor().copy(this)}},Data3DTexture:nl,DataArrayTexture:Sa,DataTexture:_s,DataTexture2DArray:class extends Sa{constructor(n,t,e,i){console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),super(n,t,e,i)}},DataTexture3D:class extends nl{constructor(n,t,e,i){console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),super(n,t,e,i)}},DataTextureLoader:Gf,DataUtils:Za,DecrementStencilOp:7683,DecrementWrapStencilOp:34056,DefaultLoadingManager:Ss,DepthFormat:1026,DepthStencilFormat:1027,DepthTexture:pu,DirectionalLight:Ql,DirectionalLightHelper:class extends Mt{constructor(n,t,e){super(),this.light=n,this.light.updateMatrixWorld(),this.matrix=n.matrixWorld,this.matrixAutoUpdate=!1,this.color=e,t===void 0&&(t=1);let i=new gt;i.setAttribute("position",new Z([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const s=new _e({fog:!1,toneMapped:!1});this.lightPlane=new we(i,s),this.add(this.lightPlane),i=new gt,i.setAttribute("position",new Z([0,0,0,0,0,1],3)),this.targetLine=new we(i,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){vg.setFromMatrixPosition(this.light.matrixWorld),sh.setFromMatrixPosition(this.light.target.matrixWorld),_g.subVectors(sh,vg),this.lightPlane.lookAt(sh),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(sh),this.targetLine.scale.z=_g.length()}},DiscreteInterpolant:Bf,DodecahedronBufferGeometry:Pr,DodecahedronGeometry:Pr,DoubleSide:2,DstAlphaFactor:206,DstColorFactor:208,DynamicCopyUsage:35050,DynamicDrawUsage:35048,DynamicReadUsage:35049,EdgesGeometry:wf,EllipseCurve:Vl,EqualDepth:4,EqualStencilFunc:514,EquirectangularReflectionMapping:303,EquirectangularRefractionMapping:304,Euler:yn,EventDispatcher:Ji,ExtrudeBufferGeometry:Lr,ExtrudeGeometry:Lr,FileLoader:_i,FlatShading:1,Float16BufferAttribute:class extends Lt{constructor(n,t,e){super(new Uint16Array(n),t,e),this.isFloat16BufferAttribute=!0}},Float32BufferAttribute:Z,Float64BufferAttribute:class extends Lt{constructor(n,t,e){super(new Float64Array(n),t,e)}},FloatType:1015,Fog:Ia,FogExp2:Al,Font:function(){console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")},FontLoader:function(){console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")},FramebufferTexture:xu,FrontSide:0,Frustum:gr,GLBufferAttribute:class{constructor(n,t,e,i,s){this.isGLBufferAttribute=!0,this.buffer=n,this.type=t,this.itemSize=e,this.elementSize=i,this.count=s,this.version=0}set needsUpdate(n){n===!0&&this.version++}setBuffer(n){return this.buffer=n,this}setType(n,t){return this.type=n,this.elementSize=t,this}setItemSize(n){return this.itemSize=n,this}setCount(n){return this.count=n,this}},GLSL1:"100",GLSL3:Qo,GreaterDepth:6,GreaterEqualDepth:5,GreaterEqualStencilFunc:518,GreaterStencilFunc:516,GridHelper:class extends vi{constructor(n=10,t=10,e=4473924,i=8947848){e=new nt(e),i=new nt(i);const s=t/2,r=n/t,a=n/2,o=[],l=[];for(let c=0,u=0,d=-a;c<=t;c++,d+=r){o.push(-a,0,d,a,0,d),o.push(d,0,-a,d,0,a);const p=c===s?e:i;p.toArray(l,u),u+=3,p.toArray(l,u),u+=3,p.toArray(l,u),u+=3,p.toArray(l,u),u+=3}const h=new gt;h.setAttribute("position",new Z(o,3)),h.setAttribute("color",new Z(l,3)),super(h,new _e({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}},Group:Me,HalfFloatType:1016,HemisphereLight:Uu,HemisphereLightHelper:class extends Mt{constructor(n,t,e){super(),this.light=n,this.light.updateMatrixWorld(),this.matrix=n.matrixWorld,this.matrixAutoUpdate=!1,this.color=e;const i=new zi(t);i.rotateY(.5*Math.PI),this.material=new Zt({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const s=i.getAttribute("position"),r=new Float32Array(3*s.count);i.setAttribute("color",new Lt(r,3)),this.add(new ot(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const n=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=n.geometry.getAttribute("color");fg.copy(this.light.color),gg.copy(this.light.groundColor);for(let e=0,i=t.count;e<i;e++){const s=e<i/2?fg:gg;t.setXYZ(e,s.r,s.g,s.b)}t.needsUpdate=!0}n.lookAt(wb.setFromMatrixPosition(this.light.matrixWorld).negate())}},HemisphereLightProbe:class extends $l{constructor(n,t,e=1){super(void 0,e),this.isHemisphereLightProbe=!0;const i=new nt().set(n),s=new nt().set(t),r=new S(i.r,i.g,i.b),a=new S(s.r,s.g,s.b),o=Math.sqrt(Math.PI),l=o*Math.sqrt(.75);this.sh.coefficients[0].copy(r).add(a).multiplyScalar(o),this.sh.coefficients[1].copy(r).sub(a).multiplyScalar(l)}},IcosahedronBufferGeometry:Ir,IcosahedronGeometry:Ir,ImageBitmapLoader:tg,ImageLoader:Xa,ImageUtils:Nc,ImmediateRenderObject:function(){console.error("THREE.ImmediateRenderObject has been removed.")},IncrementStencilOp:7682,IncrementWrapStencilOp:34055,InstancedBufferAttribute:Di,InstancedBufferGeometry:th,InstancedInterleavedBuffer:class extends xr{constructor(n,t,e=1){super(n,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=e}copy(n){return super.copy(n),this.meshPerAttribute=n.meshPerAttribute,this}clone(n){const t=super.clone(n);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(n){const t=super.toJSON(n);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}},InstancedMesh:Fl,Int16BufferAttribute:class extends Lt{constructor(n,t,e){super(new Int16Array(n),t,e)}},Int32BufferAttribute:class extends Lt{constructor(n,t,e){super(new Int32Array(n),t,e)}},Int8BufferAttribute:class extends Lt{constructor(n,t,e){super(new Int8Array(n),t,e)}},IntType:1013,InterleavedBuffer:xr,InterleavedBufferAttribute:Ki,Interpolant:Nr,InterpolateDiscrete:2300,InterpolateLinear:2301,InterpolateSmooth:2302,InvertStencilOp:5386,KeepStencilOp:7680,KeyframeTrack:Fi,LOD:tf,LatheBufferGeometry:ys,LatheGeometry:ys,Layers:cl,LessDepth:2,LessEqualDepth:3,LessEqualStencilFunc:515,LessStencilFunc:513,Light:qn,LightProbe:$l,Line:we,Line3:class{constructor(n=new S,t=new S){this.start=n,this.end=t}set(n,t){return this.start.copy(n),this.end.copy(t),this}copy(n){return this.start.copy(n.start),this.end.copy(n.end),this}getCenter(n){return n.addVectors(this.start,this.end).multiplyScalar(.5)}delta(n){return n.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(n,t){return this.delta(t).multiplyScalar(n).add(this.start)}closestPointToPointParameter(n,t){dg.subVectors(n,this.start),ih.subVectors(this.end,this.start);const e=ih.dot(ih);let i=ih.dot(dg)/e;return t&&(i=de(i,0,1)),i}closestPointToPoint(n,t,e){const i=this.closestPointToPointParameter(n,t);return this.delta(e).multiplyScalar(i).add(this.start)}applyMatrix4(n){return this.start.applyMatrix4(n),this.end.applyMatrix4(n),this}equals(n){return n.start.equals(this.start)&&n.end.equals(this.end)}clone(){return new this.constructor().copy(this)}},LineBasicMaterial:_e,LineCurve:jl,LineCurve3:bf,LineDashedMaterial:Nf,LineLoop:_u,LineSegments:vi,LinearEncoding:3e3,LinearFilter:1006,LinearInterpolant:Du,LinearMipMapLinearFilter:1008,LinearMipMapNearestFilter:1007,LinearMipmapLinearFilter:1008,LinearMipmapNearestFilter:1007,LinearSRGBColorSpace:Ko,LinearToneMapping:1,Loader:Ge,LoaderUtils:nn,LoadingManager:Kl,LoopOnce:2200,LoopPingPong:2202,LoopRepeat:2201,LuminanceAlphaFormat:1025,LuminanceFormat:1024,MOUSE:{LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Material:ae,MaterialLoader:Jf,MathUtils:Ie,Matrix3:De,Matrix4:at,MaxEquation:104,Mesh:ot,MeshBasicMaterial:Zt,MeshDepthMaterial:cu,MeshDistanceMaterial:uu,MeshLambertMaterial:Uf,MeshMatcapMaterial:Ff,MeshNormalMaterial:zf,MeshPhongMaterial:Jl,MeshPhysicalMaterial:wn,MeshStandardMaterial:en,MeshToonMaterial:Of,MinEquation:103,MirroredRepeatWrapping:1002,MixOperation:1,MultiplyBlending:4,MultiplyOperation:0,NearestFilter:1003,NearestMipMapLinearFilter:1005,NearestMipMapNearestFilter:1004,NearestMipmapLinearFilter:1005,NearestMipmapNearestFilter:1004,NeverDepth:0,NeverStencilFunc:512,NoBlending:0,NoColorSpace:"",NoToneMapping:0,NormalAnimationBlendMode:2500,NormalBlending:1,NotEqualDepth:7,NotEqualStencilFunc:517,NumberKeyframeTrack:kr,Object3D:Mt,ObjectLoader:class extends Ge{constructor(n){super(n)}load(n,t,e,i){const s=this,r=this.path===""?nn.extractUrlBase(n):this.path;this.resourcePath=this.resourcePath||r;const a=new _i(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(n,function(o){let l=null;try{l=JSON.parse(o)}catch(c){return i!==void 0&&i(c),void console.error("THREE:ObjectLoader: Can't parse "+n+".",c.message)}const h=l.metadata;h!==void 0&&h.type!==void 0&&h.type.toLowerCase()!=="geometry"?s.parse(l,t):console.error("THREE.ObjectLoader: Can't load "+n)},e,i)}async loadAsync(n,t){const e=this.path===""?nn.extractUrlBase(n):this.path;this.resourcePath=this.resourcePath||e;const i=new _i(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials);const s=await i.loadAsync(n,t),r=JSON.parse(s),a=r.metadata;if(a===void 0||a.type===void 0||a.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+n);return await this.parseAsync(r)}parse(n,t){const e=this.parseAnimations(n.animations),i=this.parseShapes(n.shapes),s=this.parseGeometries(n.geometries,i),r=this.parseImages(n.images,function(){t!==void 0&&t(l)}),a=this.parseTextures(n.textures,r),o=this.parseMaterials(n.materials,a),l=this.parseObject(n.object,s,o,a,e),h=this.parseSkeletons(n.skeletons,l);if(this.bindSkeletons(l,h),t!==void 0){let c=!1;for(const u in r)if(r[u].data instanceof HTMLImageElement){c=!0;break}c===!1&&t(l)}return l}async parseAsync(n){const t=this.parseAnimations(n.animations),e=this.parseShapes(n.shapes),i=this.parseGeometries(n.geometries,e),s=await this.parseImagesAsync(n.images),r=this.parseTextures(n.textures,s),a=this.parseMaterials(n.materials,r),o=this.parseObject(n.object,i,a,r,t),l=this.parseSkeletons(n.skeletons,o);return this.bindSkeletons(o,l),o}parseShapes(n){const t={};if(n!==void 0)for(let e=0,i=n.length;e<i;e++){const s=new xs().fromJSON(n[e]);t[s.uuid]=s}return t}parseSkeletons(n,t){const e={},i={};if(t.traverse(function(s){s.isBone&&(i[s.uuid]=s)}),n!==void 0)for(let s=0,r=n.length;s<r;s++){const a=new Fa().fromJSON(n[s],i);e[a.uuid]=a}return e}parseGeometries(n,t){const e={};if(n!==void 0){const i=new Kf;for(let s=0,r=n.length;s<r;s++){let a;const o=n[s];switch(o.type){case"BufferGeometry":case"InstancedBufferGeometry":a=i.parse(o);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:o.type in If?a=If[o.type].fromJSON(o,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`)}a.uuid=o.uuid,o.name!==void 0&&(a.name=o.name),a.isBufferGeometry===!0&&o.userData!==void 0&&(a.userData=o.userData),e[o.uuid]=a}}return e}parseMaterials(n,t){const e={},i={};if(n!==void 0){const s=new Jf;s.setTextures(t);for(let r=0,a=n.length;r<a;r++){const o=n[r];if(o.type==="MultiMaterial"){const l=[];for(let h=0;h<o.materials.length;h++){const c=o.materials[h];e[c.uuid]===void 0&&(e[c.uuid]=s.parse(c)),l.push(e[c.uuid])}i[o.uuid]=l}else e[o.uuid]===void 0&&(e[o.uuid]=s.parse(o)),i[o.uuid]=e[o.uuid]}}return i}parseAnimations(n){const t={};if(n!==void 0)for(let e=0;e<n.length;e++){const i=n[e],s=Vr.parse(i);t[s.uuid]=s}return t}parseImages(n,t){const e=this,i={};let s;function r(a){if(typeof a=="string"){const o=a;return function(l){return e.manager.itemStart(l),s.load(l,function(){e.manager.itemEnd(l)},void 0,function(){e.manager.itemError(l),e.manager.itemEnd(l)})}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o)?o:e.resourcePath+o)}return a.data?{data:er(a.type,a.data),width:a.width,height:a.height}:null}if(n!==void 0&&n.length>0){const a=new Kl(t);s=new Xa(a),s.setCrossOrigin(this.crossOrigin);for(let o=0,l=n.length;o<l;o++){const h=n[o],c=h.url;if(Array.isArray(c)){const u=[];for(let d=0,p=c.length;d<p;d++){const m=r(c[d]);m!==null&&(m instanceof HTMLImageElement?u.push(m):u.push(new _s(m.data,m.width,m.height)))}i[h.uuid]=new ds(u)}else{const u=r(h.url);i[h.uuid]=new ds(u)}}}return i}async parseImagesAsync(n){const t=this,e={};let i;async function s(r){if(typeof r=="string"){const a=r,o=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:t.resourcePath+a;return await i.loadAsync(o)}return r.data?{data:er(r.type,r.data),width:r.width,height:r.height}:null}if(n!==void 0&&n.length>0){i=new Xa(this.manager),i.setCrossOrigin(this.crossOrigin);for(let r=0,a=n.length;r<a;r++){const o=n[r],l=o.url;if(Array.isArray(l)){const h=[];for(let c=0,u=l.length;c<u;c++){const d=l[c],p=await s(d);p!==null&&(p instanceof HTMLImageElement?h.push(p):h.push(new _s(p.data,p.width,p.height)))}e[o.uuid]=new ds(h)}else{const h=await s(o.url);e[o.uuid]=new ds(h)}}}return e}parseTextures(n,t){function e(s,r){return typeof s=="number"?s:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",s),r[s])}const i={};if(n!==void 0)for(let s=0,r=n.length;s<r;s++){const a=n[s];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const o=t[a.image],l=o.data;let h;Array.isArray(l)?(h=new mr,l.length===6&&(h.needsUpdate=!0)):(h=l&&l.data?new _s:new Gt,l&&(h.needsUpdate=!0)),h.source=o,h.uuid=a.uuid,a.name!==void 0&&(h.name=a.name),a.mapping!==void 0&&(h.mapping=e(a.mapping,hb)),a.offset!==void 0&&h.offset.fromArray(a.offset),a.repeat!==void 0&&h.repeat.fromArray(a.repeat),a.center!==void 0&&h.center.fromArray(a.center),a.rotation!==void 0&&(h.rotation=a.rotation),a.wrap!==void 0&&(h.wrapS=e(a.wrap[0],Qf),h.wrapT=e(a.wrap[1],Qf)),a.format!==void 0&&(h.format=a.format),a.type!==void 0&&(h.type=a.type),a.encoding!==void 0&&(h.encoding=a.encoding),a.minFilter!==void 0&&(h.minFilter=e(a.minFilter,$f)),a.magFilter!==void 0&&(h.magFilter=e(a.magFilter,$f)),a.anisotropy!==void 0&&(h.anisotropy=a.anisotropy),a.flipY!==void 0&&(h.flipY=a.flipY),a.premultiplyAlpha!==void 0&&(h.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(h.unpackAlignment=a.unpackAlignment),a.userData!==void 0&&(h.userData=a.userData),i[a.uuid]=h}return i}parseObject(n,t,e,i,s){let r,a,o;function l(u){return t[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",u),t[u]}function h(u){if(u!==void 0){if(Array.isArray(u)){const d=[];for(let p=0,m=u.length;p<m;p++){const f=u[p];e[f]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",f),d.push(e[f])}return d}return e[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",u),e[u]}}function c(u){return i[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",u),i[u]}switch(n.type){case"Scene":r=new Pl,n.background!==void 0&&(Number.isInteger(n.background)?r.background=new nt(n.background):r.background=c(n.background)),n.environment!==void 0&&(r.environment=c(n.environment)),n.fog!==void 0&&(n.fog.type==="Fog"?r.fog=new Ia(n.fog.color,n.fog.near,n.fog.far):n.fog.type==="FogExp2"&&(r.fog=new Al(n.fog.color,n.fog.density)));break;case"PerspectiveCamera":r=new ee(n.fov,n.aspect,n.near,n.far),n.focus!==void 0&&(r.focus=n.focus),n.zoom!==void 0&&(r.zoom=n.zoom),n.filmGauge!==void 0&&(r.filmGauge=n.filmGauge),n.filmOffset!==void 0&&(r.filmOffset=n.filmOffset),n.view!==void 0&&(r.view=Object.assign({},n.view));break;case"OrthographicCamera":r=new vr(n.left,n.right,n.top,n.bottom,n.near,n.far),n.zoom!==void 0&&(r.zoom=n.zoom),n.view!==void 0&&(r.view=Object.assign({},n.view));break;case"AmbientLight":r=new Xf(n.color,n.intensity);break;case"DirectionalLight":r=new Ql(n.color,n.intensity);break;case"PointLight":r=new Bu(n.color,n.intensity,n.distance,n.decay);break;case"RectAreaLight":r=new Yf(n.color,n.intensity,n.width,n.height);break;case"SpotLight":r=new Nu(n.color,n.intensity,n.distance,n.angle,n.penumbra,n.decay);break;case"HemisphereLight":r=new Uu(n.color,n.groundColor,n.intensity);break;case"LightProbe":r=new $l().fromJSON(n);break;case"SkinnedMesh":a=l(n.geometry),o=h(n.material),r=new gu(a,o),n.bindMode!==void 0&&(r.bindMode=n.bindMode),n.bindMatrix!==void 0&&r.bindMatrix.fromArray(n.bindMatrix),n.skeleton!==void 0&&(r.skeleton=n.skeleton);break;case"Mesh":a=l(n.geometry),o=h(n.material),r=new ot(a,o);break;case"InstancedMesh":a=l(n.geometry),o=h(n.material);const u=n.count,d=n.instanceMatrix,p=n.instanceColor;r=new Fl(a,o,u),r.instanceMatrix=new Di(new Float32Array(d.array),16),p!==void 0&&(r.instanceColor=new Di(new Float32Array(p.array),p.itemSize));break;case"LOD":r=new tf;break;case"Line":r=new we(l(n.geometry),h(n.material));break;case"LineLoop":r=new _u(l(n.geometry),h(n.material));break;case"LineSegments":r=new vi(l(n.geometry),h(n.material));break;case"PointCloud":case"Points":r=new ka(l(n.geometry),h(n.material));break;case"Sprite":r=new Il(h(n.material));break;case"Group":r=new Me;break;case"Bone":r=new zl;break;default:r=new Mt}if(r.uuid=n.uuid,n.name!==void 0&&(r.name=n.name),n.matrix!==void 0?(r.matrix.fromArray(n.matrix),n.matrixAutoUpdate!==void 0&&(r.matrixAutoUpdate=n.matrixAutoUpdate),r.matrixAutoUpdate&&r.matrix.decompose(r.position,r.quaternion,r.scale)):(n.position!==void 0&&r.position.fromArray(n.position),n.rotation!==void 0&&r.rotation.fromArray(n.rotation),n.quaternion!==void 0&&r.quaternion.fromArray(n.quaternion),n.scale!==void 0&&r.scale.fromArray(n.scale)),n.castShadow!==void 0&&(r.castShadow=n.castShadow),n.receiveShadow!==void 0&&(r.receiveShadow=n.receiveShadow),n.shadow&&(n.shadow.bias!==void 0&&(r.shadow.bias=n.shadow.bias),n.shadow.normalBias!==void 0&&(r.shadow.normalBias=n.shadow.normalBias),n.shadow.radius!==void 0&&(r.shadow.radius=n.shadow.radius),n.shadow.mapSize!==void 0&&r.shadow.mapSize.fromArray(n.shadow.mapSize),n.shadow.camera!==void 0&&(r.shadow.camera=this.parseObject(n.shadow.camera))),n.visible!==void 0&&(r.visible=n.visible),n.frustumCulled!==void 0&&(r.frustumCulled=n.frustumCulled),n.renderOrder!==void 0&&(r.renderOrder=n.renderOrder),n.userData!==void 0&&(r.userData=n.userData),n.layers!==void 0&&(r.layers.mask=n.layers),n.children!==void 0){const u=n.children;for(let d=0;d<u.length;d++)r.add(this.parseObject(u[d],t,e,i,s))}if(n.animations!==void 0){const u=n.animations;for(let d=0;d<u.length;d++){const p=u[d];r.animations.push(s[p])}}if(n.type==="LOD"){n.autoUpdate!==void 0&&(r.autoUpdate=n.autoUpdate);const u=n.levels;for(let d=0;d<u.length;d++){const p=u[d],m=r.getObjectByProperty("uuid",p.object);m!==void 0&&r.addLevel(m,p.distance)}}return r}bindSkeletons(n,t){Object.keys(t).length!==0&&n.traverse(function(e){if(e.isSkinnedMesh===!0&&e.skeleton!==void 0){const i=t[e.skeleton];i===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",e.skeleton):e.bind(i,e.bindMatrix)}})}setTexturePath(n){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(n)}},ObjectSpaceNormalMap:1,OctahedronBufferGeometry:zi,OctahedronGeometry:zi,OneFactor:201,OneMinusDstAlphaFactor:207,OneMinusDstColorFactor:209,OneMinusSrcAlphaFactor:205,OneMinusSrcColorFactor:203,OrthographicCamera:vr,PCFShadowMap:1,PCFSoftShadowMap:2,PMREMGenerator:vs,ParametricGeometry:class extends gt{constructor(){console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"),super()}},Path:Ga,PerspectiveCamera:ee,Plane:ri,PlaneBufferGeometry:gi,PlaneGeometry:gi,PlaneHelper:class extends we{constructor(n,t=1,e=16776960){const i=e,s=new gt;s.setAttribute("position",new Z([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),s.computeBoundingSphere(),super(s,new _e({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=n,this.size=t;const r=new gt;r.setAttribute("position",new Z([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),r.computeBoundingSphere(),this.add(new ot(r,new Zt({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(n){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?1:0,this.lookAt(this.plane.normal),super.updateMatrixWorld(n)}},PointLight:Bu,PointLightHelper:class extends ot{constructor(n,t,e){super(new tn(t,4,2),new Zt({wireframe:!0,fog:!1,toneMapped:!1})),this.light=n,this.light.updateMatrixWorld(),this.color=e,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}},Points:ka,PointsMaterial:Tr,PolarGridHelper:class extends vi{constructor(n=10,t=16,e=8,i=64,s=4473924,r=8947848){s=new nt(s),r=new nt(r);const a=[],o=[];for(let h=0;h<=t;h++){const c=h/t*(2*Math.PI),u=Math.sin(c)*n,d=Math.cos(c)*n;a.push(0,0,0),a.push(u,0,d);const p=1&h?s:r;o.push(p.r,p.g,p.b),o.push(p.r,p.g,p.b)}for(let h=0;h<=e;h++){const c=1&h?s:r,u=n-n/e*h;for(let d=0;d<i;d++){let p=d/i*(2*Math.PI),m=Math.sin(p)*u,f=Math.cos(p)*u;a.push(m,0,f),o.push(c.r,c.g,c.b),p=(d+1)/i*(2*Math.PI),m=Math.sin(p)*u,f=Math.cos(p)*u,a.push(m,0,f),o.push(c.r,c.g,c.b)}}const l=new gt;l.setAttribute("position",new Z(a,3)),l.setAttribute("color",new Z(o,3)),super(l,new _e({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}},PolyhedronBufferGeometry:Qi,PolyhedronGeometry:Qi,PositionalAudio:class extends ag{constructor(n){super(n),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(n){return this.panner.refDistance=n,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(n){return this.panner.rolloffFactor=n,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(n){return this.panner.distanceModel=n,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(n){return this.panner.maxDistance=n,this}setDirectionalCone(n,t,e){return this.panner.coneInnerAngle=n,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=e,this}updateMatrixWorld(n){if(super.updateMatrixWorld(n),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(As,og,ub),Ps.set(0,0,1).applyQuaternion(og);const t=this.panner;if(t.positionX){const e=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(As.x,e),t.positionY.linearRampToValueAtTime(As.y,e),t.positionZ.linearRampToValueAtTime(As.z,e),t.orientationX.linearRampToValueAtTime(Ps.x,e),t.orientationY.linearRampToValueAtTime(Ps.y,e),t.orientationZ.linearRampToValueAtTime(Ps.z,e)}else t.setPosition(As.x,As.y,As.z),t.setOrientation(Ps.x,Ps.y,Ps.z)}},PropertyBinding:Nt,PropertyMixer:lg,QuadraticBezierCurve:Eu,QuadraticBezierCurve3:Cu,Quaternion:Ft,QuaternionKeyframeTrack:Wn,QuaternionLinearInterpolant:Vf,REVISION:ti,RGBADepthPacking:3201,RGBAFormat:1023,RGBAIntegerFormat:1033,RGBA_ASTC_10x10_Format:37819,RGBA_ASTC_10x5_Format:37816,RGBA_ASTC_10x6_Format:37817,RGBA_ASTC_10x8_Format:37818,RGBA_ASTC_12x10_Format:37820,RGBA_ASTC_12x12_Format:37821,RGBA_ASTC_4x4_Format:37808,RGBA_ASTC_5x4_Format:37809,RGBA_ASTC_5x5_Format:37810,RGBA_ASTC_6x5_Format:37811,RGBA_ASTC_6x6_Format:37812,RGBA_ASTC_8x5_Format:37813,RGBA_ASTC_8x6_Format:37814,RGBA_ASTC_8x8_Format:37815,RGBA_BPTC_Format:36492,RGBA_ETC2_EAC_Format:37496,RGBA_PVRTC_2BPPV1_Format:35843,RGBA_PVRTC_4BPPV1_Format:35842,RGBA_S3TC_DXT1_Format:33777,RGBA_S3TC_DXT3_Format:33778,RGBA_S3TC_DXT5_Format:33779,RGBFormat:1022,RGB_ETC1_Format:36196,RGB_ETC2_Format:37492,RGB_PVRTC_2BPPV1_Format:35841,RGB_PVRTC_4BPPV1_Format:35840,RGB_S3TC_DXT1_Format:33776,RGFormat:1030,RGIntegerFormat:1031,RawShaderMaterial:qa,Ray:kn,Raycaster:Rs,RectAreaLight:Yf,RedFormat:1028,RedIntegerFormat:1029,ReinhardToneMapping:2,RepeatWrapping:1e3,ReplaceStencilOp:7681,ReverseSubtractEquation:102,RingBufferGeometry:Dr,RingGeometry:Dr,SRGBColorSpace:Jo,Scene:Pl,ShaderChunk:_t,ShaderLib:ai,ShaderMaterial:Qt,ShadowMaterial:Df,Shape:xs,ShapeBufferGeometry:Or,ShapeGeometry:Or,ShapePath:class{constructor(){this.type="ShapePath",this.color=new nt,this.subPaths=[],this.currentPath=null}moveTo(n,t){return this.currentPath=new Ga,this.subPaths.push(this.currentPath),this.currentPath.moveTo(n,t),this}lineTo(n,t){return this.currentPath.lineTo(n,t),this}quadraticCurveTo(n,t,e,i){return this.currentPath.quadraticCurveTo(n,t,e,i),this}bezierCurveTo(n,t,e,i,s,r){return this.currentPath.bezierCurveTo(n,t,e,i,s,r),this}splineThru(n){return this.currentPath.splineThru(n),this}toShapes(n,t){function e(_){const y=[];for(let x=0,b=_.length;x<b;x++){const w=_[x],M=new xs;M.curves=w.curves,y.push(M)}return y}function i(_,y){const x=y.length;let b=!1;for(let w=x-1,M=0;M<x;w=M++){let T=y[w],R=y[M],E=R.x-T.x,A=R.y-T.y;if(Math.abs(A)>Number.EPSILON){if(A<0&&(T=y[M],E=-E,R=y[w],A=-A),_.y<T.y||_.y>R.y)continue;if(_.y===T.y){if(_.x===T.x)return!0}else{const z=A*(_.x-T.x)-E*(_.y-T.y);if(z===0)return!0;if(z<0)continue;b=!b}}else{if(_.y!==T.y)continue;if(R.x<=_.x&&_.x<=T.x||T.x<=_.x&&_.x<=R.x)return!0}}return b}const s=$i.isClockWise,r=this.subPaths;if(r.length===0)return[];if(t===!0)return e(r);let a,o,l;const h=[];if(r.length===1)return o=r[0],l=new xs,l.curves=o.curves,h.push(l),h;let c=!s(r[0].getPoints());c=n?!c:c;const u=[],d=[];let p,m,f=[],v=0;d[v]=void 0,f[v]=[];for(let _=0,y=r.length;_<y;_++)o=r[_],p=o.getPoints(),a=s(p),a=n?!a:a,a?(!c&&d[v]&&v++,d[v]={s:new xs,p},d[v].s.curves=o.curves,c&&v++,f[v]=[]):f[v].push({h:o,p:p[0]});if(!d[0])return e(r);if(d.length>1){let _=!1,y=0;for(let x=0,b=d.length;x<b;x++)u[x]=[];for(let x=0,b=d.length;x<b;x++){const w=f[x];for(let M=0;M<w.length;M++){const T=w[M];let R=!0;for(let E=0;E<d.length;E++)i(T.p,d[E].p)&&(x!==E&&y++,R?(R=!1,u[E].push(T)):_=!0);R&&u[x].push(T)}}y>0&&_===!1&&(f=u)}for(let _=0,y=d.length;_<y;_++){l=d[_].s,h.push(l),m=f[_];for(let x=0,b=m.length;x<b;x++)l.holes.push(m[x].h)}return h}},ShapeUtils:$i,ShortType:1011,Skeleton:Fa,SkeletonHelper:class extends vi{constructor(n){const t=mg(n),e=new gt,i=[],s=[],r=new nt(0,0,1),a=new nt(0,1,0);for(let o=0;o<t.length;o++){const l=t[o];l.parent&&l.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),s.push(r.r,r.g,r.b),s.push(a.r,a.g,a.b))}e.setAttribute("position",new Z(i,3)),e.setAttribute("color",new Z(s,3)),super(e,new _e({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=n,this.bones=t,this.matrix=n.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(n){const t=this.bones,e=this.geometry,i=e.getAttribute("position");Wu.copy(this.root.matrixWorld).invert();for(let s=0,r=0;s<t.length;s++){const a=t[s];a.parent&&a.parent.isBone&&(nh.multiplyMatrices(Wu,a.matrixWorld),Xn.setFromMatrixPosition(nh),i.setXYZ(r,Xn.x,Xn.y,Xn.z),nh.multiplyMatrices(Wu,a.parent.matrixWorld),Xn.setFromMatrixPosition(nh),i.setXYZ(r+1,Xn.x,Xn.y,Xn.z),r+=2)}e.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(n)}},SkinnedMesh:gu,SmoothShading:2,Source:ds,Sphere:ii,SphereBufferGeometry:tn,SphereGeometry:tn,Spherical:class{constructor(n=1,t=0,e=0){return this.radius=n,this.phi=t,this.theta=e,this}set(n,t,e){return this.radius=n,this.phi=t,this.theta=e,this}copy(n){return this.radius=n.radius,this.phi=n.phi,this.theta=n.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(n){return this.setFromCartesianCoords(n.x,n.y,n.z)}setFromCartesianCoords(n,t,e){return this.radius=Math.sqrt(n*n+t*t+e*e),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(n,e),this.phi=Math.acos(de(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}},SphericalHarmonics3:Zf,SplineCurve:Au,SpotLight:Nu,SpotLightHelper:class extends Mt{constructor(n,t){super(),this.light=n,this.light.updateMatrixWorld(),this.matrix=n.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const e=new gt,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let r=0,a=1,o=32;r<o;r++,a++){const l=r/o*Math.PI*2,h=a/o*Math.PI*2;i.push(Math.cos(l),Math.sin(l),1,Math.cos(h),Math.sin(h),1)}e.setAttribute("position",new Z(i,3));const s=new _e({fog:!1,toneMapped:!1});this.cone=new vi(e,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const n=this.light.distance?this.light.distance:1e3,t=n*Math.tan(this.light.angle);this.cone.scale.set(t,t,n),pg.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(pg),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}},Sprite:Il,SpriteMaterial:Da,SrcAlphaFactor:204,SrcAlphaSaturateFactor:210,SrcColorFactor:202,StaticCopyUsage:35046,StaticDrawUsage:35044,StaticReadUsage:35045,StereoCamera:class{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new ee,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new ee,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(n){const t=this._cache;if(t.focus!==n.focus||t.fov!==n.fov||t.aspect!==n.aspect*this.aspect||t.near!==n.near||t.far!==n.far||t.zoom!==n.zoom||t.eyeSep!==this.eyeSep){t.focus=n.focus,t.fov=n.fov,t.aspect=n.aspect*this.aspect,t.near=n.near,t.far=n.far,t.zoom=n.zoom,t.eyeSep=this.eyeSep,Ts.copy(n.projectionMatrix);const e=t.eyeSep/2,i=e*t.near/t.focus,s=t.near*Math.tan(cs*t.fov*.5)/t.zoom;let r,a;ig.elements[12]=-e,eg.elements[12]=e,r=-s*t.aspect+i,a=s*t.aspect+i,Ts.elements[0]=2*t.near/(a-r),Ts.elements[8]=(a+r)/(a-r),this.cameraL.projectionMatrix.copy(Ts),r=-s*t.aspect-i,a=s*t.aspect-i,Ts.elements[0]=2*t.near/(a-r),Ts.elements[8]=(a+r)/(a-r),this.cameraR.projectionMatrix.copy(Ts)}this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(ig),this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(eg)}},StreamCopyUsage:35042,StreamDrawUsage:35040,StreamReadUsage:35041,StringKeyframeTrack:Ms,SubtractEquation:101,SubtractiveBlending:3,TOUCH:{ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},TangentSpaceNormalMap:0,TetrahedronBufferGeometry:zr,TetrahedronGeometry:zr,TextGeometry:class extends gt{constructor(){console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"),super()}},Texture:Gt,TextureLoader:Te,TorusBufferGeometry:Ui,TorusGeometry:Ui,TorusKnotBufferGeometry:Ur,TorusKnotGeometry:Ur,Triangle:mi,TriangleFanDrawMode:2,TriangleStripDrawMode:1,TrianglesDrawMode:0,TubeBufferGeometry:Fr,TubeGeometry:Fr,UVMapping:300,Uint16BufferAttribute:Kc,Uint32BufferAttribute:pl,Uint8BufferAttribute:class extends Lt{constructor(n,t,e){super(new Uint8Array(n),t,e)}},Uint8ClampedBufferAttribute:class extends Lt{constructor(n,t,e){super(new Uint8ClampedArray(n),t,e)}},Uniform:ju,UniformsLib:rt,UniformsUtils:ft,UnsignedByteType:1009,UnsignedInt248Type:1020,UnsignedIntType:1014,UnsignedShort4444Type:1017,UnsignedShort5551Type:1018,UnsignedShortType:1012,VSMShadowMap:3,Vector2:V,Vector3:S,Vector4:Ot,VectorKeyframeTrack:Br,VideoTexture:class extends Gt{constructor(n,t,e,i,s,r,a,o,l){super(n,t,e,i,s,r,a,o,l),this.isVideoTexture=!0,this.minFilter=r!==void 0?r:1006,this.magFilter=s!==void 0?s:1006,this.generateMipmaps=!1;const h=this;"requestVideoFrameCallback"in n&&n.requestVideoFrameCallback(function c(){h.needsUpdate=!0,n.requestVideoFrameCallback(c)})}clone(){return new this.constructor(this.image).copy(this)}update(){const n=this.image;!("requestVideoFrameCallback"in n)&&n.readyState>=n.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}},WebGL1Renderer:Zm,WebGL3DRenderTarget:class extends Yt{constructor(n,t,e){super(n,t),this.isWebGL3DRenderTarget=!0,this.depth=e,this.texture=new nl(null,n,t,e),this.texture.isRenderTargetTexture=!0}},WebGLArrayRenderTarget:class extends Yt{constructor(n,t,e){super(n,t),this.isWebGLArrayRenderTarget=!0,this.depth=e,this.texture=new Sa(null,n,t,e),this.texture.isRenderTargetTexture=!0}},WebGLCubeRenderTarget:Sl,WebGLMultipleRenderTargets:am,WebGLMultisampleRenderTarget:class extends Yt{constructor(n,t,e){console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),super(n,t,e),this.samples=4}},WebGLRenderTarget:Yt,WebGLRenderer:mu,WebGLUtils:Xm,WireframeGeometry:Rf,WrapAroundEnding:2402,ZeroCurvatureEnding:2400,ZeroFactor:200,ZeroSlopeEnding:2401,ZeroStencilOp:0,_SRGBAFormat:1035,sRGBEncoding:3001},Symbol.toStringTag,{value:"Module"}));var Eg,Cg,Yu,Ja=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof Xo<"u"?Xo:typeof self<"u"?self:{},Ag={exports:{}};Cg=Ja,Yu=function(){function n(t){var e=[];if(t.length===0)return"";if(typeof t[0]!="string")throw new TypeError("Url must be a string. Received "+t[0]);if(t[0].match(/^[^/:]+:\/*$/)&&t.length>1){var i=t.shift();t[0]=i+t[0]}t[0].match(/^file:\/\/\//)?t[0]=t[0].replace(/^([^/:]+):\/*/,"$1:///"):t[0]=t[0].replace(/^([^/:]+):\/*/,"$1://");for(var s=0;s<t.length;s++){var r=t[s];if(typeof r!="string")throw new TypeError("Url must be a string. Received "+r);r!==""&&(s>0&&(r=r.replace(/^[\/]+/,"")),r=s<t.length-1?r.replace(/[\/]+$/,""):r.replace(/[\/]+$/,"/"),e.push(r))}var a=e.join("/"),o=(a=a.replace(/\/(\?|&|#[^!])/g,"$1")).split("?");return a=o.shift()+(o.length>0?"?":"")+o.join("&")}return function(){return n(typeof arguments[0]=="object"?arguments[0]:[].slice.call(arguments))}},(Eg=Ag).exports?Eg.exports=Yu():Cg.urljoin=Yu();const Zu=Ag.exports;let Ju=null;function lh(){if(Ju!==null)return Ju;let n="";if(n=typeof MAPV_BASE_URL=="string"?MAPV_BASE_URL:"https://mapv-three.bj.bcebos.com",!n)throw new Error("Unable to determine base URL automatically, try defining a global variable called MAPV_BASE_URL.");return Ju=n,n}function me(...n){return Zu(lh(),...n)}const Sb=Object.freeze(Object.defineProperty({__proto__:null,getBaseUrl:lh,getAssetUrl:me},Symbol.toStringTag,{value:"Module"}));class jr extends Mt{constructor(){super(),g(this,"isEmptySky",!0),g(this,"_addDefaultEnvMap",!1),g(this,"_time",21600),g(this,"_startTimestamp",new Date().getTime()),g(this,"_timeAnimation",!1),g(this,"_timeAnimationSpeed",1),g(this,"_skyLightIntensity",.5),g(this,"_skyLightAttenuationRatio",.2),g(this,"_sunIntensityBias",0),g(this,"_sunIntensityScale",.8),g(this,"_weather","partlyCloudy"),g(this,"_timeChangedListeners",[]),g(this,"_sunDirection",new S),g(this,"_sunLightColorDay",new nt(16777215)),g(this,"_sunLightColorSunset",new nt(15090944)),g(this,"_sunLightColorCurrent",new nt(16777215)),g(this,"_sunRadian",null),g(this,"_skyLightColorDay",new nt(16777215)),g(this,"_skyLightColorNight",new nt(16777215)),g(this,"_groundLightColorDay",new nt(16777215)),g(this,"_groundLightColorNight",new nt(16758093)),g(this,"_lightNeedsUpdate",!1),g(this,"_sunNeedsUpdate",!1),g(this,"_affectWorld",!1),g(this,"updateSunLightShadowCamera",()=>{const i=this.engine;if(!i.renderer.shadowMap.enabled){const f=this.sunLight;return f.position.copy(this._sunDirection),f.target.position.set(0,0,0),f.updateMatrix(),f.updateMatrixWorld(),f.target.updateMatrix(),void f.target.updateMatrixWorld()}const s=this._sunDirection,r=[s.x,s.y,s.z],a=this.sunLight,[o,l]=i.map.getProjectionCenter();let h=i.map.getCameraDistance(),c=1e3;const u=c*r[0],d=c*r[1],p=c*r[2];a.position.set(o+u,l+d,p),a.target.position.set(o,l,0),a.shadow.camera.left=-h,a.shadow.camera.bottom=-h,a.shadow.camera.right=h,a.shadow.camera.top=h,a.shadow.camera.near=1,a.shadow.camera.far=h>2e4?1:2e3,a.updateMatrix(),a.updateMatrixWorld(),a.target.updateMatrix(),a.target.updateMatrixWorld(),a.shadow.camera.updateProjectionMatrix();const m=Ie.mapLinear(i.rendering.camera.position.z,1,500,-8e-5,-.001);a.shadow.bias=m<-.001?-.001:m});const t=this.sunLight=new Ql(16777215,.6),e=this.skyLight=new Uu(16755200,255,this._skyLightIntensity);e.position.set(0,0,1),t.castShadow=!0,t.shadow.mapSize=new V(1024,1024),t.shadow.bias=-1e-4,this.add(t),this.add(t.target),this.add(e),t.matrixAutoUpdate=!1,t.target.matrixAutoUpdate=!1}afterAddToEngine(t){if(this.engine=t,this.weather=this._weather,!this.isDynamicSky&&!this.isStaticSky&&this._addDefaultEnvMap){const e=new Te().load(me("assets/textures/sky/partlyCloudy_default.jpg"));e.mapping=303,e.encoding=3001,t.rendering.scene.environment=e}}set time(t){this._time=t;const e=this._sunRadian=(t/86400-.25)*Math.PI*2,i=Math.cos(e),s=Math.sin(e);this._sunDirection.set(i,0,s),this._lightNeedsUpdate=!0,this.onTimeChanged(this._time);for(const r of this._timeChangedListeners)r(t)}get time(){return this._time}get weather(){return this._weather}set weather(t){this._weather=t,this.onWeatherChanged(t)}get timeAnimation(){return this._timeAnimation}set timeAnimation(t){t&&(this._startTimestamp=new Date().getTime()-this.time/86400*(86400/this._timeAnimationSpeed)),this._timeAnimation=t}get timeAnimationSpeed(){return this._timeAnimationSpeed}set timeAnimationSpeed(t){this._timeAnimationSpeed=t}tickTime(){const t=new Date().getTime()-this._startTimestamp,e=86400/this._timeAnimationSpeed;this.time=t%e/e*86400}onBeforeScenePrepareRender(){this._timeAnimation&&this.tickTime(),this._lightNeedsUpdate&&this.updateLight(),this.updateSunLightShadowCamera()}updateLight(){const t=this._sunDirection.z,e=t>.5?1:t<0?0:2*t;this.sunLight.intensity=this._sunIntensityBias+this._sunIntensityScale*e;const i=this.sunsetRatio=t>.259?0:t<0?1:1-t/.259;this.skyLight.intensity=this._skyLightIntensity*Ie.clamp(1-i,this._skyLightAttenuationRatio,1),this._sunLightColorCurrent.lerpColors(this._sunLightColorDay,this._sunLightColorSunset,i),this.sunLight.color.copy(this._sunLightColorCurrent),this.skyLight.color.lerpColors(this._skyLightColorDay,this._skyLightColorNight,i),this.skyLight.groundColor.lerpColors(this._groundLightColorDay,this._groundLightColorNight,i)}addTimeChangedListener(t){this._timeChangedListeners.indexOf(t)===-1&&this._timeChangedListeners.push(t)}removeTimeChangedListener(t){const e=this._timeChangedListeners.indexOf(t);e!==-1&&this._timeChangedListeners.splice(e,1)}onTimeChanged(t){}onWeatherChanged(t){}dispose(){}get sunIntensityBias(){return this._sunIntensityBias}set sunIntensityBias(t){this._sunIntensityBias=t,this._lightNeedsUpdate=!0}get sunIntensityScale(){return this._sunIntensityScale}set sunIntensityScale(t){this._sunIntensityScale=t,this._lightNeedsUpdate=!0}get skyLightIntensity(){return this._skyLightIntensity}set skyLightIntensity(t){this._skyLightIntensity=t,this._lightNeedsUpdate=!0}get skyLightAttenuationRatio(){return this._skyLightAttenuationRatio}set skyLightAttenuationRatio(t){this._skyLightAttenuationRatio=t,this._lightNeedsUpdate=!0}get sunDirection(){return this._sunDirection}get affectWorld(){return this._affectWorld}}const Pg="Alpha",Rg="Attraction",Lg="Color",Ig="CrossZone",Dg="Force",Og="Gravity",zg="RandomDrift",Ug="Repulsion",Fg="Rotate",Ng="Scale",kg="Spring",Bg="Body",Ku="BodySprite",Qu="Texture",Vg="Life",Gg="Mass",jg="Position",Hg="Radius",Wg="VectorVelocity",qg="PolarVelocity",Xg="RadialVelocity",Yg=[Ku,Qu],Zg="BoxZone",Jg="LineZone",Kg="MeshZone",Qg="PointZone",$g="SphereZone",je=3.142,$u=500,Hr=je/180,t0="euler",Tb=()=>!!process&&!!process.env&&!1,hh={easeLinear:function(n){return n},easeInQuad:function(n){return Math.pow(n,2)},easeOutQuad:function(n){return-(Math.pow(n-1,2)-1)},easeInOutQuad:function(n){return(n/=.5)<1?.5*Math.pow(n,2):-.5*((n-=2)*n-2)},easeInCubic:function(n){return Math.pow(n,3)},easeOutCubic:function(n){return Math.pow(n-1,3)+1},easeInOutCubic:function(n){return(n/=.5)<1?.5*Math.pow(n,3):.5*(Math.pow(n-2,3)+2)},easeInQuart:function(n){return Math.pow(n,4)},easeOutQuart:function(n){return-(Math.pow(n-1,4)-1)},easeInOutQuart:function(n){return(n/=.5)<1?.5*Math.pow(n,4):-.5*((n-=2)*Math.pow(n,3)-2)},easeInSine:function(n){return 1-Math.cos(n*(je/2))},easeOutSine:function(n){return Math.sin(n*(je/2))},easeInOutSine:function(n){return-.5*(Math.cos(je*n)-1)},easeInExpo:function(n){return n===0?0:Math.pow(2,10*(n-1))},easeOutExpo:function(n){return n===1?1:1-Math.pow(2,-10*n)},easeInOutExpo:function(n){return n===0?0:n===1?1:(n/=.5)<1?.5*Math.pow(2,10*(n-1)):.5*(2-Math.pow(2,-10*--n))},easeInCirc:function(n){return-(Math.sqrt(1-n*n)-1)},easeOutCirc:function(n){return Math.sqrt(1-Math.pow(n-1,2))},easeInOutCirc:function(n){return(n/=.5)<1?-.5*(Math.sqrt(1-n*n)-1):.5*(Math.sqrt(1-(n-=2)*n)+1)},easeInBack:function(n){var t=1.70158;return n*n*((t+1)*n-t)},easeOutBack:function(n){var t=1.70158;return(n-=1)*n*((t+1)*n+t)+1},easeInOutBack:function(n){var t=1.70158;return(n/=.5)<1?n*n*((1+(t*=1.525))*n-t)*.5:.5*((n-=2)*n*((1+(t*=1.525))*n+t)+2)}},{easeLinear:e0,easeInQuad:g3,easeOutQuad:v3,easeInOutQuad:_3,easeInCubic:y3,easeOutCubic:x3,easeInOutCubic:b3,easeInQuart:M3,easeOutQuart:w3,easeInOutQuart:S3,easeInSine:T3,easeOutSine:E3,easeInOutSine:C3,easeInExpo:A3,easeOutExpo:P3,easeInOutExpo:R3,easeInCirc:L3,easeOutCirc:I3,easeInOutCirc:D3,easeInBack:O3,easeOutBack:z3,easeInOutBack:U3}=hh,Bi=n=>hh[n]?hh[n]:hh.easeLinear,i0=1/0,n0=e0,s0=.0167,td=[jg,Vg,Hg,Gg,Bg,Ku,Qu,qg,Xg,Wg],r0=[Pg,Rg,Lg,Ig,Dg,Og,zg,Ug,Fg,Ng,kg],Eb=[Zg,Jg,Kg,Qg,$g];function Ka(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}const a0=function(n){var t={};if(typeof n=="number")i=Math.floor(n),t.r=(n>>16&255)/255,t.g=(n>>8&255)/255,t.b=(255&n)/255;else if(typeof n=="string"){var e;if(e=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n))t.r=Math.min(255,parseInt(e[1],10))/255,t.g=Math.min(255,parseInt(e[2],10))/255,t.b=Math.min(255,parseInt(e[3],10))/255;else if(e=/^\#([A-Fa-f0-9]+)$/.exec(n)){var i=e[1];t.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,t.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,t.b=parseInt(i.charAt(4)+i.charAt(5),16)/255}}else t.r=n.r,t.g=n.g,t.b=n.b;return t},o0={_id:0,_uids:new Map,getNewId:function(){return"PUID_"+ ++this._id},id:function(n){if(this._uids.has(n))return this._uids.get(n);const t=this.getNewId();return this._uids.set(n,t),t}};var ed,l0,ch,yi,Tn,Qa,qe,h0,c0,id,$a={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){for(var n=[],t=0;t<256;t++)n[t]=(t<16?"0":"")+t.toString(16);return function(){var e=4294967295*Math.random()|0,i=4294967295*Math.random()|0,s=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(n[255&e]+n[e>>8&255]+n[e>>16&255]+n[e>>24&255]+"-"+n[255&i]+n[i>>8&255]+"-"+n[i>>16&15|64]+n[i>>24&255]+"-"+n[63&s|128]+n[s>>8&255]+"-"+n[s>>16&255]+n[s>>24&255]+n[255&r]+n[r>>8&255]+n[r>>16&255]+n[r>>24&255]).toUpperCase()}}(),clamp:function(n,t,e){return Math.max(t,Math.min(e,n))},euclideanModulo:function(n,t){return(n%t+t)%t},mapLinear:function(n,t,e,i,s){return i+(n-t)*(s-i)/(e-t)},lerp:function(n,t,e){return(1-e)*n+e*t},smoothstep:function(n,t,e){return n<=t?0:n>=e?1:(n=(n-t)/(e-t))*n*(3-2*n)},smootherstep:function(n,t,e){return n<=t?0:n>=e?1:(n=(n-t)/(e-t))*n*n*(n*(6*n-15)+10)},randInt:function(n,t){return n+Math.floor(Math.random()*(t-n+1))},randFloat:function(n,t){return n+Math.random()*(t-n)},randFloatSpread:function(n){return n*(.5-Math.random())},degToRad:function(n){return n*$a.DEG2RAD},radToDeg:function(n){return n*$a.RAD2DEG},isPowerOfTwo:function(n){return(n&n-1)==0&&n!==0},ceilPowerOfTwo:function(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))},floorPowerOfTwo:function(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}};function Wr(n,t,e,i){this._x=n||0,this._y=t||0,this._z=e||0,this._w=i!==void 0?i:1}function ze(n,t,e){this.x=n||0,this.y=t||0,this.z=e||0}function uh(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}function Ls(n,t,e,i){this._x=n||0,this._y=t||0,this._z=e||0,this._order=i||Ls.DefaultOrder}Object.assign(Wr,{slerp:function(n,t,e,i){return e.copy(n).slerp(t,i)},slerpFlat:function(n,t,e,i,s,r,a){var o=e[i+0],l=e[i+1],h=e[i+2],c=e[i+3],u=s[r+0],d=s[r+1],p=s[r+2],m=s[r+3];if(c!==m||o!==u||l!==d||h!==p){var f=1-a,v=o*u+l*d+h*p+c*m,_=v>=0?1:-1,y=1-v*v;if(y>Number.EPSILON){var x=Math.sqrt(y),b=Math.atan2(x,v*_);f=Math.sin(f*b)/x,a=Math.sin(a*b)/x}var w=a*_;if(o=o*f+u*w,l=l*f+d*w,h=h*f+p*w,c=c*f+m*w,f===1-a){var M=1/Math.sqrt(o*o+l*l+h*h+c*c);o*=M,l*=M,h*=M,c*=M}}n[t]=o,n[t+1]=l,n[t+2]=h,n[t+3]=c}}),Object.defineProperties(Wr.prototype,{x:{get:function(){return this._x},set:function(n){this._x=n,this._onChangeCallback()}},y:{get:function(){return this._y},set:function(n){this._y=n,this._onChangeCallback()}},z:{get:function(){return this._z},set:function(n){this._z=n,this._onChangeCallback()}},w:{get:function(){return this._w},set:function(n){this._w=n,this._onChangeCallback()}}}),Object.assign(Wr.prototype,{isQuaternion:!0,set:function(n,t,e,i){return this._x=n,this._y=t,this._z=e,this._w=i,this._onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._w)},copy:function(n){return this._x=n.x,this._y=n.y,this._z=n.z,this._w=n.w,this._onChangeCallback(),this},setFromEuler:function(n,t){if(!n||!n.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");var e=n._x,i=n._y,s=n._z,r=n.order,a=Math.cos,o=Math.sin,l=a(e/2),h=a(i/2),c=a(s/2),u=o(e/2),d=o(i/2),p=o(s/2);return r==="XYZ"?(this._x=u*h*c+l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c-u*d*p):r==="YXZ"?(this._x=u*h*c+l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c+u*d*p):r==="ZXY"?(this._x=u*h*c-l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c-u*d*p):r==="ZYX"?(this._x=u*h*c-l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c+u*d*p):r==="YZX"?(this._x=u*h*c+l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c-u*d*p):r==="XZY"&&(this._x=u*h*c-l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c+u*d*p),t!==!1&&this._onChangeCallback(),this},setFromAxisAngle:function(n,t){var e=t/2,i=Math.sin(e);return this._x=n.x*i,this._y=n.y*i,this._z=n.z*i,this._w=Math.cos(e),this._onChangeCallback(),this},setFromRotationMatrix:function(n){var t,e=n.elements,i=e[0],s=e[4],r=e[8],a=e[1],o=e[5],l=e[9],h=e[2],c=e[6],u=e[10],d=i+o+u;return d>0?(t=.5/Math.sqrt(d+1),this._w=.25/t,this._x=(c-l)*t,this._y=(r-h)*t,this._z=(a-s)*t):i>o&&i>u?(t=2*Math.sqrt(1+i-o-u),this._w=(c-l)/t,this._x=.25*t,this._y=(s+a)/t,this._z=(r+h)/t):o>u?(t=2*Math.sqrt(1+o-i-u),this._w=(r-h)/t,this._x=(s+a)/t,this._y=.25*t,this._z=(l+c)/t):(t=2*Math.sqrt(1+u-i-o),this._w=(a-s)/t,this._x=(r+h)/t,this._y=(l+c)/t,this._z=.25*t),this._onChangeCallback(),this},setFromUnitVectors:function(n,t){var e=n.dot(t)+1;return e<1e-6?(e=0,Math.abs(n.x)>Math.abs(n.z)?(this._x=-n.y,this._y=n.x,this._z=0,this._w=e):(this._x=0,this._y=-n.z,this._z=n.y,this._w=e)):(this._x=n.y*t.z-n.z*t.y,this._y=n.z*t.x-n.x*t.z,this._z=n.x*t.y-n.y*t.x,this._w=e),this.normalize()},angleTo:function(n){return 2*Math.acos(Math.abs($a.clamp(this.dot(n),-1,1)))},rotateTowards:function(n,t){var e=this.angleTo(n);if(e===0)return this;var i=Math.min(1,t/e);return this.slerp(n,i),this},inverse:function(){return this.conjugate()},conjugate:function(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this},dot:function(n){return this._x*n._x+this._y*n._y+this._z*n._z+this._w*n._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var n=this.length();return n===0?(this._x=0,this._y=0,this._z=0,this._w=1):(n=1/n,this._x=this._x*n,this._y=this._y*n,this._z=this._z*n,this._w=this._w*n),this._onChangeCallback(),this},multiply:function(n,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(n,t)):this.multiplyQuaternions(this,n)},premultiply:function(n){return this.multiplyQuaternions(n,this)},multiplyQuaternions:function(n,t){var e=n._x,i=n._y,s=n._z,r=n._w,a=t._x,o=t._y,l=t._z,h=t._w;return this._x=e*h+r*a+i*l-s*o,this._y=i*h+r*o+s*a-e*l,this._z=s*h+r*l+e*o-i*a,this._w=r*h-e*a-i*o-s*l,this._onChangeCallback(),this},slerp:function(n,t){if(t===0)return this;if(t===1)return this.copy(n);var e=this._x,i=this._y,s=this._z,r=this._w,a=r*n._w+e*n._x+i*n._y+s*n._z;if(a<0?(this._w=-n._w,this._x=-n._x,this._y=-n._y,this._z=-n._z,a=-a):this.copy(n),a>=1)return this._w=r,this._x=e,this._y=i,this._z=s,this;var o=1-a*a;if(o<=Number.EPSILON){var l=1-t;return this._w=l*r+t*this._w,this._x=l*e+t*this._x,this._y=l*i+t*this._y,this._z=l*s+t*this._z,this.normalize(),this._onChangeCallback(),this}var h=Math.sqrt(o),c=Math.atan2(h,a),u=Math.sin((1-t)*c)/h,d=Math.sin(t*c)/h;return this._w=r*u+this._w*d,this._x=e*u+this._x*d,this._y=i*u+this._y*d,this._z=s*u+this._z*d,this._onChangeCallback(),this},equals:function(n){return n._x===this._x&&n._y===this._y&&n._z===this._z&&n._w===this._w},fromArray:function(n,t){return t===void 0&&(t=0),this._x=n[t],this._y=n[t+1],this._z=n[t+2],this._w=n[t+3],this._onChangeCallback(),this},toArray:function(n,t){return n===void 0&&(n=[]),t===void 0&&(t=0),n[t]=this._x,n[t+1]=this._y,n[t+2]=this._z,n[t+3]=this._w,n},_onChange:function(n){return this._onChangeCallback=n,this},_onChangeCallback:function(){}}),Object.assign(ze.prototype,{isVector3:!0,set:function(n,t,e){return this.x=n,this.y=t,this.z=e,this},setScalar:function(n){return this.x=n,this.y=n,this.z=n,this},setX:function(n){return this.x=n,this},setY:function(n){return this.y=n,this},setZ:function(n){return this.z=n,this},setComponent:function(n,t){switch(n){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+n)}return this},getComponent:function(n){switch(n){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+n)}},clone:function(){return new this.constructor(this.x,this.y,this.z)},copy:function(n){return this.x=n.x,this.y=n.y,this.z=n.z,this},add:function(n,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(n,t)):(this.x+=n.x,this.y+=n.y,this.z+=n.z,this)},addScalar:function(n){return this.x+=n,this.y+=n,this.z+=n,this},addVectors:function(n,t){return this.x=n.x+t.x,this.y=n.y+t.y,this.z=n.z+t.z,this},addScaledVector:function(n,t){return this.x+=n.x*t,this.y+=n.y*t,this.z+=n.z*t,this},sub:function(n,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(n,t)):(this.x-=n.x,this.y-=n.y,this.z-=n.z,this)},subScalar:function(n){return this.x-=n,this.y-=n,this.z-=n,this},subVectors:function(n,t){return this.x=n.x-t.x,this.y=n.y-t.y,this.z=n.z-t.z,this},multiply:function(n,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(n,t)):(this.x*=n.x,this.y*=n.y,this.z*=n.z,this)},multiplyScalar:function(n){return this.x*=n,this.y*=n,this.z*=n,this},multiplyVectors:function(n,t){return this.x=n.x*t.x,this.y=n.y*t.y,this.z=n.z*t.z,this},applyEuler:(l0=new Wr,function(n){return n&&n.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(l0.setFromEuler(n))}),applyAxisAngle:function(){var n=new Wr;return function(t,e){return this.applyQuaternion(n.setFromAxisAngle(t,e))}}(),applyMatrix3:function(n){var t=this.x,e=this.y,i=this.z,s=n.elements;return this.x=s[0]*t+s[3]*e+s[6]*i,this.y=s[1]*t+s[4]*e+s[7]*i,this.z=s[2]*t+s[5]*e+s[8]*i,this},applyMatrix4:function(n){var t=this.x,e=this.y,i=this.z,s=n.elements,r=1/(s[3]*t+s[7]*e+s[11]*i+s[15]);return this.x=(s[0]*t+s[4]*e+s[8]*i+s[12])*r,this.y=(s[1]*t+s[5]*e+s[9]*i+s[13])*r,this.z=(s[2]*t+s[6]*e+s[10]*i+s[14])*r,this},applyQuaternion:function(n){var t=this.x,e=this.y,i=this.z,s=n.x,r=n.y,a=n.z,o=n.w,l=o*t+r*i-a*e,h=o*e+a*t-s*i,c=o*i+s*e-r*t,u=-s*t-r*e-a*i;return this.x=l*o+u*-s+h*-a-c*-r,this.y=h*o+u*-r+c*-s-l*-a,this.z=c*o+u*-a+l*-r-h*-s,this},project:function(n){return this.applyMatrix4(n.matrixWorldInverse).applyMatrix4(n.projectionMatrix)},unproject:function(n){return this.applyMatrix4(n.projectionMatrixInverse).applyMatrix4(n.matrixWorld)},transformDirection:function(n){var t=this.x,e=this.y,i=this.z,s=n.elements;return this.x=s[0]*t+s[4]*e+s[8]*i,this.y=s[1]*t+s[5]*e+s[9]*i,this.z=s[2]*t+s[6]*e+s[10]*i,this.normalize()},divide:function(n){return this.x/=n.x,this.y/=n.y,this.z/=n.z,this},divideScalar:function(n){return this.multiplyScalar(1/n)},min:function(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this.z=Math.min(this.z,n.z),this},max:function(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this.z=Math.max(this.z,n.z),this},clamp:function(n,t){return this.x=Math.max(n.x,Math.min(t.x,this.x)),this.y=Math.max(n.y,Math.min(t.y,this.y)),this.z=Math.max(n.z,Math.min(t.z,this.z)),this},clampScalar:function(n,t){return this.x=Math.max(n,Math.min(t,this.x)),this.y=Math.max(n,Math.min(t,this.y)),this.z=Math.max(n,Math.min(t,this.z)),this},clampLength:function(n,t){var e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(n,Math.min(t,e)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this},dot:function(n){return this.x*n.x+this.y*n.y+this.z*n.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(n){return this.normalize().multiplyScalar(n)},lerp:function(n,t){return this.x+=(n.x-this.x)*t,this.y+=(n.y-this.y)*t,this.z+=(n.z-this.z)*t,this},lerpVectors:function(n,t,e){return this.subVectors(t,n).multiplyScalar(e).add(n)},cross:function(n,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(n,t)):this.crossVectors(this,n)},crossVectors:function(n,t){var e=n.x,i=n.y,s=n.z,r=t.x,a=t.y,o=t.z;return this.x=i*o-s*a,this.y=s*r-e*o,this.z=e*a-i*r,this},projectOnVector:function(n){var t=n.dot(this)/n.lengthSq();return this.copy(n).multiplyScalar(t)},projectOnPlane:(ed=new ze,function(n){return ed.copy(this).projectOnVector(n),this.sub(ed)}),reflect:function(){var n=new ze;return function(t){return this.sub(n.copy(t).multiplyScalar(2*this.dot(t)))}}(),angleTo:function(n){var t=this.dot(n)/Math.sqrt(this.lengthSq()*n.lengthSq());return Math.acos($a.clamp(t,-1,1))},distanceTo:function(n){return Math.sqrt(this.distanceToSquared(n))},distanceToSquared:function(n){var t=this.x-n.x,e=this.y-n.y,i=this.z-n.z;return t*t+e*e+i*i},manhattanDistanceTo:function(n){return Math.abs(this.x-n.x)+Math.abs(this.y-n.y)+Math.abs(this.z-n.z)},setFromSpherical:function(n){return this.setFromSphericalCoords(n.radius,n.phi,n.theta)},setFromSphericalCoords:function(n,t,e){var i=Math.sin(t)*n;return this.x=i*Math.sin(e),this.y=Math.cos(t)*n,this.z=i*Math.cos(e),this},setFromCylindrical:function(n){return this.setFromCylindricalCoords(n.radius,n.theta,n.y)},setFromCylindricalCoords:function(n,t,e){return this.x=n*Math.sin(t),this.y=e,this.z=n*Math.cos(t),this},setFromMatrixPosition:function(n){var t=n.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this},setFromMatrixScale:function(n){var t=this.setFromMatrixColumn(n,0).length(),e=this.setFromMatrixColumn(n,1).length(),i=this.setFromMatrixColumn(n,2).length();return this.x=t,this.y=e,this.z=i,this},setFromMatrixColumn:function(n,t){return this.fromArray(n.elements,4*t)},equals:function(n){return n.x===this.x&&n.y===this.y&&n.z===this.z},fromArray:function(n,t){return t===void 0&&(t=0),this.x=n[t],this.y=n[t+1],this.z=n[t+2],this},toArray:function(n,t){return n===void 0&&(n=[]),t===void 0&&(t=0),n[t]=this.x,n[t+1]=this.y,n[t+2]=this.z,n},fromBufferAttribute:function(n,t,e){return e!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=n.getX(t),this.y=n.getY(t),this.z=n.getZ(t),this}}),Object.assign(uh.prototype,{isMatrix4:!0,set:function(n,t,e,i,s,r,a,o,l,h,c,u,d,p,m,f){var v=this.elements;return v[0]=n,v[4]=t,v[8]=e,v[12]=i,v[1]=s,v[5]=r,v[9]=a,v[13]=o,v[2]=l,v[6]=h,v[10]=c,v[14]=u,v[3]=d,v[7]=p,v[11]=m,v[15]=f,this},identity:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this},clone:function(){return new uh().fromArray(this.elements)},copy:function(n){var t=this.elements,e=n.elements;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],this},copyPosition:function(n){var t=this.elements,e=n.elements;return t[12]=e[12],t[13]=e[13],t[14]=e[14],this},extractBasis:function(n,t,e){return n.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this},makeBasis:function(n,t,e){return this.set(n.x,t.x,e.x,0,n.y,t.y,e.y,0,n.z,t.z,e.z,0,0,0,0,1),this},extractRotation:function(){var n=new ze;return function(t){var e=this.elements,i=t.elements,s=1/n.setFromMatrixColumn(t,0).length(),r=1/n.setFromMatrixColumn(t,1).length(),a=1/n.setFromMatrixColumn(t,2).length();return e[0]=i[0]*s,e[1]=i[1]*s,e[2]=i[2]*s,e[3]=0,e[4]=i[4]*r,e[5]=i[5]*r,e[6]=i[6]*r,e[7]=0,e[8]=i[8]*a,e[9]=i[9]*a,e[10]=i[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}}(),makeRotationFromEuler:function(n){n&&n.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");var t=this.elements,e=n.x,i=n.y,s=n.z,r=Math.cos(e),a=Math.sin(e),o=Math.cos(i),l=Math.sin(i),h=Math.cos(s),c=Math.sin(s);if(n.order==="XYZ"){var u=r*h,d=r*c,p=a*h,m=a*c;t[0]=o*h,t[4]=-o*c,t[8]=l,t[1]=d+p*l,t[5]=u-m*l,t[9]=-a*o,t[2]=m-u*l,t[6]=p+d*l,t[10]=r*o}else if(n.order==="YXZ"){var f=o*h,v=o*c,_=l*h,y=l*c;t[0]=f+y*a,t[4]=_*a-v,t[8]=r*l,t[1]=r*c,t[5]=r*h,t[9]=-a,t[2]=v*a-_,t[6]=y+f*a,t[10]=r*o}else if(n.order==="ZXY")f=o*h,v=o*c,_=l*h,y=l*c,t[0]=f-y*a,t[4]=-r*c,t[8]=_+v*a,t[1]=v+_*a,t[5]=r*h,t[9]=y-f*a,t[2]=-r*l,t[6]=a,t[10]=r*o;else if(n.order==="ZYX")u=r*h,d=r*c,p=a*h,m=a*c,t[0]=o*h,t[4]=p*l-d,t[8]=u*l+m,t[1]=o*c,t[5]=m*l+u,t[9]=d*l-p,t[2]=-l,t[6]=a*o,t[10]=r*o;else if(n.order==="YZX"){var x=r*o,b=r*l,w=a*o,M=a*l;t[0]=o*h,t[4]=M-x*c,t[8]=w*c+b,t[1]=c,t[5]=r*h,t[9]=-a*h,t[2]=-l*h,t[6]=b*c+w,t[10]=x-M*c}else n.order==="XZY"&&(x=r*o,b=r*l,w=a*o,M=a*l,t[0]=o*h,t[4]=-c,t[8]=l*h,t[1]=x*c+M,t[5]=r*h,t[9]=b*c-w,t[2]=w*c-b,t[6]=a*h,t[10]=M*c+x);return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this},makeRotationFromQuaternion:(h0=new ze(0,0,0),c0=new ze(1,1,1),function(n){return this.compose(h0,n,c0)}),lookAt:(Tn=new ze,Qa=new ze,qe=new ze,function(n,t,e){var i=this.elements;return qe.subVectors(n,t),qe.lengthSq()===0&&(qe.z=1),qe.normalize(),Tn.crossVectors(e,qe),Tn.lengthSq()===0&&(Math.abs(e.z)===1?qe.x+=1e-4:qe.z+=1e-4,qe.normalize(),Tn.crossVectors(e,qe)),Tn.normalize(),Qa.crossVectors(qe,Tn),i[0]=Tn.x,i[4]=Qa.x,i[8]=qe.x,i[1]=Tn.y,i[5]=Qa.y,i[9]=qe.y,i[2]=Tn.z,i[6]=Qa.z,i[10]=qe.z,this}),multiply:function(n,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(n,t)):this.multiplyMatrices(this,n)},premultiply:function(n){return this.multiplyMatrices(n,this)},multiplyMatrices:function(n,t){var e=n.elements,i=t.elements,s=this.elements,r=e[0],a=e[4],o=e[8],l=e[12],h=e[1],c=e[5],u=e[9],d=e[13],p=e[2],m=e[6],f=e[10],v=e[14],_=e[3],y=e[7],x=e[11],b=e[15],w=i[0],M=i[4],T=i[8],R=i[12],E=i[1],A=i[5],z=i[9],F=i[13],G=i[2],U=i[6],k=i[10],H=i[14],W=i[3],N=i[7],X=i[11],K=i[15];return s[0]=r*w+a*E+o*G+l*W,s[4]=r*M+a*A+o*U+l*N,s[8]=r*T+a*z+o*k+l*X,s[12]=r*R+a*F+o*H+l*K,s[1]=h*w+c*E+u*G+d*W,s[5]=h*M+c*A+u*U+d*N,s[9]=h*T+c*z+u*k+d*X,s[13]=h*R+c*F+u*H+d*K,s[2]=p*w+m*E+f*G+v*W,s[6]=p*M+m*A+f*U+v*N,s[10]=p*T+m*z+f*k+v*X,s[14]=p*R+m*F+f*H+v*K,s[3]=_*w+y*E+x*G+b*W,s[7]=_*M+y*A+x*U+b*N,s[11]=_*T+y*z+x*k+b*X,s[15]=_*R+y*F+x*H+b*K,this},multiplyScalar:function(n){var t=this.elements;return t[0]*=n,t[4]*=n,t[8]*=n,t[12]*=n,t[1]*=n,t[5]*=n,t[9]*=n,t[13]*=n,t[2]*=n,t[6]*=n,t[10]*=n,t[14]*=n,t[3]*=n,t[7]*=n,t[11]*=n,t[15]*=n,this},applyToBufferAttribute:function(){var n=new ze;return function(t){for(var e=0,i=t.count;e<i;e++)n.x=t.getX(e),n.y=t.getY(e),n.z=t.getZ(e),n.applyMatrix4(this),t.setXYZ(e,n.x,n.y,n.z);return t}}(),determinant:function(){var n=this.elements,t=n[0],e=n[4],i=n[8],s=n[12],r=n[1],a=n[5],o=n[9],l=n[13],h=n[2],c=n[6],u=n[10],d=n[14];return n[3]*(+s*o*c-i*l*c-s*a*u+e*l*u+i*a*d-e*o*d)+n[7]*(+t*o*d-t*l*u+s*r*u-i*r*d+i*l*h-s*o*h)+n[11]*(+t*l*c-t*a*d-s*r*c+e*r*d+s*a*h-e*l*h)+n[15]*(-i*a*h-t*o*c+t*a*u+i*r*c-e*r*u+e*o*h)},transpose:function(){var n,t=this.elements;return n=t[1],t[1]=t[4],t[4]=n,n=t[2],t[2]=t[8],t[8]=n,n=t[6],t[6]=t[9],t[9]=n,n=t[3],t[3]=t[12],t[12]=n,n=t[7],t[7]=t[13],t[13]=n,n=t[11],t[11]=t[14],t[14]=n,this},setPosition:function(n,t,e){var i=this.elements;return n.isVector3?(i[12]=n.x,i[13]=n.y,i[14]=n.z):(i[12]=n,i[13]=t,i[14]=e),this},getInverse:function(n,t){var e=this.elements,i=n.elements,s=i[0],r=i[1],a=i[2],o=i[3],l=i[4],h=i[5],c=i[6],u=i[7],d=i[8],p=i[9],m=i[10],f=i[11],v=i[12],_=i[13],y=i[14],x=i[15],b=p*y*u-_*m*u+_*c*f-h*y*f-p*c*x+h*m*x,w=v*m*u-d*y*u-v*c*f+l*y*f+d*c*x-l*m*x,M=d*_*u-v*p*u+v*h*f-l*_*f-d*h*x+l*p*x,T=v*p*c-d*_*c-v*h*m+l*_*m+d*h*y-l*p*y,R=s*b+r*w+a*M+o*T;if(R===0){var E="THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";if(t===!0)throw new Error(E);return console.warn(E),this.identity()}var A=1/R;return e[0]=b*A,e[1]=(_*m*o-p*y*o-_*a*f+r*y*f+p*a*x-r*m*x)*A,e[2]=(h*y*o-_*c*o+_*a*u-r*y*u-h*a*x+r*c*x)*A,e[3]=(p*c*o-h*m*o-p*a*u+r*m*u+h*a*f-r*c*f)*A,e[4]=w*A,e[5]=(d*y*o-v*m*o+v*a*f-s*y*f-d*a*x+s*m*x)*A,e[6]=(v*c*o-l*y*o-v*a*u+s*y*u+l*a*x-s*c*x)*A,e[7]=(l*m*o-d*c*o+d*a*u-s*m*u-l*a*f+s*c*f)*A,e[8]=M*A,e[9]=(v*p*o-d*_*o-v*r*f+s*_*f+d*r*x-s*p*x)*A,e[10]=(l*_*o-v*h*o+v*r*u-s*_*u-l*r*x+s*h*x)*A,e[11]=(d*h*o-l*p*o-d*r*u+s*p*u+l*r*f-s*h*f)*A,e[12]=T*A,e[13]=(d*_*a-v*p*a+v*r*m-s*_*m-d*r*y+s*p*y)*A,e[14]=(v*h*a-l*_*a-v*r*c+s*_*c+l*r*y-s*h*y)*A,e[15]=(l*p*a-d*h*a+d*r*c-s*p*c-l*r*m+s*h*m)*A,this},scale:function(n){var t=this.elements,e=n.x,i=n.y,s=n.z;return t[0]*=e,t[4]*=i,t[8]*=s,t[1]*=e,t[5]*=i,t[9]*=s,t[2]*=e,t[6]*=i,t[10]*=s,t[3]*=e,t[7]*=i,t[11]*=s,this},getMaxScaleOnAxis:function(){var n=this.elements,t=n[0]*n[0]+n[1]*n[1]+n[2]*n[2],e=n[4]*n[4]+n[5]*n[5]+n[6]*n[6],i=n[8]*n[8]+n[9]*n[9]+n[10]*n[10];return Math.sqrt(Math.max(t,e,i))},makeTranslation:function(n,t,e){return this.set(1,0,0,n,0,1,0,t,0,0,1,e,0,0,0,1),this},makeRotationX:function(n){var t=Math.cos(n),e=Math.sin(n);return this.set(1,0,0,0,0,t,-e,0,0,e,t,0,0,0,0,1),this},makeRotationY:function(n){var t=Math.cos(n),e=Math.sin(n);return this.set(t,0,e,0,0,1,0,0,-e,0,t,0,0,0,0,1),this},makeRotationZ:function(n){var t=Math.cos(n),e=Math.sin(n);return this.set(t,-e,0,0,e,t,0,0,0,0,1,0,0,0,0,1),this},makeRotationAxis:function(n,t){var e=Math.cos(t),i=Math.sin(t),s=1-e,r=n.x,a=n.y,o=n.z,l=s*r,h=s*a;return this.set(l*r+e,l*a-i*o,l*o+i*a,0,l*a+i*o,h*a+e,h*o-i*r,0,l*o-i*a,h*o+i*r,s*o*o+e,0,0,0,0,1),this},makeScale:function(n,t,e){return this.set(n,0,0,0,0,t,0,0,0,0,e,0,0,0,0,1),this},makeShear:function(n,t,e){return this.set(1,t,e,0,n,1,e,0,n,t,1,0,0,0,0,1),this},compose:function(n,t,e){var i=this.elements,s=t._x,r=t._y,a=t._z,o=t._w,l=s+s,h=r+r,c=a+a,u=s*l,d=s*h,p=s*c,m=r*h,f=r*c,v=a*c,_=o*l,y=o*h,x=o*c,b=e.x,w=e.y,M=e.z;return i[0]=(1-(m+v))*b,i[1]=(d+x)*b,i[2]=(p-y)*b,i[3]=0,i[4]=(d-x)*w,i[5]=(1-(u+v))*w,i[6]=(f+_)*w,i[7]=0,i[8]=(p+y)*M,i[9]=(f-_)*M,i[10]=(1-(u+m))*M,i[11]=0,i[12]=n.x,i[13]=n.y,i[14]=n.z,i[15]=1,this},decompose:(ch=new ze,yi=new uh,function(n,t,e){var i=this.elements,s=ch.set(i[0],i[1],i[2]).length(),r=ch.set(i[4],i[5],i[6]).length(),a=ch.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),n.x=i[12],n.y=i[13],n.z=i[14],yi.copy(this);var o=1/s,l=1/r,h=1/a;return yi.elements[0]*=o,yi.elements[1]*=o,yi.elements[2]*=o,yi.elements[4]*=l,yi.elements[5]*=l,yi.elements[6]*=l,yi.elements[8]*=h,yi.elements[9]*=h,yi.elements[10]*=h,t.setFromRotationMatrix(yi),e.x=s,e.y=r,e.z=a,this}),makePerspective:function(n,t,e,i,s,r){r===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");var a=this.elements,o=2*s/(t-n),l=2*s/(e-i),h=(t+n)/(t-n),c=(e+i)/(e-i),u=-(r+s)/(r-s),d=-2*r*s/(r-s);return a[0]=o,a[4]=0,a[8]=h,a[12]=0,a[1]=0,a[5]=l,a[9]=c,a[13]=0,a[2]=0,a[6]=0,a[10]=u,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this},makeOrthographic:function(n,t,e,i,s,r){var a=this.elements,o=1/(t-n),l=1/(e-i),h=1/(r-s),c=(t+n)*o,u=(e+i)*l,d=(r+s)*h;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-c,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-u,a[2]=0,a[6]=0,a[10]=-2*h,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this},equals:function(n){for(var t=this.elements,e=n.elements,i=0;i<16;i++)if(t[i]!==e[i])return!1;return!0},fromArray:function(n,t){t===void 0&&(t=0);for(var e=0;e<16;e++)this.elements[e]=n[e+t];return this},toArray:function(n,t){n===void 0&&(n=[]),t===void 0&&(t=0);var e=this.elements;return n[t]=e[0],n[t+1]=e[1],n[t+2]=e[2],n[t+3]=e[3],n[t+4]=e[4],n[t+5]=e[5],n[t+6]=e[6],n[t+7]=e[7],n[t+8]=e[8],n[t+9]=e[9],n[t+10]=e[10],n[t+11]=e[11],n[t+12]=e[12],n[t+13]=e[13],n[t+14]=e[14],n[t+15]=e[15],n}}),Ls.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"],Ls.DefaultOrder="XYZ",Object.defineProperties(Ls.prototype,{x:{get:function(){return this._x},set:function(n){this._x=n,this._onChangeCallback()}},y:{get:function(){return this._y},set:function(n){this._y=n,this._onChangeCallback()}},z:{get:function(){return this._z},set:function(n){this._z=n,this._onChangeCallback()}},order:{get:function(){return this._order},set:function(n){this._order=n,this._onChangeCallback()}}}),Object.assign(Ls.prototype,{isEuler:!0,set:function(n,t,e,i){return this._x=n,this._y=t,this._z=e,this._order=i||this._order,this._onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._order)},copy:function(n){return this._x=n._x,this._y=n._y,this._z=n._z,this._order=n._order,this._onChangeCallback(),this},setFromRotationMatrix:function(n,t,e){var i=$a.clamp,s=n.elements,r=s[0],a=s[4],o=s[8],l=s[1],h=s[5],c=s[9],u=s[2],d=s[6],p=s[10];return(t=t||this._order)==="XYZ"?(this._y=Math.asin(i(o,-1,1)),Math.abs(o)<.99999?(this._x=Math.atan2(-c,p),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(d,h),this._z=0)):t==="YXZ"?(this._x=Math.asin(-i(c,-1,1)),Math.abs(c)<.99999?(this._y=Math.atan2(o,p),this._z=Math.atan2(l,h)):(this._y=Math.atan2(-u,r),this._z=0)):t==="ZXY"?(this._x=Math.asin(i(d,-1,1)),Math.abs(d)<.99999?(this._y=Math.atan2(-u,p),this._z=Math.atan2(-a,h)):(this._y=0,this._z=Math.atan2(l,r))):t==="ZYX"?(this._y=Math.asin(-i(u,-1,1)),Math.abs(u)<.99999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-a,h))):t==="YZX"?(this._z=Math.asin(i(l,-1,1)),Math.abs(l)<.99999?(this._x=Math.atan2(-c,h),this._y=Math.atan2(-u,r)):(this._x=0,this._y=Math.atan2(o,p))):t==="XZY"?(this._z=Math.asin(-i(a,-1,1)),Math.abs(a)<.99999?(this._x=Math.atan2(d,h),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-c,p),this._y=0)):console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: "+t),this._order=t,e!==!1&&this._onChangeCallback(),this},setFromQuaternion:function(){var n=new uh;return function(t,e,i){return n.makeRotationFromQuaternion(t),this.setFromRotationMatrix(n,e,i)}}(),setFromVector3:function(n,t){return this.set(n.x,n.y,n.z,t||this._order)},reorder:(id=new Wr,function(n){return id.setFromEuler(this),this.setFromQuaternion(id,n)}),equals:function(n){return n._x===this._x&&n._y===this._y&&n._z===this._z&&n._order===this._order},fromArray:function(n){return this._x=n[0],this._y=n[1],this._z=n[2],n[3]!==void 0&&(this._order=n[3]),this._onChangeCallback(),this},toArray:function(n,t){return n===void 0&&(n=[]),t===void 0&&(t=0),n[t]=this._x,n[t+1]=this._y,n[t+2]=this._z,n[t+3]=this._order,n},toVector3:function(n){return n?n.set(this._x,this._y,this._z):new ze(this._x,this._y,this._z)},_onChange:function(n){return this._onChangeCallback=n,this},_onChangeCallback:function(){}});const Yn={toScreenPos:function(){var n=new ze;return function(t,e,i){return n.copy(t),n.project(e),n.x=Math.round((n.x+1)*i.width/2),n.y=Math.round((1-n.y)*i.height/2),n.z=0,n}}(),toSpacePos:function(){var n,t=new ze,e=new ze;return function(i,s,r){return t.set(i.x/r.width*2-1,-i.y/r.height*2+1,.5),t.unproject(s),e.copy(t.sub(s.position).normalize()),n=-s.position.z/e.z,t.copy(s.position),t.add(e.multiplyScalar(n)),t}}()},Xe={initValue:function(n,t){return n!=null&&n!=null?n:t},isArray:function(n){return Object.prototype.toString.call(n)==="[object Array]"},destroyArray:function(n){n.length=0},destroyObject:function(n){for(var t in n)delete n[t]},isUndefined:function(){for(var n in arguments){var t=arguments[n];if(t!==void 0)return!1}return!0},setVectorByObj:function(n,t){t.x!==void 0&&(n.position.x=t.x),t.y!==void 0&&(n.position.y=t.y),t.z!==void 0&&(n.position.z=t.z),t.vx!==void 0&&(n.velocity.x=t.vx),t.vy!==void 0&&(n.velocity.y=t.vy),t.vz!==void 0&&(n.velocity.z=t.vz),t.ax!==void 0&&(n.acceleration.x=t.ax),t.ay!==void 0&&(n.acceleration.y=t.ay),t.az!==void 0&&(n.acceleration.z=t.az),t.p!==void 0&&n.position.copy(t.p),t.v!==void 0&&n.velocity.copy(t.v),t.a!==void 0&&n.acceleration.copy(t.a),t.position!==void 0&&n.position.copy(t.position),t.velocity!==void 0&&n.velocity.copy(t.velocity),t.accelerate!==void 0&&n.acceleration.copy(t.accelerate)},setPrototypeByObj:function(n,t,e){for(var i in t)n.hasOwnProperty(i)&&(e?e.indexOf(i)<0&&(n[i]=this._getValue(t[i])):n[i]=this._getValue(t[i]));return n},_getValue:function(n){return n.constructor.type==="Span"?n.getValue():n}};var nd={exports:{}},u0=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof window.msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto);if(u0){var d0=new Uint8Array(16);nd.exports=function(){return u0(d0),d0}}else{var p0=new Array(16);nd.exports=function(){for(var n,t=0;t<16;t++)!(3&t)&&(n=4294967296*Math.random()),p0[t]=n>>>((3&t)<<3)&255;return p0}}for(var m0=[],dh=0;dh<256;++dh)m0[dh]=(dh+256).toString(16).substr(1);var f0,sd,Cb=function(n,t){var e=t||0,i=m0;return[i[n[e++]],i[n[e++]],i[n[e++]],i[n[e++]],"-",i[n[e++]],i[n[e++]],"-",i[n[e++]],i[n[e++]],"-",i[n[e++]],i[n[e++]],"-",i[n[e++]],i[n[e++]],i[n[e++]],i[n[e++]],i[n[e++]],i[n[e++]]].join("")},Ab=nd.exports,Pb=Cb,rd=0,ad=0,od=function(n,t,e){var i=t&&e||0,s=t||[],r=(n=n||{}).node||f0,a=n.clockseq!==void 0?n.clockseq:sd;if(r==null||a==null){var o=Ab();r==null&&(r=f0=[1|o[0],o[1],o[2],o[3],o[4],o[5]]),a==null&&(a=sd=16383&(o[6]<<8|o[7]))}var l=n.msecs!==void 0?n.msecs:new Date().getTime(),h=n.nsecs!==void 0?n.nsecs:ad+1,c=l-rd+(h-ad)/1e4;if(c<0&&n.clockseq===void 0&&(a=a+1&16383),(c<0||l>rd)&&n.nsecs===void 0&&(h=0),h>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");rd=l,ad=h,sd=a;var u=(1e4*(268435455&(l+=122192928e5))+h)%4294967296;s[i++]=u>>>24&255,s[i++]=u>>>16&255,s[i++]=u>>>8&255,s[i++]=255&u;var d=l/4294967296*1e4&268435455;s[i++]=d>>>8&255,s[i++]=255&d,s[i++]=d>>>24&15|16,s[i++]=d>>>16&255,s[i++]=a>>>8|128,s[i++]=255&a;for(var p=0;p<6;++p)s[i+p]=r[p];return t||Pb(s)};function g0(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),e.push.apply(e,i)}return e}function v0(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?g0(Object(e),!0).forEach(function(i){Ka(n,i,e[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):g0(Object(e)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(e,i))})}return n}const ph=(n,t)=>v0(v0({},n),t),fe={randomAToB:function(n,t,e){return e?(Math.random()*(t-n)>>0)+n:n+Math.random()*(t-n)},randomFloating:function(n,t,e){return this.randomAToB(n-t,n+t,e)},randomZone:function(n){},degreeTransform:function(n){return n*je/180},toColor16:function(n){return"#"+n.toString(16)},randomColor:function(){return"#"+("00000"+(16777216*Math.random()<<0).toString(16)).slice(-6)},lerp:function(n,t,e){return t+(n-t)*e},getNormal:function(n,t){return n.x==0&&n.y==0?n.z==0?t.set(1,0,1):t.set(1,1,-n.y/n.z):n.x==0?t.set(1,0,1):t.set(-n.y/n.x,1,1),t.normalize()},axisRotate:function(n,t,e,i){var s=Math.cos(i),r=Math.sin(i),a=e.dot(t)*(1-s);n.copy(e),n.cross(t).scalar(r),n.addValue(t.x*s,t.y*s,t.z*s),n.addValue(e.x*a,e.y*a,e.z*a)}};class Ye{constructor(t,e,i){this._isArray=!1,this.type="Span",Xe.isArray(t)?(this._isArray=!0,this.a=t):(this.a=Xe.initValue(t,1),this.b=Xe.initValue(e,this.a),this._center=Xe.initValue(i,!1))}getValue(t){return this._isArray?this.a[this.a.length*Math.random()>>0]:this._center?fe.randomFloating(this.a,this.b,t):fe.randomAToB(this.a,this.b,t)}}const Ue=(n,t,e)=>n instanceof Ye?n:t===void 0?new Ye(n):e===void 0?new Ye(n,t):new Ye(n,t,e);var Rb=Math.floor,Lb=Math.random,Ib=function(n,t){return n+Rb(Lb()*(t-n+1))},_0=function(n){var t=n.length;return t?n[Ib(0,t-1)]:void 0},Db=function(n,t){for(var e=-1,i=n==null?0:n.length,s=Array(i);++e<i;)s[e]=t(n[e],e,n);return s},Ob=function(n,t){return Db(t,function(e){return n[e]})},zb=function(n,t){for(var e=-1,i=Array(n);++e<n;)i[e]=t(e);return i},y0=typeof Ja=="object"&&Ja&&Ja.Object===Object&&Ja,Ub=y0,Fb=typeof self=="object"&&self&&self.Object===Object&&self,x0=Ub||Fb||Function("return this")(),ld=x0.Symbol,b0=ld,M0=Object.prototype,Nb=M0.hasOwnProperty,kb=M0.toString,to=b0?b0.toStringTag:void 0,Bb=function(n){var t=Nb.call(n,to),e=n[to];try{n[to]=void 0;var i=!0}catch{}var s=kb.call(n);return i&&(t?n[to]=e:delete n[to]),s},Vb=Object.prototype.toString,Gb=Bb,jb=function(n){return Vb.call(n)},w0=ld?ld.toStringTag:void 0,mh=function(n){return n==null?n===void 0?"[object Undefined]":"[object Null]":w0&&w0 in Object(n)?Gb(n):jb(n)},fh=function(n){return n!=null&&typeof n=="object"},Hb=mh,Wb=fh,S0=function(n){return Wb(n)&&Hb(n)=="[object Arguments]"},qb=fh,T0=Object.prototype,Xb=T0.hasOwnProperty,Yb=T0.propertyIsEnumerable,Zb=S0(function(){return arguments}())?S0:function(n){return qb(n)&&Xb.call(n,"callee")&&!Yb.call(n,"callee")},Jb=Zb,E0=Array.isArray,hd={exports:{}},Kb=function(){return!1};(function(n,t){var e=x0,i=Kb,s=t&&!t.nodeType&&t,r=s&&n&&!n.nodeType&&n,a=r&&r.exports===s?e.Buffer:void 0,o=(a?a.isBuffer:void 0)||i;n.exports=o})(hd,hd.exports);var Qb=/^(?:0|[1-9]\d*)$/,$b=function(n,t){var e=typeof n;return!!(t=t??9007199254740991)&&(e=="number"||e!="symbol"&&Qb.test(n))&&n>-1&&n%1==0&&n<t},C0=function(n){return typeof n=="number"&&n>-1&&n%1==0&&n<=9007199254740991},tM=mh,eM=C0,iM=fh,te={};te["[object Float32Array]"]=te["[object Float64Array]"]=te["[object Int8Array]"]=te["[object Int16Array]"]=te["[object Int32Array]"]=te["[object Uint8Array]"]=te["[object Uint8ClampedArray]"]=te["[object Uint16Array]"]=te["[object Uint32Array]"]=!0,te["[object Arguments]"]=te["[object Array]"]=te["[object ArrayBuffer]"]=te["[object Boolean]"]=te["[object DataView]"]=te["[object Date]"]=te["[object Error]"]=te["[object Function]"]=te["[object Map]"]=te["[object Number]"]=te["[object Object]"]=te["[object RegExp]"]=te["[object Set]"]=te["[object String]"]=te["[object WeakMap]"]=!1;var nM=function(n){return iM(n)&&eM(n.length)&&!!te[tM(n)]},sM=function(n){return function(t){return n(t)}},cd={exports:{}};(function(n,t){var e=y0,i=t&&!t.nodeType&&t,s=i&&n&&!n.nodeType&&n,r=s&&s.exports===i&&e.process,a=function(){try{var o=s&&s.require&&s.require("util").types;return o||r&&r.binding&&r.binding("util")}catch{}}();n.exports=a})(cd,cd.exports);var rM=nM,aM=sM,A0=cd.exports,P0=A0&&A0.isTypedArray,oM=P0?aM(P0):rM,lM=zb,hM=Jb,cM=E0,uM=hd.exports,dM=$b,pM=oM,mM=Object.prototype.hasOwnProperty,fM=function(n,t){var e=cM(n),i=!e&&hM(n),s=!e&&!i&&uM(n),r=!e&&!i&&!s&&pM(n),a=e||i||s||r,o=a?lM(n.length,String):[],l=o.length;for(var h in n)!t&&!mM.call(n,h)||a&&(h=="length"||s&&(h=="offset"||h=="parent")||r&&(h=="buffer"||h=="byteLength"||h=="byteOffset")||dM(h,l))||o.push(h);return o},gM=Object.prototype,vM=function(n){var t=n&&n.constructor;return n===(typeof t=="function"&&t.prototype||gM)},_M=function(n,t){return function(e){return n(t(e))}}(Object.keys,Object),yM=vM,xM=_M,bM=Object.prototype.hasOwnProperty,MM=mh,wM=function(n){var t=typeof n;return n!=null&&(t=="object"||t=="function")},SM=function(n){if(!wM(n))return!1;var t=MM(n);return t=="[object Function]"||t=="[object GeneratorFunction]"||t=="[object AsyncFunction]"||t=="[object Proxy]"},TM=C0,EM=fM,CM=function(n){if(!yM(n))return xM(n);var t=[];for(var e in Object(n))bM.call(n,e)&&e!="constructor"&&t.push(e);return t},AM=function(n){return n!=null&&TM(n.length)&&!SM(n)},PM=Ob,RM=function(n){return AM(n)?EM(n):CM(n)},LM=_0,IM=function(n){return n==null?[]:PM(n,RM(n))},DM=_0,OM=function(n){return LM(IM(n))},zM=E0,R0=function(n){return(zM(n)?DM:OM)(n)};class L0 extends Ye{constructor(t){super(),this.type="ArraySpan",this.items=Array.isArray(t)?t:[t]}getValue(){return R0(this.items)}}class I0 extends Ye{constructor(t){super(),this.type="ColorSpan",this.shouldRandomize=t==="random",this.colors=Array.isArray(t)?t:[t]}getValue(){return this.shouldRandomize?fe.randomColor():R0(this.colors)}}const D0=n=>(n||(console.warn(`Invalid colors argument ${n} passed to createColorSpan. Defaulting to 'random'.`),n="random"),n instanceof I0?n:new I0(n)),UM="EULER",FM=(n,t,e)=>{n.sleep||(n.old.position.copy(n.position),n.old.velocity.copy(n.velocity),n.acceleration.scalar(1/n.mass),n.velocity.add(n.acceleration.scalar(t)),n.position.add(n.old.velocity.scalar(t)),e&&n.velocity.scalar(Math.pow(e,t/s0)),n.acceleration.clear())},O0=(n,t,e,i="EULER")=>{FM(n,t,e)};class kt extends ze{clear(){return this.x=0,this.y=0,this.z=0,this}scalar(t){return this.x*=t,this.y*=t,this.z*=t,this}addValue(t,e,i){return this.x+=t,this.y+=e,this.z+=i,this}toString(){return"x:"+this.x+"y:"+this.y+"z:"+this.z}eulerFromDir(t){return new Ls().setFromVector3(t)}}class ud{constructor(t,e,i){this.type="Polar3D",this.radius=t||1,this.phi=i||0,this.theta=e||0}set(t,e,i){return this.radius=t||1,this.phi=i||0,this.theta=e||0,this}setRadius(t){return this.radius=t,this}setPhi(t){return this.phi=t,this}setTheta(t){return this.theta=t,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}toVector3D(){return new kt(this.getX(),this.getY(),this.getZ())}getX(){return this.radius*Math.sin(this.theta)*Math.cos(this.phi)}getY(){return-this.radius*Math.sin(this.theta)*Math.sin(this.phi)}getZ(){return this.radius*Math.cos(this.theta)}normalize(){return this.radius=1,this}equals(t){return t.radius===this.radius&&t.phi===this.phi&&t.theta===this.theta}clear(){return this.radius=0,this.phi=0,this.theta=0,this}clone(){return new ud(this.radius,this.phi,this.theta)}}class z0{constructor(t){this.id=`particle-${od()}`,this.type="Particle",this.life=i0,this.age=0,this.energy=1,this.dead=!1,this.sleep=!1,this.body=null,this.parent=null,this.mass=1,this.radius=10,this.alpha=1,this.scale=1,this.useColor=!1,this.useAlpha=!1,this.easing=n0,this.position=new kt,this.velocity=new kt,this.acceleration=new kt,this.old={},this.old.position=this.position.clone(),this.old.velocity=this.velocity.clone(),this.old.acceleration=this.acceleration.clone(),this.behaviours=[],this.transform={},this.color={r:0,g:0,b:0},this.rotation=new kt,this.distanceToCamera=0,Xe.setPrototypeByObj(this,t)}getDirection(){return Math.atan2(this.velocity.x,-this.velocity.y)*(180/je)}reset(){return this.life=i0,this.age=0,this.energy=1,this.dead=!1,this.sleep=!1,this.body=null,this.parent=null,this.mass=1,this.radius=10,this.alpha=1,this.scale=1,this.useColor=!1,this.useAlpha=!1,this.easing=n0,this.position.set(0,0,0),this.velocity.set(0,0,0),this.acceleration.set(0,0,0),this.old.position.set(0,0,0),this.old.velocity.set(0,0,0),this.old.acceleration.set(0,0,0),this.color.r=0,this.color.g=0,this.color.b=0,this.rotation.clear(),Xe.destroyObject(this.transform),this.removeAllBehaviours(),this}update(t,e){if(!this.sleep){this.age+=t;let i=this.behaviours.length;for(;i--;)this.behaviours[i].applyBehaviour(this,t,e)}if(this.age>=this.life)this.destroy();else{const i=this.easing(this.age/this.life);this.energy=Math.max(1-i,0)}}addBehaviour(t){this.behaviours.push(t),t.initialize(this)}addBehaviours(t){let e=t.length;for(;e--;)this.addBehaviour(t[e])}removeBehaviour(t){const e=this.behaviours.indexOf(t);e>-1&&this.behaviours.splice(e,1)}removeAllBehaviours(){Xe.destroyArray(this.behaviours)}destroy(){this.removeAllBehaviours(),this.energy=0,this.dead=!0,this.parent=null}}class dd{constructor(){this.type="Pool",this.cID=0,this.list={}}create(t,...e){if(!this.canCreateNewObject(t))throw new Error("The pool is unable to create or clone the object supplied");return this.cID++,this.canInstantiateObject(t)?new t(...e):this.canCloneObject(t)?t.clone():void 0}canInstantiateObject(t){return typeof t=="function"}canCloneObject(t){return t.clone&&typeof t.clone=="function"}canCreateNewObject(t){return!(!this.canInstantiateObject(t)&&!this.canCloneObject(t))}getCount(){var t=0;for(var e in this.list)t+=this.list[e].length;return t++}get(t,...e){var i,s=t.__puid||o0.id(t);return(i=this.list[s]&&this.list[s].length>0?this.list[s].pop():this.create(t,...e)).__puid=t.__puid||s,i}expire(t){return this._getList(t.__puid).push(t)}destroy(){for(var t in this.list)this.list[t].length=0,delete this.list[t]}_getList(t){return t=t||"default",this.list[t]||(this.list[t]=[]),this.list[t]}}class U0{constructor(){this.listeners=null}set listeners(t){this._listeners=t}get listeners(){return this._listeners}addEventListener(t,e){return this.listeners?this.removeEventListener(t,e):this.listeners={},this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e),e}removeEventListener(t,e){if(this.listeners&&this.listeners[t]){for(var i=this.listeners[t],s=0,r=i.length;s<r;s++)if(i[s]==e){r==1?delete this.listeners[t]:i.splice(s,1);break}}}removeAllEventListeners(t){t?this.listeners&&delete this.listeners[t]:this.listeners=null}dispatchEvent(t,e){var i=!1,s=this.listeners;if(t&&s){var r=s[t];if(!r)return i;for(var a,o=(r=r.slice()).length;o--;)a=r[o],i=i||a(e)}return!!i}hasEventListener(t){var e=this.listeners;return!(!e||!e[t])}}const pd="SYSTEM_UPDATE",md="PARTICLE_CREATED",fd="PARTICLE_UPDATE",gd="PARTICLE_DEAD";class En{constructor(t="Initializer",e=!0){this.type=t,this.isEnabled=e}init(t,e){this.isEnabled&&(e?(this.initialize(e),e.hasBeenInitialized=!0):(this.initialize(t),t.hasBeenInitialized=!0))}reset(){}initialize(t){}static requiresWebGlApi(){return!1}static fromJSON(t){}}class eo extends En{constructor(t,e,i,s=!0){var r;super(Bg,s),this.body=(r=t)?r instanceof L0?r:new L0(r):null,this.w=e,this.h=i||e}initialize(t){var e=this.body.getValue();this.w?t.body={width:this.w,height:this.h,body:e}:t.body=e}static fromJSON(t){const{body:e,width:i,height:s,isEnabled:r=!0}=t;return new eo(e,i,s,r)}}function F0(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),e.push.apply(e,i)}return e}function N0(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?F0(Object(e),!0).forEach(function(i){Ka(n,i,e[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):F0(Object(e)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(e,i))})}return n}const gh={AdditiveBlending:2,CustomBlending:5,MultiplyBlending:4,NoBlending:0,NormalBlending:1,SubtractiveBlending:3},io={color:16711680,blending:2,fog:!0},qr=N0(N0({},io),{},{blending:"AdditiveBlending"});function k0(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),e.push.apply(e,i)}return e}function vh(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?k0(Object(e),!0).forEach(function(i){Ka(n,i,e[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):k0(Object(e)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(e,i))})}return n}class vd extends En{constructor(t,e,i=io,s=!0){super(Ku,s);const{Sprite:r,SpriteMaterial:a,TextureLoader:o}=t;this.materialProperties=ph(io,i),new o().load(e,l=>{this.texture=l,this.material=new a(vh(vh({},{map:l}),this.materialProperties)),this.sprite=new r(this.material)},void 0,l=>{throw new Error(l)})}initialize(t){t.body=this.sprite}static fromJSON(t,e){const{texture:i,materialProperties:s=qr,isEnabled:r=!0}=t;return new vd(e,i,ph(qr,(a=>{const{blending:o}=a;return vh(vh({},a),{},{blending:o?gh[o]:gh[qr.blending]})})(s)),r)}}const NM=new Ls,B0={particleEuler:null,initialize:function(n,t,e){let i=e.length;for(;i--;)e[i].init(n,t);n.bindEmitter&&this.bindEmitter(n,t)},bindEmitter:function(n,t){const{rotation:{x:e,y:i,z:s}}=n;t.position.add(n.position),t.velocity.add(n.velocity),t.acceleration.add(n.acceleration),t.velocity.applyEuler(NM.set(e,i,s))}};class no extends En{constructor(t,e,i,s=!0){super(Vg,s),this.lifePan=Ue(t,e,i)}initialize(t){this.lifePan.a==1/0||this.lifePan.a=="infi"?t.life=1/0:t.life=this.lifePan.getValue()}static fromJSON(t){const{min:e,max:i,center:s=!1,isEnabled:r=!0}=t;return new no(e,i,s,r)}}class so extends En{constructor(t,e,i=!1,s=!0){super(Gg,s),this.massPan=Ue(t,e,i)}initialize(t){t.mass=this.massPan.getValue()}static fromJSON(t){const{min:e,max:i,center:s=!1,isEnabled:r=!0}=t;return new so(e,i,s,r)}}function kM(n,t){if(n==null)return{};var e,i,s=function(a,o){if(a==null)return{};var l,h,c={},u=Object.keys(a);for(h=0;h<u.length;h++)l=u[h],o.indexOf(l)>=0||(c[l]=a[l]);return c}(n,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(i=0;i<r.length;i++)e=r[i],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(s[e]=n[e])}return s}class Xr{constructor(t="Zone"){this.type=t,this.vector=new kt(0,0,0),this.random=0,this.crossType="dead",this.log=!0,this.supportsCrossing=!0}getPosition(){return null}crossing(t){if(!this.supportsCrossing)return console.warn(`${this.constructor.name} does not support the crossing method`);switch(this.crossType){case"bound":this._bound(t);break;case"cross":this._cross(t);break;case"dead":this._dead(t)}}isBoxZone(){return!1}isLineZone(){return!1}isMeshZone(){return!1}isPointZone(){return!1}isScreenZone(){return!1}isSphereZone(){return!1}_dead(t){}_bound(t){}_cross(t){}}class _d extends Xr{constructor(t,e,i,s,r,a){var o,l,h,c,u;super(Zg),Xe.isUndefined(e,i,s,r,a)?(o=l=h=0,c=u=s=t||100):Xe.isUndefined(s,r,a)?(o=l=h=0,c=t,u=e,s=i):(o=t,l=e,h=i,c=s,u=r,s=a),this.x=o,this.y=l,this.z=h,this.width=c,this.height=u,this.depth=s,this.friction=.85,this.max=6}isBoxZone(){return!0}getPosition(){return this.vector.x=this.x+fe.randomAToB(-.5,.5)*this.width,this.vector.y=this.y+fe.randomAToB(-.5,.5)*this.height,this.vector.z=this.z+fe.randomAToB(-.5,.5)*this.depth,this.vector}_dead(t){(t.position.x+t.radius<this.x-this.width/2||t.position.x-t.radius>this.x+this.width/2)&&(t.dead=!0),(t.position.y+t.radius<this.y-this.height/2||t.position.y-t.radius>this.y+this.height/2)&&(t.dead=!0),(t.position.z+t.radius<this.z-this.depth/2||t.position.z-t.radius>this.z+this.depth/2)&&(t.dead=!0)}_bound(t){t.position.x-t.radius<this.x-this.width/2?(t.position.x=this.x-this.width/2+t.radius,t.velocity.x*=-this.friction,this._static(t,"x")):t.position.x+t.radius>this.x+this.width/2&&(t.position.x=this.x+this.width/2-t.radius,t.velocity.x*=-this.friction,this._static(t,"x")),t.position.y-t.radius<this.y-this.height/2?(t.position.y=this.y-this.height/2+t.radius,t.velocity.y*=-this.friction,this._static(t,"y")):t.position.y+t.radius>this.y+this.height/2&&(t.position.y=this.y+this.height/2-t.radius,t.velocity.y*=-this.friction,this._static(t,"y")),t.position.z-t.radius<this.z-this.depth/2?(t.position.z=this.z-this.depth/2+t.radius,t.velocity.z*=-this.friction,this._static(t,"z")):t.position.z+t.radius>this.z+this.depth/2&&(t.position.z=this.z+this.depth/2-t.radius,t.velocity.z*=-this.friction,this._static(t,"z"))}_static(t,e){t.velocity[e]*t.acceleration[e]>0||Math.abs(t.velocity[e])<.0167*Math.abs(t.acceleration[e])*this.max&&(t.velocity[e]=0,t.acceleration[e]=0)}_cross(t){t.position.x+t.radius<this.x-this.width/2&&t.velocity.x<=0?t.position.x=this.x+this.width/2+t.radius:t.position.x-t.radius>this.x+this.width/2&&t.velocity.x>=0&&(t.position.x=this.x-this.width/2-t.radius),t.position.y+t.radius<this.y-this.height/2&&t.velocity.y<=0?t.position.y=this.y+this.height/2+t.radius:t.position.y-t.radius>this.y+this.height/2&&t.velocity.y>=0&&(t.position.y=this.y-this.height/2-t.radius),t.position.z+t.radius<this.z-this.depth/2&&t.velocity.z<=0?t.position.z=this.z+this.depth/2+t.radius:t.position.z-t.radius>this.z+this.depth/2&&t.velocity.z>=0&&(t.position.z=this.z-this.depth/2-t.radius)}}class yd extends Xr{constructor(t,e,i,s){super("ScreenZone"),this.camera=t,this.renderer=e,this.dis=i||20,s=s||"1234";for(var r=1;r<5;r++)this["d"+r]=s.indexOf(r+"")>=0}isScreenZone(){return!0}_dead(t){var e=Yn.toScreenPos(t.position,this.camera,this.renderer.domElement),i=this.renderer.domElement;(e.y+t.radius<-this.dis&&this.d1||e.y-t.radius>i.height+this.dis&&this.d3)&&(t.dead=!0),(e.x+t.radius<-this.dis&&this.d4||e.x-t.radius>i.width+this.dis&&this.d2)&&(t.dead=!0)}_bound(t){var e=Yn.toScreenPos(t.position,this.camera,this.renderer.domElement),i=this.renderer.domElement;(e.y+t.radius<-this.dis||e.y-t.radius>i.height+this.dis)&&(t.velocity.y*=-1),(e.x+t.radius<-this.dis||e.x-t.radius>i.width+this.dis)&&(t.velocity.y*=-1)}}var _h,yh,xh,xd,bh,V0,Mh,bd;yd.prototype.getPosition=(yh=new kt,function(){return _h=this.renderer.domElement,yh.x=Math.random()*_h.width,yh.y=Math.random()*_h.height,this.vector.copy(Yn.toSpacePos(yh,this.camera,_h)),this.vector}),yd.prototype._cross=function(){var n=new kt;return function(t){var e=Yn.toScreenPos(t.position,this.camera,this.renderer.domElement),i=this.renderer.domElement;e.y+t.radius<-this.dis?(n.x=e.x,n.y=i.height+this.dis+t.radius,t.position.y=Yn.toSpacePos(n,this.camera,i).y):e.y-t.radius>i.height+this.dis&&(n.x=e.x,n.y=-this.dis-t.radius,t.position.y=Yn.toSpacePos(n,this.camera,i).y),e.x+t.radius<-this.dis?(n.y=e.y,n.x=i.width+this.dis+t.radius,t.position.x=Yn.toSpacePos(n,this.camera,i).x):e.x-t.radius>i.width+this.dis&&(n.y=e.y,n.x=-this.dis-t.radius,t.position.x=Yn.toSpacePos(n,this.camera,i).x)}}();class Md extends Xr{constructor(t,e,i,s){let r,a;super($g),Xe.isUndefined(e,i,s)?(r=0,a=t||100):(r=t,a=s),this.x=r,this.y=r,this.z=r,this.radius=a,this.the=this.phi=0}isSphereZone(){return!0}_dead(t){t.position.distanceTo(this)-t.radius>this.radius&&(t.dead=!0)}_cross(){console.warn(`${this.constructor.name} does not support the _cross method`)}}Md.prototype.getPosition=function(){return this.random=Math.random(),bh=this.random*this.radius,xh=je*Math.random(),xd=2*je*Math.random(),this.vector.x=this.x+bh*Math.sin(xh)*Math.cos(xd),this.vector.y=this.y+bh*Math.sin(xd)*Math.sin(xh),this.vector.z=this.z+bh*Math.cos(xh),this.vector},Md.prototype._bound=(Mh=new kt,bd=new kt,function(n){n.position.distanceTo(this)+n.radius>=this.radius&&(Mh.copy(n.position).sub(this).normalize(),bd.copy(n.velocity),V0=2*bd.dot(Mh),n.velocity.sub(Mh.scalar(V0)))});const G0=Object.freeze(Object.defineProperty({__proto__:null,BoxZone:_d,LineZone:class extends Xr{constructor(n,t,e,i,s,r){super(Jg),n instanceof kt?(this.x1=n.x,this.y1=n.y,this.z1=n.z,this.x2=i.x,this.y2=i.y,this.z2=i.z):(this.x1=n,this.y1=t,this.z1=e,this.x2=i,this.y2=s,this.z2=r),this.supportsCrossing=!1}isLineZone(){return!0}getPosition(){return this.random=Math.random(),this.vector.x=this.x1+this.random*(this.x2-this.x1),this.vector.y=this.y1+this.random*(this.y2-this.y1),this.vector.z=this.z1+this.random*(this.z2-this.z1),this.vector}},MeshZone:class extends Xr{constructor(n,t=1,e){if(super(Kg),this.geometry=null,this.scale=t,this.supportsCrossing=!1,n.type&&n.type==="Geometry"&&(this.geometry=n),n.geometry&&(this.geometry=n.geometry),!this.geometry)throw new Error("MeshZone unable to set geometry from the supplied bounds");this.geometry.isBufferGeometry&&(this.geometry=new e().fromBufferGeometry(this.geometry))}isMeshZone(){return!0}getPosition(){const n=this.geometry.vertices,t=n[n.length*Math.random()>>0];return this.vector.x=t.x*this.scale,this.vector.y=t.y*this.scale,this.vector.z=t.z*this.scale,this.vector}},PointZone:class extends Xr{constructor(n,t,e){var i;super(Qg),i=Xe.isUndefined(n,t,e)?0:n,this.x=i,this.y=i,this.z=i,this.supportsCrossing=!1}isPointZone(){return!0}getPosition(){return this.vector.x=this.x,this.vector.y=this.y,this.vector.z=this.z,this.vector}},ScreenZone:yd,SphereZone:Md},Symbol.toStringTag,{value:"Module"})),BM=["zoneType"];class Yr extends En{constructor(){super(jg),this.reset.apply(this,arguments)}reset(){this.zones?this.zones.length=0:this.zones=[],this.zones=this.zones.concat(Array.prototype.slice.call(arguments))}addZone(){this.zones=this.zones.concat(Array.prototype.slice.call(arguments))}static fromJSON(t){const{zoneType:e}=t,i=kM(t,BM);if(!Eb.includes(e))throw new Error(`The zone type ${e} is invalid or not yet supported`);return new Yr(new G0[e](...Object.values(i)))}}Yr.prototype.initialize=function(){let n;return function(t){n=this.zones[Math.random()*this.zones.length>>0],n.getPosition(),t.position.x=n.vector.x,t.position.y=n.vector.y,t.position.z=n.vector.z}}();class ro extends En{constructor(t,e,i=!1,s=!0){super(Hg,s),this.radius=Ue(t,e,i)}reset(t,e,i=!1){this.radius=Ue(t,e,i)}initialize(t){t.radius=this.radius.getValue(),t.transform.oldRadius=t.radius}static fromJSON(t){const{width:e,height:i,center:s=!1,isEnabled:r=!0}=t;return new ro(e,i,s,r)}}class Zn extends En{constructor(t=1,e=1){super("Rate"),this.numPan=Ue(t),this.timePan=Ue(e),this.startTime=0,this.nextTime=0,this.init()}init(){this.startTime=0,this.nextTime=this.timePan.getValue()}getValue(t){return this.startTime+=t,this.startTime>=this.nextTime?(this.init(),this.numPan.b==1?this.numPan.getValue("Float")>.5?1:0:this.numPan.getValue("Int")):0}static fromJSON(t){const{particlesMin:e,particlesMax:i,perSecondMin:s,perSecondMax:r}=t;return new Zn(new Ye(e,i),new Ye(s,r))}}function j0(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),e.push.apply(e,i)}return e}function wh(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?j0(Object(e),!0).forEach(function(i){Ka(n,i,e[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):j0(Object(e)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(e,i))})}return n}class Sh extends En{constructor(t,e,i=io,s=!0){super(Qu,s);const{Sprite:r,SpriteMaterial:a}=t;this.materialProperties=ph(io,i),this.texture=e,this.material=new a(wh(wh({},{map:e}),this.materialProperties)),this.sprite=new r(this.material)}initialize(t){t.body=this.sprite}static fromJSON(t,e){const{loadedTexture:i,materialProperties:s=qr,isEnabled:r=!0}=t;return new Sh(e,i,ph(qr,(a=>{const{blending:o}=a;return wh(wh({},a),{},{blending:o?gh[o]:gh[qr.blending]})})(s)),r)}}class Th extends En{constructor(t,e=!0){super(t,e),this.dirVec=new kt(0,0,0)}normalize(t){return 100*t}}Th.prototype.initialize=function(){var n,t=new kt(0,0,1),e=new kt(0,0,0);return function(i){return n=this.tha*Math.random(),this._useV&&this.dirVec.copy(this.dir).scalar(this.radiusPan.getValue()),fe.getNormal(this.dirVec,t),e.copy(this.dirVec).applyAxisAngle(t,n),e.applyAxisAngle(this.dirVec.normalize(),Math.random()*je*2),i.velocity.copy(e),this}}();class wd extends Th{constructor(t,e,i=!0){super(qg,i),this.tha=e*Hr,this.dirVec=t.toVector3D(),this._useV=!1}static fromJSON(t){const{polarRadius:e,polarTheta:i,polarPhi:s,velocityTheta:r,isEnabled:a=!0}=t;return new wd(new ud(e,i,s),r,a)}}class ao extends Th{constructor(t,e,i,s=!0){super(Xg,s),this.radiusPan=Ue(t),this.dir=e.clone().normalize(),this.tha=i*Hr,this._useV=!0}static fromJSON(t){const{radius:e,x:i,y:s,z:r,theta:a,isEnabled:o=!0}=t;return new ao(e,new kt(i,s,r),a,o)}}class Sd extends Th{constructor(t,e,i=!0){super(Wg,i),this.radiusPan=Ue(1),this.dir=t.clone(),this.tha=e*Hr,this._useV=!0}static fromJSON(t){const{x:e,y:i,z:s,theta:r,isEnabled:a=!0}=t;return new Sd(new kt(e,i,s),r,a)}}const Eh=Object.freeze(Object.defineProperty({__proto__:null,Body:eo,BodySprite:vd,InitializerUtil:B0,Life:no,Mass:so,Position:Yr,Radius:ro,Rate:Zn,Texture:Sh,VectorVelocity:Sd,PolarVelocity:wd,RadialVelocity:ao},Symbol.toStringTag,{value:"Module"})),VM=new Zn(1,.1);var GM=mh,jM=fh,oo=function(n){return typeof n=="number"||jM(n)&&GM(n)=="[object Number]"};class Ch extends z0{constructor(t){super(t),this.type="Emitter",this.particles=[],this.initializers=[],this.behaviours=[],this.emitterBehaviours=[],this.currentEmitTime=0,this.totalEmitTimes=-1,this.damping=.006,this.bindEmitter=!0,this.bindEmitterEvent=!1,this.rate=VM,this.isEmitting=!1,this.id=`emitter-${od()}`,this.cID=0,this.name="Emitter",this.index=void 0,this.eventDispatcher=new U0}dispatch(t,e=this){this.eventDispatcher.dispatchEvent(t,e)}setRate(t){return this.rate=t,this}setPosition(t={}){const{position:e}=this,{x:i=e.x,y:s=e.y,z:r=e.z}=t;return this.position.set(i,s,r),this}setRotation(t={}){const{rotation:e}=this,{x:i=e.x,y:s=e.y,z:r=e.z}=t;return this.rotation.set(i,s,r),this}emit(t=1/0,e=1/0){return this.currentEmitTime=0,this.totalEmitTimes=oo(t)?t:1/0,this.life=t===1?t:oo(e)?e:1/0,this.rate.init(),this.isEmitting=!0,this}experimental_emit(){const{isEmitting:t,totalEmitTimes:e,life:i}=this;return t||(this.currentEmitTime=0,e||this.setTotalEmitTimes(1/0),i||this.setLife(1/0),this.rate.init(),this.isEmitting=!0),this}setTotalEmitTimes(t=1/0){return this.totalEmitTimes=oo(t)?t:1/0,this}setLife(t=1/0){return this.totalEmitTimes===1?this.life=this.totalEmitTimes:this.life=oo(t)?t:1/0,this}stopEmit(){this.totalEmitTimes=-1,this.currentEmitTime=0,this.isEmitting=!1}removeAllParticles(){let t=this.particles.length;for(;t--;)this.particles[t].dead=!0}addInitializer(t){return this.initializers.push(t),this}addInitializers(t){let e=t.length;for(;e--;)this.addInitializer(t[e]);return this}setInitializers(t){return this.initializers=t,this}removeInitializer(t){const e=this.initializers.indexOf(t);return e>-1&&this.initializers.splice(e,1),this}removeAllInitializers(){return Xe.destroyArray(this.initializers),this}addBehaviour(t){return this.behaviours.push(t),this}addBehaviours(t){let e=t.length;for(;e--;)this.addBehaviour(t[e]);return this}setBehaviours(t){return this.behaviours=t,this}removeBehaviour(t){const e=this.behaviours.indexOf(t);return e>-1&&this.behaviours.splice(e,1),this}removeAllBehaviours(){return Xe.destroyArray(this.behaviours),this}addEmitterBehaviour(t){return this.emitterBehaviours.push(t),t.initialize(this),this}addEmitterBehaviours(t){let e=t.length;for(;e--;)this.addEmitterBehaviour(t[e]);return this}setEmitterBehaviours(t){const e=t.length;this.emitterBehaviours=t;for(let i=0;i<e;i++)this.emitterBehaviours[i].initialize(this);return this}removeEmitterBehaviour(t){const e=this.emitterBehaviours.indexOf(t);return e>-1&&this.emitterBehaviours.splice(e,1),this}removeAllEmitterBehaviours(){return Xe.destroyArray(this.emitterBehaviours),this}addOnEmitterDeadEventListener(t){return this.eventDispatcher.addEventListener(`${this.id}_EMITTER_DEAD`,()=>t()),this}createParticle(){const t=this.parent.pool.get(z0),e=this.particles.length;return this.setupParticle(t,e),this.parent&&this.parent.dispatch(md,t),this.bindEmitterEvent&&this.dispatch(md,t),t}setupParticle(t,e){const{initializers:i,behaviours:s}=this;B0.initialize(this,t,i),t.addBehaviours(s),t.parent=this,t.index=e,this.particles.push(t)}update(t){if(!this.isEmitting)return;this.age+=t,(this.dead||this.age>=this.life)&&this.destroy(),this.generate(t),this.integrate(t);let e=this.particles.length;for(;e--;){const i=this.particles[e];i.dead&&(this.parent&&this.parent.dispatch(gd,i),this.bindEmitterEvent&&this.dispatch(gd,i),this.parent.pool.expire(i.reset()),this.particles.splice(e,1))}this.updateEmitterBehaviours(t)}updateEmitterBehaviours(t){if(this.sleep)return;const e=this.emitterBehaviours.length;for(let i=0;i<e;i++)this.emitterBehaviours[i].applyBehaviour(this,t,i)}integrate(t){const e=this.parent?this.parent.integrationType:UM,i=1-this.damping;O0(this,t,i,e);let s=this.particles.length;for(;s--;){const r=this.particles[s];r.update(t,s),O0(r,t,i,e),this.parent&&this.parent.dispatch(fd,r),this.bindEmitterEvent&&this.dispatch(fd,r)}}generate(t){if(this.totalEmitTimes!==1){if(this.currentEmitTime+=t,this.currentEmitTime<this.totalEmitTimes){let e=this.rate.getValue(t);for(e>0&&(this.cID=e);e--;)this.createParticle()}}else{let e=this.rate.getValue(99999);for(e>0&&(this.cID=e);e--;)this.createParticle();this.totalEmitTimes=0}}destroy(){this.dead=!0,this.energy=0,this.totalEmitTimes=-1,this.particles.length==0&&(this.isEmitting=!1,this.removeAllInitializers(),this.removeAllBehaviours(),this.dispatch(`${this.id}_EMITTER_DEAD`),this.parent&&this.parent.removeEmitter(this))}}const HM=1/0,Ah=e0;class Vi{constructor(t=1/0,e=Ah,i="Behaviour",s=!0){this.type=i,this.isEnabled=s,this.id=`behaviour-${od()}`,this.life=t,this.easing=e,this.age=0,this.energy=1,this.dead=!1}reset(t=1/0,e=Ah){this.life=t,this.easing=e||Ah}set life(t){this._life=oo(t)?t:HM}get life(){return this._life}normalizeForce(t){return t.scalar(100)}normalizeValue(t){return 100*t}initialize(t){}applyBehaviour(t,e,i){this.isEnabled&&this.mutate(t,e,i)}mutate(t,e,i){}energize(t,e){if(this.dead)return;if(this.age+=e,this.age>=this.life)return this.energy=0,void(this.dead=!0);const i=this.easing(t.age/t.life);this.energy=Math.max(1-i,0)}destroy(){}fromJSON(t){}}class Td extends Vi{constructor(t=1,e=null,i,s,r=!0){super(i,s,Pg,r),this.alphaA=t,this.alphaB=e,this.reset(t,e)}get same(){return this._same}set same(t){this._same=t}reset(t=1,e=null,i,s){this.same=e==null,this.alphaA=Ue(t),this.alphaB=Ue(e),i&&super.reset(i,s)}initialize(t){t.useAlpha=!0,t.transform.alphaA=this.alphaA.getValue(),t.transform.alphaB=this.same?t.transform.alphaA:this.alphaB.getValue()}mutate(t,e,i){this.energize(t,e,i),t.alpha=fe.lerp(t.transform.alphaA,t.transform.alphaB,this.energy),t.alpha<.002&&(t.alpha=0)}static fromJSON(t){const{alphaA:e,alphaB:i,life:s,easing:r,isEnabled:a=!0}=t;return new Td(e,i,s,Bi(r),a)}}class Ph extends Vi{constructor(t=new kt,e=100,i=1e3,s=1/0,r=Ah,a=!0){super(s,r,Rg,a),this.targetPosition=t,this.radius=i,this.force=this.normalizeValue(e),this.radiusSq=this.radius*this.radius,this.attractionForce=new kt,this.lengthSq=0}reset(t=new kt,e=100,i=1e3,s,r){this.targetPosition=t,this.radius=i,this.force=this.normalizeValue(e),this.radiusSq=this.radius*this.radius,this.attractionForce=new kt,this.lengthSq=0,s&&super.reset(s,r)}mutate(t,e,i){this.energize(t,e,i),this.attractionForce.copy(this.targetPosition),this.attractionForce.sub(t.position),this.lengthSq=this.attractionForce.lengthSq(),this.lengthSq>4e-6&&this.lengthSq<this.radiusSq&&(this.attractionForce.normalize(),this.attractionForce.scalar(1-this.lengthSq/this.radiusSq),this.attractionForce.scalar(this.force),t.acceleration.add(this.attractionForce))}static fromJSON(t){const{x:e,y:i,z:s,force:r,radius:a,life:o,easing:l,isEnabled:h=!0}=t;return new Ph(new kt(e,i,s),r,a,o,Bi(l),h)}}class Ed extends Vi{constructor(t,e,i,s,r=!0){super(i,s,Lg,r),this.reset(t,e)}get same(){return this._same}set same(t){this._same=t}reset(t,e,i,s){this.same=e==null,this.colorA=D0(t),this.colorB=D0(e),i&&super.reset(i,s)}initialize(t){t.transform.colorA=a0(this.colorA.getValue()),t.useColor=!0,t.transform.colorB=this.same?t.transform.colorA:a0(this.colorB.getValue())}mutate(t,e,i){this.energize(t,e,i),this._same?(t.color.r=t.transform.colorA.r,t.color.g=t.transform.colorA.g,t.color.b=t.transform.colorA.b):(t.color.r=fe.lerp(t.transform.colorA.r,t.transform.colorB.r,this.energy),t.color.g=fe.lerp(t.transform.colorA.g,t.transform.colorB.g,this.energy),t.color.b=fe.lerp(t.transform.colorA.b,t.transform.colorB.b,this.energy))}static fromJSON(t){const{colorA:e,colorB:i,life:s,easing:r,isEnabled:a=!0}=t;return new Ed(e,i,s,Bi(r),a)}}class Cd extends Vi{constructor(t,e,i,s,r){super(i,s,Ig,r),this.reset(t,e)}reset(t,e="dead",i,s){this.zone=t,this.zone.crossType=e,i&&super.reset(i,s)}mutate(t,e,i){this.energize(t,e,i),this.zone.crossing.call(this.zone,t)}static fromJSON(t){const{zoneType:e,zoneParams:i,crossType:s,life:r,easing:a,isEnabled:o=!0}=t,l=new G0[e](...Object.values(i));return new Cd(l,s,r,Bi(a),o)}}class Rh extends Vi{constructor(t,e,i,s,r,a=!0){super(s,r,Dg,a),this.reset(t,e,i)}reset(t,e,i){this.force=this.normalizeForce(new kt(t,e,i)),this.force.id=Math.random()}mutate(t,e,i){this.energize(t,e,i),t.acceleration.add(this.force)}static fromJSON(t){const{fx:e,fy:i,fz:s,life:r,easing:a,isEnabled:o=!0}=t;return new Rh(e,i,s,r,Bi(a),o)}}class lo extends Rh{constructor(t,e,i,s=!0){super(0,-t,0,e,i,s),this.type=Og}static fromJSON(t){const{gravity:e,life:i,easing:s,isEnabled:r=!0}=t;return new lo(e,i,Bi(s),r)}}class Lh extends Vi{constructor(t,e,i,s=.03,r,a,o=!0){super(r,a,zg,o),this.reset(t,e,i,s),this.time=0}reset(t,e,i,s=.03,r,a){this.randomForce=this.normalizeForce(new kt(t,e,i)),this.delayPan=Ue(s),this.time=0,r&&super.reset(r,a)}mutate(t,e,i){if(this.energize(t,e,i),this.time+=e,this.time>=this.delayPan.getValue()){const s=fe.randomAToB(-this.randomForce.x,this.randomForce.x),r=fe.randomAToB(-this.randomForce.y,this.randomForce.y),a=fe.randomAToB(-this.randomForce.z,this.randomForce.z);t.acceleration.addValue(s,r,a),this.time=0}}static fromJSON(t){const{x:e,y:i,z:s,delay:r,life:a,easing:o,isEnabled:l=!0}=t;return new Lh(e,i,s,r,a,Bi(o),l)}}class Ad extends Ph{constructor(t,e,i,s,r,a=!0){super(t,e,i,s,r,a),this.force*=-1,this.type=Ug}reset(t,e,i,s,r){super.reset(t,e,i,s,r),this.force*=-1}static fromJSON(t){const{x:e,y:i,z:s,force:r,radius:a,life:o,easing:l,isEnabled:h=!0}=t;return new Ad(new kt(e,i,s),r,a,o,Bi(l),h)}}class Ih extends Vi{constructor(t,e,i,s,r,a=!0){super(s,r,Fg,a),this.reset(t,e,i)}get rotationType(){return this._rotationType}set rotationType(t){this._rotationType=t}reset(t,e,i,s,r){this.x=t||0,this.y=e||0,this.z=i||0,t===void 0||t=="same"?this.rotationType="same":e==null?this.rotationType="set":i===void 0?this.rotationType="to":(this.rotationType="add",this.x=Ue(this.x*Hr),this.y=Ue(this.y*Hr),this.z=Ue(this.z*Hr)),s&&super.reset(s,r)}initialize(t){switch(this.rotationType){case"same":break;case"set":this._setRotation(t.rotation,this.x);break;case"to":t.transform.fR=t.transform.fR||new kt,t.transform.tR=t.transform.tR||new kt,this._setRotation(t.transform.fR,this.x),this._setRotation(t.transform.tR,this.y);break;case"add":t.transform.addR=new kt(this.x.getValue(),this.y.getValue(),this.z.getValue())}}_setRotation(t,e){if(t=t||new kt,e=="random"){var i=fe.randomAToB(-je,je),s=fe.randomAToB(-je,je),r=fe.randomAToB(-je,je);t.set(i,s,r)}else e instanceof kt&&t.copy(e)}mutate(t,e,i){switch(this.energize(t,e,i),this.rotationType){case"same":t.rotation||(t.rotation=new kt),t.rotation.eulerFromDir(t.velocity);break;case"set":break;case"to":t.rotation.x=fe.lerp(t.transform.fR.x,t.transform.tR.x,this.energy),t.rotation.y=fe.lerp(t.transform.fR.y,t.transform.tR.y,this.energy),t.rotation.z=fe.lerp(t.transform.fR.z,t.transform.tR.z,this.energy);break;case"add":t.rotation.add(t.transform.addR)}}static fromJSON(t){const{x:e,y:i,z:s,life:r,easing:a,isEnabled:o=!0}=t;return new Ih(e,i,s,r,Bi(a),o)}}class Pd extends Vi{constructor(t,e,i,s,r=!0){super(i,s,Ng,r),this.reset(t,e)}get same(){return this._same}set same(t){this._same=t}reset(t,e,i,s){this.same=e==null,this.scaleA=Ue(t||1),this.scaleB=Ue(e),i&&super.reset(i,s)}initialize(t){t.transform.scaleA=this.scaleA.getValue(),t.transform.oldRadius=t.radius,t.transform.scaleB=this.same?t.transform.scaleA:this.scaleB.getValue()}mutate(t,e,i){this.energize(t,e,i),t.scale=fe.lerp(t.transform.scaleA,t.transform.scaleB,this.energy),t.scale<5e-4&&(t.scale=0),t.radius=t.transform.oldRadius*t.scale}static fromJSON(t){const{scaleA:e,scaleB:i,life:s,easing:r,isEnabled:a=!0}=t;return new Pd(e,i,s,Bi(r),a)}}class Rd extends Vi{constructor(t,e,i,s,r,a,o,l=!0){super(a,o,kg,l),this.reset(t,e,i,s,r)}reset(t,e,i,s,r){this.pos?this.pos.set(t,e,i):this.pos=new kt(t,e,i),this.spring=s||.1,this.friction=r||.98}mutate(t,e,i){this.energize(t,e,i),t.velocity.x+=(this.pos.x-t.position.x)*this.spring,t.velocity.y+=(this.pos.y-t.position.y)*this.spring,t.velocity.z+=(this.pos.z-t.position.z)*this.spring}static fromJSON(t){const{x:e,y:i,z:s,spring:r,friction:a,life:o,easing:l,isEnabled:h=!0}=t;return new Rd(e,i,s,r,a,o,Bi(l),h)}}const H0=Object.freeze(Object.defineProperty({__proto__:null,Alpha:Td,Attraction:Ph,Collision:class extends Vi{constructor(n,t,e,i,s,r=!0){super(i,s,"Collision",r),this.reset(n,t,e)}reset(n,t,e,i,s){this.emitter=n,this.useMass=t,this.onCollide=e,this.particles=[],this.delta=new kt,i&&super.reset(i,s)}mutate(n,t,e){const i=this.emitter?this.emitter.particles.slice(e):this.particles.slice(e);let s,r,a,o,l,h,c=i.length;for(;c--;)s=i[c],s!=n&&(this.delta.copy(s.position).sub(n.position),r=this.delta.lengthSq(),o=n.radius+s.radius,r<=o*o&&(a=o-Math.sqrt(r),a+=.5,l=this._getAverageMass(n,s),h=this._getAverageMass(s,n),n.position.add(this.delta.clone().normalize().scalar(a*-l)),s.position.add(this.delta.normalize().scalar(a*h)),this.onCollide&&this.onCollide(n,s)))}_getAverageMass(n,t){return this.useMass?t.mass/(n.mass+t.mass):.5}fromJSON(n){}},Color:Ed,CrossZone:Cd,Force:Rh,Gravity:lo,RandomDrift:Lh,Repulsion:Ad,Rotate:Ih,Scale:Pd,Spring:Rd,Behaviour:Vi},Symbol.toStringTag,{value:"Module"})),W0=n=>{const t=[];return n.forEach(e=>{const{type:i,properties:s}=e;if(!r0.includes(i))throw new Error(`The behaviour type ${i} is invalid or not yet supported`);t.push(H0[i].fromJSON(s))}),t},WM=(n,t,e,i)=>{const{preParticles:s=$u,integrationType:r=t0,emitters:a=[]}=n,o=new e(t,s,r);return a.forEach(l=>{const h=new i,{rate:c,rotation:u,initializers:d,behaviours:p,emitterBehaviours:m=[],position:f,totalEmitTimes:v=1/0,life:_=1/0}=l;h.setRate((y=>Zn.fromJSON(y))(c)).setRotation(u).setInitializers(((y,x)=>{const b=[];return y.forEach(w=>{const{type:M,properties:T}=w;if(!td.includes(M))throw new Error(`The initializer type ${M} is invalid or not yet supported`);Yg.includes(M)?b.push(Eh[M].fromJSON(T,x)):b.push(Eh[M].fromJSON(T))}),b})(d,t)).setBehaviours(W0(p)).setEmitterBehaviours(W0(m)).setPosition(f).emit(v,_),o.addEmitter(h)}),o};function q0(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(n,s).enumerable})),e.push.apply(e,i)}return e}function Dh(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?q0(Object(e),!0).forEach(function(i){Ka(n,i,e[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):q0(Object(e)).forEach(function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(e,i))})}return n}const qM={shouldAutoEmit:!0},X0=n=>new Promise((t,e)=>{if(!n.length)return t([]);const i=n.length,s=[];n.forEach(r=>{const{type:a,properties:o}=r;return r0.includes(a)?(s.push(H0[a].fromJSON(o)),s.length===i?t(s):void 0):e(`The behaviour type ${a} is invalid or not yet supported`)})}),XM=(n,t,e,i)=>new Promise((s,r)=>{if(!n.length)return s([]);const a=[],o=n.length;if(!o)return s(a);n.forEach(l=>{const h=new t,{rate:c,rotation:u,initializers:d,behaviours:p,emitterBehaviours:m=[],position:f,totalEmitTimes:v=1/0,life:_=1/0}=l;var y;h.setRate((y=c,Zn.fromJSON(y))).setRotation(u).setPosition(f),((x,b)=>new Promise((w,M)=>{if(!x.length)return w([]);const T=x.length,R=[],E=x.filter(({properties:z})=>!z.texture),A=x.filter(({properties:z})=>z.texture);E.forEach(z=>{const{type:F,properties:G}=z;return td.includes(F)?(Yg.includes(F)?R.push(Eh[F].fromJSON(G,b)):R.push(Eh[F].fromJSON(G)),R.length===T?w(R):void 0):M(`The initializer type ${F} is invalid or not yet supported`)}),A.forEach(z=>{const{type:F,properties:G,properties:{texture:U}}=z,k=new b.TextureLoader;if(!td.includes(F))return M(`The initializer type ${F} is invalid or not yet supported`);k.load(U,H=>{if(R.push(Sh.fromJSON(Dh(Dh({},G),{},{loadedTexture:H}),b)),R.length===T)return w(R)},void 0,M)})}))(d,e).then(x=>(h.setInitializers(x),X0(p))).then(x=>(h.setBehaviours(x),X0(m))).then(x=>(h.setEmitterBehaviours(x),Promise.resolve(h))).then(x=>{if(a.push(i?x.emit(v,_):x.setTotalEmitTimes(v).setLife(_)),a.length===o)return s(a)}).catch(r)})});class ho{constructor(t=$u,e="EULER"){this.type="System",this.canUpdate=!0,this.preParticles=t,this.integrationType=e,this.emitters=[],this.renderers=[],this.pool=new dd,this.eventDispatcher=new U0}static fromJSON(t,e){return WM(t,e,ho,Ch)}static fromJSONAsync(t,e,i){return((s,r,a,o,l={})=>new Promise((h,c)=>{const{preParticles:u=$u,integrationType:d=t0,emitters:p=[]}=s,m=new a(u,d),{shouldAutoEmit:f}=Dh(Dh({},qM),l);XM(p,o,r,f).then(v=>{const _=v.length;if(!_)return h(m);v.forEach(y=>{m.addEmitter(y),m.emitters.length===_&&h(m)})}).catch(c)}))(t,e,ho,Ch,i)}dispatch(t,e=this){this.eventDispatcher.dispatchEvent(t,e)}addRenderer(t){return this.renderers.push(t),t.init(this),this}removeRenderer(t){return this.renderers.splice(this.renderers.indexOf(t),1),t.remove(this),this}addEmitter(t){const e=this.emitters.length;return t.parent=this,t.index=e,this.emitters.push(t),this.dispatch("EMITTER_ADDED",t),this}removeEmitter(t){return t.parent!==this||(t.parent=null,t.index=void 0,this.emitters.splice(this.emitters.indexOf(t),1),this.dispatch("EMITTER_REMOVED",t)),this}emit({onStart:t,onUpdate:e,onEnd:i}){t&&t(),e&&this.eventDispatcher.addEventListener(pd,e);const s=this.emitters.map(r=>{const{life:a}=r;return a===1/0?(i&&i(),r.experimental_emit(),Promise.resolve()):new Promise(o=>{r.addOnEmitterDeadEventListener(()=>{i&&i(),o()}),r.experimental_emit()})});try{return Promise.all(s)}catch(r){console.warn(r)}}update(t=.0167){const e=t||s0;if(this.canUpdate){if(e>0){let i=this.emitters.length;for(;i--;){const s=this.emitters[i];s.update(e),s.isEmitting&&this.dispatch(pd)}}this.dispatch("SYSTEM_UPDATE_AFTER")}return Promise.resolve()}getCount(){const t=this.emitters.length;let e,i=0;for(e=0;e<t;e++)i+=this.emitters[e].particles.length;return i}destroy(){const t=this.emitters.length;this.canUpdate=!1;for(let e=0;e<t;e++)this.emitters[e]&&this.emitters[e].destroy(),delete this.emitters[e];for(let e=0;e<t;e++)this.renderers[e]&&this.renderers[e].destroy&&(this.renderers[e].destroy(),delete this.renderers[e]);this.emitters.length=0,this.pool.destroy(),this.canUpdate=!0}}class Y0 extends class extends class{constructor(t="BaseRenderer"){this.type=t}init(t){var e=this;this.system=t,this.system.eventDispatcher.addEventListener(pd,function(i){e.onSystemUpdate.call(e,i)}),this.system.eventDispatcher.addEventListener(md,function(i){e.onParticleCreated.call(e,i)}),this.system.eventDispatcher.addEventListener(fd,function(i){e.onParticleUpdate.call(e,i)}),this.system.eventDispatcher.addEventListener(gd,function(i){e.onParticleDead.call(e,i)}),this.logRendererType()}remove(){this.system=null}onParticleCreated(t){}onParticleUpdate(t){}onParticleDead(t){}onSystemUpdate(t){}logRendererType(){Tb&&console.log(`${this.type}`)}}{constructor(t,e){super("MeshRenderer"),this.container=t,this._targetPool=new dd,this._materialPool=new dd,this._body=new e.Mesh(new e.BoxGeometry(50,50,50),new e.MeshLambertMaterial({color:"#ff0000"}))}isThreeSprite(t){return t.target.isSprite}onSystemUpdate(){}onParticleCreated(t){t.target||(t.body||(t.body=this._body),t.target=this._targetPool.get(t.body),(t.useAlpha||t.useColor)&&(t.target.material.__puid=o0.id(t.body.material),t.target.material=this._materialPool.get(t.target.material))),t.target&&(t.target.position.copy(t.position),this.container.add(t.target))}onParticleUpdate(t){const{target:e,useAlpha:i,useColor:s,rotation:r}=t;e&&(e.position.copy(t.position),this.isThreeSprite(t)||e.rotation.set(r.x,r.y,r.z),this.scale(t),i&&(e.material.opacity=t.alpha,e.material.transparent=!0),s&&e.material.color.copy(t.color))}scale(t){t.target.scale.set(t.scale,t.scale,t.scale)}onParticleDead(t){t.target&&((t.useAlpha||t.useColor)&&this._materialPool.expire(t.target.material),this._targetPool.expire(t.target),this.container.remove(t.target),t.target=null)}}{constructor(t,e){super(t,e),this.type="SpriteRenderer",this._body=new e.Sprite(new e.SpriteMaterial({color:16777215}))}scale(t){t.target.scale.set(t.scale*t.radius,t.scale*t.radius,1)}}function Z0(n){let t=0,e=0;for(const a of n)t+=a.w*a.h,e=Math.max(e,a.w);n.sort((a,o)=>o.h-a.h);const i=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(t/.95)),e),h:1/0}];let s=0,r=0;for(const a of n)for(let o=i.length-1;o>=0;o--){const l=i[o];if(!(a.w>l.w||a.h>l.h)){if(a.x=l.x,a.y=l.y,r=Math.max(r,a.y+a.h),s=Math.max(s,a.x+a.w),a.w===l.w&&a.h===l.h){const h=i.pop();o<i.length&&(i[o]=h)}else a.h===l.h?(l.x+=a.w,l.w-=a.w):a.w===l.w?(l.y+=a.h,l.h-=a.h):(i.push({x:l.x+a.w,y:l.y,w:l.w-a.w,h:a.h}),l.y+=a.h,l.h-=a.h);break}}return{w:s,h:r,fill:t/(s*r)||0}}class YM extends Mt{constructor(t,e){super(),g(this,"update",()=>{this._system.update()}),g(this,"createSnow",()=>{const r=new Te().load(me("assets/textures/sky/others/snow.png")),a=new Da({map:r,transparent:!0,opacity:.8,color:16777215,depthWrite:!1,depthTest:!0});return new Il(a)}),g(this,"createEmitter",(r,a)=>{const o=new Ch,l=new Yr;return l.addZone(new _d(10,10,10)),o.setRate(new Zn(new Ye(60,80),new Ye(.2,.5))).addInitializers([new so(1),new ro(new Ye(5,10)),l,new no(3,7),new eo(this.createSnow()),new ao(0,new kt(0,-1,0),90)]).addBehaviours([new Lh(10,1,10,.05),new Ih("random","random"),new lo(5)]).setPosition({x:0,y:500}).emit()}),this._renderer=t,this._camera=e;const i=this._system=new ho,s=this.createEmitter(e,t);i.addEmitter(s).addRenderer(new Y0(this,Tg))}dispose(){}}class ZM extends Mt{constructor(t,e){super(),g(this,"update",()=>{this._system.update()}),g(this,"createRain",()=>{const r=new Te().load(me("assets/textures/sky/others/trace_01.png")),a=new Da({map:r,transparent:!0,opacity:.7,color:16777215,depthWrite:!1,depthTest:!0});return new Il(a)}),g(this,"createEmitter",(r,a)=>{const o=new Ch,l=new Yr;return l.addZone(new _d(1e3,10,1e3)),o.setRate(new Zn(new Ye(60,80),new Ye(.2,.4))).addInitializers([new so(1),new ro(new Ye(15,20)),l,new no(2,4),new eo(this.createRain()),new ao(0,new kt(0,-1,0),30)]).addBehaviours([new lo(15)]).setPosition({y:400}).emit()}),this._renderer=t,this._camera=e;const i=this._system=new ho,s=this.createEmitter(e,t);i.addEmitter(s).addRenderer(new Y0(this,Tg))}dispose(){}}class Ld extends Mt{constructor(t){super(),g(this,"_engine"),g(this,"_sky"),g(this,"_snow"),g(this,"_rain"),g(this,"_weather",""),g(this,"_currentConverageTextureType",null),g(this,"_tCoverageIntensity",null),g(this,"_skyGroundColorBlue",new nt(1657983)),g(this,"_skyGroundColorGray",new nt(11184810)),g(this,"_weatherChangedListeners",[]),g(this,"_sunLightScale",.5),g(this,"_skyLightScale",1),g(this,"handleBeforeRender",()=>{if(this._snow){this._engine.map.getProjectionCenter();const e=this._engine.camera.position;this._snow.position.copy(e),this._snow.update()}if(this._rain){const e=this._engine.camera.position;this._rain.position.copy(e),this._rain.update()}}),g(this,"beforeRemoveFromEngine",e=>{e.removeBeforeRenderListener(this.handleBeforeRender)}),this._sky=t}get weather(){return this._weather}set weather(t){if(t&&t!==this._weather){this._weather=t,this.updateWeather(t);for(const e of this._weatherChangedListeners)e(t)}}afterAddToEngine(t){this._engine=t,t.addBeforeRenderListener(this.handleBeforeRender),this.updateWeather(this._weather)}getCoverageTexture(t){if(this._tCoverageIntensity===null||t!==this._currentConverageTextureType){this._tCoverageIntensity&&this._tCoverageIntensity.dispose();let e="assets/textures/realistic/TexturesCom_Snow_Plain_3x3_512_noise.jpg";t==="rain"&&(e="assets/textures/realistic/TexturesCom_Ground_MudWet_512_roughness.jpg"),this._tCoverageIntensity=new Te().load(me(e),()=>{this._engine.requestRender()})}return this._tCoverageIntensity}updateWeather(t){const e=this._engine;let i=1,s=.2,r=.5,a=0,o=null;this._skyGroundColorGray;let l=0,h=!1,c=!1;if(t==="sunny")i=1.5,s=0,r=.8,this._skyGroundColorBlue,l=.1;else if(t==="partlyCloudy")i=1.3,s=.2,r=.9,this._skyGroundColorBlue,l=.2;else if(t==="cloudy")i=0,s=.7,r=1,l=.3;else if(t==="overcast")i=0,s=.9,r=.4,l=.4;else if(t==="foggy")i=0,s=.9,r=.4,l=1;else if(t==="rainy")i=0,s=.9,r=.4,c=!0,l=.5;else{if(t!=="snowy")return;i=0,s=.9,r=.4,a=1,o=this.getCoverageTexture("snow"),h=!0,l=.5}if(this.sunIntensityScale=i*this._sunLightScale,this.cloudIntensity=s,this.skyLightIntensity=r*this._skyLightScale,this.coverageIntensity=a,this.tCoverageIntensity=o,this.fogDensity=l,this._sky.isStaticSky&&(["overcast","foggy","rainy","snowy"].includes(t)?this._sky.weather="overcast":this._sky.weather=t),h){if(!this._snow){const u=this._snow=new YM(e.renderer,e.camera);u.rotateX(90),this.add(u)}}else this._snow&&(this.remove(this._snow),this._snow.dispose(),this._snow=null);if(c){if(!this._rain){const u=this._rain=new ZM(e.renderer,e.camera);u.rotateX(90),this.add(u)}}else this._rain&&(this.remove(this._rain),this._rain.dispose(),this._rain=null)}addWeatherChangedListener(t){this._weatherChangedListeners.indexOf(t)===-1&&this._weatherChangedListeners.push(t)}removeWeatherChangedListener(t){const e=this._weatherChangedListeners.indexOf(t);e!==-1&&this._weatherChangedListeners.splice(e,1)}get sunIntensityScale(){return this._sky.sunIntensityScale}set sunIntensityScale(t){this._sky.sunIntensityScale=t}get cloudIntensity(){return this._sky.cloudIntensity}set cloudIntensity(t){this._sky.cloudIntensity=t}get skyLightIntensity(){return this._sky.skyLightIntensity}set skyLightIntensity(t){this._sky.skyLightIntensity=t}get groundColor(){return this._sky.groundColor}set groundColor(t){this._sky.groundColor=t}get coverageIntensity(){return this._engine.rendering.composition.coverageIntensity}set coverageIntensity(t){this._engine.rendering.composition.coverageIntensity=t}get tCoverageIntensity(){return this._engine.rendering.composition.tCoverageIntensity}set tCoverageIntensity(t){this._engine.rendering.composition.tCoverageIntensity=t}get tRelectionEnhancement(){return this._engine.rendering.ssr.tEnhancement}set tRelectionEnhancement(t){this._engine.rendering.ssr.tEnhancement=t}set fogDensity(t){this._engine.rendering.fog.density=t}get fogDensity(){return this._engine.rendering.fog.density}get skyLightScale(){return this._skyLightScale}set skyLightScale(t){this._skyLightScale=t}get sunLightScale(){return this._sunLightScale}set sunLightScale(t){this._sunLightScale=t}}class JM{constructor(t){g(this,"_rendering"),g(this,"_useMrt",!1),g(this,"_mainMrt",null),g(this,"_renderPass",null),g(this,"_needsPrepare",!0),g(this,"_antialias",!0),g(this,"_msaaSamples",4),g(this,"cleanup",e=>{e&&(this._mainMrt&&this._mainMrt.dispose(),this._mainMrt=null)}),this._rendering=t}get useMrt(){return this._useMrt}set useMrt(t){t!==this._useMrt&&(this._useMrt=t,this._needsPrepare=!0)}_init(){const t=this._rendering,e=t.resolution;if(this.cleanup(!this.useMrt),this._useMrt){const i=this._tDepth=new pu({type:1015}),s=this._mainMrt=new am(e.x*t.pixelRatio,e.y*t.pixelRatio,4,{samples:this._antialias?this._msaaSamples:0});s.depthTexture=i,s.depthBuffer=!0;for(let r=0,a=s.texture.length;r<a;r++)s.texture[r].minFilter=1003,s.texture[r].magFilter=1003,s.texture[r].encoding=t.outputEncoding,s.texture[r].format=1023;s.texture.isTexture=!0,s.texture.encoding=t.outputEncoding,this._tDiffuse=s.texture[0],this._tEmissive=s.texture[1],this._tNormal=s.texture[2],this._tSpecular=s.texture[3]}}render(){this._needsPrepare&&(this._needsPrepare=!1,this._init());const t=this._rendering,e=t.renderer;this._useMrt?(e.setRenderTarget(this._mainMrt),e.render(t.scene,t.camera)):(e.setRenderTarget(null),e.render(t.scene,t.camera))}dispose(){this.cleanup(this._useMrt)}getTextures(){return this._useMrt?[this._tDiffuse,this._tEmissive,this._tNormal,this._tDepth,this._tSpecular]:[]}setSize(t,e){const i=this._rendering;this._mainMrt&&this._mainMrt.setSize(t*i.pixelRatio,e*i.pixelRatio)}get tDiffuse(){return this._tDiffuse}get tNormal(){return this._tNormal}get tDepth(){return this._tDepth}get tSpecular(){return this._tSpecular}get tEmissive(){return this._tEmissive}get antialias(){return this._antialias}set antialias(t){this._antialias=!!t,t?this._useMrt&&(this._mainMrt.samples=this._msaaSamples):this._useMrt&&(this._mainMrt.samples=0)}}class KM{constructor(t){g(this,"_rendering"),this._rendering=t}get enabled(){return this._rendering.renderer.shadowMap.enabled}set enabled(t){this._rendering.renderer.shadowMap.enabled=t,t&&(this._rendering.renderer.shadowMap.toneMapping=2,this._rendering.renderer.shadowMap.toneMappingExposure=0)}}class QM{constructor(t){g(this,"_needsCreate",!1),g(this,"_fogStartFactor",.5),g(this,"_rendering"),g(this,"_enabled",!1),g(this,"_density",1),g(this,"_color",new nt(16777215)),g(this,"_skyColorStartFactor",.5),g(this,"_altitudeBottom",0),g(this,"_altitudeTop",1e3),g(this,"createFog",()=>{const e=this._rendering;if(e.useMrt){const i=e.composition;i.useFog=!0,i.fogDensity=this._density,i.fogSkyColorStartFactor=this._skyColorStartFactor,i.fogAltitudeTop=this._altitudeTop,i.fogAltitudeBottom=this._altitudeBottom}else e.scene.fog=new Ia(this._color,1,1e3)}),g(this,"destoryFog",()=>{const e=this._rendering;e.useMrt?e.composition.useFog=!1:e.scene.fog=null}),this._rendering=t}get enabled(){return this._enabled}set enabled(t){t!==this._enabled&&(this._enabled=t,t?this._needsCreate=!0:this.destoryFog())}set color(t){this._color=t;const e=this._rendering,i=e.useMrt;this._enabled&&(i?e.composition.fogColor=t:e.scene.fog&&(e.scene.fog.color=t))}get color(){return this._color}get density(){return this._density}set density(t){this._density=t;const e=this._rendering,i=e.useMrt;this._enabled&&(i?e.composition.fogDensity=this._density:e.scene.fog&&(e.scene.fog.density=t))}get skyColorStartFactor(){return this._skyColorStartFactor}set skyColorStartFactor(t){this._skyColorStartFactor=t;const e=this._rendering,i=e.useMrt;this._enabled&&i&&(e.composition.fogSkyColorStartFactor=this._skyColorStartFactor)}get altitudeTop(){return this._altitudeTop}set altitudeTop(t){this._altitudeTop=t;const e=this._rendering,i=e.useMrt;this._enabled&&i&&(e.composition.fogAltitudeTop=this._altitudeTop)}get altitudeBottom(){return this._altitudeBottom}set altitudeBottom(t){this._altitudeBottom=t;const e=this._rendering,i=e.useMrt;this._enabled&&i&&(e.composition.fogAltitudeBottom=this._altitudeBottom)}render(){if(this._enabled)if(this._needsCreate&&(this._needsCreate=!1,this.createFog(),this._rendering.requestRender()),this._rendering.useMrt)this._rendering.scene.fog&&(this._rendering.scene.fog=null,this._rendering.requestRender());else{let t=this._rendering.scene.fog;t||(this.createFog(),t=this._rendering.scene.fog,this._rendering.requestRender());const e=this._rendering.camera.far;t.near=this._fogStartFactor*e,t.far=e}}}class Id{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const $M=new vr(-1,1,1,-1,0,1),Dd=new gt;Dd.setAttribute("position",new Z([-1,3,0,-1,-1,0,3,-1,0],3)),Dd.setAttribute("uv",new Z([0,2,0,0,2,0],2));class co{constructor(t){this._mesh=new ot(Dd,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,$M)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}const J0={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`},K0={shaderID:"luminosityHighPass",uniforms:{tDiffuse:{value:null},luminosityThreshold:{value:1},smoothWidth:{value:1},defaultColor:{value:new nt(0)},defaultOpacity:{value:0}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`};class Zr extends Id{constructor(t,e,i,s){super(),this.strength=e!==void 0?e:1,this.radius=i,this.threshold=s,this.resolution=t!==void 0?new V(t.x,t.y):new V(256,256),this.clearColor=new nt(0,0,0);const r={minFilter:1006,magFilter:1006,format:1023,type:1016};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let a=Math.round(this.resolution.x/2),o=Math.round(this.resolution.y/2);this.renderTargetBright=new Yt(a,o,r),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let u=0;u<this.nMips;u++){const d=new Yt(a,o,r);d.texture.name="UnrealBloomPass.h"+u,d.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(d);const p=new Yt(a,o,r);p.texture.name="UnrealBloomPass.v"+u,p.texture.generateMipmaps=!1,this.renderTargetsVertical.push(p),a=Math.round(a/2),o=Math.round(o/2)}K0===void 0&&console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");const l=K0;this.highPassUniforms=ft.clone(l.uniforms),this.highPassUniforms.luminosityThreshold.value=s,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new Qt({uniforms:this.highPassUniforms,vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,defines:{}}),this.separableBlurMaterials=[];const h=[3,5,7,9,11];a=Math.round(this.resolution.x/2),o=Math.round(this.resolution.y/2);for(let u=0;u<this.nMips;u++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(h[u])),this.separableBlurMaterials[u].uniforms.texSize.value=new V(a,o),a=Math.round(a/2),o=Math.round(o/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=e,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0,this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new S(1,1,1),new S(1,1,1),new S(1,1,1),new S(1,1,1),new S(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,J0===void 0&&console.error("THREE.UnrealBloomPass relies on CopyShader");const c=J0;this.copyUniforms=ft.clone(c.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new Qt({uniforms:this.copyUniforms,vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,blending:2,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new nt,this.oldClearAlpha=1,this.basic=new Zt,this.fsQuad=new co(null)}dispose(){for(let t=0;t<this.renderTargetsHorizontal.length;t++)this.renderTargetsHorizontal[t].dispose();for(let t=0;t<this.renderTargetsVertical.length;t++)this.renderTargetsVertical[t].dispose();this.renderTargetBright.dispose()}setSize(t,e){let i=Math.round(t/2),s=Math.round(e/2);this.renderTargetBright.setSize(i,s);for(let r=0;r<this.nMips;r++)this.renderTargetsHorizontal[r].setSize(i,s),this.renderTargetsVertical[r].setSize(i,s),this.separableBlurMaterials[r].uniforms.texSize.value=new V(i,s),i=Math.round(i/2),s=Math.round(s/2)}render(t,e,i,s,r){t.getClearColor(this._oldClearColor),this.oldClearAlpha=t.getClearAlpha();const a=t.autoClear;t.autoClear=!1,t.setClearColor(this.clearColor,0),r&&t.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=e,t.setRenderTarget(null),t.clear(),this.fsQuad.render(t)),this.highPassUniforms.tDiffuse.value=e,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,t.setRenderTarget(this.renderTargetBright),t.clear(),this.fsQuad.render(t);let o=this.renderTargetBright;for(let l=0;l<this.nMips;l++)this.fsQuad.material=this.separableBlurMaterials[l],this.separableBlurMaterials[l].uniforms.colorTexture.value=o.texture,this.separableBlurMaterials[l].uniforms.direction.value=Zr.BlurDirectionX,t.setRenderTarget(this.renderTargetsHorizontal[l]),t.clear(),this.fsQuad.render(t),this.separableBlurMaterials[l].uniforms.colorTexture.value=this.renderTargetsHorizontal[l].texture,this.separableBlurMaterials[l].uniforms.direction.value=Zr.BlurDirectionY,t.setRenderTarget(this.renderTargetsVertical[l]),t.clear(),this.fsQuad.render(t),o=this.renderTargetsVertical[l];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,t.setRenderTarget(this.renderTargetsHorizontal[0]),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,r&&t.state.buffers.stencil.setTest(!0),this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(i),this.fsQuad.render(t)),t.setClearColor(this._oldClearColor,this.oldClearAlpha),t.autoClear=a}getSeperableBlurMaterial(t){return new Qt({defines:{KERNEL_RADIUS:t,SIGMA:t},uniforms:{colorTexture:{value:null},texSize:{value:new V(.5,.5)},direction:{value:new V(.5,.5)}},vertexShader:`varying vec2 vUv;
                  void main() {
                      vUv = uv;
                      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                  }`,fragmentShader:`#include <common>
                  varying vec2 vUv;
                  uniform sampler2D colorTexture;
                  uniform vec2 texSize;
                  uniform vec2 direction;
                  float gaussianPdf(in float x, in float sigma) {
                      return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
                  }
                  void main() {
            vec2 invSize = 1.0 / texSize;            float fSigma = float(SIGMA);            float weightSum = gaussianPdf(0.0, fSigma);            float alphaSum = 0.0;            vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;            for( int i = 1; i < KERNEL_RADIUS; i ++ ) {              float x = float(i);              float w = gaussianPdf(x, fSigma);              vec2 uvOffset = direction * invSize * x;              vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);              vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);              diffuseSum += (sample1.rgb + sample2.rgb) * w;              alphaSum += (sample1.a + sample2.a) * w;              weightSum += 2.0 * w;            }            gl_FragColor = vec4(diffuseSum/weightSum, alphaSum/weightSum);
          }`})}getCompositeMaterial(t){return new Qt({defines:{NUM_MIPS:t},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:`varying vec2 vUv;
                  void main() {
                      vUv = uv;
                      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                  }`,fragmentShader:`varying vec2 vUv;
                  uniform sampler2D blurTexture1;
                  uniform sampler2D blurTexture2;
                  uniform sampler2D blurTexture3;
                  uniform sampler2D blurTexture4;
                  uniform sampler2D blurTexture5;
                  uniform sampler2D dirtTexture;
                  uniform float bloomStrength;
                  uniform float bloomRadius;
                  uniform float bloomFactors[NUM_MIPS];
                  uniform vec3 bloomTintColors[NUM_MIPS];
                  float lerpBloomFactor(const in float factor) {
                      float mirrorFactor = 1.2 - factor;
                      return mix(factor, mirrorFactor, bloomRadius);
                  }
                  void main() {
                      gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
                          lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
                          lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
                          lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
                          lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
                  }`})}}Zr.BlurDirectionX=new V(1,0),Zr.BlurDirectionY=new V(0,1);const Q0=new nt,tw=new nt(0);let $0=0;class ew{constructor(t){g(this,"_rendering"),g(this,"_strength",3),g(this,"_threshold",0),g(this,"_radius",.5),g(this,"_needsSetTexture",!1),g(this,"_enabled",!1),g(this,"_renderPass",null),g(this,"_useMrt",!1),this._rendering=t}get useMrt(){return this._useMrt}set useMrt(t){t!==this._useMrt&&(this._useMrt=t,t||this.dispose())}set enabled(t){(t=!!t)!==this._enabled&&(this._enabled=t,t||this.dispose())}get enabled(){return this._enabled}_init(){const t=this._rendering,e=t.resolution,i=new V(e.x,e.y),s=t.pixelRatio;this._renderPass=new Zr(i,this._strength,this._radius,this._threshold),this._bloomRenderTarget=new Yt(i.x*s,i.y*s,{type:1016}),t.composition.tBloom=this._bloomRenderTarget.texture}render(){if(!this._enabled||!this._useMrt)return;this._enabled&&!this._renderPass&&this._init();const t=this._rendering,e=t.main.tEmissive,i=t.renderer;i.setRenderTarget(this._bloomRenderTarget),i.getClearColor(Q0),$0=i.getClearAlpha(),i.setClearColor(tw),i.setClearAlpha(0),i.clear(),i.setClearColor(Q0),i.setClearAlpha($0),this._renderPass.render(t.renderer,e,this._bloomRenderTarget)}dispose(){this._rendering.composition.tBloom=null,this._renderPass&&(this._renderPass.dispose(),this._renderPass=null),this._bloomRenderTarget&&(this._bloomRenderTarget.dispose(),this._bloomRenderTarget=null)}getTextures(){const t=[];return this._bloomRenderTarget&&t.push(this._bloomRenderTarget.texture),t}setSize(t,e){this._rendering,this._bloomRenderTarget&&this._bloomRenderTarget.setSize(t,e)}get tBloom(){return this._bloomRenderTarget&&this._bloomRenderTarget.texture||null}get strength(){return this._strength}set strength(t){this._strength=t,this._renderPass&&(this._renderPass.strength=t)}get radius(){return this._radius}set radius(t){this._radius=t,this._renderPass&&(this._renderPass.radius=t)}get threshold(){return this._threshold}set threshold(t){this._threshold=t,this._renderPass&&(this._renderPass.threshold=t)}}var tv={exports:{}},ev={exports:{}},iw=function(n){return!(!n||typeof n=="string")&&(n instanceof Array||Array.isArray(n)||n.length>=0&&(n.splice instanceof Function||Object.getOwnPropertyDescriptor(n,n.length-1)&&n.constructor.name!=="String"))},nw=Array.prototype.concat,sw=Array.prototype.slice,iv=ev.exports=function(n){for(var t=[],e=0,i=n.length;e<i;e++){var s=n[e];iw(s)?t=nw.call(t,sw.call(s)):t.push(s)}return t};iv.wrap=function(n){return function(){return n(iv(arguments))}};var uo={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},po=ev.exports,nv=Object.hasOwnProperty,sv=Object.create(null);for(var Od in uo)nv.call(uo,Od)&&(sv[uo[Od]]=Od);var oi=tv.exports={to:{},get:{}};function Jn(n,t,e){return Math.min(Math.max(t,n),e)}function Oh(n){var t=Math.round(n).toString(16).toUpperCase();return t.length<2?"0"+t:t}oi.get=function(n){var t,e;switch(n.substring(0,3).toLowerCase()){case"hsl":t=oi.get.hsl(n),e="hsl";break;case"hwb":t=oi.get.hwb(n),e="hwb";break;default:t=oi.get.rgb(n),e="rgb"}return t?{model:e,value:t}:null},oi.get.rgb=function(n){if(!n)return null;var t,e,i,s=[0,0,0,1];if(t=n.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)){for(i=t[2],t=t[1],e=0;e<3;e++){var r=2*e;s[e]=parseInt(t.slice(r,r+2),16)}i&&(s[3]=parseInt(i,16)/255)}else if(t=n.match(/^#([a-f0-9]{3,4})$/i)){for(i=(t=t[1])[3],e=0;e<3;e++)s[e]=parseInt(t[e]+t[e],16);i&&(s[3]=parseInt(i+i,16)/255)}else if(t=n.match(/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)){for(e=0;e<3;e++)s[e]=parseInt(t[e+1],0);t[4]&&(t[5]?s[3]=.01*parseFloat(t[4]):s[3]=parseFloat(t[4]))}else{if(!(t=n.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)))return(t=n.match(/^(\w+)$/))?t[1]==="transparent"?[0,0,0,0]:nv.call(uo,t[1])?((s=uo[t[1]])[3]=1,s):null:null;for(e=0;e<3;e++)s[e]=Math.round(2.55*parseFloat(t[e+1]));t[4]&&(t[5]?s[3]=.01*parseFloat(t[4]):s[3]=parseFloat(t[4]))}for(e=0;e<3;e++)s[e]=Jn(s[e],0,255);return s[3]=Jn(s[3],0,1),s},oi.get.hsl=function(n){if(!n)return null;var t=n.match(/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);if(t){var e=parseFloat(t[4]);return[(parseFloat(t[1])%360+360)%360,Jn(parseFloat(t[2]),0,100),Jn(parseFloat(t[3]),0,100),Jn(isNaN(e)?1:e,0,1)]}return null},oi.get.hwb=function(n){if(!n)return null;var t=n.match(/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);if(t){var e=parseFloat(t[4]);return[(parseFloat(t[1])%360+360)%360,Jn(parseFloat(t[2]),0,100),Jn(parseFloat(t[3]),0,100),Jn(isNaN(e)?1:e,0,1)]}return null},oi.to.hex=function(){var n=po(arguments);return"#"+Oh(n[0])+Oh(n[1])+Oh(n[2])+(n[3]<1?Oh(Math.round(255*n[3])):"")},oi.to.rgb=function(){var n=po(arguments);return n.length<4||n[3]===1?"rgb("+Math.round(n[0])+", "+Math.round(n[1])+", "+Math.round(n[2])+")":"rgba("+Math.round(n[0])+", "+Math.round(n[1])+", "+Math.round(n[2])+", "+n[3]+")"},oi.to.rgb.percent=function(){var n=po(arguments),t=Math.round(n[0]/255*100),e=Math.round(n[1]/255*100),i=Math.round(n[2]/255*100);return n.length<4||n[3]===1?"rgb("+t+"%, "+e+"%, "+i+"%)":"rgba("+t+"%, "+e+"%, "+i+"%, "+n[3]+")"},oi.to.hsl=function(){var n=po(arguments);return n.length<4||n[3]===1?"hsl("+n[0]+", "+n[1]+"%, "+n[2]+"%)":"hsla("+n[0]+", "+n[1]+"%, "+n[2]+"%, "+n[3]+")"},oi.to.hwb=function(){var n=po(arguments),t="";return n.length>=4&&n[3]!==1&&(t=", "+n[3]),"hwb("+n[0]+", "+n[1]+"%, "+n[2]+"%"+t+")"},oi.to.keyword=function(n){return sv[n.slice(0,3)]};const mo={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},rv={};for(const n of Object.keys(mo))rv[mo[n]]=n;const vt={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};var av=vt;for(const n of Object.keys(vt)){if(!("channels"in vt[n]))throw new Error("missing channels property: "+n);if(!("labels"in vt[n]))throw new Error("missing channel labels property: "+n);if(vt[n].labels.length!==vt[n].channels)throw new Error("channel and label counts mismatch: "+n);const{channels:t,labels:e}=vt[n];delete vt[n].channels,delete vt[n].labels,Object.defineProperty(vt[n],"channels",{value:t}),Object.defineProperty(vt[n],"labels",{value:e})}function rw(n,t){return(n[0]-t[0])**2+(n[1]-t[1])**2+(n[2]-t[2])**2}vt.rgb.hsl=function(n){const t=n[0]/255,e=n[1]/255,i=n[2]/255,s=Math.min(t,e,i),r=Math.max(t,e,i),a=r-s;let o,l;r===s?o=0:t===r?o=(e-i)/a:e===r?o=2+(i-t)/a:i===r&&(o=4+(t-e)/a),o=Math.min(60*o,360),o<0&&(o+=360);const h=(s+r)/2;return l=r===s?0:h<=.5?a/(r+s):a/(2-r-s),[o,100*l,100*h]},vt.rgb.hsv=function(n){let t,e,i,s,r;const a=n[0]/255,o=n[1]/255,l=n[2]/255,h=Math.max(a,o,l),c=h-Math.min(a,o,l),u=function(d){return(h-d)/6/c+.5};return c===0?(s=0,r=0):(r=c/h,t=u(a),e=u(o),i=u(l),a===h?s=i-e:o===h?s=1/3+t-i:l===h&&(s=2/3+e-t),s<0?s+=1:s>1&&(s-=1)),[360*s,100*r,100*h]},vt.rgb.hwb=function(n){const t=n[0],e=n[1];let i=n[2];const s=vt.rgb.hsl(n)[0],r=1/255*Math.min(t,Math.min(e,i));return i=1-1/255*Math.max(t,Math.max(e,i)),[s,100*r,100*i]},vt.rgb.cmyk=function(n){const t=n[0]/255,e=n[1]/255,i=n[2]/255,s=Math.min(1-t,1-e,1-i);return[100*((1-t-s)/(1-s)||0),100*((1-e-s)/(1-s)||0),100*((1-i-s)/(1-s)||0),100*s]},vt.rgb.keyword=function(n){const t=rv[n];if(t)return t;let e,i=1/0;for(const s of Object.keys(mo)){const r=rw(n,mo[s]);r<i&&(i=r,e=s)}return e},vt.keyword.rgb=function(n){return mo[n]},vt.rgb.xyz=function(n){let t=n[0]/255,e=n[1]/255,i=n[2]/255;return t=t>.04045?((t+.055)/1.055)**2.4:t/12.92,e=e>.04045?((e+.055)/1.055)**2.4:e/12.92,i=i>.04045?((i+.055)/1.055)**2.4:i/12.92,[100*(.4124*t+.3576*e+.1805*i),100*(.2126*t+.7152*e+.0722*i),100*(.0193*t+.1192*e+.9505*i)]},vt.rgb.lab=function(n){const t=vt.rgb.xyz(n);let e=t[0],i=t[1],s=t[2];return e/=95.047,i/=100,s/=108.883,e=e>.008856?e**(1/3):7.787*e+16/116,i=i>.008856?i**(1/3):7.787*i+16/116,s=s>.008856?s**(1/3):7.787*s+16/116,[116*i-16,500*(e-i),200*(i-s)]},vt.hsl.rgb=function(n){const t=n[0]/360,e=n[1]/100,i=n[2]/100;let s,r,a;if(e===0)return a=255*i,[a,a,a];s=i<.5?i*(1+e):i+e-i*e;const o=2*i-s,l=[0,0,0];for(let h=0;h<3;h++)r=t+1/3*-(h-1),r<0&&r++,r>1&&r--,a=6*r<1?o+6*(s-o)*r:2*r<1?s:3*r<2?o+(s-o)*(2/3-r)*6:o,l[h]=255*a;return l},vt.hsl.hsv=function(n){const t=n[0];let e=n[1]/100,i=n[2]/100,s=e;const r=Math.max(i,.01);return i*=2,e*=i<=1?i:2-i,s*=r<=1?r:2-r,[t,100*(i===0?2*s/(r+s):2*e/(i+e)),100*((i+e)/2)]},vt.hsv.rgb=function(n){const t=n[0]/60,e=n[1]/100;let i=n[2]/100;const s=Math.floor(t)%6,r=t-Math.floor(t),a=255*i*(1-e),o=255*i*(1-e*r),l=255*i*(1-e*(1-r));switch(i*=255,s){case 0:return[i,l,a];case 1:return[o,i,a];case 2:return[a,i,l];case 3:return[a,o,i];case 4:return[l,a,i];case 5:return[i,a,o]}},vt.hsv.hsl=function(n){const t=n[0],e=n[1]/100,i=n[2]/100,s=Math.max(i,.01);let r,a;a=(2-e)*i;const o=(2-e)*s;return r=e*s,r/=o<=1?o:2-o,r=r||0,a/=2,[t,100*r,100*a]},vt.hwb.rgb=function(n){const t=n[0]/360;let e=n[1]/100,i=n[2]/100;const s=e+i;let r;s>1&&(e/=s,i/=s);const a=Math.floor(6*t),o=1-i;r=6*t-a,1&a&&(r=1-r);const l=e+r*(o-e);let h,c,u;switch(a){default:case 6:case 0:h=o,c=l,u=e;break;case 1:h=l,c=o,u=e;break;case 2:h=e,c=o,u=l;break;case 3:h=e,c=l,u=o;break;case 4:h=l,c=e,u=o;break;case 5:h=o,c=e,u=l}return[255*h,255*c,255*u]},vt.cmyk.rgb=function(n){const t=n[0]/100,e=n[1]/100,i=n[2]/100,s=n[3]/100;return[255*(1-Math.min(1,t*(1-s)+s)),255*(1-Math.min(1,e*(1-s)+s)),255*(1-Math.min(1,i*(1-s)+s))]},vt.xyz.rgb=function(n){const t=n[0]/100,e=n[1]/100,i=n[2]/100;let s,r,a;return s=3.2406*t+-1.5372*e+-.4986*i,r=-.9689*t+1.8758*e+.0415*i,a=.0557*t+-.204*e+1.057*i,s=s>.0031308?1.055*s**(1/2.4)-.055:12.92*s,r=r>.0031308?1.055*r**(1/2.4)-.055:12.92*r,a=a>.0031308?1.055*a**(1/2.4)-.055:12.92*a,s=Math.min(Math.max(0,s),1),r=Math.min(Math.max(0,r),1),a=Math.min(Math.max(0,a),1),[255*s,255*r,255*a]},vt.xyz.lab=function(n){let t=n[0],e=n[1],i=n[2];return t/=95.047,e/=100,i/=108.883,t=t>.008856?t**(1/3):7.787*t+16/116,e=e>.008856?e**(1/3):7.787*e+16/116,i=i>.008856?i**(1/3):7.787*i+16/116,[116*e-16,500*(t-e),200*(e-i)]},vt.lab.xyz=function(n){let t,e,i;e=(n[0]+16)/116,t=n[1]/500+e,i=e-n[2]/200;const s=e**3,r=t**3,a=i**3;return e=s>.008856?s:(e-16/116)/7.787,t=r>.008856?r:(t-16/116)/7.787,i=a>.008856?a:(i-16/116)/7.787,t*=95.047,e*=100,i*=108.883,[t,e,i]},vt.lab.lch=function(n){const t=n[0],e=n[1],i=n[2];let s;return s=360*Math.atan2(i,e)/2/Math.PI,s<0&&(s+=360),[t,Math.sqrt(e*e+i*i),s]},vt.lch.lab=function(n){const t=n[0],e=n[1],i=n[2]/360*2*Math.PI;return[t,e*Math.cos(i),e*Math.sin(i)]},vt.rgb.ansi16=function(n,t=null){const[e,i,s]=n;let r=t===null?vt.rgb.hsv(n)[2]:t;if(r=Math.round(r/50),r===0)return 30;let a=30+(Math.round(s/255)<<2|Math.round(i/255)<<1|Math.round(e/255));return r===2&&(a+=60),a},vt.hsv.ansi16=function(n){return vt.rgb.ansi16(vt.hsv.rgb(n),n[2])},vt.rgb.ansi256=function(n){const t=n[0],e=n[1],i=n[2];return t===e&&e===i?t<8?16:t>248?231:Math.round((t-8)/247*24)+232:16+36*Math.round(t/255*5)+6*Math.round(e/255*5)+Math.round(i/255*5)},vt.ansi16.rgb=function(n){let t=n%10;if(t===0||t===7)return n>50&&(t+=3.5),t=t/10.5*255,[t,t,t];const e=.5*(1+~~(n>50));return[(1&t)*e*255,(t>>1&1)*e*255,(t>>2&1)*e*255]},vt.ansi256.rgb=function(n){if(n>=232){const e=10*(n-232)+8;return[e,e,e]}let t;return n-=16,[Math.floor(n/36)/5*255,Math.floor((t=n%36)/6)/5*255,t%6/5*255]},vt.rgb.hex=function(n){const t=(((255&Math.round(n[0]))<<16)+((255&Math.round(n[1]))<<8)+(255&Math.round(n[2]))).toString(16).toUpperCase();return"000000".substring(t.length)+t},vt.hex.rgb=function(n){const t=n.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!t)return[0,0,0];let e=t[0];t[0].length===3&&(e=e.split("").map(s=>s+s).join(""));const i=parseInt(e,16);return[i>>16&255,i>>8&255,255&i]},vt.rgb.hcg=function(n){const t=n[0]/255,e=n[1]/255,i=n[2]/255,s=Math.max(Math.max(t,e),i),r=Math.min(Math.min(t,e),i),a=s-r;let o,l;return o=a<1?r/(1-a):0,l=a<=0?0:s===t?(e-i)/a%6:s===e?2+(i-t)/a:4+(t-e)/a,l/=6,l%=1,[360*l,100*a,100*o]},vt.hsl.hcg=function(n){const t=n[1]/100,e=n[2]/100,i=e<.5?2*t*e:2*t*(1-e);let s=0;return i<1&&(s=(e-.5*i)/(1-i)),[n[0],100*i,100*s]},vt.hsv.hcg=function(n){const t=n[1]/100,e=n[2]/100,i=t*e;let s=0;return i<1&&(s=(e-i)/(1-i)),[n[0],100*i,100*s]},vt.hcg.rgb=function(n){const t=n[0]/360,e=n[1]/100,i=n[2]/100;if(e===0)return[255*i,255*i,255*i];const s=[0,0,0],r=t%1*6,a=r%1,o=1-a;let l=0;switch(Math.floor(r)){case 0:s[0]=1,s[1]=a,s[2]=0;break;case 1:s[0]=o,s[1]=1,s[2]=0;break;case 2:s[0]=0,s[1]=1,s[2]=a;break;case 3:s[0]=0,s[1]=o,s[2]=1;break;case 4:s[0]=a,s[1]=0,s[2]=1;break;default:s[0]=1,s[1]=0,s[2]=o}return l=(1-e)*i,[255*(e*s[0]+l),255*(e*s[1]+l),255*(e*s[2]+l)]},vt.hcg.hsv=function(n){const t=n[1]/100,e=t+n[2]/100*(1-t);let i=0;return e>0&&(i=t/e),[n[0],100*i,100*e]},vt.hcg.hsl=function(n){const t=n[1]/100,e=n[2]/100*(1-t)+.5*t;let i=0;return e>0&&e<.5?i=t/(2*e):e>=.5&&e<1&&(i=t/(2*(1-e))),[n[0],100*i,100*e]},vt.hcg.hwb=function(n){const t=n[1]/100,e=t+n[2]/100*(1-t);return[n[0],100*(e-t),100*(1-e)]},vt.hwb.hcg=function(n){const t=n[1]/100,e=1-n[2]/100,i=e-t;let s=0;return i<1&&(s=(e-i)/(1-i)),[n[0],100*i,100*s]},vt.apple.rgb=function(n){return[n[0]/65535*255,n[1]/65535*255,n[2]/65535*255]},vt.rgb.apple=function(n){return[n[0]/255*65535,n[1]/255*65535,n[2]/255*65535]},vt.gray.rgb=function(n){return[n[0]/100*255,n[0]/100*255,n[0]/100*255]},vt.gray.hsl=function(n){return[0,0,n[0]]},vt.gray.hsv=vt.gray.hsl,vt.gray.hwb=function(n){return[0,100,n[0]]},vt.gray.cmyk=function(n){return[0,0,0,n[0]]},vt.gray.lab=function(n){return[n[0],0,0]},vt.gray.hex=function(n){const t=255&Math.round(n[0]/100*255),e=((t<<16)+(t<<8)+t).toString(16).toUpperCase();return"000000".substring(e.length)+e},vt.rgb.gray=function(n){return[(n[0]+n[1]+n[2])/3/255*100]};const zh=av;function aw(n){const t=function(){const i={},s=Object.keys(zh);for(let r=s.length,a=0;a<r;a++)i[s[a]]={distance:-1,parent:null};return i}(),e=[n];for(t[n].distance=0;e.length;){const i=e.pop(),s=Object.keys(zh[i]);for(let r=s.length,a=0;a<r;a++){const o=s[a],l=t[o];l.distance===-1&&(l.distance=t[i].distance+1,l.parent=i,e.unshift(o))}}return t}function ow(n,t){return function(e){return t(n(e))}}function lw(n,t){const e=[t[n].parent,n];let i=zh[t[n].parent][n],s=t[n].parent;for(;t[s].parent;)e.unshift(t[s].parent),i=ow(zh[t[s].parent][s],i),s=t[s].parent;return i.conversion=e,i}const zd=av,hw=function(n){const t=aw(n),e={},i=Object.keys(t);for(let s=i.length,r=0;r<s;r++){const a=i[r];t[a].parent!==null&&(e[a]=lw(a,t))}return e},Jr={};Object.keys(zd).forEach(n=>{Jr[n]={},Object.defineProperty(Jr[n],"channels",{value:zd[n].channels}),Object.defineProperty(Jr[n],"labels",{value:zd[n].labels});const t=hw(n);Object.keys(t).forEach(e=>{const i=t[e];Jr[n][e]=function(s){const r=function(...a){const o=a[0];if(o==null)return o;o.length>1&&(a=o);const l=s(a);if(typeof l=="object")for(let h=l.length,c=0;c<h;c++)l[c]=Math.round(l[c]);return l};return"conversion"in s&&(r.conversion=s.conversion),r}(i),Jr[n][e].raw=function(s){const r=function(...a){const o=a[0];return o==null?o:(o.length>1&&(a=o),s(a))};return"conversion"in s&&(r.conversion=s.conversion),r}(i)})});var cw=Jr;const Kr=tv.exports,li=cw,ov=["keyword","gray","hex"],Ud={};for(const n of Object.keys(li))Ud[[...li[n].labels].sort().join("")]=n;const Uh={};function Ee(n,t){if(!(this instanceof Ee))return new Ee(n,t);if(t&&t in ov&&(t=null),t&&!(t in li))throw new Error("Unknown model: "+t);let e,i;if(n==null)this.model="rgb",this.color=[0,0,0],this.valpha=1;else if(n instanceof Ee)this.model=n.model,this.color=[...n.color],this.valpha=n.valpha;else if(typeof n=="string"){const s=Kr.get(n);if(s===null)throw new Error("Unable to parse color from string: "+n);this.model=s.model,i=li[this.model].channels,this.color=s.value.slice(0,i),this.valpha=typeof s.value[i]=="number"?s.value[i]:1}else if(n.length>0){this.model=t||"rgb",i=li[this.model].channels;const s=Array.prototype.slice.call(n,0,i);this.color=Fd(s,i),this.valpha=typeof n[i]=="number"?n[i]:1}else if(typeof n=="number")this.model="rgb",this.color=[n>>16&255,n>>8&255,255&n],this.valpha=1;else{this.valpha=1;const s=Object.keys(n);"alpha"in n&&(s.splice(s.indexOf("alpha"),1),this.valpha=typeof n.alpha=="number"?n.alpha:0);const r=s.sort().join("");if(!(r in Ud))throw new Error("Unable to parse color from object: "+JSON.stringify(n));this.model=Ud[r];const{labels:a}=li[this.model],o=[];for(e=0;e<a.length;e++)o.push(n[a[e]]);this.color=Fd(o)}if(Uh[this.model])for(i=li[this.model].channels,e=0;e<i;e++){const s=Uh[this.model][e];s&&(this.color[e]=s(this.color[e]))}this.valpha=Math.max(0,Math.min(1,this.valpha)),Object.freeze&&Object.freeze(this)}Ee.prototype={toString(){return this.string()},toJSON(){return this[this.model]()},string(n){let t=this.model in Kr.to?this:this.rgb();t=t.round(typeof n=="number"?n:1);const e=t.valpha===1?t.color:[...t.color,this.valpha];return Kr.to[t.model](e)},percentString(n){const t=this.rgb().round(typeof n=="number"?n:1),e=t.valpha===1?t.color:[...t.color,this.valpha];return Kr.to.rgb.percent(e)},array(){return this.valpha===1?[...this.color]:[...this.color,this.valpha]},object(){const n={},{channels:t}=li[this.model],{labels:e}=li[this.model];for(let i=0;i<t;i++)n[e[i]]=this.color[i];return this.valpha!==1&&(n.alpha=this.valpha),n},unitArray(){const n=this.rgb().color;return n[0]/=255,n[1]/=255,n[2]/=255,this.valpha!==1&&n.push(this.valpha),n},unitObject(){const n=this.rgb().object();return n.r/=255,n.g/=255,n.b/=255,this.valpha!==1&&(n.alpha=this.valpha),n},round(n){return n=Math.max(n||0,0),new Ee([...this.color.map(uw(n)),this.valpha],this.model)},alpha(n){return n!==void 0?new Ee([...this.color,Math.max(0,Math.min(1,n))],this.model):this.valpha},red:he("rgb",0,ye(255)),green:he("rgb",1,ye(255)),blue:he("rgb",2,ye(255)),hue:he(["hsl","hsv","hsl","hwb","hcg"],0,n=>(n%360+360)%360),saturationl:he("hsl",1,ye(100)),lightness:he("hsl",2,ye(100)),saturationv:he("hsv",1,ye(100)),value:he("hsv",2,ye(100)),chroma:he("hcg",1,ye(100)),gray:he("hcg",2,ye(100)),white:he("hwb",1,ye(100)),wblack:he("hwb",2,ye(100)),cyan:he("cmyk",0,ye(100)),magenta:he("cmyk",1,ye(100)),yellow:he("cmyk",2,ye(100)),black:he("cmyk",3,ye(100)),x:he("xyz",0,ye(95.047)),y:he("xyz",1,ye(100)),z:he("xyz",2,ye(108.833)),l:he("lab",0,ye(100)),a:he("lab",1),b:he("lab",2),keyword(n){return n!==void 0?new Ee(n):li[this.model].keyword(this.color)},hex(n){return n!==void 0?new Ee(n):Kr.to.hex(this.rgb().round().color)},hexa(n){if(n!==void 0)return new Ee(n);const t=this.rgb().round().color;let e=Math.round(255*this.valpha).toString(16).toUpperCase();return e.length===1&&(e="0"+e),Kr.to.hex(t)+e},rgbNumber(){const n=this.rgb().color;return(255&n[0])<<16|(255&n[1])<<8|255&n[2]},luminosity(){const n=this.rgb().color,t=[];for(const[e,i]of n.entries()){const s=i/255;t[e]=s<=.04045?s/12.92:((s+.055)/1.055)**2.4}return .2126*t[0]+.7152*t[1]+.0722*t[2]},contrast(n){const t=this.luminosity(),e=n.luminosity();return t>e?(t+.05)/(e+.05):(e+.05)/(t+.05)},level(n){const t=this.contrast(n);return t>=7?"AAA":t>=4.5?"AA":""},isDark(){const n=this.rgb().color;return(2126*n[0]+7152*n[1]+722*n[2])/1e4<128},isLight(){return!this.isDark()},negate(){const n=this.rgb();for(let t=0;t<3;t++)n.color[t]=255-n.color[t];return n},lighten(n){const t=this.hsl();return t.color[2]+=t.color[2]*n,t},darken(n){const t=this.hsl();return t.color[2]-=t.color[2]*n,t},saturate(n){const t=this.hsl();return t.color[1]+=t.color[1]*n,t},desaturate(n){const t=this.hsl();return t.color[1]-=t.color[1]*n,t},whiten(n){const t=this.hwb();return t.color[1]+=t.color[1]*n,t},blacken(n){const t=this.hwb();return t.color[2]+=t.color[2]*n,t},grayscale(){const n=this.rgb().color,t=.3*n[0]+.59*n[1]+.11*n[2];return Ee.rgb(t,t,t)},fade(n){return this.alpha(this.valpha-this.valpha*n)},opaquer(n){return this.alpha(this.valpha+this.valpha*n)},rotate(n){const t=this.hsl();let e=t.color[0];return e=(e+n)%360,e=e<0?360+e:e,t.color[0]=e,t},mix(n,t){if(!n||!n.rgb)throw new Error('Argument to "mix" was not a Color instance, but rather an instance of '+typeof n);const e=n.rgb(),i=this.rgb(),s=t===void 0?.5:t,r=2*s-1,a=e.alpha()-i.alpha(),o=((r*a==-1?r:(r+a)/(1+r*a))+1)/2,l=1-o;return Ee.rgb(o*e.red()+l*i.red(),o*e.green()+l*i.green(),o*e.blue()+l*i.blue(),e.alpha()*s+i.alpha()*(1-s))}};for(const n of Object.keys(li)){if(ov.includes(n))continue;const{channels:t}=li[n];Ee.prototype[n]=function(...e){return this.model===n?new Ee(this):e.length>0?new Ee(e,n):new Ee([...(i=li[this.model][n].raw(this.color),Array.isArray(i)?i:[i]),this.valpha],n);var i},Ee[n]=function(...e){let i=e[0];return typeof i=="number"&&(i=Fd(e,t)),new Ee(i,n)}}function uw(n){return function(t){return function(e,i){return Number(e.toFixed(i))}(t,n)}}function he(n,t,e){n=Array.isArray(n)?n:[n];for(const i of n)(Uh[i]||(Uh[i]=[]))[t]=e;return n=n[0],function(i){let s;return i!==void 0?(e&&(i=e(i)),s=this[n](),s.color[t]=i,s):(s=this[n]().color[t],e&&(s=e(s)),s)}}function ye(n){return function(t){return Math.max(0,Math.min(n,t))}}function Fd(n,t){for(let e=0;e<t;e++)typeof n[e]!="number"&&(n[e]=0);return n}const dw=Ee;function Kn(n){if(!n)return new Ot;if(n.isColor)return[n.r,n.g,n.b,1];const t=sn(n);return new Ot(t[0],t[1],t[2],t[3])}function sn(n){if(!n)return[1,1,1,1];const t=dw(n),e=t.unitArray();return[e[0],e[1],e[2],e[3]||t.valpha]}const pw=Object.freeze(Object.defineProperty({__proto__:null,colorToVec4:Kn,colorToVec3:function(n){if(!n)return new S;const t=sn(n);return new S(t[0],t[1],t[2])},colorToArr4:sn},Symbol.toStringTag,{value:"Module"})),fo={mvt_emissive:{value:null},mvt_emissiveIntensity:{value:1}},Gi={selectedObjectColor:{value:[1,1,0,.5]},selectedObjectIndex:{value:-1},selectedObjectColorMode:{value:0}},Nd={keepSize:{value:!1},zoomUnits:{value:1}},Jt=(n,t=[])=>{for(let e of t)Object.defineProperty(n,e,{get:function(){return this.uniforms[e].value},set:function(i){this.uniforms[e].value=i}})},Qr=(n,t=[])=>{for(let e of t)Object.defineProperty(n,e,{get:function(){return this.uniforms[e].value},set:function(i){this.uniforms[e].value=Kn(i)}})},rn=(n,t=[])=>{for(let[e,i,s]of t)Object.defineProperty(n,e,{get:function(){return this.uniforms[i].value},set:function(r){this.uniforms[i].value=s?s(r):r}})},Ze=(n,t=[])=>{for(let[e,i]of t)Object.defineProperty(n,e,{get:function(){return!!this.defines[i]},set:function(s){this[e]!==s&&(s?this.defines[i]=!0:delete this.defines[i],this.needsUpdate=!0)}})},Qn=n=>{Object.defineProperties(n,{selectedObjectColor:{get:function(){return this.uniforms.selectedObjectColor.value},set:function(t){this.uniforms.selectedObjectColor.value=t}},selectedObjectColorMode:{get:function(){return this.uniforms.selectedObjectColorMode.value},set:function(t){this.uniforms.selectedObjectColorMode.value=t}},selectedObjectIndex:{get:function(){return this.uniforms.selectedObjectIndex.value},set:function(t){this.uniforms.selectedObjectIndex.value=t}},selective:{get:function(){return!!this.defines.MVT_ENABLE_SELECTIVE},set:function(t){this.selective!==t&&(t?this.defines.MVT_ENABLE_SELECTIVE=!0:delete this.defines.MVT_ENABLE_SELECTIVE,this.needsUpdate=!0)}}})},kd=n=>{Object.defineProperties(n,{keepSize:{get:function(){return this.uniforms.keepSize.value},set:function(t){this.uniforms.keepSize.value=t}},zoomUnits:{get:function(){return this.uniforms.zoomUnits.value},set:function(t){this.uniforms.zoomUnits.value=t}},zoomUnitsUniform:{get:function(){return this.uniforms.zoomUnits},set:function(t){this.uniforms.zoomUnits=t}}})},go=n=>{Object.defineProperties(n,{emissiveEnabled:{get:function(){return this.defines.MVT_EMISSIVE_UNIFORM||!1},set:function(t){t?this.defines.MVT_EMISSIVE_UNIFORM=!0:delete this.defines.MVT_EMISSIVE_UNIFORM}},emissive:{get:function(){return this.uniforms.mvt_emissive.value},set:function(t){t?this.defines.MVT_EMISSIVE_COLOR=!0:delete this.defines.MVT_EMISSIVE_COLOR,this.uniforms.mvt_emissive.value=t}},emissiveIntensity:{get:function(){return this.uniforms.mvt_emissiveIntensity.value},set:function(t){this.uniforms.mvt_emissiveIntensity.value=t}}})},lv=n=>{const t=n&&n.source&&n.source.data&&n.source.data.height||null;if(t===null)return null;const e=Math.log2(t)-2,i=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,e),112)),texelHeight:i,maxMip:e}},mw={tDiffuse:{value:null},tNormal:{value:null},tMetalness:{value:null},tEnhancement:{value:null},tEnhancementScale:{value:new V(20,20)},tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null},resolution:{value:new V},cameraProjectionMatrix:{value:new at},cameraInverseProjectionMatrix:{value:new at},mvt_viewInverseMatrix:{value:new at},mvt_normalInverseMatrix:{value:new De},opacity:{value:.5},maxDistance:{value:180},cameraRange:{value:0},thickness:{value:.018},logDepthBufFC:{value:1},threshold:{value:.35}};class fw extends Qt{constructor(t){super(),this.vertexShader=`#define GLSLIFY 1
varying vec2 vUv;

void main() {

    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}`,this.fragmentShader=`precision highp sampler2D;
#define GLSLIFY 1
varying vec2 vUv;
uniform sampler2D tDepth;
uniform sampler2D tNormal;
uniform sampler2D tMetalness;
uniform sampler2D tDiffuse;

#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)
uniform sampler2D tEnhancement;
uniform vec2 tEnhancementScale;
uniform mat4 mvt_viewInverseMatrix;
uniform mat3 mvt_normalInverseMatrix;
#endif

uniform float cameraRange;
uniform vec2 resolution;
uniform float opacity;
uniform float cameraNear;
uniform float cameraFar;
uniform float maxDistance;
uniform float thickness;
uniform mat4 cameraProjectionMatrix;
uniform mat4 cameraInverseProjectionMatrix;
uniform float threshold; // 控制反射最低阈值，低于此致的不计算，可提高性能

#include <packing>
float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
    //x0: point, x1: linePointA, x2: linePointB
    //https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
    return length(cross(x0 - x1, x0 - x2)) / length(x2 - x1);
}
float pointPlaneDistance(vec3 point, vec3 planePoint, vec3 planeNormal) {
    // https://mathworld.wolfram.com/Point-PlaneDistance.html
    //// https://en.wikipedia.org/wiki/Plane_(geometry)
    //// http://paulbourke.net/geometry/pointlineplane/
    float a = planeNormal.x, b = planeNormal.y, c = planeNormal.z;
    float x0 = point.x, y0 = point.y, z0 = point.z;
    float x = planePoint.x, y = planePoint.y, z = planePoint.z;
    float d = -(a * x + b * y + c * z);
    float distance = (a * x0 + b * y0 + c * z0 + d) / sqrt(a * a + b * b + c * c);
    return distance;
}
// https://stackoverflow.com/questions/40373184/world-space-position-from-logarithmic-depth-buffer
float linearize_depth(in float depth) {
    float a = cameraFar / (cameraFar - cameraNear);
    float b = cameraFar * cameraNear / (cameraNear - cameraFar);
    return a + b / depth;
}

float reconstruct_depth(const in vec2 uv) {
    float depth = texture2D(tDepth, uv).x;
    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
}

float getDepth(const in vec2 uv) {
    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
    return linearize_depth(reconstruct_depth(uv)); //exp2(logDepth * 2.0 / logDepthBufFC) - 1.0;
    #else
    return texture2D(tDepth, uv).x;
    #endif

}
float getViewZ(const in float depth) {
    #ifdef PERSPECTIVE_CAMERA
    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
    #else
    return orthographicDepthToViewZ(depth, cameraNear, cameraFar);
    #endif
}
vec3 getViewPosition(const in vec2 uv, const in float depth/*clip space*/, const in float clipW) {
    vec4 clipPosition = vec4((vec3(uv, depth) - 0.5) * 2.0, 1.0);//ndc
    clipPosition *= clipW; //clip
    return (cameraInverseProjectionMatrix * clipPosition).xyz;//view
}
#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)
vec3 getWorldPositionFromDepth(float depth) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(vUv * 2.0 - 1.0, z, 1.0);
    vec4 viewSpacePosition = cameraInverseProjectionMatrix * clipSpacePosition;
    vec4 worldSpacePosition = mvt_viewInverseMatrix * viewSpacePosition;
    return worldSpacePosition.xyz / worldSpacePosition.w;
}
#endif
vec3 getViewNormal(const in vec2 uv) {
    return unpackRGBToNormal(texture2D(tNormal, uv).xyz);
}
vec2 viewPositionToXY(vec3 viewPosition) {
    vec2 xy;
    vec4 clip = cameraProjectionMatrix * vec4(viewPosition, 1);
    xy = clip.xy;//clip
    float clipW = clip.w;
    xy /= clipW;//NDC
    xy = (xy + 1.) / 2.;//uv
    xy *= resolution;//screen
    return xy;
}
void main() {

    float depth = getDepth(vUv);
    vec3 viewNormal = getViewNormal(vUv);
    #ifdef SELECTIVE
    // 完全没反射的表面直接剔除
    float intensity = texture2D(tMetalness, vUv).x;

    #if defined(MVT_SSR_USE_ENHANCEMENT_MAP)
        float dirAlpha = dot(viewNormal * mvt_normalInverseMatrix, vec3(0.0, 0.0, 1.0));
        if (dirAlpha > 0.5) {
            vec3 worldSpacePosition = getWorldPositionFromDepth(depth);
            vec2 enhancementUv = vec2(mod(worldSpacePosition.x, tEnhancementScale.x) / tEnhancementScale.x, 
                    mod(worldSpacePosition.y, tEnhancementScale.y) / tEnhancementScale.y);
            float enhancement = texture2D(tEnhancement, enhancementUv).x;
            intensity += (1.0 - enhancement);
        }
        // gl_FragColor = vec4(enhancement, 0.0, 0.0, 1.0);
        // return;
    #endif

    if(intensity < threshold)
        return;
    intensity -= threshold;
    intensity *= 1.0 / (1.0 - threshold);
    #endif

    
    float viewZ = getViewZ(depth);
    // z值已经超过相机远端距离
    if(-viewZ >= cameraFar)
        return;

    float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
    // 相机视图下的当前片元坐标
    vec3 viewPosition = getViewPosition(vUv, depth, clipW);

    // 起点的屏幕坐标
    vec2 d0 = gl_FragCoord.xy;
    vec2 d1;

    #ifdef PERSPECTIVE_CAMERA
    // 入射光方向，相机在原点，方向即为坐标的单位向量
    vec3 viewIncidentDir = normalize(viewPosition);
    // 反射光方向
    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);
    #else
    vec3 viewIncidentDir = vec3(0, 0, -1);
    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);
    #endif

    // 反射光线最长距离由输入的最大反射距离和入射角决定
    float maxReflectRayLen = maxDistance / dot(-viewIncidentDir, viewNormal);
    // dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
    // if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
    // maxDistance/maxReflectRayLen=cos(theta)
    // maxDistance/maxReflectRayLen==dot(a,b)
    // maxReflectRayLen==maxDistance/dot(a,b)

    // 反射最远距离下的坐标点
    vec3 d1viewPosition = viewPosition + viewReflectDir * maxReflectRayLen;
    #ifdef PERSPECTIVE_CAMERA
    if(d1viewPosition.z > -cameraNear) {
            //https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
        // 应该是处理反射点溢出相机视野外的情况
        float t = (-cameraNear - viewPosition.z) / viewReflectDir.z;
        d1viewPosition = viewPosition + viewReflectDir * t;
    }
    #endif
    // 反射最远点在屏幕上的位置
    d1 = viewPositionToXY(d1viewPosition);

    // 屏幕像素距离
    float totalLen = length(d1 - d0);
    float xLen = d1.x - d0.x;
    float yLen = d1.y - d0.y;
    // 最大步数取xy方向较大的一个方向，每次步进一个像素
    float totalStep = max(abs(xLen), abs(yLen));
    // x方向每次步进的大小
    float xSpan = xLen / totalStep;
    // y方向每次步进的大小
    float ySpan = yLen / totalStep;
    // 步进次数最大是屏幕对角线距离（应该是横向或者纵向的最大值），实际次数要远小于这个
    for(float i = 0.; i < float(MAX_STEP); i++) {
        if(i >= totalStep)
            break;
        // march到的当前屏幕像素
        vec2 xy = vec2(d0.x + i * xSpan, d0.y + i * ySpan);
        // 跑到屏幕外march失败
        if(xy.x < 0. || xy.x > resolution.x || xy.y < 0. || xy.y > resolution.y)
            break;
        // 当前百分比
        float s = length(xy - d0) / totalLen;
        // 当前uv
        vec2 uv = xy / resolution;
        // 计算当前点的各项参数，和一开始一样
        float d = getDepth(uv);
        float vZ = getViewZ(d);
        // gl_FragColor = vec4(-vZ / 1000., 0.0, 0.0, 1.0);
        // return;
        if(-vZ >= cameraFar)
            continue;
        float cW = cameraProjectionMatrix[2][3] * vZ + cameraProjectionMatrix[3][3];
        // 得到当前点的viewposition
        vec3 vP = getViewPosition(uv, d, cW);

        // 得到当前反射线的z
        #ifdef PERSPECTIVE_CAMERA
            // https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
        float recipVPZ = 1. / viewPosition.z;
        float viewReflectRayZ = 1. / (recipVPZ + s * (1. / d1viewPosition.z - recipVPZ));
        #else
        float viewReflectRayZ = viewPosition.z + s * (d1viewPosition.z - viewPosition.z);
        #endif

        // if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.
        // https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164
        // 反射线的z小于当前点的z,否则就是被遮挡住了
        if(viewReflectRayZ <= vZ) {

            bool hit;
            #ifdef INFINITE_THICK
            hit = true;
            #else
            // 点到射线的距离
            float away = pointToLineDistance(vP, viewPosition, d1viewPosition);

            // minThickness没看懂，和横向邻接点的viewx差值，大约代表了此处一个像素和实际距离的比例，乘3.0？
            float minThickness;
            vec2 xyNeighbor = xy;
            xyNeighbor.x += 1.;
            vec2 uvNeighbor = xyNeighbor / resolution;
            vec3 vPNeighbor = getViewPosition(uvNeighbor, d, cW);
            minThickness = vPNeighbor.x - vP.x;
            minThickness *= 3.;
            float tk = max(minThickness, thickness);
            // 当距离小于阈值时才算是真正相交
            hit = away <= tk;
            #endif

            if(hit) {
                vec3 vN = getViewNormal(uv);
                // 相交到物体的反面了，march无效
                if(dot(viewReflectDir, vN) >= 0.)
                    continue;
                float distance = pointPlaneDistance(vP, viewPosition, viewNormal);
                // march距离超过最大
                if(distance > maxDistance)
                    break;
                float op = opacity;
                // 随着距离减弱反射，防止反射突然消失
                #ifdef DISTANCE_ATTENUATION
                float ratio = 1. - (distance / maxDistance);
                float attenuation = ratio * ratio;
                op = opacity * attenuation;
                #endif
                // 菲涅尔反射定律，与视野角度偏离越大，颜色权重越大
                #ifdef FRESNEL
                float fresnelCoe = (dot(viewIncidentDir, viewReflectDir) + 1.) / 2.;
                op *= fresnelCoe;
                #endif
                // 读取反射颜色赋给当前片元
                vec4 reflectColor = texture2D(tDiffuse, uv);
                gl_FragColor.xyz = reflectColor.xyz;
                gl_FragColor.a = op;
                #ifdef SELECTIVE
                gl_FragColor.a *= intensity;
                #endif
                break;
            }
        }
    }
}`,this.uniforms=ft.clone(mw),this.defines={MAX_STEP:0,PERSPECTIVE_CAMERA:!0,DISTANCE_ATTENUATION:!0,FRESNEL:!0,INFINITE_THICK:!1,SELECTIVE:!1},Jt(this,["tDiffuse","tNormal","tDepth","tMetalness","cameraNear","cameraFar","threshold","thickness","opacity","tEnhancementScale"]),Ze(this,[]),Object.defineProperties(this,{tEnhancement:{get:function(){return this.uniforms.tEnhancement.value},set:function(e){e?(this.uniforms.tEnhancement.value=e,this.defines.MVT_SSR_USE_ENHANCEMENT_MAP=!0):(this.uniforms.tEnhancement.value=null,delete this.defines.MVT_SSR_USE_ENHANCEMENT_MAP)}}}),this.setValues(t)}dispose(){let t=["tEnhancement","tDiffuse","tNormal","tDepth","tMetalness","tEnhancementScale"];for(let e=0;e<t.length;e++){const i=t[e];this.uniforms[i]&&this.uniforms[i].value&&this.uniforms[i].value.dispose()}super.dispose()}}class gw extends Id{constructor(t,{tDiffuse:e,tDepth:i,tNormal:s,tMetalness:r,resolution:a}){super();const o=this.material=new fw;o.uniforms.tDiffuse.value=e,o.uniforms.tDepth.value=i,o.uniforms.tNormal.value=s,o.uniforms.tMetalness.value=r,o.uniforms.resolution.value=a,o.defines.MAX_STEP=Math.sqrt(a.x*a.x+a.y*a.y),o.defines.DISTANCE_ATTENUATION=!0,o.defines.SELECTIVE=!0,this.renderTarget=t,this.fsQuad=new co(null)}render(t,e){const i=this.material;i.uniforms.cameraProjectionMatrix.value.copy(e.projectionMatrix),i.uniforms.cameraInverseProjectionMatrix.value.copy(e.projectionMatrixInverse),i.uniforms.mvt_viewInverseMatrix.value.copy(e.matrixWorld),i.uniforms.mvt_normalInverseMatrix.value.getNormalMatrix(e.matrixWorldInverse),i.uniforms.cameraNear.value=e.near,i.uniforms.cameraFar.value=e.far,this.fsQuad.material=i,t.setRenderTarget(this.renderTarget),this.fsQuad.render(t)}dispose(){this.material.dispose(),this.fsQuad.dispose()}}class vw{constructor(t){g(this,"_rendering"),g(this,"_enabled",!1),g(this,"_renderPass",null),g(this,"_threshold",.5),g(this,"_thickness",.018),g(this,"_opacity",.5),g(this,"_useMrt",!1),this._rendering=t}get useMrt(){return this._useMrt}set useMrt(t){t!==this._useMrt&&(this._useMrt=t,t||this.dispose())}set enabled(t){(t=!!t)!==this._enabled&&(this._enabled=t,t||this.dispose())}get enabled(){return this._enabled}_init(){const t=this._rendering,e=t.resolution,i=this._ssrRenderTarget=new Yt(e.x,e.y,{encoding:t.outputEncoding}),s=this._renderPass=new gw(i,{tDiffuse:t.main.tDiffuse,tNormal:t.main.tNormal,tMetalness:t.main.tSpecular,tDepth:t.main.tDepth,resolution:e});s.material.threshold=this._threshold,s.material.thickness=this._thickness,s.material.opacity=this._opacity,t.composition.tReflection=i.texture,console.log("ssr init")}render(){if(!this._enabled||!this._useMrt)return;this._enabled&&!this._renderPass&&this._init();const t=this._rendering;this._renderPass.render(t.renderer,t.camera)}dispose(){this._rendering.composition.tReflection=null,this._renderPass&&(this._renderPass.dispose(),this._renderPass=null),this._ssrRenderTarget&&(this._ssrRenderTarget.dispose(),this._ssrRenderTarget=null)}getTextures(){const t=[];return this._ssrRenderTarget&&t.push(this._ssrRenderTarget.texture),t}setSize(t,e){this._ssrRenderTarget&&this._ssrRenderTarget.setSize(t,e)}get tReflection(){return this._ssrRenderTarget&&this._ssrRenderTarget.texture||null}get threshold(){return this._threshold}set threshold(t){this._threshold=t,this._renderPass&&(this._renderPass.material.threshold=t)}get thickness(){return this._thickness}set thickness(t){this._thickness=t,this._renderPass&&(this._renderPass.material.thickness=t)}get opacity(){return this._opacity}set opacity(t){this._opacity=t,this._renderPass&&(this._renderPass.material.opacity=t)}set tEnhancement(t){this._renderPass&&(this._renderPass.material.tEnhancement=t)}get tEnhancement(){return this._renderPass?this._renderPass.material.tEnhancement:null}set tEnhancementScale(t){this._renderPass&&(this._renderPass.material.tEnhancementScale=t)}get tEnhancementScale(){return this._renderPass?this._renderPass.material.tEnhancementScale:null}}const _w={tDiffuse:{value:null},tBloom:{value:null},tNormal:{value:null},tReflection:{value:null},tDepth:{value:null},tEnv:{value:null},tCount:{value:0},tDebug1:{value:null},tDebug2:{value:null},tDebug3:{value:null},tDebug4:{value:null},debugDimension:{value:new V(.25,.2)},debugOffset:{value:new V(0,0)},mvt_normalInverseMatrix:{value:new De},mvt_projectionInverseMatrix:{value:new at},mvt_viewInverseMatrix:{value:new at},mvt_projectionMatrix:{value:new at},coverageColor:{value:new nt(16777215)},coverageSacle:{value:new V(20,20)},coverageIntensity:{value:0},tCoverageIntensity:{value:null},resolution:{value:[1,1]},cameraNear:{value:1},cameraFar:{value:100},logDepthBufFC:{value:1},fogColor:{value:new nt(16777215)},fogDensity:{value:1},fogAltitudeBottom:{value:0},fogAltitudeTop:{value:1e3},fogSkyColorStartFactor:{value:.3},adjustBrightnessFactor:{value:0},adjustContrastFactor:{value:0},adjustSaturationFactor:{value:0}};class yw extends Qt{constructor(t){super(),this.vertexShader=`#define GLSLIFY 1
// attribute vec3 position;
// attribute vec2 uv;
varying vec2 vUv;
// uniform mat4 modelViewMatrix;
// uniform mat4 projectionMatrix;
void main() {

    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}`,this.fragmentShader=`precision highp float;
precision highp int;
#define GLSLIFY 1

#include <common>
#include <packing>
#include <cube_uv_reflection_fragment>

uniform sampler2D tDiffuse;
uniform sampler2D tNormal;
uniform sampler2D tDepth;

#if defined(MVT_POST_ENABLE_BLOOM)
    uniform sampler2D tBloom;
#endif

#if defined(MVT_POST_ENABLE_REFLECTION)
    uniform sampler2D tReflection;
#endif

#if defined(MVT_POST_ENABLE_COVERAGE)
    #if defined(MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP)
        uniform sampler2D tCoverageIntensity; 
    #endif
    uniform vec2 coverageSacle;
    uniform float coverageIntensity;
    // 覆盖层颜色
    uniform vec3 coverageColor;
#endif

// 加前缀防止被three.js本身变量覆盖
uniform float cameraNear;
uniform float cameraFar;
uniform mat3 mvt_normalInverseMatrix;
uniform mat4 mvt_projectionMatrix;
uniform mat4 mvt_projectionInverseMatrix;
uniform mat4 mvt_viewInverseMatrix;

#if defined(MVT_POST_USE_FOG)
    uniform vec3 fogColor;
    uniform float fogDensity;
    uniform float fogSkyColorStartFactor;
    uniform float fogAltitudeBottom;
    uniform float fogAltitudeTop;
#endif

#if defined(ENVMAP_TYPE_CUBE_UV)
    uniform sampler2D tEnv;
#elif defined(ENVMAP_TYPE_CUBE)
    uniform samplerCube tEnv;
#endif

#ifdef MVT_POST_ENABLE_COLOR_ADJUST
    uniform float adjustBrightnessFactor;
    uniform float adjustContrastFactor; 
    uniform float adjustSaturationFactor; 
#endif

#ifdef MVT_MRT_POST_DEBUG
    uniform vec2 debugDimension;
    uniform vec2 debugOffset;
    uniform int tCount;
    uniform sampler2D tDebug1;
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 1
        uniform sampler2D tDebug2;
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 2
        uniform sampler2D tDebug3;
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 3
        uniform sampler2D tDebug4;
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 4
        uniform sampler2D tDebug5;
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 5
        uniform sampler2D tDebug6;
    #endif
#endif

varying vec2 vUv;

float linearize_depth(in float depth){
    float a = cameraFar / (cameraFar - cameraNear);
    float b = cameraFar * cameraNear / (cameraNear - cameraFar);
    return a + b / depth;
}

float reconstruct_depth(const in vec2 uv){
    float depth = texture2D(tDepth, uv).x;
    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
}

float getDepth(vec2 uv) {
    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
        return linearize_depth(reconstruct_depth(uv));
    #else
        return texture2D(tDepth, uv).x;
    #endif
}
vec3 getWorldPositionFromDepth(float depth) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(vUv * 2.0 - 1.0, z, 1.0);

    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];
    // clipSpacePosition *= clipW;
    vec4 viewSpacePosition = mvt_projectionInverseMatrix * clipSpacePosition;
    
    // viewSpacePosition /= viewSpacePosition.w;
    // return viewSpacePosition.xyz;
    vec4 worldSpacePosition = mvt_viewInverseMatrix * viewSpacePosition;

    return worldSpacePosition.xyz / worldSpacePosition.w;
}

float getNoramlLength(vec3 normal) {
    if (normal.x < 0. || normal.y < 0. || normal.z < 0.) {
        return 0.;
    }
    return length(normal);
}
void renderOutputColor() {
    vec4 outColor = texture2D(tDiffuse, vUv);

    // bloom
    #if defined(MVT_POST_ENABLE_BLOOM)
    outColor += vec4( 1.0 ) * texture2D(tBloom, vUv);
    #endif

    // reflection
    #if defined(MVT_POST_ENABLE_REFLECTION)
    vec4 reflectionColor = texture2D( tReflection, vUv );
    outColor.xyz = mix(outColor.xyz, reflectionColor.xyz, reflectionColor.w);
    #endif

    vec4 viewNormal = texture2D(tNormal, vUv);
    vec3 normal = unpackRGBToNormal(viewNormal.xyz);
    float normalLength = getNoramlLength(normal);
    
    #if (defined(MVT_POST_ENABLE_COVERAGE) && defined(MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP)) || defined(MVT_POST_USE_FOG)
        float depth = getDepth(vUv);
        vec3 worldSpacePosition = getWorldPositionFromDepth(depth);
    #endif

    #if defined(MVT_POST_ENABLE_COVERAGE)
    if (coverageIntensity > 0.0 && normalLength > 0.5) {
        float dirAlpha = dot(normal * mvt_normalInverseMatrix, vec3(0.0, 0.0, 1.0));
        if (dirAlpha > 0.2) {
            float coverageAlpha = clamp(0.0, 1.0, dirAlpha) * coverageIntensity;
            vec3 coverageFinalColor = vec3(coverageColor);
            #if defined(MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP)
                
                vec2 coverageUv = vec2(mod(worldSpacePosition.x, coverageSacle.x) / coverageSacle.x, 
                    mod(worldSpacePosition.y, coverageSacle.y) / coverageSacle.y);
                coverageAlpha *= texture2D(tCoverageIntensity, coverageUv).x;
            #endif
            // outColor.xyz = vec3(coverageAlpha, 0.0, 0.0);
            outColor.xyz = mix(outColor.xyz, coverageFinalColor, coverageAlpha);
        }
    }
    #endif

    #if defined(MVT_POST_USE_FOG)
        float fogDepth = texture2D(tDepth, vUv).x;
        float fogHeight = fogAltitudeTop - fogAltitudeBottom;
        float fogHeightRatio = (clamp(worldSpacePosition.z, fogAltitudeBottom, fogAltitudeTop) - fogAltitudeBottom) / fogHeight;
        // 混合大气雾，只混合除去天空的部分
        if (normalLength > 0.1) {
            #if defined(ENVMAP_TYPE_CUBE_UV) || defined(ENVMAP_TYPE_CUBE)
                vec3 worldViewDir = normalize(worldSpacePosition.xyz - mvt_viewInverseMatrix[3].xyz);
                // worldViewDir.z = clamp(worldSpacePosition.z / 1000.0, 0.0, 0.2);
                // worldViewDir = reflect(worldViewDir, vec3(0.0, 0.0, 1.0));
                #if defined(ENVMAP_TYPE_CUBE_UV)
                    vec3 skyColor = textureCubeUV(tEnv, worldViewDir, 0.0).xyz;
                #else
                    vec3 skyColor = textureCube(tEnv, worldViewDir).xyz;
                #endif
                float skyColorDepth = 1.0 - fogSkyColorStartFactor;
                float skyColrFactor = clamp(fogDepth - fogSkyColorStartFactor, 0.0, skyColorDepth) / skyColorDepth;
                skyColrFactor = skyColrFactor * skyColrFactor * skyColrFactor;
                skyColrFactor *= 1.0 - fogHeightRatio;
                outColor.xyz = mix(outColor.xyz, skyColor, skyColrFactor);

                // outColor.xyz = vec3(abs(normal.xyz)); //vec3(0.0, 0.0, normalLength);
                // outColor.xyz = vec3(mod(worldSpacePosition.x, 1000.0), mod(worldSpacePosition.y, 1000.0), 0.0);
                // outColor.xyz = skyColor;
                // skyColor = vec3(0.0, 0.0, 1.0);
                // outColor.xyz = vec3(clamp(fogDepth - 0.95, 0.0, 0.05) * 20.0, 0.0, 0.0);
                // fogCompseColor = mix(fogColor, skyColor, clamp(fogDepth - 0.5, 0.0, 0.5) * 2.0);
                // fogCompseColor = mix(fogCompseColor, fogColor, clamp(fogDensity - 0.5, 0.0, 1.0));
            #endif
        }
        float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
        // fogFactor *= clamp(worldSpacePosition.z, 1.0, 0.0);
        // 高度衰减系数
        float heightAttenuation = fogHeightRatio;
        heightAttenuation = clamp(heightAttenuation - (fogDensity - 0.5), 0.0, 1.0);
        fogFactor = clamp(fogFactor - heightAttenuation, 0.0, 1.0);
        // vec3 fogCompseColor = vec3(fogColor);
        // #if defined(ENVMAP_TYPE_CUBE_UV) || defined(ENVMAP_TYPE_CUBE)
        //     vec3 worldViewDir = normalize(worldSpacePosition.xyz - mvt_viewInverseMatrix[3].xyz);
        //     worldViewDir.z = clamp(worldSpacePosition.z / 1000.0, 0.0, 0.2);
        //     // worldViewDir = reflect(worldViewDir, vec3(0.0, 0.0, 1.0));
        //     #if defined(ENVMAP_TYPE_CUBE_UV)
        //         vec3 skyColor = textureCubeUV(tEnv, worldViewDir, 0.0).xyz;
        //     #else
        //         vec3 skyColor = textureCube(tEnv, worldViewDir).xyz;
        //     #endif
        //     // skyColor = vec3(0.0, 0.0, 1.0);
        //     fogCompseColor = mix(fogColor, skyColor, clamp(fogDepth - 0.5, 0.0, 0.5) * 2.0);
        //     fogCompseColor = mix(fogCompseColor, fogColor, clamp(fogDensity - 0.5, 0.0, 1.0));
        // #endif
        
        // // outColor.xyz = skyColor;
        outColor.xyz = mix(outColor.xyz, fogColor, fogFactor);
    #endif

    #ifdef MVT_POST_ENABLE_COLOR_ADJUST
        // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance
        vec3 grayscale = vec3(dot(outColor.xyz,  vec3(0.2126, 0.7152, 0.0722)));
        outColor.xyz = mix(grayscale, outColor.xyz, 1.0 + adjustSaturationFactor);

        outColor.xyz = 0.5 + (1.0 + adjustContrastFactor) * (outColor.xyz - 0.5);
        outColor.xyz = outColor.xyz + adjustBrightnessFactor;
    #endif

    gl_FragColor = outColor;
}

#ifdef MVT_MRT_POST_DEBUG
void renderDebugColor(float u, float v) {
    vec4 color;
    
    if (u < 1.0) {
        color = texture2D(tDebug1, vec2(mod(u, 1.0), v));
    }
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 1
    else if (u < 2.0) {
        color = texture2D(tDebug2, vec2(mod(u, 1.0), v));
    }
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 2
    else if (u < 3.0) {
        color = texture2D(tDebug3, vec2(mod(u, 1.0), v));
    }
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 3
    else if (u < 4.0) {
        color = texture2D(tDebug4, vec2(mod(u, 1.0), v));
    }
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 4
    else if (u < 5.0) {
        color = texture2D(tDebug5, vec2(mod(u, 1.0), v));
    }
    #endif
    #if MVT_POST_DEBUG_TEXTURE_COUNT > 5
    else if (u < 6.0) {
        color = texture2D(tDebug6, vec2(mod(u, 1.0), v));
    }
    #endif

    gl_FragColor = color;
}
#endif

void main() {

    #ifdef MVT_MRT_POST_DEBUG
        float u = (debugOffset.x + vUv.x) / debugDimension.x;
        float v = (debugOffset.y + vUv.y) / debugDimension.y;
        if (v >= 0.0 && v <= 1.0 && u >= 0.0 && u <= 1.0 * float(tCount)) {
            renderDebugColor(u, v);
        }
        else {
            renderOutputColor();
        }
    #else
        renderOutputColor();
    #endif
    // #include <tonemapping_fragment>
    #include <encodings_fragment>
}`,this.uniforms=ft.clone(_w),this.defines={MVT_POST_ENABLE_BLOOM:!1,MVT_POST_DEBUG_TEXTURE_COUNT:0,MVT_POST_USE_FOG:!1,MVT_POST_ENABLE_COLOR_ADJUST:!1,CUBEUV_TEXEL_WIDTH:.0003255208333333333,CUBEUV_TEXEL_HEIGHT:.000244140625,CUBEUV_MAX_MIP:"10.0"},Jt(this,["tDiffuse","tNormal","tDepth","debugDimension","debugOffset","fogColor","fogDensity","fogAltitudeBottom","fogAltitudeTop","fogSkyColorStartFactor","adjustBrightnessFactor","adjustContrastFactor","adjustSaturationFactor"]),Object.defineProperties(this,{tBloom:{get:function(){return this.uniforms.tBloom.value},set:function(e){e?(this.uniforms.tBloom.value=e,this.defines.MVT_POST_ENABLE_BLOOM=!0):(this.uniforms.tBloom.value=null,delete this.defines.MVT_POST_ENABLE_BLOOM),this.needsUpdate=!0}},tReflection:{get:function(){return this.uniforms.tReflection.value},set:function(e){e?(this.uniforms.tReflection.value=e,this.defines.MVT_POST_ENABLE_REFLECTION=!0):(this.uniforms.tReflection.value=null,delete this.defines.MVT_POST_ENABLE_REFLECTION),this.needsUpdate=!0}},coverageIntensity:{get:function(){return this.uniforms.coverageIntensity.value},set:function(e){this.uniforms.coverageIntensity.value=e,e>0?this.defines.MVT_POST_ENABLE_COVERAGE=!0:delete this.defines.MVT_POST_ENABLE_COVERAGE,(e===0&&this._lastCoverageIntensity>0||e>0&&this._lastCoverageIntensity===0)&&(this.needsUpdate=!0),this._lastCoverageIntensity=e}},tCoverageIntensity:{get:function(){return this.uniforms.tCoverageIntensity.value},set:function(e){e?(this.uniforms.tCoverageIntensity.value=e,this.defines.MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP=!0):(this.uniforms.tCoverageIntensity.value=null,delete this.defines.MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP),this.needsUpdate=!0}},debugTextures:{get:function(){return null},set:function(e){if(Array.isArray(e)){this.defines.MVT_MRT_POST_DEBUG=!0;const i=e.length;this.uniforms.tCount.value=i,this.defines.MVT_POST_DEBUG_TEXTURE_COUNT=i,this.uniforms.tDebug1.value=e[0]||null,this.uniforms.tDebug2.value=e[1]||null,this.uniforms.tDebug3.value=e[2]||null,this.uniforms.tDebug4.value=e[3]||null}else delete this.defines.MVT_MRT_POST_DEBUG,this.defines.MVT_POST_DEBUG_TEXTURE_COUNT=0,this.uniforms.tCount.value=0,this.uniforms.tDebug1.value=null,this.uniforms.tDebug2.value=null,this.uniforms.tDebug3.value=null,this.uniforms.tDebug4.value=null;this.needsUpdate=!0}},useFog:{get:function(){return this.defines.MVT_POST_USE_FOG||!1},set:function(e){e!==!!this.defines.MVT_POST_USE_FOG&&(e?this.defines.MVT_POST_USE_FOG=!0:delete this.defines.MVT_POST_USE_FOG,this.needsUpdate=!0)}},tEnv:{get:function(){return this.uniforms.tEnv.value},set:function(e){if(e!==this.uniforms.tEnv.value){if(e)if(e.mapping===306){this.defines.ENVMAP_TYPE_CUBE_UV=!0,delete this.defines.ENVMAP_TYPE_CUBE;const i=lv(e);i&&(this.defines.CUBEUV_TEXEL_WIDTH=i.texelWidth,this.defines.CUBEUV_TEXEL_HEIGHT=i.texelHeight,this.defines.CUBEUV_MAX_MIP=i.maxMip+".0")}else this.defines.ENVMAP_TYPE_CUBE=!0,delete this.defines.ENVMAP_TYPE_CUBE_UV;else delete this.defines.ENVMAP_TYPE_CUBE,delete this.defines.ENVMAP_TYPE_CUBE_UV;this.uniforms.tEnv.value=e,this.needsUpdate=!0}}},colorAdjustEnabled:{get:function(){return this.defines.MVT_POST_ENABLE_COLOR_ADJUST},set:function(e){e!==this.defines.MVT_POST_ENABLE_COLOR_ADJUST&&(e?this.defines.MVT_POST_ENABLE_COLOR_ADJUST=!0:delete this.defines.MVT_POST_ENABLE_COLOR_ADJUST,this.needsUpdate=!0)}}}),this.setValues(t)}dispose(){let t=["tEnv","tDiffuse","tNormal","tDepth","tBloom","tReflection","tCoverageIntensity","tDebug1","tDebug2","tDebug3","tDebug4","tDebug5","tDebug6"];for(let e=0;e<t.length;e++){const i=t[e];this.uniforms[i]&&this.uniforms[i].value&&this.uniforms[i].value.dispose()}super.dispose()}}class xw extends Id{constructor({tDiffuse:t,tDepth:e,tNormal:i,tMetalness:s,tBloom:r,tReflection:a}){super();const o=this.material=new yw;this.tBloom=r,this.tReflection=a,o.uniforms.tDiffuse.value=t,o.uniforms.tDepth.value=e,o.uniforms.tNormal.value=i,this.fsQuad=new co(null),this.renderTarget=null}render(t,e,i){const s=this.material;s.uniforms.mvt_normalInverseMatrix.value.getNormalMatrix(e.matrixWorldInverse),s.uniforms.mvt_projectionInverseMatrix.value.copy(e.projectionMatrixInverse),s.uniforms.mvt_projectionMatrix.value.copy(e.projectionMatrix),s.uniforms.mvt_viewInverseMatrix.value.copy(e.matrixWorld),s.uniforms.cameraNear.value=e.near,s.uniforms.cameraFar.value=e.far,s.tEnv=i.environment,this.fsQuad.material=s,t.setRenderTarget(this.renderTarget),this.fsQuad.render(t)}dispose(){this.material.dispose(),this.material=null,this.fsQuad.dispose(),this.fsQuad=null}get tBloom(){return this.material.tBloom}set tBloom(t){this.material.tBloom=t}get tReflection(){return this.material.tReflection}set tReflection(t){this.material.tReflection=t}}class bw{constructor(t){g(this,"_enabled",!0),g(this,"_rendering"),g(this,"_renderPass"),g(this,"_tDiffuse"),g(this,"_tDepth"),g(this,"_tNormal"),g(this,"_tSpecular"),g(this,"_tBloom"),g(this,"_tReflection"),g(this,"_useMrt",!1),this._rendering=t}get useMrt(){return this._useMrt}set useMrt(t){t!==this._useMrt&&(this._useMrt=t,t||this.dispose())}set enabled(t){(t=!!t)!==this._enabled&&(this._enabled=t,t||this.dispose())}get enabled(){return this._enabled}_init(){const t=this._rendering;this._tDiffuse=t.main.tDiffuse,this._tDepth=t.main.tDepth,this._tNormal=t.main.tNormal,this._tSpecular=t.main.tSpecular,this._tBloom=t.bloom.tBloom,this._tReflection=t.ssr.tReflection,this._renderPass=new xw({tDiffuse:this._tDiffuse,tNormal:this._tNormal,tDepth:this._tDepth,tBloom:this._tBloom,tReflection:this._tReflection,tSpecular:this._tSpecular}),this.colorAdjustEnabled=t.colorAdjust.enabled,this.adjustBrightnessFactor=t.colorAdjust.brightness,this.adjustContrastFactor=t.colorAdjust.contrast,this.adjustSaturationFactor=t.colorAdjust.saturation}render(){if(!this._enabled||!this._useMrt)return;this._enabled&&!this._renderPass&&this._init();const t=this._rendering;this._renderPass.render(t.renderer,t.camera,t.scene)}dispose(){this._renderPass&&(this._renderPass.dispose(),this._renderPass=null)}set debugTextures(t){this._renderPass&&(this._renderPass.material.debugTextures=t)}set tDiffuse(t){this._tDiffuse=t,this._renderPass&&(this._renderPass.tDiffuse=t)}set tDepth(t){this._tDepth=t,this._renderPass&&(this._renderPass.tDepth=t)}set tNormal(t){this._tNormal=t,this._renderPass&&(this._renderPass.tNormal=t)}set tBloom(t){this._tBloom=t,this._renderPass&&(this._renderPass.tBloom=t)}set tReflection(t){this._tReflection=t,this._renderPass&&(this._renderPass.tReflection=t)}set tSpecular(t){this._tSpecular=t,this._renderPass&&(this._renderPass.tSpecular=t)}set coverageIntensity(t){this._renderPass&&(this._renderPass.material.coverageIntensity=t)}get coverageIntensity(){return this._renderPass&&this._renderPass.material.coverageIntensity||0}set tCoverageIntensity(t){this._renderPass&&(this._renderPass.material.tCoverageIntensity=t)}get tCoverageIntensity(){return this._renderPass&&null|this._renderPass.material.tCoverageIntensity}get debugDimension(){return this._renderPass&&this._renderPass.material.debugDimension||{x:0,y:0}}get debugOffset(){return this._renderPass&&this._renderPass.material.debugOffset||{x:0,y:0}}get tEnv(){return this._renderPass&&this._renderPass.material.tEnv||null}set tEnv(t){this.renderPass&&(this._renderPass.material.tEnv=t)}get useFog(){return this._renderPass&&this._renderPass.material.useFog||!1}set useFog(t){this._renderPass&&(this._renderPass.material.useFog=t)}get fogDensity(){return this._renderPass&&this._renderPass.material.fogDensity||0}set fogDensity(t){this._renderPass&&(this._renderPass.material.fogDensity=t)}get adjustBrightnessFactor(){return this._renderPass&&this._renderPass.material.adjustBrightnessFactor||0}set adjustBrightnessFactor(t){this._renderPass&&(this._renderPass.material.adjustBrightnessFactor=t)}get colorAdjustEnabled(){return this._renderPass&&this._renderPass.material.colorAdjustEnabled||!1}set colorAdjustEnabled(t){this._renderPass&&(this._renderPass.material.colorAdjustEnabled=!!t)}get adjustContrastFactor(){return this._renderPass&&this._renderPass.material.adjustContrastFactor||0}set adjustContrastFactor(t){this._renderPass&&(this._renderPass.material.adjustContrastFactor=t)}get adjustSaturationFactor(){return this._renderPass&&this._renderPass.material.adjustSaturationFactor||0}set adjustSaturationFactor(t){this._renderPass&&(this._renderPass.material.adjustSaturationFactor=t)}get fogSkyColorStartFactor(){return this._renderPass&&this._renderPass.material.fogSkyColorStartFactor||0}set fogSkyColorStartFactor(t){this._renderPass&&(this._renderPass.material.fogSkyColorStartFactor=t)}get fogAltitudeBottom(){return this._renderPass&&this._renderPass.material.fogAltitudeBottom||0}set fogAltitudeBottom(t){this._renderPass&&(this._renderPass.material.fogAltitudeBottom=t)}get fogAltitudeTop(){return this._renderPass&&this._renderPass.material.fogAltitudeTop||0}set fogAltitudeTop(t){this._renderPass&&(this._renderPass.material.fogAltitudeTop=t)}}function $r(n){var t=Math.PI/180,e=6378137,i=20037508342789244e-9,s=Math.abs(n[0])<=180?n[0]:n[0]-360*function(a){return a<0?-1:a>0?1:0}(n[0]),r=[e*s*t,e*Math.log(Math.tan(.25*Math.PI+.5*n[1]*t))];return r[0]>i&&(r[0]=i),r[0]<-i&&(r[0]=-i),r[1]>i&&(r[1]=i),r[1]<-i&&(r[1]=-i),r}function hv(n){var t=180/Math.PI,e=6378137;return[n[0]*t/e,(.5*Math.PI-2*Math.atan(Math.exp(-n[1]/e)))*t]}function Is(){}function Bd(n,t){for(let e in t)n[e]=t[e]}function hi(n,t){this.lng=n,this.lat=t}function cv(n,t){this.x=n,this.y=t}Bd(hi.prototype,{equals:function(n){return this.lat===n.lat&&this.lng===n.lng},clone:function(){return new hi(this.lat,this.lng)},getLngSpan:function(n){let t=this.lng,e=Math.abs(n-t);return e>180&&(e=360-e),e},sub:function(n){return new hi(this.lat-n.lat,this.lng-n.lng)},toString:function(){return"Point"}}),Bd(Is,{EARTHRADIUS:637099681e-2,MCBAND:[1289059486e-2,836237787e-2,5591021,348198983e-2,167804312e-2,0],LLBAND:[75,60,45,30,15,0],MC2LL:[[1410526172116255e-23,898305509648872e-20,-1.9939833816331,200.9824383106796,-187.2403703815547,91.6087516669843,-23.38765649603339,2.57121317296198,-.03801003308653,173379812e-1],[-7435856389565537e-24,8983055097726239e-21,-.78625201886289,96.32687599759846,-1.85204757529826,-59.36935905485877,47.40033549296737,-16.50741931063887,2.28786674699375,1026014486e-2],[-3030883460898826e-23,898305509983578e-20,.30071316287616,59.74293618442277,7.357984074871,-25.38371002664745,13.45380521110908,-3.29883767235584,.32710905363475,685681737e-2],[-1981981304930552e-23,8983055099779535e-21,.03278182852591,40.31678527705744,.65659298677277,-4.44255534477492,.85341911805263,.12923347998204,-.04625736007561,448277706e-2],[309191371068437e-23,8983055096812155e-21,6995724062e-14,23.10934304144901,-.00023663490511,-.6321817810242,-.00663494467273,.03430082397953,-.00466043876332,25551644e-1],[2890871144776878e-24,8983055095805407e-21,-3068298e-14,7.47137025468032,-353937994e-14,-.02145144861037,-1234426596e-14,.00010322952773,-323890364e-14,826088.5]],LL2MC:[[-.0015702102444,111320.7020616939,0x60e374c3105a3,-0x24bb4115e2e164,0x5cc55543bb0ae8,-0x7ce070193f3784,0x5e7ca61ddf8150,-0x261a578d8b24d0,0x665d60f3742ca,82.5],[.0008277824516172526,111320.7020463578,6477955746671607e-7,-4082003173641316e-6,1077490566351142e-5,-1517187553151559e-5,1205306533862167e-5,-5124939663577472e-6,9133119359512032e-7,67.5],[.00337398766765,111320.7020202162,4481351045890365e-9,-2339375119931662e-8,7968221547186455e-8,-1159649932797253e-7,9723671115602145e-8,-4366194633752821e-8,8477230501135234e-9,52.5],[.00220636496208,111320.7020209128,51751.86112841131,3796837749470245e-9,992013.7397791013,-122195221711287e-8,1340652697009075e-9,-620943.6990984312,144416.9293806241,37.5],[-.0003441963504368392,111320.7020576856,278.2353980772752,2485758690035394e-9,6070.750963243378,54821.18345352118,9540.606633304236,-2710.55326746645,1405.483844121726,22.5],[-.0003218135878613132,111320.7020701615,.00369383431289,823725.6402795718,.46104986909093,2351.343141331292,1.58060784298199,8.77738589078284,.37238884252424,7.45]],getDistanceByMC:function(n,t){if(!n||!t)return 0;let e,i,s,r;return(n=this.convertMC2LL(n))?(e=this.toRadians(n.lng),i=this.toRadians(n.lat),(t=this.convertMC2LL(t))?(s=this.toRadians(t.lng),r=this.toRadians(t.lat),this.getDistance(e,s,i,r)):0):0},getDistanceByLL:function(n,t){if(!n||!t)return 0;let e,i,s,r;return n.lng=this.getLoop(n.lng,-180,180),n.lat=this.getRange(n.lat,-74,74),t.lng=this.getLoop(t.lng,-180,180),t.lat=this.getRange(t.lat,-74,74),e=this.toRadians(n.lng),s=this.toRadians(n.lat),i=this.toRadians(t.lng),r=this.toRadians(t.lat),this.getDistance(e,i,s,r)},convertMC2LL:function(n){if(n==null)return new hi(0,0);if(n.lng<180&&n.lng>-180&&n.lat<90&&n.lat>-90)return n;let t,e;t=new hi(Math.abs(n.lng),Math.abs(n.lat));for(let s=0;s<this.MCBAND.length;s++)if(t.lat>=this.MCBAND[s]){e=this.MC2LL[s];break}let i=this.convertor(n,e);return n=new hi(i.lng.toFixed(6),i.lat.toFixed(6))},convertLL2MC:function(n){if(n==null)return new hi(0,0);if(n.lng>180||n.lng<-180||n.lat>90||n.lat<-90)return n;let t,e;if(n.lng=this.getLoop(n.lng,-180,180),n.lat=this.getRange(n.lat,-74,74),t=new hi(n.lng,n.lat),window.BMAPGL_84){var i={},s=6378137;i.lng=t.lng*Math.PI/180*s;var r=t.lat*Math.PI/180;return i.lat=31890685e-1*Math.log((1+Math.sin(r))/(1-Math.sin(r))),new hi(Number(i.lng),Number(i.lat))}for(var a=0;a<this.LLBAND.length;a++)if(t.lat>=this.LLBAND[a]){e=this.LL2MC[a];break}if(!e){for(a=0;a<this.LLBAND.length;a++)if(t.lat<=-this.LLBAND[a]){e=this.LL2MC[a];break}}let o=this.convertor(n,e);return n=new hi(Number(o.lng),Number(o.lat))},convertor:function(n,t){if(!n||!t)return;let e=t[0]+t[1]*Math.abs(n.lng),i=Math.abs(n.lat)/t[9],s=t[2]+t[3]*i+t[4]*i*i+t[5]*i*i*i+t[6]*i*i*i*i+t[7]*i*i*i*i*i+t[8]*i*i*i*i*i*i;return e*=n.lng<0?-1:1,s*=n.lat<0?-1:1,new hi(e,s)},getDistance:function(n,t,e,i){return this.EARTHRADIUS*Math.acos(Math.sin(e)*Math.sin(i)+Math.cos(e)*Math.cos(i)*Math.cos(t-n))},toRadians:function(n){return Math.PI*n/180},toDegrees:function(n){return 180*n/Math.PI},getRange:function(n,t,e){return t!=null&&(n=Math.max(n,t)),e!=null&&(n=Math.min(n,e)),n},getLoop:function(n,t,e){for(;n>e;)n-=e-t;for(;n<t;)n+=e-t;return n}}),Bd(Is.prototype,{lngLatToMercator:function(n){return Is.convertLL2MC(n)},lngLatToPoint:function(n){let t=Is.convertLL2MC(n);return new cv(t.lng,t.lat)},mercatorToLngLat:function(n){return Is.convertMC2LL(n)},pointToLngLat:function(n){let t=new hi(n.x,n.y);return Is.convertMC2LL(t)},pointToPixel:function(n,t,e,i,s){if(!n)return;n=this.lngLatToMercator(n,s);let r=this.getZoomUnits(t);return new cv(Math.round((n.lng-e.lng)/r+i.width/2),Math.round((e.lat-n.lat)/r+i.height/2))},pixelToPoint:function(n,t,e,i,s){if(!n)return;let r=this.getZoomUnits(t),a=new hi(e.lng+r*(n.x-i.width/2),e.lat-r*(n.y-i.height/2));return this.mercatorToLngLat(a,s)},getZoomUnits:function(n){return Math.pow(2,18-n)}});const uv=(n,t)=>{if(n)if(t===0)n[2]||(n[2]=0);else for(const e of n)uv(e,t-1)};function Vd(n,t){if(!n)return[];let e=null;return t&&Gd(n,t),e=n.features?n.features:Array.isArray(n)?n:[n],e}function Gd(n,t){if(n){if(n.type==="FeatureCollection"||n.features){const e=n.features;for(const i of e)Gd(i,t)}else if(Array.isArray(n)){const e=n;for(const i of e)Gd(i,t)}else if((n.type==="Feature"||n.geometry)&&Array.isArray(n.geometry.coordinates)){if(n.geometry[t])return;pv(n);const e=Fh(n.geometry.coordinates,t);n.geometry[t]=e}}}function Fh(n,t){if(Array.isArray(n[0])){const e=[];for(let i of n)e.push(Fh(i,t));return e}if(typeof n[0]=="number"||typeof n[0]=="string")return dv(n,t)}function dv(n,t){if(!n)return[];let e=[];if(n[0]>180||n[1]>90)e=[n[0],n[1]];else if(t==="_bmap_mercator"){const i=Is.convertLL2MC({lng:n[0],lat:n[1]});e[0]=i.lng,e[1]=i.lat}else e=$r(n);return n[2]!==void 0?e[2]=n[2]:e[2]=0,e}function pv(n){n.type||(n.type="Feature");const t=n.geometry.type,e={Point:0,MultiPoint:1,LineString:1,MultiLineString:2,Polygon:2,MultiPolygon:3};return Object.keys(e).includes(t)&&uv(n.geometry.coordinates,e[t]),n}function mv(n,t){if(n.geometry.type==="Point")return[n];if(n.geometry.type==="MultiPoint"||n.geometry.type==="LineString"){const e=[],{type:i,geometry:s,...r}=n;for(let a=0;a<n.geometry.coordinates.length;a++){const o=n.geometry.coordinates[a];if(t){const l=n.geometry[t][a];e.push({type:"Feature",geometry:{type:"Point",coordinates:o,[t]:l},...r})}else e.push({type:"Feature",geometry:{type:"Point",coordinates:o},...r})}return e}return[]}function fv(n,t){if(n.geometry.type==="LineString")return[n];if(n.geometry.type==="MultiLineString"||n.geometry.type==="Polygon"){const e=[],{type:i,geometry:s,...r}=n;for(let a=0;a<n.geometry.coordinates.length;a++){const o=n.geometry.coordinates[a];if(t){const l=n.geometry[t][a];e.push({type:"Feature",geometry:{type:"LineString",coordinates:o,[t]:l},...r})}else e.push({type:"Feature",geometry:{type:"LineString",coordinates:o},...r})}return e}return[]}function gv(n,t){if(n.geometry.type==="Polygon")return[n];if(n.geometry.type==="MultiPolygon"){const e=[],{type:i,geometry:s,...r}=n;for(let a=0;a<n.geometry.coordinates.length;a++){const o=n.geometry.coordinates[a];if(t){const l=n.geometry[t][a];e.push({type:"Feature",geometry:{type:"Polygon",coordinates:o,[t]:l},...r})}else e.push({type:"Feature",geometry:{type:"Polygon",coordinates:o},...r})}return e}return[]}const Mw=Object.freeze(Object.defineProperty({__proto__:null,getGeoFeatures:Vd,projectCoordinates:Fh,projectPointArr:dv,fixFeature:pv,multiPointToPoints:mv,multiLineStringToLineStrings:fv,multiPolygonToPolygons:gv,convertLineString2Points:function(n){let t=this.getGeoFeatures(n),e=[];for(let i=0;i<t.length;i++){const s=t[i],r=this.multiLineStringToLineStrings(s);for(let a=0;a<r.length;a++){const o=r[a],l=this.multiPointToPoints(o);e.push(...l)}}return e},convertPolygon2LineString:function(n){let t=this.getGeoFeatures(n),e=[];for(let i=0;i<t.length;i++){const s=t[i],r=this.multiPolygonToPolygons(s);for(let a=0;a<r.length;a++){const o=r[a],l=this.multiLineStringToLineStrings(o);e.push(...l)}}return e}},Symbol.toStringTag,{value:"Module"}));function vo(n,t={}){this.position=n,this.attributes=t,t.id!==void 0&&(this.id=t.id),this._projection=[]}function jd(n,t,e,i,s){return function(r,a){let o=1-r;return o*o*o*a}(n,t)+function(r,a){let o=1-r;return 3*o*o*r*a}(n,e)+function(r,a){return 3*(1-r)*r*r*a}(n,i)+function(r,a){return r*r*r*a}(n,s)}vo.prototype.getProjection=function(n){return this._projection=Fh(this.position,n),this._projection};const ww=function(n,t){let e=n[0],i=n[1];return[(3*e+t[0])/4,(3*i+t[1])/4]},Sw=function(n,t){let e=n[0],i=n[1],s=t[0],r=t[1];return Math.sqrt(Math.pow(e-s,2)+Math.pow(i-r,2))},vv=function(n,t,e=1){return[...ww(n,t),Sw(n,t)/e]},Tw=function(n,t,e,i,s){let r=[];return r.push(jd(n,t[0],e[0],i[0],s[0]),jd(n,t[1],e[1],i[1],s[1]),jd(n,t[2],e[2],i[2],s[2])),r};function Ew(n,t=20){const e=n[0],i=n[n.length-1],s=vv(e,i,4),r=vv(i,e,5);let a=[];for(let o=0;o<=t;o++)a.push(Tw(o/t,e,s,r,i));return a}class _o{constructor(t={}){g(this,"_projectionName"),g(this,"_objects",[]),g(this,"_isLoading",!1),g(this,"_isLoaded",!1),g(this,"_url"),g(this,"_origin"),g(this,"_data",{}),g(this,"_addCache",[]),g(this,"_attributeMap",new Map),g(this,"_needsUpdate",!0),g(this,"_templateDataLength",0),g(this,"_idIndexMap",{}),g(this,"_indexIdMap",{}),g(this,"_isCurve",!1),this.options=t,this._id=t.id||new Date().valueOf()}async load(t){if(this._isLoaded&&this.clear(),this._isLoading)return this;if(this._isLoading=!0,typeof t=="string"){let e=await fetch(t),i=await this._getFetchData(e);this._url=t,this._origin=i}else typeof t=="object"&&(this._origin=t);return this._isLoading=!1,this._isLoaded=!0,this}async _getFetchData(t){return t}setAttribute(t,e){return e?this._attributeMap.set(t,e):this._attributeMap.set(t,t),this.needsUpdate=!0,this}setAttributes(t){let e=Object.keys(t);for(let i=0;i<e.length;i++){const s=e[i];this._attributeMap.set(s,t[s])}return this.needsUpdate=!0,this}removeAttribute(t){this._attributeMap.delete(t)}removeAllAttributes(){this._attributeMap.clear()}add(t){if(t instanceof vo){const e=t.id;if(e!==void 0){if(this._idIndexMap[e]!==void 0)return this;const i=this._addCache.length;this._indexIdMap[i]=e,this._idIndexMap[e]=i}this._addCache.push(t)}else if(t instanceof Array)for(let e=0;e<t.length;e++){const i=t[e];this.add(i)}return this.needsUpdate=!0,this}remove(t){if(t instanceof vo){const e=t.id,i=this._idIndexMap[e];if(i===void 0)return void console.warn("remove fail1",i,e);const s=this._addCache.length-1;if(i>s)return void console.warn("remove fail2",i,e);if(i<s){const r=this._indexIdMap[s];this._addCache[i]=this._addCache[s],this._indexIdMap[i]=r,this._idIndexMap[r]=i}delete this._idIndexMap[e],delete this._indexIdMap[s],this._addCache.length=this._addCache.length-1}return this.needsUpdate=!0,this}get(t){let e={};if(this.data.position&&this.data.position.length&&t!==void 0&&!(t>=this.data.position.length)){for(const i in this.data)if(Object.hasOwnProperty.call(this.data,i)){const s=this.data[i];e[i]=s[t]}return e}}getOriginDataIndex(t){return[t,0]}getOriginData(t){return this._addCache[t]}update(){let t={position:[],index:[]};for(const e of this._attributeMap.keys())t[e]=[];if(t=this._onProcessTemplateData(t),t=this._onProcessAddData(t),this._isCurve&&t.position.length>0&&Array.isArray(t.position[0])&&Array.isArray(t.position[0][0])&&!Array.isArray(t.position[0][0][0]))for(let e=0;e<t.position.length;e++){const i=t.position[e];t.position[e]=Ew(i)}this.data=t,this.needsUpdate=!1}setData(t){this.clear(),this._isLoaded=!0,this._origin=t,this.needsUpdate=!0}clear(){this._isLoaded=!1,this._url=void 0,this._origin=void 0,this._data={},this._addCache=[],this.needsUpdate=!0,this._idIndexMap={},this._indexIdMap={},this.onClear()}onClear(){}_onProcessTemplateData(t){return t}_onProcessAddData(t){const e=this.projectionName,i=t.index[t.index.length-1];this._templateDataLength=t.index.length;for(let s=0;s<this._addCache.length;s++){const r=this._addCache[s],a=r.getProjection(e);t.position.push(a),i!==void 0?t.index.push(i+s+1):t.index.push(s);for(const o of this._attributeMap.keys())r.attributes&&r.attributes[this._attributeMap.get(o)]?t[o].push(r.attributes[this._attributeMap.get(o)]):this._attributeMap.get(o)instanceof Function?t[o].push(this._attributeMap.get(o)(r.attributes)):t[o].push(void 0)}return t}dispose(){this.clear()}get size(){return this.needsUpdate&&this.update(),this.data&&this.data.position&&this.data.position.length||0}get data(){return this._data}set data(t){this._data=t}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}get origin(){return this._origin}get projectionName(){return this._projectionName}set projectionName(t){this._projectionName=t}get objects(){return this._objects}set objects(t){this._objects=t}get isCurve(){return this._isCurve}set isCurve(t){this._isCurve=t,this.needsUpdate=!0}}class Cw extends Mt{constructor(t){super(),g(this,"_enableRtc",!0),g(this,"_cachedRtc",[0,0,0]),g(this,"makeMeshPositionOffset",e=>{this._cachedRtc=[e[0],e[1],e[2]||0],this.updateTransform()}),g(this,"makeGeometryOffsetPosition",(e,i)=>{if(!this._enableRtc)return;const s=e.boundingSphere&&e.boundingSphere.center;if(!s)return this._cachedRtc=[0,0,0],void this.updateTransform();const{x:r,y:a,z:o}=s;e.isCustomInstancedBufferGeometry?this.makePostionArrayOffset(e.attributes.instancedPosition.array,r,a,o,i):(this.makePostionArrayOffset(e.attributes.position.array,r,a,o,i),e.attributes.position.array.length),e.computeBoundingSphere(),this._cachedRtc=[r,a,o],this.updateTransform()}),g(this,"makePostionArrayOffset",(e,i,s,r,a)=>{if(!e||e.length<3)return;let o=a||e;for(let l=0,h=e.length-2;l<h;l+=3)e[l]=o[l]-i,e[l+1]=o[l+1]-s,e[l+2]=o[l+2]-r}),g(this,"updateTransform",()=>{const[e,i,s]=this._cachedRtc;this.position.set(e,i,s),this.updateMatrixWorld(!0)}),Object.defineProperties(this,{enableRtc:{get:function(){return this._enableRtc},set:function(e){this._enableRtc=e}}})}defineGeometryProxyProperties(t=[]){for(let e=0;e<t.length;e++){const i=t[e];Object.defineProperty(this,i,{get:function(){return this.geometry[i]},set:function(s){this.geometry[i]=s}})}}defineMaterialProxyProperties(t=[]){for(let e=0;e<t.length;e++){const i=t[e];Object.defineProperty(this,i,{get:function(){return this.material[i]},set:function(s){this.material[i]=s}})}}}class Ds extends Cw{constructor(){super(...arguments),g(this,"isGeoObject",!0),g(this,"dataAutoUpdate",!0),g(this,"_parameters"),g(this,"_dataSource"),g(this,"_needsUpdate"),g(this,"_zooms",[0,100]),g(this,"_zoomVisibleCache"),g(this,"engine"),g(this,"getGeoFeatures",(t,e=!1)=>{if(!t)return[];let i=null;return e||this.map.projectGeoJSON(t),i=t.features?t.features:Array.isArray(t)?t:[t],i}),g(this,"travelFeatureLineCoordinate",(t,e,i)=>{const s=t.geometry;if(!s||!s[e]||!s.type)return;const r=s[e];if(s.type==="LineString")i&&i(r);else if(s.type==="MultiLineString"||s.type==="Polygon")for(let a of r)i&&i(a);else if(s.type==="MultiPolygon")for(let a of r)for(let o of a)i&&i(o)}),g(this,"travelLineCoordinates",(t,e="coordinates",i,s=0)=>{if(Array.isArray(t)&&i)for(let r=0,a=t.length;r<a;r++){const o=t[r],l=s+r,h=o.geometry;if(!h||!h[e]||!h.type)continue;const c=h[e];if(h.type==="LineString")i&&i(c,o,l);else if(h.type==="MultiLineString"||h.type==="Polygon")for(let u of c)i&&i(u,o,l);else if(h.type==="MultiPolygon")for(let u of c)for(let d of u)i&&i(d,o,l)}}),g(this,"travelPolygonCoordinates",(t,e="coordinates",i,s=0)=>{if(Array.isArray(t)&&i)for(let r=0,a=t.length;r<a;r++){const o=t[r],l=s+r,h=o.geometry;if(!h||!h[e]||!h.type)continue;const c=h[e];if(h.type==="Polygon")i&&i(c,o,l);else if(h.type==="MultiPolygon")for(let u of c)i&&i(u,o,l);else if(h.type==="LineString")i&&i([c],o,l);else if(h.type==="MultiLineString")for(let u of c)i&&i([u],o,l)}}),g(this,"travelPointCoordinates",(t,e="coordinates",i,s=0)=>{if(Array.isArray(t)&&i)for(let r=0,a=t.length;r<a;r++){const o=t[r],l=s+r,h=o.geometry;if(!h||!h[e]||!h.type)continue;const c=h[e];h.type==="Point"&&i&&i(c,o,l)}}),g(this,"getPointsBounding",(t,e="coordinates")=>{let i=1/0,s=1/0,r=1/0,a=-1/0,o=-1/0,l=-1/0;return this.travelPointCoordinates(t,e,h=>{const[c,u,d=0]=h;c<i&&(i=c),c>a&&(a=c),u<s&&(s=u),u>o&&(o=u),d<r&&(r=d),d>l&&(l=d)}),isFinite(i)||(i=0),isFinite(a)||(a=0),isFinite(s)||(s=0),isFinite(o)||(o=0),isFinite(r)||(r=0),isFinite(l)||(l=0),[i,s,r,a,o,l]})}get parameters(){return this._parameters}set parameters(t){this._parameters?this._parameters={...this._parameters,...t}:this._parameters={...this.getDefaultParams(),...t}}get dataSource(){return this._dataSource}set dataSource(t){this.setDataSource(t)}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}get zooms(){return this._zooms}set zooms(t){this._zooms=t}get inZoomsRange(){const t=this.engine;return!!t&&t.map.getZoom()>=this.zooms[0]&&t.map.getZoom()<=this.zooms[1]}afterAddToEngine(t){this.engine=t,this.initObject()}beforeRemoveFromEngine(t){this.dispose()}initObject(){}getDefaultParams(){return{}}getEntityByIndex(t){const e=this.dataSource;if(!e)return;const i={index:t,value:e.getOriginData(t),itemIndex:e.getOriginDataIndex(t),pairs:{}},s=e.data;for(const r of Object.keys(s))i.pairs[r]=s[r][t];return i}setDataSource(t){if(!t&&this._dataSource){const e=this._dataSource.objects.indexOf(this);e>-1&&this._dataSource.splice(e,1),this._dataSource=null}t.objects.indexOf(this)>-1||(this._dataSource=t,t.projectionName=this.engine.map.projectionCoordsName,t.objects.push(this),this.needsUpdate=!0,this.engine.requestRender())}onBeforeSceneRender(t,e,i,s){if(this.dataSource){if(this.dataSource.needsUpdate===!0){if(this.dataSource.update(),!this.dataSource.data)return;this.dataAutoUpdate&&this.setData()}this.dataAutoUpdate&&this.needsUpdate===!0&&this.setData(),this.geometry&&this.geometry.needsUpdate===!0&&this.geometry.updateGeometry&&(this.geometry.updateGeometry(),this.afterGeometryUpdate&&this.afterGeometryUpdate()),this.visible&&!this.inZoomsRange?(this._zoomVisibleCache=this.visible,this.visible=!1):!this.visible&&this._zoomVisibleCache&&this.inZoomsRange&&(this.visible=this._zoomVisibleCache,this._zoomVisibleCache=void 0),this.onBeforeSceneRenderHook&&this.onBeforeSceneRenderHook(t,e,i,s)}}setData(){}onDispose(){}dispose(){if(this.geometry&&this.geometry.dispose(),this.material)if(Array.isArray(this.material))for(let t=0;t<this.material.length;t++)this.material[t].dispose();else this.material.dispose();this.onDispose()}}class $n extends Ds{constructor(){super(...arguments),g(this,"isMesh",!0)}}function Aw(n,t,e,i,s){_v(n,t,e||0,i||n.length-1,s||Pw)}function _v(n,t,e,i,s){for(;i>e;){if(i-e>600){var r=i-e+1,a=t-e+1,o=Math.log(r),l=.5*Math.exp(2*o/3),h=.5*Math.sqrt(o*l*(r-l)/r)*(a-r/2<0?-1:1);_v(n,t,Math.max(e,Math.floor(t-a*l/r+h)),Math.min(i,Math.floor(t+(r-a)*l/r+h)),s)}var c=n[t],u=e,d=i;for(yo(n,e,t),s(n[i],c)>0&&yo(n,e,i);u<d;){for(yo(n,u,d),u++,d--;s(n[u],c)<0;)u++;for(;s(n[d],c)>0;)d--}s(n[e],c)===0?yo(n,e,d):yo(n,++d,i),d<=t&&(e=d+1),t<=d&&(i=d-1)}}function yo(n,t,e){var i=n[t];n[t]=n[e],n[e]=i}function Pw(n,t){return n<t?-1:n>t?1:0}class Rw{constructor(t=9){this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()}all(){return this._all(this.data,[])}search(t){let e=this.data;const i=[];if(!kh(t,e))return i;const s=this.toBBox,r=[];for(;e;){for(let a=0;a<e.children.length;a++){const o=e.children[a],l=e.leaf?s(o):o;kh(t,l)&&(e.leaf?i.push(o):Wd(t,l)?this._all(o,i):r.push(o))}e=r.pop()}return i}collides(t){let e=this.data;if(!kh(t,e))return!1;const i=[];for(;e;){for(let s=0;s<e.children.length;s++){const r=e.children[s],a=e.leaf?this.toBBox(r):r;if(kh(t,a)){if(e.leaf||Wd(t,a))return!0;i.push(r)}}e=i.pop()}return!1}load(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(let i=0;i<t.length;i++)this.insert(t[i]);return this}let e=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===e.height)this._splitRoot(this.data,e);else{if(this.data.height<e.height){const i=this.data;this.data=e,e=i}this._insert(e,this.data.height-e.height-1,!0)}else this.data=e;return this}insert(t){return t&&this._insert(t,this.data.height-1),this}clear(){return this.data=ea([]),this}remove(t,e){if(!t)return this;let i=this.data;const s=this.toBBox(t),r=[],a=[];let o,l,h;for(;i||r.length;){if(i||(i=r.pop(),l=r[r.length-1],o=a.pop(),h=!0),i.leaf){const c=Lw(t,i.children,e);if(c!==-1)return i.children.splice(c,1),r.push(i),this._condense(r),this}h||i.leaf||!Wd(i,s)?l?(o++,i=l.children[o],h=!1):i=null:(r.push(i),a.push(o),o=0,l=i,i=i.children[0])}return this}toBBox(t){return t}compareMinX(t,e){return t.minX-e.minX}compareMinY(t,e){return t.minY-e.minY}toJSON(){return this.data}fromJSON(t){return this.data=t,this}_all(t,e){const i=[];for(;t;)t.leaf?e.push(...t.children):i.push(...t.children),t=i.pop();return e}_build(t,e,i,s){const r=i-e+1;let a,o=this._maxEntries;if(r<=o)return a=ea(t.slice(e,i+1)),ta(a,this.toBBox),a;s||(s=Math.ceil(Math.log(r)/Math.log(o)),o=Math.ceil(r/Math.pow(o,s-1))),a=ea([]),a.leaf=!1,a.height=s;const l=Math.ceil(r/o),h=l*Math.ceil(Math.sqrt(o));yv(t,e,i,h,this.compareMinX);for(let c=e;c<=i;c+=h){const u=Math.min(c+h-1,i);yv(t,c,u,l,this.compareMinY);for(let d=c;d<=u;d+=l){const p=Math.min(d+l-1,u);a.children.push(this._build(t,d,p,s-1))}}return ta(a,this.toBBox),a}_chooseSubtree(t,e,i,s){for(;s.push(e),!e.leaf&&s.length-1!==i;){let o,l=1/0,h=1/0;for(let c=0;c<e.children.length;c++){const u=e.children[c],d=Hd(u),p=(r=t,a=u,(Math.max(a.maxX,r.maxX)-Math.min(a.minX,r.minX))*(Math.max(a.maxY,r.maxY)-Math.min(a.minY,r.minY))-d);p<h?(h=p,l=d<l?d:l,o=u):p===h&&d<l&&(l=d,o=u)}e=o||e.children[0]}var r,a;return e}_insert(t,e,i){const s=i?t:this.toBBox(t),r=[],a=this._chooseSubtree(s,this.data,e,r);for(a.children.push(t),bo(a,s);e>=0&&r[e].children.length>this._maxEntries;)this._split(r,e),e--;this._adjustParentBBoxes(s,r,e)}_split(t,e){const i=t[e],s=i.children.length,r=this._minEntries;this._chooseSplitAxis(i,r,s);const a=this._chooseSplitIndex(i,r,s),o=ea(i.children.splice(a,i.children.length-a));o.height=i.height,o.leaf=i.leaf,ta(i,this.toBBox),ta(o,this.toBBox),e?t[e-1].children.push(o):this._splitRoot(i,o)}_splitRoot(t,e){this.data=ea([t,e]),this.data.height=t.height+1,this.data.leaf=!1,ta(this.data,this.toBBox)}_chooseSplitIndex(t,e,i){let s,r=1/0,a=1/0;for(let o=e;o<=i-e;o++){const l=xo(t,0,o,this.toBBox),h=xo(t,o,i,this.toBBox),c=Ow(l,h),u=Hd(l)+Hd(h);c<r?(r=c,s=o,a=u<a?u:a):c===r&&u<a&&(a=u,s=o)}return s||i-e}_chooseSplitAxis(t,e,i){const s=t.leaf?this.compareMinX:Iw,r=t.leaf?this.compareMinY:Dw;this._allDistMargin(t,e,i,s)<this._allDistMargin(t,e,i,r)&&t.children.sort(s)}_allDistMargin(t,e,i,s){t.children.sort(s);const r=this.toBBox,a=xo(t,0,e,r),o=xo(t,i-e,i,r);let l=Nh(a)+Nh(o);for(let h=e;h<i-e;h++){const c=t.children[h];bo(a,t.leaf?r(c):c),l+=Nh(a)}for(let h=i-e-1;h>=e;h--){const c=t.children[h];bo(o,t.leaf?r(c):c),l+=Nh(o)}return l}_adjustParentBBoxes(t,e,i){for(let s=i;s>=0;s--)bo(e[s],t)}_condense(t){for(let e,i=t.length-1;i>=0;i--)t[i].children.length===0?i>0?(e=t[i-1].children,e.splice(e.indexOf(t[i]),1)):this.clear():ta(t[i],this.toBBox)}}function Lw(n,t,e){if(!e)return t.indexOf(n);for(let i=0;i<t.length;i++)if(e(n,t[i]))return i;return-1}function ta(n,t){xo(n,0,n.children.length,t,n)}function xo(n,t,e,i,s){s||(s=ea(null)),s.minX=1/0,s.minY=1/0,s.maxX=-1/0,s.maxY=-1/0;for(let r=t;r<e;r++){const a=n.children[r];bo(s,n.leaf?i(a):a)}return s}function bo(n,t){return n.minX=Math.min(n.minX,t.minX),n.minY=Math.min(n.minY,t.minY),n.maxX=Math.max(n.maxX,t.maxX),n.maxY=Math.max(n.maxY,t.maxY),n}function Iw(n,t){return n.minX-t.minX}function Dw(n,t){return n.minY-t.minY}function Hd(n){return(n.maxX-n.minX)*(n.maxY-n.minY)}function Nh(n){return n.maxX-n.minX+(n.maxY-n.minY)}function Ow(n,t){const e=Math.max(n.minX,t.minX),i=Math.max(n.minY,t.minY),s=Math.min(n.maxX,t.maxX),r=Math.min(n.maxY,t.maxY);return Math.max(0,s-e)*Math.max(0,r-i)}function Wd(n,t){return n.minX<=t.minX&&n.minY<=t.minY&&t.maxX<=n.maxX&&t.maxY<=n.maxY}function kh(n,t){return t.minX<=n.maxX&&t.minY<=n.maxY&&t.maxX>=n.minX&&t.maxY>=n.minY}function ea(n){return{children:n,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function yv(n,t,e,i,s){const r=[t,e];for(;r.length;){if((e=r.pop())-(t=r.pop())<=i)continue;const a=t+Math.ceil((e-t)/i/2)*i;Aw(n,a,t,e,s),r.push(t,a,a,e)}}class Fe extends Qt{constructor(t){super(),g(this,"isCommonShaderMaterial",!0),g(this,"setCommonUniforms",e=>{for(const i of Object.keys(e))this.uniforms[i]=e[i]}),this.setValues(t)}}const zw=ft.merge([rt.fog.uniforms,Gi,{map:{value:null},pixelRatio:{value:1},lineHeight:{value:14},pixelOffsetX:{value:0},pixelOffsetY:{value:0},positionOffsetX:{value:0},positionOffsetZ:{value:0},positionOffsetY:{value:0},backgroundColor:{value:[1,1,0,0]},uFlat:{value:!1},opacity:{value:1}}]);class Uw extends Fe{constructor(t){super(),this.type="DefaultTextMaterial",this.vertexShader=`#define GLSLIFY 1
#include <common>

uniform float pixelRatio;
uniform float positionOffsetX;
uniform float positionOffsetY;
uniform float pixelOffsetX;
uniform float pixelOffsetY;
uniform float positionOffsetZ;
uniform float zoomUnits;
uniform bool uFlat;
uniform vec2 resolution;

attribute float pIndex;
attribute vec2 wh;
attribute float rotateZ;

varying vec2 vUv;
#include <logdepthbuf_pars_vertex>
#include <mvt_selective_pars_vertex>

void main() {
    #include <mvt_selective_vertex>
    // float x = position.x;
    // float y = position.y;
    vUv = uv;

    if (uFlat) {
        float hw = wh.x * 0.5 * zoomUnits;
        float hh = wh.y * 0.5 * zoomUnits;
        if (pIndex == 1.0) {
            hw = -hw;
        } else if (pIndex == 2.0) {
            
        } else if (pIndex == 3.0) {
            hh = -hh;
        } else {
            hw = -hw;
            hh = -hh;
        }
        vec2 rotatedPosition;
	    rotatedPosition.x = cos( rotateZ ) * hw - sin( rotateZ ) * hh;
	    rotatedPosition.y = sin( rotateZ ) * hw + cos( rotateZ ) * hh;
        // vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + rotatedPosition.x, position.y + rotatedPosition.y, position.z, 1.0);
        
    }
    else {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * zoomUnits, position.y + positionOffsetY * zoomUnits, position.z + positionOffsetZ * zoomUnits, 1.0);
        float w = gl_Position.w;
        gl_Position /= w;
        float hw = wh.x / resolution.x;
        float hh = wh.y / resolution.y;
        gl_Position.x += pixelOffsetX * 2. / resolution.x;
        gl_Position.y += pixelOffsetY * 2. / resolution.y;
        if (pIndex == 1.0) {
            gl_Position.x -= hw;
            gl_Position.y += hh;
        } else if (pIndex == 2.0) {
            gl_Position.x += hw;
            gl_Position.y += hh;
        } else if (pIndex == 3.0) {
            gl_Position.x += hw;
            gl_Position.y -= hh;
        } else {
            gl_Position.x -= hw;
            gl_Position.y -= hh;
        }
        gl_Position *= w;
    }
    #include <logdepthbuf_vertex>
    // gl_PointSize = size * pixelRatio;
    // vSize = size;
    // vOffset = offset;
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform sampler2D map;
uniform vec4 backgroundColor;
uniform float opacity;
uniform float lineHeight;

varying vec2 vUv;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>
    // gl_FragColor = vec4(1., 0, 0, 1.);
    gl_FragColor = texture2D(map, vec2(vUv.x, 1.0 - vUv.y));

    if (backgroundColor.a > 0.0) {
        gl_FragColor = mix(backgroundColor, gl_FragColor, gl_FragColor.a);
    }

    if (gl_FragColor.a == 0.0) {
        discard;
    }
    gl_FragColor.a *= opacity;

    #include <mvt_selective_fragment> 
    #include <tonemapping_fragment>
	#include <encodings_fragment>
    
}`,this.isDefaultTextMaterial=!0,this.transparent=!0,this.depthTest=!1,this.depthWrite=!1,Object.assign(this.uniforms,ft.clone(zw)),Qn(this),Jt(this,["lineHeight","pixelRatio","map","pixelOffsetX","pixelOffsetY","positionOffsetX","positionOffsetY","positionOffsetZ","backgroundColor","resolution","opacity"]),rn(this,[["flat","uFlat"]]),this.setValues(t)}}const Fw=new at;class xv extends $n{constructor(t){super(t),g(this,"_collides"),g(this,"_fontSize"),g(this,"_fontFamily"),g(this,"_fillStyle"),g(this,"_padding"),g(this,"_margin"),g(this,"_strokeStyle"),g(this,"_shouldStroke"),g(this,"_maxRenderDepth"),g(this,"_canRenderAll"),g(this,"shouldUpdateRenderingData"),g(this,"geometry"),g(this,"material"),g(this,"cachedData",[]),g(this,"drawingData"),g(this,"canvas"),g(this,"ctx"),g(this,"texture"),g(this,"matrixAutoUpdate",!0),g(this,"onBeforeSceneRenderHook",(s,r,a)=>{this.updateRenderingData()}),g(this,"updateRenderingData",()=>{const s=this.engine.camera,r=this.engine.rendering.pixelRatio;this.updateMatrix(),this.updateMatrixWorld();let a=Fw.copy(this.engine.rendering.renderState.viewMatrixWorldInverse),o=s.projectionMatrix;const l=this.canvas,h=this.ctx,c=this._fontSize,u=this._fontFamily,d=this._fillStyle,p=this._padding,m=this._margin,f=this.resolution?this.resolution.toArray():[0,0],[v,_]=f;if(isNaN(v)||v<=0||isNaN(_)||_<=0)return void console.warn("resolution is invalid");h.save(),h.scale(r,r),h.textBaseline="top",h.font=c+"px "+u;const y=new Rw,x=[];this.drawingData=[];const b=!this._collides;for(let H=0;H<this.cachedData.position.length;H++){const W=this.cachedData.position[H],N=this.cachedData.text&&this.cachedData.text[H];if(N===void 0)continue;const X=this.cachedData.index[H],K=this.cachedData.rotateZ?this.cachedData.rotateZ[H]:0,[$,lt,yt]=W,mt=new Ot($,lt,yt,1);mt.applyMatrix4(a).applyMatrix4(o),mt.divideScalar(mt.w);const bt=(mt.x+1)/2*v,I=(1-mt.y)/2*_;if(mt.z>this._maxRenderDepth)continue;const P=h.measureText(N).width+2*p[0],q=c+2*p[1],B=P+m[0],D=q+m[1],C=bt-B/2,j=I-D/2,L=C+B,et=j+D;if(b||!(L<0||et<0||C>v||j>_)){if(this._collides){const Y={minX:C,minY:j,maxX:L,maxY:et};if(y.collides(Y))continue;y.insert(Y)}x.push({w:P,h:q,position:W,index:X,text:N,rotateZ:K})}}h.restore();const w=Z0(x);let M=w.w,T=w.h;l.width=M*r,l.height=T*r,h.save(),h.scale(r,r),h.textBaseline="top",h.fillStyle=d,this._shouldStroke&&(h.strokeStyle=this._strokeStyle),h.font=c+"px "+u,this.shadowColor&&(h.shadowColor=this.shadowColor,h.shadowOffsetX=this.shadowOffsetX||0,h.shadowOffsetY=this.shadowOffsetY||0,h.shadowBlur=this.shadowBlur||0);const R=[],E=[],A=[],z=[],F=[],G=[],U=[];for(let H=0,W=x.length;H<W;++H){const N=x[H];this._shouldStroke&&h.strokeText(N.text,N.x+p[0],N.y+p[1]),h.fillText(N.text,N.x+p[0],N.y+p[1]);const[X,K,$=0]=N.position;R.push(X,K,$,X,K,$,X,K,$,X,K,$),A.push(0,1,2,3),F.push(N.w,N.h,N.w,N.h,N.w,N.h,N.w,N.h);const lt=4*H;z.push(lt,lt+2,lt+1,lt,lt+3,lt+2);const yt=N.x/M,mt=(N.x+N.w)/M,bt=(N.y+N.h)/T,I=N.y/T;E.push(yt,bt,yt,I,mt,I,mt,bt),G.push(N.index,N.index,N.index,N.index),U.push(N.rotateZ,N.rotateZ,N.rotateZ,N.rotateZ)}h.restore();const k=this.geometry;k.setAttribute("position",new Z(R,3)),k.setAttribute("pIndex",new Z(A,1)),k.setAttribute("wh",new Z(F,2)),k.setAttribute("uv",new Z(E,2)),k.setAttribute("rotateZ",new Z(U,1)),k.setIndex(z),k.computeBoundingSphere(),this.makeGeometryOffsetPosition(k,R),R.length>0&&(this.texture&&this.texture.dispose(),this.texture=new Se(this.canvas),this.material.uniforms.map.value=this.texture),this.shouldUpdateRenderingData=!1,this.needsUpdate=!1}),this.parameters=t,this._collides=this.parameters.collides===void 0||this.parameters.collides,this._fontSize=this.parameters.fontSize!==void 0?this.parameters.fontSize:16,this._fontFamily=this.parameters.fontFamily!==void 0?this.parameters.fontFamily:"Microsoft Yahei",this._fillStyle=this.parameters.fillStyle!==void 0?this.parameters.fillStyle:"#f00",this._padding=this.parameters.padding!==void 0?this.parameters.padding:[2,2],this._margin=this.parameters.margin!==void 0?this.parameters.margin:[0,0],this._maxRenderDepth=this.parameters.maxRenderDepth!==void 0?this.parameters.maxRenderDepth:1,this.cachedData=[],this.shouldUpdateRenderingData=!1,this.drawingData=[];const e=this.canvas=document.createElement("canvas");e.width=e.height=1;const i=this.ctx=e.getContext("2d");i.textAlign="start",i.textBaseline="bottom",this.defineMaterialProxyProperties(["lineHeight","map","pixelOffsetX","pixelOffsetY","positionOffsetX","positionOffsetY","positionOffsetZ","backgroundColor","resolution","opacity","flat"])}initObject(){this.geometry=new gt(this.parameters),this.material=new Uw(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms),this.texture=new Se(this.canvas),this.material.uniforms.map.value=this.texture}setData(){let t=this.dataSource.data;this.cachedData=t,this.update()}update(){this.shouldUpdateRenderingData=!0,this._canRenderAll=!1}onDispose(){this.texture&&this.texture.dispose()}set collides(t){this._collides=t}get collides(){return this._collides}set fontSize(t){this._fontSize=t}get fontSize(){return this._fontSize}set fontFamily(t){this._fontFamily=t}get fontFamily(){return this._fontFamily}set fillStyle(t){this._fillStyle=t}get fillStyle(){return this._fillStyle}set strokeStyle(t){this._shouldStroke=!!t,this._strokeStyle=t}set padding(t){this._padding=t}get padding(){return this._padding}set margin(t){this._margin=t}get margin(){return this._margin}set maxRenderDepth(t){this._maxRenderDepth=t}}class Nw{constructor(t){this._rendering=t}init(){const t=this._dataSource=new _o,e=this._text=this._rendering.add(new xv);e.material.depthTest=!0,e.fillStyle="#fff",e.strokeStyle="#000",e.renderOrder=100,e.margin=[80,80],e.flat=!0,e.maxRenderDepth=.999999,e.dataSource=t,e.collides=!0,t.setAttribute("text","text"),t.setAttribute("rotateZ","rotateZ")}addLabel(t){this._dataSource.add(t)}addLabels(t){for(const e of t)this.addLabel(e);this._rendering.requestRender()}removeLabel(t){this._dataSource.remove(t)}removeLabels(t){for(const e of t)this.removeLabel(e);this._rendering.requestRender()}}class kw{constructor(t){g(this,"_needsCreate",!1),g(this,"_rendering"),g(this,"_enabled",!1),g(this,"_brightness",0),g(this,"_saturation",0),g(this,"_contrast",0),g(this,"updateComposition",(e,i,s)=>{this[e]=s;const r=this._rendering;r.useMrt&&(r.composition[i]=s)}),g(this,"createFog",()=>{const e=this._rendering;if(e.useMrt){const i=e.composition;i.useFog=!0,i.fogDensity=this._density}}),g(this,"destory",()=>{const e=this._rendering;e.useMrt&&(e.composition.useFog=!1)}),this._rendering=t}get enabled(){return this._enabled}set enabled(t){t!==this._enabled&&(this._enabled=t,this.updateComposition("_enabled","colorAdjustEnabled",t),t?this._needsCreate=!0:this.destory())}get brightness(){return this._brightness}set brightness(t){this.updateComposition("_brightness","adjustBrightnessFactor",t)}get contrast(){return this._contrast}set contrast(t){this.updateComposition("_contrast","adjustContrastFactor",t)}get saturation(){return this._saturation}set saturation(t){this.updateComposition("_saturation","adjustSaturationFactor",t)}render(){}}class Bw{constructor(){g(this,"viewMatrixWorld",new at),g(this,"viewMatrixWorldInverse",new at),g(this,"cameraMatrixWorld",new at),g(this,"cameraMatrixWorldInverse",new at),g(this,"cameraOffsetX",0),g(this,"cameraOffsetY",0)}updateCameraState(t){this.viewMatrixWorld.copy(t.matrixWorld),this.viewMatrixWorldInverse.copy(t.matrixWorldInverse)}updateCameraOffsetState(t,e,i){this.cameraMatrixWorld.copy(t.matrixWorld),this.cameraMatrixWorld.copy(t.matrixWorldInverse),this.cameraOffsetX=e,this.cameraOffsetY=i}}new De;class bv{constructor(t,e={}){g(this,"_engine"),g(this,"_outputEncoding"),g(this,"_enableAnimationLoop"),g(this,"_animationLoopFrameTime"),g(this,"_uniforms"),g(this,"_main"),g(this,"_shadow"),g(this,"_bloom"),g(this,"_ssr"),g(this,"_composition"),g(this,"_fog"),g(this,"_label"),g(this,"_colorAdjust"),g(this,"_renderState"),g(this,"_camera"),g(this,"_canvas"),g(this,"_context"),g(this,"_renderer"),g(this,"_scene"),g(this,"_weather"),g(this,"_useMrt",!1),g(this,"_mainRenderTarget",null),g(this,"_needsPrepareRendering",!0),g(this,"_needsUpdateExtraProgramCacheKey",!0),g(this,"_tDiffuse",null),g(this,"_tDepth",null),g(this,"_tEmissive",null),g(this,"_tNormal",null),g(this,"_tSpecular",null),g(this,"_isRunning",!1),g(this,"_needsRenderImmediately",!1),g(this,"_needsRenderNext",!1),g(this,"_beforeRenderListeners",[]),g(this,"_startTime",0),g(this,"_pixelRatio",window.devicePixelRatio),g(this,"_resolution"),g(this,"_sky",null),g(this,"_debugShaderType",0),g(this,"_beforeScenePrepareRenderObjects",new Set),g(this,"_beforeSceneRenderObjects",new Set),g(this,"_wireframe",!1),g(this,"_wireframeMaterial",null),g(this,"_autoOffsetRelativeCenter",!0),g(this,"handleShaderBeforeResolve",(i,s,r)=>{if(this._useMrt){const a=this._renderer.getRenderTarget();a&&a.isWebGLMultipleRenderTargets&&(s=this.convertMrtSupportedFragment(s))}return r.shaderID==="basic"&&(s=`#define BASIC
uniform vec3 emissive;
`+s),{vertexShader:i,fragmentShader:s}}),g(this,"handleShaderBeforeCompile",(i,s,r)=>{if(i=((a,o,l,h)=>{if((o||l)&&(a=a.replace("void main()",(o||"")+`void main()
`+(l||""))),h){const c=a.lastIndexOf("}");a=a.substring(0,c),a+=h+"}"}return a})(i,`
attribute float _tileEditableValue;
`,null,`
if (_tileEditableValue == 1.0) {
    gl_Position = vec4(-1.0, -1.0, -1.0, -1.0);
}
`),this._useMrt){const a=this._renderer.getRenderTarget();a&&a.isWebGLMultipleRenderTargets&&r.isRawShaderMaterial&&r.glslVersion!==Qo&&(i=["#version 300 es","precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+i,s=["#version 300 es","#define varying in","layout(location = 0) out highp vec4 pc_fragColor;","#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+s)}return{vertexShader:i,fragmentShader:s}}),g(this,"convertMrtSupportedFragment",(i,s)=>(r=>{let a=r;a=a.replace("void main() {",`#include <mvt_mrt_output_pars_fragment>
void main() {`);const o=a.lastIndexOf("}");return a=a.substring(0,o),a+=`#include <mvt_mrt_output_fragment>
}`,a})(i)),g(this,"render",()=>{if(!this._isRunning)return;requestAnimationFrame(this.render);const i=new Date().valueOf();if((this._needsRenderNext||this._enableAnimationLoop)&&this._animationLoopFrameTime<17&&(this._needsRenderImmediately=!0),!(this._needsRenderImmediately||(this._needsRenderNext||this._enableAnimationLoop)&&i-this.lastRenderTime>=this._animationLoopFrameTime))return;let s=this._needsRenderImmediately?0:i-this.lastRenderTime-this._animationLoopFrameTime;s>this._animationLoopFrameTime-16&&(s=this._animationLoopFrameTime-16),this.lastRenderTime=i-s,this._needsRenderImmediately=!1,this._needsRenderNext=!1,this.renderScene(i)}),g(this,"getExtraProgramCacheKey",()=>{if(this._useMrt){const i=this._renderer.getRenderTarget();if(i&&i.isWebGLMultipleRenderTargets)return"1"}return"0"}),g(this,"scaleZAtCurrentPosition",()=>{const i=this._engine.map,s=i.getScaleAt(i.getCenter());this.scene.scale.z=s}),this._engine=t,this._outputEncoding=e.outputEncoding||3001,this._enableAnimationLoop=e.enableAnimationLoop||!1,this._animationLoopFrameTime=e.animationLoopFrameTime||16,this._pixelRatio=e.pixelRatio||window.devicePixelRatio,this._resolution=e.resolution,this._uniforms={time:{value:0},elapsedTime:{value:0},pixelRatio:{value:this._pixelRatio},zoomUnits:{value:1},resolution:{value:new V(e.resolution.x,e.resolution.y)}},Object.freeze(this._uniforms),this._main=new JM(this),this._shadow=new KM(this),this._bloom=new ew(this),this._ssr=new vw(this),this._composition=new bw(this),this._fog=new QM(this),this._label=new Nw(this),this._colorAdjust=new kw(this),this._renderState=new Bw(this)}init(){const t=this._canvas=document.createElement("canvas");t.style.position="absolute",t.style.top="0",t.style.left="0";const e=this._context=t.getContext("webgl2",{alpha:!0}),i=this._resolution;(this._camera=new ee(35,i.x/i.y,.1,100)).matrixAutoUpdate=!1;const s=this._scene=new Pl,r=this.objectsScene=new Me,a=this.environmentScene=new Me;s.add(r),s.add(a),s.autoUpdate=!1;const o=this._renderer=new mu({alpha:!0,antialias:!0,canvas:t,logarithmicDepthBuffer:!0,context:e});o.setClearColor(16777215,0),o.setPixelRatio(this._pixelRatio),o.setSize(i.x,i.y),o.outputEncoding=this._outputEncoding,o.info.autoReset=!1,this._renderer.extraProgramCacheKey="0",o.onShaderBeforeResolve=this.handleShaderBeforeResolve,o.onShaderBeforeCompile=this.handleShaderBeforeCompile,this._uniforms.resolution.value[0]=i.x,this._uniforms.resolution.value[1]=i.y,this._label.init()}addBeforeRenderListener(t){this._beforeRenderListeners.indexOf(t)===-1&&this._beforeRenderListeners.push(t)}removeBeforeRenderListener(t){const e=this._beforeRenderListeners.indexOf(t);e>-1&&this._beforeRenderListeners.splice(e,1)}add(t){return t.traverse(e=>{e.afterAddToEngine&&!e.__initInEngine&&(e.__initInEngine=!0,e.afterAddToEngine(this._engine)),e instanceof jr?this._sky=e:e instanceof Ld&&(this._weather=e),this.addBeforePrepareRenderObject(e),this.addBeforeRenderObject(e)}),t.__isEnvironment?this.environmentScene.add(t):this.objectsScene.add(t),this._needsRenderImmediately=!0,t}remove(t){t.traverse(e=>{e.beforeRemoveFromEngine&&(e.__initInEngine=void 0,e.beforeRemoveFromEngine(this._engine)),e instanceof jr?this._sky=null:e instanceof Ld&&(this._weather=null),this.removeBeforeRenderObject(e),this.removeBeforePrepareRenderObject(e)}),t.__isEnvironment?this.environmentScene.remove(t):this.objectsScene.remove(t),this._needsRenderImmediately=!0}addBeforePrepareRenderObject(t){t.onBeforeScenePrepareRender&&this._beforeScenePrepareRenderObjects.add(t)}removeBeforePrepareRenderObject(t){this._beforeScenePrepareRenderObjects.delete(t)}addBeforeRenderObject(t){t.onBeforeSceneRender&&this._beforeSceneRenderObjects.add(t)}removeBeforeRenderObject(t){this._beforeSceneRenderObjects.delete(t)}startRenderLoop(){this._isRunning=!0,this._needsRenderImmediately=!0,this._startTime=new Date().valueOf(),this.render()}stopRenderLoop(){this._isRunning=!1}updateCamera(){this._engine.map.updateCamera()}requestRender(){this._needsRenderImmediately=!0}renderScene(t){const e=this._engine;t||(t=new Date().valueOf()),this._uniforms.time.value=t,this._uniforms.elapsedTime.value=t-this._startTime,this._uniforms.zoomUnits.value=this._engine.map.getZoomUnits(),this.camera._isLocked||this.updateCamera(),e.event.executeMousemoveRaycast();const i=this._camera,s=this._scene;this._renderState.time=t,this._renderState.updateCameraState(this._camera);for(let u of this._beforeRenderListeners)u(this._engine,t);this._beforeScenePrepareRenderObjects.forEach(u=>{u.onBeforeScenePrepareRender(e,s,i,this._renderState)});const r=new S(i.matrix.elements[12],i.matrix.elements[13],i.matrix.elements[14]);let a=0,o=0;const l=1e3,h=Math.floor(r.x/l)*l,c=Math.floor(r.y/l)*l;a=r.x-h,o=r.y-c,this._autoOffsetRelativeCenter&&(i.position.set(a,o,r.z),i.updateMatrix(),i.updateMatrixWorld(),s.position.set(-h,-c,0)),this._renderState.updateCameraOffsetState(i,h,c),s.updateMatrix(),s.updateMatrixWorld(),this._renderer.info.reset(),this._beforeSceneRenderObjects.forEach(u=>{u.onBeforeSceneRender(e,s,i,[h,c])}),this._renderer.extraProgramCacheKey=this._useMrt?"1":"0",this._main.render(),this._renderer.extraProgramCacheKey="0",this._bloom.render(),this._ssr.render(),this._composition.render(),this._fog.render(),this._autoOffsetRelativeCenter&&(i.position.set(r.x,r.y,r.z),i.updateMatrix(),i.updateMatrixWorld(),s.position.set(0,0,0),s.updateMatrix(),s.updateMatrixWorld())}setResolution(t){this._resolution.copy(t),this._uniforms.resolution.value.copy(t),this._renderer.setSize(t.x,t.y),this._main.setSize(t.x,t.y),this._bloom.setSize(t.x,t.y),this._ssr.setSize(t.x,t.y),this._needsRenderNext=!0}dispose(){this.stopRenderLoop(),this._wireframeMaterial&&this._wireframeMaterial.dispose();const t=Array.from(this.objectsScene.children),e=Array.from(this.environmentScene.children);for(const s of t)this.remove(s),s.dispose&&s.dispose();for(const s of e)this.remove(s),s.dispose&&s.dispose();this._renderer.dispose();let i=this._context.getExtension("WEBGL_lose_context");i&&i.loseContext()}get sky(){return this._sky}get weather(){return this._weather}get debugShaderType(){return this._debugShaderType}set debugShaderType(t){if(this._debugShaderType=t,!this._useMrt)return;t=parseInt(t,10);const e=this._composition;if(t&&t!==0)if(t===1)e.debugTextures=this._main.getTextures();else if(t===2){const i=[];this.objectsScene.traverse(s=>{s.isLight&&s.shadow&&s.shadow.map&&i.push(s.shadow.map.texture)}),e.debugTextures=i}else t===3?e.debugTextures=this._bloom.getTextures():t===4?e.debugTextures=this._ssr.getTextures():t===5&&this._sky&&this._sky.getTextures&&(e.debugTextures=this._sky.getTextures());else e.debugTextures=null}get useMrt(){return this._useMrt}set useMrt(t){this._useMrt!==t&&(this._useMrt=t,this._main.useMrt=t,this._bloom.useMrt=t,this._ssr.useMrt=t,this._composition.useMrt=t,this._needsUpdateExtraProgramCacheKey=!0)}get main(){return this._main}get shadow(){return this._shadow}get bloom(){return this._bloom}get ssr(){return this._ssr}get composition(){return this._composition}get fog(){return this._fog}get label(){return this._label}get colorAdjust(){return this._colorAdjust}get renderState(){return this._renderState}get enableAnimationLoop(){return this._enableAnimationLoop}set enableAnimationLoop(t){this._enableAnimationLoop=t}get animationLoopFrameTime(){return this._animationLoopFrameTime}set animationLoopFrameTime(t){this._animationLoopFrameTime=t}get resolution(){return this._resolution}set resolution(t){this._resolution=t}get pixelRatio(){return this._pixelRatio}set pixelRatio(t){this._pixelRatio=t}get outputEncoding(){return this._outputEncoding}set outputEncoding(t){this._outputEncoding=t}get canvas(){return this._canvas}get renderer(){return this._renderer}get camera(){return this._camera}get scene(){return this._scene}get uniforms(){return this._uniforms}set wireframe(t){t?(this._wireframe=!0,this._wireframeMaterial||(this._wireframeMaterial=new Zt({color:35071,wireframe:!0})),this._scene.overrideMaterial=this._wireframeMaterial):(this._wireframe=!1,this._scene.overrideMaterial=null)}get wireframe(){return this._wireframe}get autoOffsetRelativeCenter(){return this._autoOffsetRelativeCenter}set autoOffsetRelativeCenter(t){this._autoOffsetRelativeCenter=t}}const He=class{constructor(n){g(this,"_realtimePickEnabled",!1),g(this,"_mousePickNeedsUpdate",!1),g(this,"_mouse",new V),g(this,"_mousePosition",new V),g(this,"_eventMaps",{}),g(this,"_objectEvents",new Map),g(this,"_raycaster",new Rs),g(this,"_intersections"),g(this,"_defaultEventObject"),g(this,"_mousePickParams",null),g(this,"_lastMousePickIntersectParams",null),g(this,"_engine",null),g(this,"_pickEventNames",null),g(this,"_checkShouldEnableRealtimePick",()=>{let t=null;for(const e of Object.keys(this._eventMaps))if(this._pickEventNames[e]&&(t=this._eventMaps[e],t&&t.size>0))return void(this._realtimePickEnabled=!0);this._realtimePickEnabled=!1}),g(this,"_raycast",()=>{const t=this._engine;this._raycaster.setFromCamera(this._mouse,t.camera),this._raycaster.mouse.copy(this._mouse);const e=this._raycaster.intersectObjects(t.rendering.objectsScene.children,!0);this._intersections=e}),g(this,"get3DTilesObject",t=>{for(;t&&!t.is3DTiles;)t=t.parent;return t}),g(this,"get3DTilesPropertiesByBatchId",(t,e)=>{let i=t;for(;!i.batchTable;)i=i.parent;if(!i)return void console.warn("batch table not found");const s=i.batchTable,r={};for(const a of Object.keys(s.header)){const o=s.header[a];r[a]=o[e]}return r._tileUri=i._tileUri,r.tile=i,r}),g(this,"triggerFirstEventObject",(t,e)=>{if(!this._intersections||this._intersections.length===0||!this._eventMaps[t])return!1;const i=this._eventMaps[t];for(let s=0,r=this._intersections.length;s<r;++s){const a=this._intersections[s],o=a.object;if(!o.visible)continue;let l=this._getEventProxyObject(o);if(!l.visible)continue;const h=o.geometry.getAttribute("_batchid");let c=!1,u=!1,d=null;if(h){const p=this.get3DTilesObject(o);p&&(l=p,c=!0)}else{const p=this.get3DTilesObject(o);p&&(u=!0,d=l,l=p)}if(i.has(l)){if(e.object=l,a.point&&this._correctHitPosition(a.point,e),c){const m=h.getX(a.face.a);e.entity=this.get3DTilesPropertiesByBatchId(o,m)}else u?d.isEventEntitySupported&&(e.entity=this._getEventEntity(d,a)):l.isEventEntitySupported&&(e.entity=this._getEventEntity(l,a));e.directObject=o;const p=i.get(l);for(const m of p)m(e);return!0}}return!1}),g(this,"_getEventEntity",(t,e)=>{let i=-1;return e.instanceId!==void 0?i=e.instanceId:e.face!==void 0&&e.face!==null?t.getEntityIndexByFace&&(i=t.getEntityIndexByFace(e.faceIndex,e.face.a)):e.index!==void 0&&(i=e.index),i<0?null:t.getEntityByIndex(i)}),g(this,"_getEventProxyObject",t=>{for(;t.__eventProxyObject||t.__eventProxyByParent;)t=t.__eventProxyByParent?t.parent:t.__eventProxyObject;return t}),g(this,"_correctHitPosition",(t,e)=>{const i=[t.x,t.y,t.z],s=this._engine.map._map.normalizeEarthPointArr(i);s[2]=i[2],e.point=s,e.position=i}),g(this,"_handleClick",t=>{if(this._updateMouse(t),this._raycast(),this.triggerFirstEventObject(He.EVENT_NAME_CLICK,t)&&t.event.defaultPrevented)return;const e=this._eventMaps.click&&this._eventMaps.click.get(this._defaultEventObject);if(e)for(const i of e)i(t)}),g(this,"_handleDblClick",t=>{if(this._updateMouse(t),this._raycast(),this.triggerFirstEventObject(He.EVENT_NAME_DOUBLE_CLICK,t)&&t.event.defaultPrevented)return;const e=this._eventMaps.dblclick&&this._eventMaps.dblclick.get(this._defaultEventObject);if(e)for(const i of e)i(t)}),g(this,"_handleRightClick",t=>{if(this._updateMouse(t),this._raycast(),this.triggerFirstEventObject(He.EVENT_NAME_RIGHT_CLICK,t)&&t.event.defaultPrevented)return;const e=this._eventMaps.rightclick&&this._eventMaps.rightclick.get(this._defaultEventObject);if(e)for(const i of e)i(t)}),g(this,"_handleRightDblClick",t=>{if(this._updateMouse(t),this._raycast(),this.triggerFirstEventObject(He.EVENT_NAME_RIGHT_DOUBLE_CLICK,t)&&t.event.defaultPrevented)return;const e=this._eventMaps.rightdblclick&&this._eventMaps.rightdblclick.get(this._defaultEventObject);if(e)for(const i of e)i(t)}),g(this,"_updateMouse",t=>{const e=this._engine.map.getResolution(),i=t.pixel[0]/e.x,s=t.pixel[1]/e.y;this._mouse.set(2*i-1,1-2*s),this._mousePosition.set(t.pixel[0],t.pixel[1])}),g(this,"_triggerMouseleaveEvent",()=>{const t=this._lastMousePickIntersectParams,e=t.object;if(!e)return;const i=this._objectEvents.get(e);i&&i[He.EVENT_NAME_MOUSE_LEAVE]&&this._triggerCallbacks(i[He.EVENT_NAME_MOUSE_LEAVE],{...this._mousePickParams,object:t.object,entity:t.entity})}),g(this,"_isSameObjectAndEntity",(t,e)=>{const i=t.object,s=e.object,r=t.entity,a=e.entity;return i===s&&(r===void 0&&a===void 0||r!==void 0&&a!==void 0&&(r.index===void 0||r.index===a.index))}),g(this,"_triggerCallbacks",(t,e)=>{if(t)for(const i of t)i(e)}),g(this,"_getMouseHoverIntersetion",()=>{if(!this._intersections||this._intersections.length===0)return!1;const t=this._mousePickParams;for(let e=0,i=this._intersections.length;e<i;++e){const s=this._intersections[e],r=s.object;if(!r.visible)continue;let a=this._getEventProxyObject(r);if(!a.visible)continue;const o=r.geometry.getAttribute("_batchid");let l=!1;if(o){const c=this.get3DTilesObject(r);c&&(a=c,l=!0)}else{const c=this.get3DTilesObject(r);c&&(a=c)}let h=null;if(this._objectEvents.has(a)&&(h=this._objectEvents.get(a)),h&&(h[He.EVENT_NAME_MOUSE_MOVE]||h[He.EVENT_NAME_MOUSE_ENTER]||h[He.EVENT_NAME_MOUSE_LEAVE])){if(t.object=a,s.point&&this._correctHitPosition(s.point,t),l){const c=o.getX(s.face.a);t.entity=this.get3DTilesPropertiesByBatchId(r,c)}else a.isEventEntitySupported&&(t.entity=this._getEventEntity(a,s));return h}}}),this._engine=n,this._defaultEventObject={},this._raycaster.mouse=new V,this._pickEventNames={[He.EVENT_NAME_MOUSE_MOVE]:!0,[He.EVENT_NAME_MOUSE_ENTER]:!0,[He.EVENT_NAME_MOUSE_LEAVE]:!0}}bind(n,t,e){typeof n=="string"&&(e=t,t=n,n=this._defaultEventObject),this._eventMaps[t]||(this._eventMaps[t]=new Map);const i=this._eventMaps[t];i.has(n)||i.set(n,[]);const s=i.get(n);s.indexOf(e)===-1&&s.push(e),this._objectEvents.has(n)||this._objectEvents.set(n,{});const r=this._objectEvents.get(n);r[t]||(r[t]=s),this._checkShouldEnableRealtimePick()}unbind(n,t,e){typeof n=="string"&&(e=t,t=n,n=this._defaultEventObject);const i=this._eventMaps[t];let s=!1;if(i&&i.has(n)){const r=i.get(n),a=r.indexOf(e);a>-1&&r.splice(a,1),r.length===0&&(i.delete(n),s=!0)}if(s){const r=this._objectEvents.get(n);r&&delete r[t]}this._checkShouldEnableRealtimePick()}markEventProxy(n,t){const e=t||n;if(n.children)for(let i=0,s=n.children.length;i<s;i++)n.children[i].__eventProxyObject=e,this.markEventProxy(n.children[i])}requestMousemoveRaycast(n){this._realtimePickEnabled&&(this._updateMouse(n),this._mousePickParams=n,this._mousePickNeedsUpdate=!0,this._engine.requestRender())}executeMousemoveRaycast(){if(!this._mousePickNeedsUpdate)return;this._mousePickNeedsUpdate=!1,this._raycast();const n=this._getMouseHoverIntersetion();if(n){if(this._triggerCallbacks(n[He.EVENT_NAME_MOUSE_MOVE],this._mousePickParams),this._lastMousePickIntersectParams&&this._isSameObjectAndEntity(this._mousePickParams,this._lastMousePickIntersectParams))return void(this._lastMousePickIntersectParams=this._mousePickParams);this._lastMousePickIntersectParams&&this._triggerMouseleaveEvent(),this._triggerCallbacks(n[He.EVENT_NAME_MOUSE_ENTER],this._mousePickParams),this._lastMousePickIntersectParams=this._mousePickParams}else this._lastMousePickIntersectParams&&this._triggerMouseleaveEvent(),this._lastMousePickIntersectParams=null}dispose(){}};let ji=He;g(ji,"EVENT_NAME_CLICK","click"),g(ji,"EVENT_NAME_DOUBLE_CLICK","dblclick"),g(ji,"EVENT_NAME_RIGHT_CLICK","rightclick"),g(ji,"EVENT_NAME_RIGHT_DOUBLE_CLICK","rightdblclick"),g(ji,"EVENT_NAME_MOUSE_MOVE","mousemove"),g(ji,"EVENT_NAME_MOUSE_ENTER","mouseenter"),g(ji,"EVENT_NAME_MOUSE_LEAVE","mouseleave"),g(ji,"EVENT_NAME_MOUSE_DOWN","mousedown"),g(ji,"EVENT_NAME_MOUSE_UP","mouseup");class qd{init(){}parsePointToArr(t){if(!t)return null;let e=[];if(Array.isArray(t))for(let i of t)e.push(parseFloat(i));else if(typeof t=="string"){const i=t.split(",");for(let s=0;s<i.length;s++)e[s]=parseFloat(i[s])}return e}projectPointArr(t,e){}projectGeoJSON(t){if(t){if(t.type==="FeatureCollection"||t.features){const e=t.features;for(const i of e)this.projectGeoJSON(i)}else if(Array.isArray(t)){const e=t;for(const i of e)this.projectGeoJSON(i)}else if((t.type==="Feature"||t.geometry)&&Array.isArray(t.geometry.coordinates)){if(t.geometry[this.projectionCoordsName])return;const e=this.projectCoordinates(t.geometry.coordinates);t.geometry[this.projectionCoordsName]=e}}}projectCoordinates(t){if(Array.isArray(t[0])){const e=[];for(let i of t)e.push(this.projectCoordinates(i));return e}if(typeof t[0]=="number"||typeof t[0]=="string")return this.projectPointArr(t)}dispose(){}}const ia=0,Mv=1,wv=2,Mo=new V,Sv=new Rs,Vw=new ri(new S(0,0,1),0),Os=new S,Xd=new S,wo=new S,Yd=new ee;Yd.fov=35;class Gw{constructor(t){g(this,"map"),g(this,"currentAction"),g(this,"startX"),g(this,"startY"),g(this,"startCenterX"),g(this,"startCenterY"),g(this,"startPitch"),g(this,"startHeading"),g(this,"startZoom"),g(this,"startZoomUnits"),g(this,"startAtTop"),g(this,"mapWidth"),g(this,"mapHeight"),g(this,"startCamera",new ee),g(this,"startCenter",new S),g(this,"startNdc",new V),g(this,"startPoint",new S),g(this,"startScaleX",1),g(this,"startScaleY",1),g(this,"startBoundX"),g(this,"startBoundY"),g(this,"_enabled",!1),g(this,"minPitch",0),g(this,"maxPitch",89),g(this,"zoomSpeed",.005),g(this,"headingSpeed",.4),g(this,"pitchSpeed",.3),g(this,"doubleClickTimer",null),g(this,"clickInterval",200),g(this,"init",()=>{const e=this.map.domContainer;e.addEventListener("mousedown",this.handleMouseDown),e.addEventListener("wheel",this.handleWheel),e.addEventListener("contextmenu",this.handleContextMenu),e.addEventListener("mousemove",this.handleMouseMove)}),g(this,"handleMouseMove",e=>{this.currentAction===ia&&this.onEventMouseMove&&this.onEventMouseMove(e)}),g(this,"handleMouseDown",e=>{const[i,s]=this.map.getContainerSize();this.mapWidth=i,this.mapHeight=s;const r=this.map.domContainer.getBoundingClientRect();this.startBoundX=r.left,this.startBoundY=r.top,this.startScaleX=r.width/i,this.startScaleY=r.height/s;const a=(e.clientX-this.startBoundX)/this.startScaleX,o=(e.clientY-this.startBoundY)/this.startScaleY;if(e.button===0?(this.startZoomUnits=this.map.getZoomUnitsByZoom(this.map.zoom),this.setPanStartState(a,o),this.currentAction=Mv):e.button===2?this.currentAction=wv:this.currentAction=ia,this.currentAction===ia)return;this.startX=a,this.startY=o;const l=this.map;this.startCenterX=l.center[0],this.startCenterY=l.center[1],this.startPitch=l.pitch,this.startHeading=l.heading,this.startZoom=l.zoom,this.startAtTop=o<s/2,document.addEventListener("mousemove",this.handleMouseDragging),document.addEventListener("mouseup",this.handleMouseUp)}),g(this,"handleMouseDragging",e=>{if(this.currentAction===ia)return;this.hasMoved=!0;const i=this.currentPixelX=(e.clientX-this.startBoundX)/this.startScaleX,s=this.currentPixelY=(e.clientY-this.startBoundY)/this.startScaleY;this.currentAction===Mv?this.handlePan(i,s):this.currentAction===wv&&this.handleRotate(i,s)}),g(this,"handleMouseUp",e=>{this.currentAction=ia,document.removeEventListener("mousemove",this.handleMouseDragging),document.removeEventListener("mouseup",this.handleMouseUp),e&&this.onEventClick&&(this.hasMoved||this.onEventClick(e)),e&&this.onEventDblClick&&(!this.hasMoved&&this.waitSecondClick?(this.onEventDblClick(e),this.clearDoubleClickTimer()):this.waitSecondClick=!0),clearTimeout(this.doubleClickTimer),this.doubleClickTimer=setTimeout(()=>{this.clearDoubleClickTimer()},this.clickInterval),this.hasMoved=!1}),g(this,"clearDoubleClickTimer",()=>{this.doubleClickTimer&&clearTimeout(this.doubleClickTimer),this.waitSecondClick=!1,this.doubleClickTimer=null}),g(this,"handleContextMenu",e=>{e.preventDefault()}),g(this,"handleWheel",e=>{e.preventDefault(),e.stopPropagation();const[i,s]=this.map.getContainerSize();this.mapWidth=i,this.mapHeight=s,this.handleZoom({deltaX:e.deltaX,deltaY:e.deltaY,pixelX:e.offsetX,pixelY:e.offsetY})}),g(this,"handlePan",(e,i)=>{const s=this.map;this.getNdc(e,i,Mo),this.ndcToPoint(Mo,this.startCamera,wo),wo.distanceTo(this.startCamera.position)>6e3*s.zoomUnits?this.handleMouseUp():(Os.subVectors(this.startCenter,wo.sub(this.startPoint)),s.center=[Os.x,Os.y],s.updateView())}),g(this,"setPanStartState",(e,i)=>{const s=this.map;this.startCamera.copy(s.camera),this.startCamera.updateMatrixWorld(),this.startCenter.set(s.center[0],s.center[1],0),this.getNdc(e,i,this.startNdc),this.ndcToPoint(this.startNdc,s.camera,this.startPoint)}),g(this,"handleRotate",(e,i)=>{const s=this.map;let r=e-this.startX;const a=i-this.startY;this.startAtTop||(r*=-1);let o=this.startHeading+r*this.headingSpeed;o=this.makeHeadingSafe(o),s.heading=o;let l=this.startPitch+a*this.pitchSpeed;l=this.makePitchSafe(l),s.pitch=l,s.updateView()}),g(this,"handleZoom",e=>{const i=this.map;let s=i.zoom,r=s+e.deltaY*this.zoomSpeed*-1;if(s===r)return;if(r=this.makeZoomSafe(r),r<i.earthViewZoomMax)return this.map.zoom=r,void this.map.updateView();let a=i.center,o=i.pitch,l=i.heading;this.getNdc(e.pixelX,e.pixelY,Mo),Os.set(a[0],a[1],0),this.ndcToPoint(Mo,i.camera,Xd),Xd.distanceTo(i.camera.position)>6e3*i.zoomUnits||(i.computeMapCameraMatrix(Yd,a,r,o,l),this.ndcToPoint(Mo,Yd,wo),Os.sub(wo.sub(Xd)),this.map.center[0]=Os.x,this.map.center[1]=Os.y,this.map.zoom=r,this.map.updateView())}),g(this,"makeZoomSafe",e=>e>this.map.maxZoom?this.map.maxZoom:e<this.map.minZoom?this.map.minZoom:e),g(this,"makeHeadingSafe",e=>((e%=360)<0&&(e+=360),e)),g(this,"makePitchSafe",e=>e<this.minPitch?this.minPitch:e>this.maxPitch?this.maxPitch:e),g(this,"dispose",()=>{const e=this.map.domContainer;e.removeEventListener("mousedown",this.handleMouseDown),e.removeEventListener("wheel",this.handleWheel),e.removeEventListener("contextmenu",this.handleContextMenu),document.removeEventListener("mousemove",this.handleMouseDragging),document.removeEventListener("mouseup",this.handleMouseUp),e.removeEventListener("mousemove",this.handleMouseMove),this.clearDoubleClickTimer()}),this.map=t,this.enabled=!0,this.currentAction=ia}set enabled(t){t!==this._enabled&&(t?this.init():this.dispose(),this._enabled=t)}ndcToPoint(t,e,i){Sv.setFromCamera(t,e),Sv.ray.intersectPlane(Vw,i)}getNdc(t,e,i){i.x=t/this.mapWidth*2-1,i.y=1-e/this.mapHeight*2}}var zs={},na={},Tv={};(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var t=1;n.default=function(){return"".concat(t++)}})(Tv);var Bh={},Vh={},Zd={};(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0,n.default=function(t){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:60,i=null;return function(){for(var s=this,r=arguments.length,a=new Array(r),o=0;o<r;o++)a[o]=arguments[o];clearTimeout(i),i=setTimeout(function(){t.apply(s,a)},e)}}})(Zd);var Cn={};Object.defineProperty(Cn,"__esModule",{value:!0}),Cn.SensorTabIndex=Cn.SensorClassName=Cn.SizeSensorId=void 0,Cn.SizeSensorId="size-sensor-id",Cn.SensorClassName="size-sensor-object",Cn.SensorTabIndex="-1",Object.defineProperty(Vh,"__esModule",{value:!0}),Vh.createSensor=void 0;var Gh,jw=(Gh=Zd)&&Gh.__esModule?Gh:{default:Gh},Ev=Cn;Vh.createSensor=function(n){var t=void 0,e=[],i=(0,jw.default)(function(){e.forEach(function(r){r(n)})}),s=function(){t&&t.parentNode&&(t.contentDocument&&t.contentDocument.defaultView.removeEventListener("resize",i),t.parentNode.removeChild(t),t=void 0,e=[])};return{element:n,bind:function(r){t||(t=function(){getComputedStyle(n).position==="static"&&(n.style.position="relative");var a=document.createElement("object");return a.onload=function(){a.contentDocument.defaultView.addEventListener("resize",i),i()},a.style.display="block",a.style.position="absolute",a.style.top="0",a.style.left="0",a.style.height="100%",a.style.width="100%",a.style.overflow="hidden",a.style.pointerEvents="none",a.style.zIndex="-1",a.style.opacity="0",a.setAttribute("class",Ev.SensorClassName),a.setAttribute("tabindex",Ev.SensorTabIndex),a.type="text/html",n.appendChild(a),a.data="about:blank",a}()),e.indexOf(r)===-1&&e.push(r)},destroy:s,unbind:function(r){var a=e.indexOf(r);a!==-1&&e.splice(a,1),e.length===0&&t&&s()}}};var jh={};Object.defineProperty(jh,"__esModule",{value:!0}),jh.createSensor=void 0;var Hw=function(n){return n&&n.__esModule?n:{default:n}}(Zd);jh.createSensor=function(n){var t=void 0,e=[],i=(0,Hw.default)(function(){e.forEach(function(r){r(n)})}),s=function(){t.disconnect(),e=[],t=void 0};return{element:n,bind:function(r){var a;t||((a=new ResizeObserver(i)).observe(n),i(),t=a),e.indexOf(r)===-1&&e.push(r)},destroy:s,unbind:function(r){var a=e.indexOf(r);a!==-1&&e.splice(a,1),e.length===0&&t&&s()}}},Object.defineProperty(Bh,"__esModule",{value:!0}),Bh.createSensor=void 0;var Ww=Vh,qw=typeof ResizeObserver<"u"?jh.createSensor:Ww.createSensor;Bh.createSensor=qw,Object.defineProperty(na,"__esModule",{value:!0}),na.removeSensor=na.getSensor=void 0;var Xw=function(n){return n&&n.__esModule?n:{default:n}}(Tv),Yw=Bh,Hh=Cn,So={};na.getSensor=function(n){var t=n.getAttribute(Hh.SizeSensorId);if(t&&So[t])return So[t];var e=(0,Xw.default)();n.setAttribute(Hh.SizeSensorId,e);var i=(0,Yw.createSensor)(n);return So[e]=i,i},na.removeSensor=function(n){var t=n.element.getAttribute(Hh.SizeSensorId);n.element.removeAttribute(Hh.SizeSensorId),n.destroy(),t&&So[t]&&delete So[t]},Object.defineProperty(zs,"__esModule",{value:!0}),zs.ver=Kd=zs.clear=Cv=zs.bind=void 0;var Jd=na,Cv=zs.bind=function(n,t){var e=(0,Jd.getSensor)(n);return e.bind(t),function(){e.unbind(t)}},Kd=zs.clear=function(n){var t=(0,Jd.getSensor)(n);(0,Jd.removeSensor)(t)};zs.ver="1.0.1";const xi=new Rs,sa=new ri(new S(0,0,1),0),ts=new S,Av=new at,bi=new Ot,Zw=new V(-1,.9),Jw=new V(1,.9),Kw=new V(1,-1),Mi=new S;class Qd extends qd{constructor(t,e,i){super(e,i),g(this,"isBlankMap",!0),g(this,"MERCATOR_LENGTH",200375083427892e-7),g(this,"projectionCoordsName","_web_mercator"),g(this,"origin",[0,0]),g(this,"center",[0,0]),g(this,"pitch",0),g(this,"heading",0),g(this,"bounds",[[-this.MERCATOR_LENGTH,-this.MERCATOR_LENGTH],[this.MERCATOR_LENGTH,this.MERCATOR_LENGTH]]),g(this,"near",.1),g(this,"_far",38e3),g(this,"fov",35),g(this,"handleViewChange",()=>{this.onViewChanged&&this.onViewChanged()}),g(this,"handleMapResize",()=>{this.onResolutionChanged&&this.onResolutionChanged(this.getResolution())}),g(this,"handleEventClick",s=>{const r=this._engine,a=r.event,o=r.rendering.canvas.getBoundingClientRect(),l=s.clientX-o.left,h=s.clientY-o.top,c=l/o.width*2-1,u=1-2*h/o.height;xi.setFromCamera({x:c,y:u},r.rendering.camera),xi.ray.intersectPlane(sa,ts);const d=[l,h],p=[ts.x,ts.y,ts.z],m=this.normalizeEarthPointArr(p);s.button===2?a._handleRightClick({pixel:d,point:m,position:p,event:s}):a._handleClick({pixel:d,point:m,position:p,event:s})}),g(this,"handleEventDblClick",s=>{const r=this._engine,a=r.event,o=r.rendering.canvas.getBoundingClientRect(),l=s.clientX-o.left,h=s.clientY-o.top,c=l/o.width*2-1,u=1-2*h/o.height;xi.setFromCamera({x:c,y:u},r.rendering.camera),xi.ray.intersectPlane(sa,ts);const d=[l,h],p=[ts.x,ts.y,ts.z],m=this.normalizeEarthPointArr(p);s.button===2?a._handleRightDblClick({pixel:d,point:m,position:p,event:s}):a._handleDblClick({pixel:d,point:m,position:p,event:s})}),g(this,"handleEventMouseMove",s=>{this._engine.event.requestMousemoveRaycast({pixel:this._getPixelFromEvent(s),event:s})}),g(this,"_getPixelFromEvent",s=>{const r=this._engine.rendering.canvas.getBoundingClientRect();return[s.clientX-r.left,s.clientY-r.top]}),this._engine=t,this.domContainer=e}afterInit(){this.domContainer.appendChild(this.canvas),this.camera.matrixAutoUpdate=!1,this.handleMapResize(),Cv(this.domContainer,this.handleMapResize),this.initControl()}initControl(){this.control=new Gw(this),this.control.onEventClick=this.handleEventClick,this.control.onEventDblClick=this.handleEventDblClick,this.control.onEventMouseMove=this.handleEventMouseMove}getContainerSize(){return[this.domContainer.clientWidth,this.domContainer.clientHeight]}getResolution(){return new V(this.domContainer.clientWidth,this.domContainer.clientHeight)}getCenter(){return this.normalizeEarthPointArr(this.center)}getZoom(){return this.zoom}getPitch(){return this.pitch}getZoomUnitsByZoom(t){return this.MERCATOR_LENGTH/128/Math.pow(2,t)}getZoomByZoomUnits(t){return Math.log2(this.MERCATOR_LENGTH/128/t)}getZoomUnits(){return this.getZoomUnitsByZoom(this.zoom)}getHeading(){return this.heading}enableControl(){this.control.enabled=!0}disableControl(){this.control.enabled=!1}setCameraMatrix(){this.handleViewChange()}updateCamera(){this.computeMapCameraMatrix(this.camera,this.center,this.zoom,this.pitch,this.heading)}computeMapCameraMatrix(t,e,i,s,r){const[a,o]=this.getContainerSize();let l=this.zoomUnits=this.getZoomUnitsByZoom(i);if(a*l>this.bounds[1][0]-this.bounds[0][0]){let u=(this.bounds[1][0]-this.bounds[0][0])/a;l=this.zoomUnits=u,this.zoom=this.getZoomByZoomUnits(u)}if(o*l>this.bounds[1][1]-this.bounds[0][1]){let u=(this.bounds[1][1]-this.bounds[0][1])/o;l=this.zoomUnits=u,this.zoom=this.getZoomByZoomUnits(u)}e[0]-a/2*l<this.bounds[0][0]&&(e[0]=this.bounds[0][0]+a/2*l),e[0]+a/2*l>this.bounds[1][0]&&(e[0]=this.bounds[1][0]-a/2*l),e[1]-o/2*l<this.bounds[0][1]&&(e[1]=this.bounds[0][1]+o/2*l),e[1]+o/2*l>this.bounds[1][1]&&(e[1]=this.bounds[1][1]-o/2*l),this.center=e;const h=o/2/Math.tan(this.fov/2*Math.PI/180)*l;this.cameraDistance=h,t.position.set(0,0,0),t.quaternion.set(0,0,0,1),t.up.set(0,0,1),t.translateX(e[0]),t.translateY(e[1]),e[2]&&t.translateZ(e[2]),t.rotateOnAxis(new S(0,0,1),r*Math.PI/180),t.rotateOnAxis(new S(1,0,0),s*Math.PI/180),t.translateZ(h),t.updateMatrix(),t.updateMatrixWorld(),t.aspect=a/o;let c=l;c<1&&(c=1),t.near=this.near,t.far=this._far*c,t.updateProjectionMatrix()}setCenter(t){const e=this.normalizeMapPoint(t);e&&(this.center=e),this.setCameraMatrix()}setProjectionCenter(t){const e=this.normalizeEarthPointArr(t);this.setCenter(e)}setZoom(t){isNaN(t)||(this.zoom=t),this.setCameraMatrix()}setHeading(t){this.heading=t,this.setCameraMatrix()}setPitch(t){this.pitch=t,this.setCameraMatrix()}setBounds(t){this.bounds=[this.projectPointArr(t[0]),this.projectPointArr(t[1])]}getBoundsOld(){const t=[],e=new V,i=Ie.mapLinear(Ie.clamp(Math.abs(90-this.pitch),0,50),0,50,.1,1);e.set(-1,-1*i),xi.setFromCamera(e,this.camera),xi.ray.intersectPlane(sa,Mi);const s=Mi.x,r=Mi.y;e.set(-1,1*i),xi.setFromCamera(Zw,this.camera),xi.ray.intersectPlane(sa,Mi);const a=Mi.x,o=Mi.y;e.set(1,1*i),xi.setFromCamera(Jw,this.camera),xi.ray.intersectPlane(sa,Mi);const l=Mi.x,h=Mi.y;e.set(1,-1*i),xi.setFromCamera(Kw,this.camera),xi.ray.intersectPlane(sa,Mi);const c=Mi.x,u=Mi.y;t[0]=Math.min(s,a,l,c),t[1]=Math.min(r,o,h,u),t[2]=Math.max(s,a,l,c),t[3]=Math.max(r,o,h,u);const d=this.normalizeEarthPointArr([t[0],t[1]]),p=this.normalizeEarthPointArr([t[2],t[3]]);return new Ne(new S(d[0],d[1],0),new S(p[0],p[1],0))}getBounds(){const t=this.camera;Av.multiplyMatrices(t.matrixWorld,t.projectionMatrixInverse);let e=1/0,i=1/0,s=-1/0,r=-1/0;[[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]].forEach(l=>{bi.set(l[0],l[1],l[2],1),bi.applyMatrix4(Av),bi.divideScalar(bi.w),bi.x<e&&(e=bi.x),bi.x>s&&(s=bi.x),bi.y<i&&(i=bi.y),bi.y>r&&(r=bi.y)});const a=this.normalizeEarthPointArr([e,i]),o=this.normalizeEarthPointArr([s,r]);return new Ne(new S(a[0],a[1],0),new S(o[0],o[1],0))}normalizeMapPoint(t){return this.normalizeProjectionPointArr(t)}normalizeProjectionPointArr(t){let e=this.parsePointToArr(t),i=$r(e);return i[0]-=this.origin[0],i[1]-=this.origin[1],e[2]!==void 0&&(i[2]=e[2]),i}normalizeEarthPointArr(t){let e=this.parsePointToArr(t);e[0]+=this.origin[0],e[1]+=this.origin[1];let i=hv(e);return e[2]!==void 0&&(i[2]=e[2]),i}projectPointArr(t,e){if(!t)return e;let i=null;return i=t[0]>180||t[1]>90?[t[0],t[1]]:$r(t),t[2]!==void 0&&(i[2]=t[2]),i[0]-=this.origin[0],i[1]-=this.origin[1],i}updateView(){this.setCameraMatrix()}getCameraDistance(){return this.cameraDistance}getProjectionCenter(){return[this.center[0],this.center[1]]}dispose(){Kd(this.domContainer),this.domContainer.removeChild(this.canvas),this._engine.event,this.control.dispose(),super.dispose()}get far(){return this._far}set far(t){this._far=t}}g(Qd,"EARTH_RADIUS",637e4);const ra=0,Pv=1,Rv=2,es=new V,aa=new Rs,Lv=new ri(new S(0,0,1),0),Us=new S,To=new ee;new ee,To.fov=35;class Qw{constructor(t){g(this,"map"),g(this,"currentAction"),g(this,"startX"),g(this,"startY"),g(this,"startCenterX"),g(this,"startCenterY"),g(this,"startPitch"),g(this,"startHeading"),g(this,"startZoom"),g(this,"startZoomUnits"),g(this,"startAtTop"),g(this,"mapWidth"),g(this,"mapHeight"),g(this,"startCamera",new ee),g(this,"startCenter",new S),g(this,"startNdc",new V),g(this,"startPoint",new S),g(this,"startScaleX",1),g(this,"startScaleY",1),g(this,"startBoundX"),g(this,"startBoundY"),g(this,"_enabled",!1),g(this,"minPitch",0),g(this,"maxPitch",89),g(this,"zoomSpeed",.005),g(this,"headingSpeed",.4),g(this,"pitchSpeed",.3),g(this,"doubleClickTimer",null),g(this,"clickInterval",200),g(this,"_rotationMode",1),g(this,"init",()=>{const e=this.map.domContainer;e.addEventListener("mousedown",this.handleMouseDown),e.addEventListener("wheel",this.handleWheel),e.addEventListener("contextmenu",this.handleContextMenu),e.addEventListener("mousemove",this.handleMouseMove),this.initCursorAnchor()}),g(this,"initCursorAnchor",()=>{const e=this.cursorAnchor=document.createElement("div");e.style.position="absolute",e.style.width="40px",e.style.height="40px",e.style.backgroundColor="rgba(255, 255, 255, 0.5)",e.style.zIndex=100,e.style.pointerEvents="none",e.style.display="none",this.map.domContainer.appendChild(e)}),g(this,"showCursorAnchor",(e,i)=>{this._rotationMode!==1&&(this.cursorAnchor.style.left=e-20+"px",this.cursorAnchor.style.top=i-20+"px",this.cursorAnchor.style.display="block")}),g(this,"hideCursorAnchor",()=>{this.cursorAnchor.style.display="none"}),g(this,"handleMouseMove",e=>{this.currentAction===ra&&this.onEventMouseMove&&this.onEventMouseMove(e)}),g(this,"handleMouseDown",e=>{const i=this.map,[s,r]=this.map.getContainerSize();this.mapWidth=s,this.mapHeight=r;const a=this.map.domContainer.getBoundingClientRect();this.startBoundX=a.left,this.startBoundY=a.top,this.startScaleX=a.width/s,this.startScaleY=a.height/r;const o=(e.clientX-this.startBoundX)/this.startScaleX,l=(e.clientY-this.startBoundY)/this.startScaleY,h=new V(o/s*2-1,1-2*l/r);if(e.button===0){const c=i._getFirstIntersectionPoint(h);this.startCamera.copy(i.camera),this.startCamera.updateMatrixWorld(),Lv.constant=-c.z,this.startPoint.copy(c),this.currentAction=Pv}else if(e.button===2){if(this._rotationMode===1){const c=i.getProjectionCenter();this.startPoint.set(c[0],c[1],c[2]);const u=i.decomposeRotation();this.startHeading=u.heading,this.startPitch=u.pitch}else{const c=i._getFirstIntersectionPoint(h);this.startCamera.copy(i.camera),this.startCamera.updateMatrixWorld();const u=new S;u.subVectors(c,this.startCamera.position),u.normalize(),this.startPoint.copy(c);const d=i.decomposeRotationFromDirection(u);this.startHeading=d.heading,this.startPitch=d.pitch}this.startDistance=i.camera.position.distanceTo(this.startPoint),this.currentAction=Rv,this.showCursorAnchor(o,l)}else this.currentAction=ra;this.currentAction!==ra&&(this.startX=o,this.startY=l,this.startAtTop=l<r/2,document.addEventListener("mousemove",this.handleMouseDragging),document.addEventListener("mouseup",this.handleMouseUp))}),g(this,"handleMouseDragging",e=>{if(this.currentAction===ra)return;this.hasMoved=!0;const i=this.currentPixelX=(e.clientX-this.startBoundX)/this.startScaleX,s=this.currentPixelY=(e.clientY-this.startBoundY)/this.startScaleY;this.currentAction===Pv?(this.map.domContainer.style.cursor="grabbing",this.handlePan(i,s)):this.currentAction===Rv&&(this.map.domContainer.style.cursor="grabbing",this.handleRotate(i,s))}),g(this,"handleMouseUp",e=>{this.currentAction=ra,this.map.domContainer.style.cursor="default",this.hideCursorAnchor(),document.removeEventListener("mousemove",this.handleMouseDragging),document.removeEventListener("mouseup",this.handleMouseUp),e&&this.onEventClick&&(this.hasMoved||this.onEventClick(e)),e&&this.onEventDblClick&&(!this.hasMoved&&this.waitSecondClick?(this.onEventDblClick(e),this.clearDoubleClickTimer()):this.waitSecondClick=!0),clearTimeout(this.doubleClickTimer),this.doubleClickTimer=setTimeout(()=>{this.clearDoubleClickTimer()},this.clickInterval),this.hasMoved=!1}),g(this,"clearDoubleClickTimer",()=>{this.doubleClickTimer&&clearTimeout(this.doubleClickTimer),this.waitSecondClick=!1,this.doubleClickTimer=null}),g(this,"handleContextMenu",e=>{e.preventDefault()}),g(this,"handleWheel",e=>{e.preventDefault(),e.stopPropagation();const[i,s]=this.map.getContainerSize();this.mapWidth=i,this.mapHeight=s,this.handleZoom({deltaX:e.deltaX,deltaY:e.deltaY,pixelX:e.offsetX,pixelY:e.offsetY})}),g(this,"handlePan",(e,i)=>{const s=this.map;this.getNdc(e,i,es),this.ndcToPoint(es,this.startCamera,Us),Us.distanceTo(s.camera.position)>.8*s.camera.far?this.handleMouseUp():(Us.sub(this.startPoint),Us.subVectors(this.startCamera.position,Us),s.camera.position.copy(Us),s.updateView())}),g(this,"handleRotate",(e,i)=>{const s=this.map,r=s.camera;let a=e-this.startX;const o=i-this.startY;this.startAtTop||(a*=-1);let l=this.startHeading+a*this.headingSpeed;l=this.makeHeadingSafe(l);let h=this.startPitch+o*this.pitchSpeed;if(h=this.makePitchSafe(h),this._rotationMode===1)s._cameraLookAt(r,this.startPoint,{heading:l,pitch:h,range:this.startDistance});else{s._cameraLookAt(To,this.startPoint,{heading:l,pitch:h,range:.2}),this.getNdc(this.startX,this.startY,es),aa.setFromCamera(es,To);const c=aa.ray.direction.clone();es.set(0,0),aa.setFromCamera(es,To);const u=aa.ray.direction.clone();c.angleTo(u);const d=new S;d.copy(c),d.normalize(),d.multiplyScalar(this.startDistance),r.position.copy(Us.copy(this.startPoint).sub(d)),r.quaternion.copy(To.quaternion)}s.updateView()}),g(this,"handleZoom",e=>{const i=this.map,s=i.camera,r=Ie.clamp(e.deltaY*this.zoomSpeed*-1,-.5,.5);this.getNdc(e.pixelX,e.pixelY,es);const a=i._getFirstIntersectionPoint(es),o=s.position.distanceTo(a);if(o>.8*s.far)return void this.handleMouseUp();let l=r*Ie.clamp(o,.5,1e7);l+.2>o&&(l=o-.2);const h=new S;h.subVectors(a,s.position),h.normalize();const c=new S;c.copy(h).multiplyScalar(l).add(s.position),s.position.copy(c),i.updateView()}),g(this,"makeHeadingSafe",e=>((e%=360)<0&&(e+=360),e)),g(this,"makePitchSafe",e=>e<this.minPitch?this.minPitch:e>this.maxPitch?this.maxPitch:e),g(this,"dispose",()=>{const e=this.map.domContainer;e.removeEventListener("mousedown",this.handleMouseDown),e.removeEventListener("wheel",this.handleWheel),e.removeEventListener("contextmenu",this.handleContextMenu),document.removeEventListener("mousemove",this.handleMouseDragging),document.removeEventListener("mouseup",this.handleMouseUp),e.removeEventListener("mousemove",this.handleMouseMove),this.clearDoubleClickTimer(),this.cursorAnchor.remove()}),this.map=t,this.enabled=!0,this.currentAction=ra}set enabled(t){t!==this._enabled&&(t?this.init():this.dispose(),this._enabled=t)}ndcToPoint(t,e,i){aa.setFromCamera(t,e),aa.ray.intersectPlane(Lv,i)}getNdc(t,e,i){i.x=t/this.mapWidth*2-1,i.y=1-e/this.mapHeight*2}}const $w=new S(0,0,-1),Fs=new Rs;Fs.mouse=new V;const Iv=new ri(new S(0,0,1),0),is=new S;new at;class tS extends Qd{constructor(){super(...arguments),g(this,"isBlankMap3D",!0),g(this,"_viewStateDirty",!0),g(this,"_getFirstIntersectionPoint",t=>{const e=this._engine;Fs.setFromCamera(t,e.camera),Fs.mouse.copy(t);const i=Fs.intersectObjects(e.rendering.objectsScene.children,!0);let s=null;for(let r=0,a=i.length;r<a;r++)if(!i[r].object.isPoints&&!i[r].object.collisionDisabled){s=i[r];break}return s===null?(Fs.ray.intersectPlane(Iv,is),is):s.point})}initControl(){this.control=new Qw(this),this.control.onEventClick=this.handleEventClick,this.control.onEventDblClick=this.handleEventDblClick,this.control.onEventMouseMove=this.handleEventMouseMove}updateView(){this.handleViewChange()}getCenter(){return this.normalizeEarthPointArr(this.getProjectionCenter())}getProjectionCenter(){const t=new V,e=this._getFirstIntersectionPoint(t);return[e.x,e.y,e.z]}getPitch(){return this.decomposeRotation().pitch}getHeading(){return this.decomposeRotation().heading}getZoom(){return this.getZoomByZoomUnits(this.getZoomUnits())}getZoomUnits(){const[t,e]=this.getContainerSize();return this.camera.position.z*Math.tan(Ie.degToRad(this.fov/2))*2/e}getCameraDistance(){return Fs.setFromCamera(new V,this.camera),Fs.ray.intersectPlane(Iv,is),this.camera.position.distanceTo(is)}setCenter(t){this.setProjectionCenter(this.normalizeProjectionPointArr(t))}setProjectionCenter(t){const e=this.decomposeRotation();this.lookAt(t,{...e,height:this.camera.position.z}),this.updateView()}setZoom(t){const e=this.decomposeRotation(),i=this.getProjectionCenter(),s=this.getZoomUnitsByZoom(t),[r,a]=this.getContainerSize(),o=a/2*s/Math.tan(Ie.degToRad(this.fov/2));this.lookAt(i,{...e,height:o}),this.updateView()}setPitch(t){const e=this.decomposeRotation(),i=this.getProjectionCenter(),s=this.camera.position.distanceTo(is.set(i[0],i[1],i[2]));this.lookAt(i,{heading:e.heading,pitch:t,range:s}),this.updateView()}setHeading(t){const e=this.decomposeRotation(),i=this.getProjectionCenter(),s=this.camera.position.distanceTo(is.set(i[0],i[1],i[2]));this.lookAt(i,{heading:t,pitch:e.pitch,range:s}),this.updateView()}lookAt(t,e={}){this._cameraLookAt(this.camera,t,e)}_cameraLookAt(t,e,i){const{heading:s,pitch:r,range:a,height:o}=i,l=new Ft;l.setFromAxisAngle(new S(0,0,1),s*Math.PI/180);const h=new Ft;h.setFromAxisAngle(new S(1,0,0),r*Math.PI/180);const c=new Ft;c.multiplyQuaternions(l,h);const u=new S(0,0,-1);u.applyQuaternion(c),u.negate();const d=new S;Array.isArray(e)?d.set(e[0],e[1],e[2]||0):e.isVector3&&d.copy(e);const p=new S;if(isNaN(a)){if(!isNaN(o)){const m=new kn;m.set(d,u),m.intersectPlane(new ri(new S(0,0,1),-o),is),d.copy(is)}}else p.copy(u),p.multiplyScalar(a),d.add(p);t.position.copy(d),t.quaternion.copy(c),t.updateMatrix(),t.updateMatrixWorld()}offsetFromHeadingPitchRange(t=0,e=0,i=0){const s=new Ft;s.setFromAxisAngle(new S(0,0,1),t*Math.PI/180);const r=new Ft;r.setFromAxisAngle(new S(1,0,0),e*Math.PI/180);const a=new Ft;a.multiplyQuaternions(s,r);const o=new S(0,0,-1);o.applyQuaternion(a),o.negate();const l=new S;return l.copy(o).multiplyScalar(i),l}decomposeRotation(){const t=this.camera.quaternion,e=$w.clone();return e.applyQuaternion(t),this.decomposeRotationFromDirection(e)}decomposeRotationFromDirection(t){const e=180-Ie.radToDeg(Math.acos(t.z));let i=Ie.radToDeg(Math.atan2(t.y,t.x));return i=(i+270)%360,{heading:i,pitch:e}}updateCamera(){const t=this.camera;t.updateMatrix(),t.updateMatrixWorld();const[e,i]=this.getContainerSize();t.aspect=e/i,t.near=this.near;let s=this.getZoomUnits();s<.5&&(s=.5),t.far=this._far*s*2,t.updateProjectionMatrix()}}class eS extends qd{constructor(t,e,i){super(e,i),g(this,"near",.1),g(this,"_far",4e3),g(this,"fov",35),g(this,"projectionCoordsName","_bmap_mercator"),g(this,"handleMapUpdate",()=>{this.onViewChanged&&this.onViewChanged()}),g(this,"handleMapResize",()=>{this.onResolutionChanged&&this.onResolutionChanged(this.getResolution())}),g(this,"handleEventClick",s=>{const r=this._engine.event,a=[s.pixel.x,s.pixel.y],o=[s.latlng.lng,s.latlng.lat],l=[s.point.lng,s.point.lat];r._handleClick({pixel:a,point:o,position:l,event:s})}),g(this,"handleEventRightClick",s=>{const r=this._engine.event,a=[s.pixel.x,s.pixel.y],o=[s.latlng.lng,s.latlng.lat],l=[s.point.lng,s.point.lat];r._handleRightClick({pixel:a,point:o,position:l,event:s})}),g(this,"handleEventDblClick",s=>{const r=this._engine.event,a=[s.pixel.x,s.pixel.y],o=[s.latlng.lng,s.latlng.lat],l=[s.point.lng,s.point.lat];r._handleDblClick({pixel:a,point:o,position:l,event:s})}),g(this,"handleEventRightDblClick",s=>{const r=this._engine.event,a=[s.pixel.x,s.pixel.y],o=[s.latlng.lng,s.latlng.lat],l=[s.point.lng,s.point.lat];r._handleRightDblClick({pixel:a,point:o,position:l,event:s})}),this._engine=t,this.map=e}getContainerSize(){const t=this.map.getSize();return[t.width,t.height]}getResolution(){const t=this.map.getSize();return new V(t.width,t.height)}afterInit(){const t=this.map;this.canvas.style.zIndex="3",t.getContainer().appendChild(this.canvas),t.addEventListener("update",this.handleMapUpdate),t.addEventListener("resize",this.handleMapResize),t.addEventListener("click",this.handleEventClick),t.addEventListener("rightclick",this.handleEventRightClick),t.addEventListener("dblclick",this.handleEventDblClick),t.addEventListener("rightdblclick",this.handleEventRightDblClick),this.handleMapResize()}getCenter(){const t=this.map.getCenter();return[t.lng,t.lat]}getZoom(){return this.map.getZoom()}getZoomUnits(){return this.map.getZoomUnits()}getZoomByZoomUnits(t){return window.BMAPGL_84?Math.log2(this.MERCATOR_LENGTH/128/t):18-Math.log2(t)}getZoomUnitsByZoom(t){return this.map.getZoomUnits(t)}getHeading(){return this.map.getHeading()}getPitch(){return this.map.getTilt()}setCenter(t){this.map.setCenter(this.normalizeMapPoint(t))}setProjectionCenter(t){const e=this.normalizeEarthPointArr(t);this.setCenter(e)}setZoom(t){this.map.setZoom(t)}setPitch(t){this.map.setTilt(t)}setHeading(t){this.map.setHeading(t)}setBounds(t){let e=[this.projectPointArr(t[0]),this.projectPointArr(t[1])];this.map.setBounds(new BMapGL.Point(e[0][0],e[0][1]),new BMapGL.Point(e[1][0],e[1][1]))}getBounds(){this.map.getBounds()}enableControl(){this.map.enableDragging()}disableControl(){this.map.disableDragging()}updateCamera(){this.updateMatrixWorld(),this.updateProjectionMatrix()}updateMatrixWorld(){const t=this.map,e=this.camera,i=t.getCenterIn(),s=[i.lng,i.lat],r=t.getZoomUnits(),a=t.getTilt(),o=t.getHeading(),[l,h]=this.getContainerSize(),c=h/2/Math.tan(this.fov/2*Math.PI/180)*r;this.cameraDistance=c,e.position.set(0,0,0),e.quaternion.set(0,0,0,1),e.up.set(0,1,0),e.translateX(s[0]),e.translateY(s[1]),e.rotateOnAxis(new S(0,0,1),o*Math.PI/180),e.rotateOnAxis(new S(1,0,0),a*Math.PI/180),e.translateZ(c),e.updateMatrix(),e.updateMatrixWorld()}updateProjectionMatrix(){const t=this.camera,[e,i]=this.getContainerSize(),s=this.map.getZoomUnits();t.aspect=e/i,t.near=.1,t.far=this._far*s,t.far<1e3&&(t.far=1e3),t.updateProjectionMatrix()}normalizeMapPoint(t){const e=this.normalizeEarthPointArr(t)||[0,0];return new BMapGL.Point(e[0],e[1],e[2])}normalizeProjectionPointArr(t){const e=this.parsePointToArr(t);return e&&e[0]<180&&e[1]<90?this.map.lnglatToMercator(e[0],e[1]):e}normalizeEarthPointArr(t){const e=this.parsePointToArr(t);if(e&&(e[0]>180||e[1]>90)){const i=this.map.mercatorToLnglat(e[0],e[1]);return e[2]!==void 0&&(i[2]=e[2]),i}return e}projectPointArr(t){let e=[];return t[0]>180||t[1]>90?(e[0]=t[0],e[1]=t[1]):e=this.map.lnglatToMercator(t[0],t[1]),t[2]!==void 0&&(e[2]=t[2]),e}getCameraDistance(){return this.cameraDistance}getProjectionCenter(){const t=this.map.getCenterIn();return[t.lng,t.lat]}dispose(){const t=this.map;t.getContainer().removeChild(this.canvas),t.removeEventListener("update",this.handleMapUpdate),t.removeEventListener("resize",this.handleMapResize),t.removeEventListener("click",this.handleEventClick),super.dispose()}get far(){return this._far}set far(t){}}class Dv extends qd{constructor(t,e,i){super(e,i),g(this,"MERCATOR_LENGTH",200375083427892e-7),g(this,"projectionCoordsName","_web_mercator"),g(this,"origin",[0,0]),g(this,"center",[0,0]),g(this,"pitch",0),g(this,"heading",0),g(this,"near",.1),g(this,"_far",8e3),g(this,"fov",35),g(this,"cameraDistance",1e3),g(this,"handleEventClick",s=>{const r=this._engine.event,a=[s.point.x,s.point.y],o=[s.lngLat.lng,s.lngLat.lat],l=this.normalizeProjectionPointArr(o);r._handleClick({pixel:a,point:o,position:l,event:s.originalEvent})}),g(this,"handleEventDblClick",s=>{const r=this._engine.event,a=[s.point.x,s.point.y],o=[s.lngLat.lng,s.lngLat.lat],l=this.normalizeProjectionPointArr(o);r._handleDblClick({pixel:a,point:o,position:l,event:s.originalEvent})}),g(this,"handleEventRightClick",s=>{const r=this._engine.event,a=[s.point.x,s.point.y],o=[s.lngLat.lng,s.lngLat.lat],l=this.normalizeProjectionPointArr(o);r._handleRightClick({pixel:a,point:o,position:l,event:s.originalEvent})}),g(this,"handleMapResize",()=>{this.onResolutionChanged&&this.onResolutionChanged(this.getResolution())}),this._engine=t,this.map=e,this.domContainer=e._container}afterInit(){this.canvas.style.pointerEvents="none",this.domContainer.appendChild(this.canvas);const t=this.map;t.on("render",e=>{this.onViewChanged&&this.onViewChanged()}),t.on("click",this.handleEventClick),t.on("contextmenu",this.handleEventRightClick),t.on("dblclick",this.handleEventDblClick),t.on("resize",()=>{this.handleMapResize()}),this.handleMapResize()}getContainerSize(){return[this.domContainer.clientWidth,this.domContainer.clientHeight]}getResolution(){return new V(this.domContainer.clientWidth,this.domContainer.clientHeight)}setCenter(t){this.map.setCenter(t)}setZoom(t){this.map.setZoom(t)}setHeading(t){this.map.setBearing(t)}setPitch(t){this.map.setPitch(t)}getCenter(){const t=this.map.getCenter();return[t.lng,t.lat]}getZoom(){return this.map.getZoom()}getZoomUnitsByZoom(t){return this.MERCATOR_LENGTH/256/Math.pow(2,t)}getZoomByZoomUnits(t){return Math.log2(this.MERCATOR_LENGTH/256/t)}getZoomUnits(){return this.getZoomUnitsByZoom(this.map.getZoom())}getPitch(){return this.map.getPitch()}getHeading(){return this.map.getBearing()}enableControl(){this.map.dragPan.enable(),this.map.dragRotate.enable()}disableControl(){this.map.dragPan.disable(),this.map.dragRotate.disable()}flyTo(t){}updateCamera(){this.updateMatrixWorld(),this.updateProjectionMatrix()}updateMatrixWorld(){this.map;const t=this.camera,e=this.getCenter(),i=this.getZoomUnits(),s=this.getPitch(),r=this.getHeading(),[a,o]=this.getContainerSize(),l=this.normalizeProjectionPointArr(e),h=o/2/Math.tan(this.fov/2*Math.PI/180)*i;this.cameraDistance=h,t.position.set(0,0,0),t.quaternion.set(0,0,0,1),t.up.set(0,1,0),t.translateX(l[0]),t.translateY(l[1]),t.rotateOnAxis(new S(0,0,-1),r*Math.PI/180),t.rotateOnAxis(new S(1,0,0),s*Math.PI/180),t.translateZ(h),t.updateMatrix()}updateProjectionMatrix(){const t=this.camera,e=this.getZoomUnits(),[i,s]=this.getContainerSize();t.aspect=i/s,t.fov=this.fov,t.near=this.near*e,t.far=this._far*e,t.updateProjectionMatrix()}normalizeMapPoint(t){return this.normalizeEarthPointArr(t)}normalizeProjectionPointArr(t){let e=this.parsePointToArr(t);return e=$r(e),e[0]-=this.origin[0],e[1]-=this.origin[1],e}normalizeEarthPointArr(t){let e=this.parsePointToArr(t);e[0]+=this.origin[0],e[1]+=this.origin[1];let i=hv(e);return e[2]!==void 0&&(i[2]=e[2]),i}projectPointArr(t,e){if(!t)return e;let i=null;return i=t[0]>180||t[1]>90?[t[0],t[1]]:$r(t),t[2]!==void 0&&(i[2]=t[2]),i[0]-=this.origin[0],i[1]-=this.origin[1],i}dispose(){Kd(this.domContainer),this.domContainer.removeChild(this.canvas),this._engine.event,super.dispose()}getProjectionCenter(){const t=this.map.getCenter();return this.normalizeProjectionPointArr(t)}getCameraDistance(){return this.cameraDistance}get far(){return this._far}set far(t){}}g(Dv,"EARTH_RADIUS",637e4);class Ov{constructor(t,e={}){g(this,"_engine"),g(this,"_map"),g(this,"_container"),g(this,"_mapType"),g(this,"handleViewChange",()=>{this._engine.rendering.requestRender()}),g(this,"handleResolutionChange",s=>{this._engine.rendering.setResolution(s)}),this._engine=t;const i=t.container;if(i instanceof HTMLElement?e.is3DControl?(this._map=new tS(t,i,e),this._container=i,this._mapType="blank_3dcontrol"):(this._map=new Qd(t,i,e),this._container=i,this._mapType="blank"):window.BMapGL&&i instanceof BMapGL.Map?(this._map=new eS(t,i,e),this._container=i.container,this._mapType="bmapgl"):i._mapId&&(this._map=new Dv(t,i,e),this._container=i._container,this._mapType="mapbox"),!this._map)throw new Error("map is invalid")}init(){this._map.init(),this._map.onViewChanged=this.handleViewChange,this._map.onResolutionChanged=this.handleResolutionChange}afterInit(){const t=this._engine,e=this._map;e.canvas=t.rendering.canvas,e.camera=t.rendering.camera,e.afterInit()}setCenter(t){this._map.setCenter(t)}setZoom(t){this._map.setZoom(t)}setHeading(t){this._map.setHeading(t)}setPitch(t){this._map.setPitch(t)}setBounds(t){this._map.setBounds(t)}getBoundingBox(){return this._map.getBounds()}getCenter(){return this._map.getCenter()}getZoom(){return this._map.getZoom()}getZoomUnits(){return this._map.getZoomUnits()}getZoomByZoomUnits(t){return this._map.getZoomByZoomUnits(t)}getZoomUnitsByZoom(t){return this._map.getZoomUnitsByZoom(t)}getHeading(){return this._map.getHeading()}getPitch(){return this._map.getPitch()}getProjectionCenter(){return this._map.getProjectionCenter()}getCameraDistance(){return this._map.getCameraDistance()}getResolution(){return this._map.getResolution()}projectPointArr(t){return this._map.projectPointArr(t)}unprojectPointArr(t){return this._map.normalizeEarthPointArr(t)}enableControl(){this._map.enableControl()}disableControl(){this._map.disableControl()}updateCamera(){this._map.updateCamera()}getScaleAt(t){return 1/Math.cos(Math.PI*t[1]/180)}zoomTo(t){let e=null;if(t.is3DTiles)e=t.getBounds();else if(t.isMesh){const h=t.geometry;e=h.boundingBox,e||(h.computeBoundingBox(),e=h.boundingBox),e=e.clone(),e.applyMatrix4(t.matrixWorld)}if(!e)return;const i=this.getResolution(),s=(e.max.x-e.min.x)/i.x,r=(e.max.y-e.min.y)/i.y,a=Math.max(s,r),o=this._map.getZoomByZoomUnits(a),l=[(e.max.x+e.min.x)/2,(e.max.y+e.min.y)/2,(e.max.z+e.min.z)/2];this._map.setProjectionCenter(l),this._map.setZoom(o)}dispose(){this._map.dispose()}set onResolutionChanged(t){this._map.onResolutionChanged=t}get projectionCoordsName(){return this._map.projectionCoordsName}get map(){return this._map}get mapType(){return this._mapType}get container(){return this._container}get fov(){return this._map.fov}get near(){return this._map.near}get far(){return this._map.far}}class iS extends Mt{constructor(){super(),g(this,"_boxGeometry"),g(this,"_boxMesh"),this._boxMaterial=new Zt({transparent:!0,color:16711680,opacity:.3})}attach(t){this._object=t;const e=t.geometry;e.boundingBox||e.computeBoundingBox(),this._boxGeometry&&this._boxGeometry.dispose();const i=e.boundingBox;if(this._boxGeometry=new Wt(i.max.x-i.min.x,i.max.y-i.min.y,i.max.z-i.min.z),this._boxMesh)this._boxMesh.geometry=this._boxGeometry;else{const s=this._boxMesh=new ot(this._boxGeometry,this._boxMaterial);this.add(s)}}detach(){this._object=null,this.remove(this._boxMesh),this._boxMesh=null}onBeforeScenePrepareRender(){if(this._object){this._object.updateMatrixWorld();const t=this._boxMesh;this._object.matrixWorld.decompose(t.position,t.rotation,t.scale)}}}const Ns=new Rs,Je=new S,ns=new S,ie=new Ft,zv={X:new S(1,0,0),Y:new S(0,1,0),Z:new S(0,0,1)},$d={type:"change"},Uv={type:"mouseDown"},Fv={type:"mouseUp",mode:null},Nv={type:"objectChange"};class kv extends Mt{constructor(t,e){super(),g(this,"_cameraScale"),g(this,"_endNorm"),g(this,"_gizmo"),g(this,"_getPointer"),g(this,"_onPointerDown"),g(this,"_onPointerHover"),g(this,"_onPointerMove"),g(this,"_onPointerUp"),g(this,"_parentPosition"),g(this,"_parentQuaternion"),g(this,"_parentQuaternionInv"),g(this,"_parentScale"),g(this,"_plane"),g(this,"_positionStart"),g(this,"_quaternionStart"),g(this,"_scaleStart"),g(this,"_startNorm"),g(this,"_worldQuaternionInv"),g(this,"_worldScale"),g(this,"_worldScaleStart"),g(this,"_offset"),g(this,"isTransformControls"),e===void 0&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),e=document),this.visible=!1,this.domElement=e,this.domElement.style.touchAction="none";const i=new jv;this._gizmo=i,this.add(i);const s=new Hv;this._plane=s,this.add(s);const r=this;function a(_,y){let x=y;Object.defineProperty(r,_,{get:function(){return x!==void 0?x:y},set:function(b){x!==b&&(x=b,s[_]=b,i[_]=b,r.dispatchEvent({type:_+"-changed",value:b}),r.dispatchEvent($d))}}),r[_]=y,s[_]=y,i[_]=y}a("camera",t),a("object",void 0),a("enabled",!0),a("axis",null),a("mode","translate"),a("translationSnap",null),a("rotationSnap",null),a("scaleSnap",null),a("space","world"),a("size",1),a("dragging",!1),a("showX",!0),a("showY",!0),a("showZ",!0);const o=new S,l=new S,h=new Ft,c=new Ft,u=new S,d=new Ft,p=new S,m=new S,f=new S,v=new S;a("worldPosition",o),a("worldPositionStart",l),a("worldQuaternion",h),a("worldQuaternionStart",c),a("cameraPosition",u),a("cameraQuaternion",d),a("pointStart",p),a("pointEnd",m),a("rotationAxis",f),a("rotationAngle",0),a("eye",v),this._offset=new S,this._startNorm=new S,this._endNorm=new S,this._cameraScale=new S,this._parentPosition=new S,this._parentQuaternion=new Ft,this._parentQuaternionInv=new Ft,this._parentScale=new S,this._worldScaleStart=new S,this._worldQuaternionInv=new Ft,this._worldScale=new S,this._positionStart=new S,this._quaternionStart=new Ft,this._scaleStart=new S,this._getPointer=nS.bind(this),this._onPointerDown=rS.bind(this),this._onPointerHover=sS.bind(this),this._onPointerMove=aS.bind(this),this._onPointerUp=oS.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(t){if(this.object===void 0||this.dragging===!0)return;Ns.setFromCamera(t,this.camera);const e=tp(this._gizmo.picker[this.mode],Ns);this.axis=e?e.object.name:null}pointerDown(t){if(this.object!==void 0&&this.dragging!==!0&&t.button===0&&this.axis!==null){Ns.setFromCamera(t,this.camera);const e=tp(this._plane,Ns,!0);e&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(e.point).sub(this.worldPositionStart)),this.dragging=!0,Uv.mode=this.mode,this.dispatchEvent(Uv)}}pointerMove(t){const e=this.axis,i=this.mode,s=this.object;let r=this.space;if(i==="scale"?r="local":e!=="E"&&e!=="XYZE"&&e!=="XYZ"||(r="world"),s===void 0||e===null||this.dragging===!1||t.button!==-1)return;Ns.setFromCamera(t,this.camera);const a=tp(this._plane,Ns,!0);if(a){if(this.pointEnd.copy(a.point).sub(this.worldPositionStart),i==="translate")this._offset.copy(this.pointEnd).sub(this.pointStart),r==="local"&&e!=="XYZ"&&this._offset.applyQuaternion(this._worldQuaternionInv),e.indexOf("X")===-1&&(this._offset.x=0),e.indexOf("Y")===-1&&(this._offset.y=0),e.indexOf("Z")===-1&&(this._offset.z=0),r==="local"&&e!=="XYZ"?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),s.position.copy(this._offset).add(this._positionStart),this.translationSnap&&(r==="local"&&(s.position.applyQuaternion(ie.copy(this._quaternionStart).invert()),e.search("X")!==-1&&(s.position.x=Math.round(s.position.x/this.translationSnap)*this.translationSnap),e.search("Y")!==-1&&(s.position.y=Math.round(s.position.y/this.translationSnap)*this.translationSnap),e.search("Z")!==-1&&(s.position.z=Math.round(s.position.z/this.translationSnap)*this.translationSnap),s.position.applyQuaternion(this._quaternionStart)),r==="world"&&(s.parent&&s.position.add(Je.setFromMatrixPosition(s.parent.matrixWorld)),e.search("X")!==-1&&(s.position.x=Math.round(s.position.x/this.translationSnap)*this.translationSnap),e.search("Y")!==-1&&(s.position.y=Math.round(s.position.y/this.translationSnap)*this.translationSnap),e.search("Z")!==-1&&(s.position.z=Math.round(s.position.z/this.translationSnap)*this.translationSnap),s.parent&&s.position.sub(Je.setFromMatrixPosition(s.parent.matrixWorld))));else if(i==="scale"){if(e.search("XYZ")!==-1){let o=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(o*=-1),ns.set(o,o,o)}else Je.copy(this.pointStart),ns.copy(this.pointEnd),Je.applyQuaternion(this._worldQuaternionInv),ns.applyQuaternion(this._worldQuaternionInv),ns.divide(Je),e.search("X")===-1&&(ns.x=1),e.search("Y")===-1&&(ns.y=1),e.search("Z")===-1&&(ns.z=1);s.scale.copy(this._scaleStart).multiply(ns),this.scaleSnap&&(e.search("X")!==-1&&(s.scale.x=Math.round(s.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),e.search("Y")!==-1&&(s.scale.y=Math.round(s.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),e.search("Z")!==-1&&(s.scale.z=Math.round(s.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(i==="rotate"){this._offset.copy(this.pointEnd).sub(this.pointStart);const o=20/this.worldPosition.distanceTo(Je.setFromMatrixPosition(this.camera.matrixWorld));e==="E"?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1):e==="XYZE"?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(Je.copy(this.rotationAxis).cross(this.eye))*o):e!=="X"&&e!=="Y"&&e!=="Z"||(this.rotationAxis.copy(zv[e]),Je.copy(zv[e]),r==="local"&&Je.applyQuaternion(this.worldQuaternion),this.rotationAngle=this._offset.dot(Je.cross(this.eye).normalize())*o),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),r==="local"&&e!=="E"&&e!=="XYZE"?(s.quaternion.copy(this._quaternionStart),s.quaternion.multiply(ie.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),s.quaternion.copy(ie.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),s.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent($d),this.dispatchEvent(Nv)}}pointerUp(t){t.button===0&&(this.dragging&&this.axis!==null&&(Fv.mode=this.mode,this.dispatchEvent(Fv)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse(function(t){t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose()})}attach(t){return this.object=t,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent($d),this.dispatchEvent(Nv),this.pointStart.copy(this.pointEnd))}getRaycaster(){return Ns}getMode(){return this.mode}setMode(t){this.mode=t}setTranslationSnap(t){this.translationSnap=t}setRotationSnap(t){this.rotationSnap=t}setScaleSnap(t){this.scaleSnap=t}setSize(t){this.size=t}setSpace(t){this.space=t}update(){console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}}function nS(n){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:n.button};{const t=this.domElement.getBoundingClientRect();return{x:(n.clientX-t.left)/t.width*2-1,y:-(n.clientY-t.top)/t.height*2+1,button:n.button}}}function sS(n){if(this.enabled)switch(n.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(n))}}function rS(n){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(n.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(n)),this.pointerDown(this._getPointer(n)))}function aS(n){this.enabled&&this.pointerMove(this._getPointer(n))}function oS(n){this.enabled&&(this.domElement.releasePointerCapture(n.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(n)))}function tp(n,t,e){const i=t.intersectObject(n,!0);for(let s=0;s<i.length;s++)if(i[s].object.visible||e)return i[s];return!1}kv.prototype.isTransformControls=!0;const Wh=new yn,Kt=new S(0,1,0),Bv=new S(0,0,0),Vv=new at,qh=new Ft,Xh=new Ft,an=new S,Gv=new at,Eo=new S(1,0,0),ks=new S(0,1,0),Co=new S(0,0,1),Yh=new S,Ao=new S,Po=new S;class jv extends Mt{constructor(){super(),this.type="TransformControlsGizmo";const t=new Zt({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),e=new _e({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),i=t.clone();i.opacity=.15;const s=e.clone();s.opacity=.5;const r=t.clone();r.color.setHex(16711680);const a=t.clone();a.color.setHex(65280);const o=t.clone();o.color.setHex(255);const l=t.clone();l.color.setHex(16711680),l.opacity=.5;const h=t.clone();h.color.setHex(65280),h.opacity=.5;const c=t.clone();c.color.setHex(255),c.opacity=.5;const u=t.clone();u.opacity=.25;const d=t.clone();d.color.setHex(16776960),d.opacity=.25,t.clone().color.setHex(16776960);const p=t.clone();p.color.setHex(7895160);const m=new oe(0,.04,.1,12);m.translate(0,.05,0);const f=new Wt(.08,.08,.08);f.translate(0,.04,0);const v=new gt;v.setAttribute("position",new Z([0,0,0,1,0,0],3));const _=new oe(.0075,.0075,.5,3);function y(G,U){const k=new Ui(G,.0075,3,64,U*Math.PI*2);return k.rotateY(Math.PI/2),k.rotateX(Math.PI/2),k}_.translate(0,.25,0);const x={X:[[new ot(m,r),[.5,0,0],[0,0,-Math.PI/2]],[new ot(m,r),[-.5,0,0],[0,0,Math.PI/2]],[new ot(_,r),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new ot(m,a),[0,.5,0]],[new ot(m,a),[0,-.5,0],[Math.PI,0,0]],[new ot(_,a)]],Z:[[new ot(m,o),[0,0,.5],[Math.PI/2,0,0]],[new ot(m,o),[0,0,-.5],[-Math.PI/2,0,0]],[new ot(_,o),null,[Math.PI/2,0,0]]],XYZ:[[new ot(new zi(.1,0),u.clone()),[0,0,0]]],XY:[[new ot(new Wt(.15,.15,.01),c.clone()),[.15,.15,0]]],YZ:[[new ot(new Wt(.15,.15,.01),l.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new ot(new Wt(.15,.15,.01),h.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},b={X:[[new ot(new oe(.2,0,.6,4),i),[.3,0,0],[0,0,-Math.PI/2]],[new ot(new oe(.2,0,.6,4),i),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new ot(new oe(.2,0,.6,4),i),[0,.3,0]],[new ot(new oe(.2,0,.6,4),i),[0,-.3,0],[0,0,Math.PI]]],Z:[[new ot(new oe(.2,0,.6,4),i),[0,0,.3],[Math.PI/2,0,0]],[new ot(new oe(.2,0,.6,4),i),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new ot(new zi(.2,0),i)]],XY:[[new ot(new Wt(.2,.2,.01),i),[.15,.15,0]]],YZ:[[new ot(new Wt(.2,.2,.01),i),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new ot(new Wt(.2,.2,.01),i),[.15,0,.15],[-Math.PI/2,0,0]]]},w={START:[[new ot(new zi(.01,2),s),null,null,null,"helper"]],END:[[new ot(new zi(.01,2),s),null,null,null,"helper"]],DELTA:[[new we(function(){const G=new gt;return G.setAttribute("position",new Z([0,0,0,1,1,1],3)),G}(),s),null,null,null,"helper"]],X:[[new we(v,s.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new we(v,s.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new we(v,s.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},M={XYZE:[[new ot(y(.5,1),p),null,[0,Math.PI/2,0]]],X:[[new ot(y(.5,.5),r)]],Y:[[new ot(y(.5,.5),a),null,[0,0,-Math.PI/2]]],Z:[[new ot(y(.5,.5),o),null,[0,Math.PI/2,0]]],E:[[new ot(y(.75,1),d),null,[0,Math.PI/2,0]]]},T={AXIS:[[new we(v,s.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},R={XYZE:[[new ot(new tn(.25,10,8),i)]],X:[[new ot(new Ui(.5,.1,4,24),i),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new ot(new Ui(.5,.1,4,24),i),[0,0,0],[Math.PI/2,0,0]]],Z:[[new ot(new Ui(.5,.1,4,24),i),[0,0,0],[0,0,-Math.PI/2]]],E:[[new ot(new Ui(.75,.1,2,24),i)]]},E={X:[[new ot(f,r),[.5,0,0],[0,0,-Math.PI/2]],[new ot(_,r),[0,0,0],[0,0,-Math.PI/2]],[new ot(f,r),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new ot(f,a),[0,.5,0]],[new ot(_,a)],[new ot(f,a),[0,-.5,0],[0,0,Math.PI]]],Z:[[new ot(f,o),[0,0,.5],[Math.PI/2,0,0]],[new ot(_,o),[0,0,0],[Math.PI/2,0,0]],[new ot(f,o),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new ot(new Wt(.15,.15,.01),c),[.15,.15,0]]],YZ:[[new ot(new Wt(.15,.15,.01),l),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new ot(new Wt(.15,.15,.01),h),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new ot(new Wt(.1,.1,.1),u.clone())]]},A={X:[[new ot(new oe(.2,0,.6,4),i),[.3,0,0],[0,0,-Math.PI/2]],[new ot(new oe(.2,0,.6,4),i),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new ot(new oe(.2,0,.6,4),i),[0,.3,0]],[new ot(new oe(.2,0,.6,4),i),[0,-.3,0],[0,0,Math.PI]]],Z:[[new ot(new oe(.2,0,.6,4),i),[0,0,.3],[Math.PI/2,0,0]],[new ot(new oe(.2,0,.6,4),i),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new ot(new Wt(.2,.2,.01),i),[.15,.15,0]]],YZ:[[new ot(new Wt(.2,.2,.01),i),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new ot(new Wt(.2,.2,.01),i),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new ot(new Wt(.2,.2,.2),i),[0,0,0]]]},z={X:[[new we(v,s.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new we(v,s.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new we(v,s.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function F(G){const U=new Mt;for(const k in G)for(let H=G[k].length;H--;){const W=G[k][H][0].clone(),N=G[k][H][1],X=G[k][H][2],K=G[k][H][3],$=G[k][H][4];W.name=k,W.tag=$,N&&W.position.set(N[0],N[1],N[2]),X&&W.rotation.set(X[0],X[1],X[2]),K&&W.scale.set(K[0],K[1],K[2]),W.updateMatrix();const lt=W.geometry.clone();lt.applyMatrix4(W.matrix),W.geometry=lt,W.renderOrder=1/0,W.position.set(0,0,0),W.rotation.set(0,0,0),W.scale.set(1,1,1),U.add(W)}return U}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=F(x)),this.add(this.gizmo.rotate=F(M)),this.add(this.gizmo.scale=F(E)),this.add(this.picker.translate=F(b)),this.add(this.picker.rotate=F(R)),this.add(this.picker.scale=F(A)),this.add(this.helper.translate=F(w)),this.add(this.helper.rotate=F(T)),this.add(this.helper.scale=F(z)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}onBeforeScenePrepareRender(){const t=(this.mode==="scale"?"local":this.space)==="local"?this.worldQuaternion:Xh;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let e=[];e=e.concat(this.picker[this.mode].children),e=e.concat(this.gizmo[this.mode].children),e=e.concat(this.helper[this.mode].children);for(let i=0;i<e.length;i++){const s=e[i];let r;s.visible=!0,s.rotation.set(0,0,0),s.position.copy(this.worldPosition),r=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),s.scale.set(1,1,1).multiplyScalar(r*this.size/4),s.tag!=="helper"?(s.quaternion.copy(t),this.mode==="translate"||this.mode==="scale"?(s.name==="X"&&Math.abs(Kt.copy(Eo).applyQuaternion(t).dot(this.eye))>.99&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),s.name==="Y"&&Math.abs(Kt.copy(ks).applyQuaternion(t).dot(this.eye))>.99&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),s.name==="Z"&&Math.abs(Kt.copy(Co).applyQuaternion(t).dot(this.eye))>.99&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),s.name==="XY"&&Math.abs(Kt.copy(Co).applyQuaternion(t).dot(this.eye))<.2&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),s.name==="YZ"&&Math.abs(Kt.copy(Eo).applyQuaternion(t).dot(this.eye))<.2&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),s.name==="XZ"&&Math.abs(Kt.copy(ks).applyQuaternion(t).dot(this.eye))<.2&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1)):this.mode==="rotate"&&(qh.copy(t),Kt.copy(this.eye).applyQuaternion(ie.copy(t).invert()),s.name.search("E")!==-1&&s.quaternion.setFromRotationMatrix(Vv.lookAt(this.eye,Bv,ks)),s.name==="X"&&(ie.setFromAxisAngle(Eo,Math.atan2(-Kt.y,Kt.z)),ie.multiplyQuaternions(qh,ie),s.quaternion.copy(ie)),s.name==="Y"&&(ie.setFromAxisAngle(ks,Math.atan2(Kt.x,Kt.z)),ie.multiplyQuaternions(qh,ie),s.quaternion.copy(ie)),s.name==="Z"&&(ie.setFromAxisAngle(Co,Math.atan2(Kt.y,Kt.x)),ie.multiplyQuaternions(qh,ie),s.quaternion.copy(ie))),s.visible=s.visible&&(s.name.indexOf("X")===-1||this.showX),s.visible=s.visible&&(s.name.indexOf("Y")===-1||this.showY),s.visible=s.visible&&(s.name.indexOf("Z")===-1||this.showZ),s.visible=s.visible&&(s.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),s.material._color=s.material._color||s.material.color.clone(),s.material._opacity=s.material._opacity||s.material.opacity,s.material.color.copy(s.material._color),s.material.opacity=s.material._opacity,this.enabled&&this.axis&&(s.name===this.axis||this.axis.split("").some(function(a){return s.name===a}))&&(s.material.color.setHex(16776960),s.material.opacity=1)):(s.visible=!1,s.name==="AXIS"?(s.position.copy(this.worldPositionStart),s.visible=!!this.axis,this.axis==="X"&&(ie.setFromEuler(Wh.set(0,0,0)),s.quaternion.copy(t).multiply(ie),Math.abs(Kt.copy(Eo).applyQuaternion(t).dot(this.eye))>.9&&(s.visible=!1)),this.axis==="Y"&&(ie.setFromEuler(Wh.set(0,0,Math.PI/2)),s.quaternion.copy(t).multiply(ie),Math.abs(Kt.copy(ks).applyQuaternion(t).dot(this.eye))>.9&&(s.visible=!1)),this.axis==="Z"&&(ie.setFromEuler(Wh.set(0,Math.PI/2,0)),s.quaternion.copy(t).multiply(ie),Math.abs(Kt.copy(Co).applyQuaternion(t).dot(this.eye))>.9&&(s.visible=!1)),this.axis==="XYZE"&&(ie.setFromEuler(Wh.set(0,Math.PI/2,0)),Kt.copy(this.rotationAxis),s.quaternion.setFromRotationMatrix(Vv.lookAt(Bv,Kt,ks)),s.quaternion.multiply(ie),s.visible=this.dragging),this.axis==="E"&&(s.visible=!1)):s.name==="START"?(s.position.copy(this.worldPositionStart),s.visible=this.dragging):s.name==="END"?(s.position.copy(this.worldPosition),s.visible=this.dragging):s.name==="DELTA"?(s.position.copy(this.worldPositionStart),s.quaternion.copy(this.worldQuaternionStart),Je.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),Je.applyQuaternion(this.worldQuaternionStart.clone().invert()),s.scale.copy(Je),s.visible=this.dragging):(s.quaternion.copy(t),this.dragging?s.position.copy(this.worldPositionStart):s.position.copy(this.worldPosition),this.axis&&(s.visible=this.axis.search(s.name)!==-1)))}}}jv.prototype.isTransformControlsGizmo=!0;class Hv extends ot{constructor(){super(new gi(1e5,1e5,2,2),new Zt({visible:!1,wireframe:!0,side:2,transparent:!0,opacity:.1,toneMapped:!1})),this.type="TransformControlsPlane"}updateMatrixWorld(t){let e=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(e="local"),Yh.copy(Eo).applyQuaternion(e==="local"?this.worldQuaternion:Xh),Ao.copy(ks).applyQuaternion(e==="local"?this.worldQuaternion:Xh),Po.copy(Co).applyQuaternion(e==="local"?this.worldQuaternion:Xh),Kt.copy(Ao),this.mode){case"translate":case"scale":switch(this.axis){case"X":Kt.copy(this.eye).cross(Yh),an.copy(Yh).cross(Kt);break;case"Y":Kt.copy(this.eye).cross(Ao),an.copy(Ao).cross(Kt);break;case"Z":Kt.copy(this.eye).cross(Po),an.copy(Po).cross(Kt);break;case"XY":an.copy(Po);break;case"YZ":an.copy(Yh);break;case"XZ":Kt.copy(Po),an.copy(Ao);break;case"XYZ":case"E":an.set(0,0,0)}break;default:an.set(0,0,0)}an.length()===0?this.quaternion.copy(this.cameraQuaternion):(Gv.lookAt(Je.set(0,0,0),an,Kt),this.quaternion.setFromRotationMatrix(Gv)),super.updateMatrixWorld(t)}}Hv.prototype.isTransformControlsPlane=!0;class Wv extends kv{constructor(t){super(t.camera,t.map.container),g(this,"_enableKeyboardEvent",!1),g(this,"handleKeyboardEvent",e=>{switch(e.keyCode){case 81:this.setSpace(this.space==="local"?"world":"local");break;case 87:this.setMode("translate");break;case 69:this.setMode("rotate");break;case 82:this.setMode("scale");break;case 187:case 107:this.setSize(this.size+.1);break;case 189:case 109:this.setSize(Math.max(this.size-.1,.1));break;case 88:this.showX=!this.showX;break;case 89:this.showY=!this.showY;break;case 90:this.showZ=!this.showZ;break;case 32:this.enabled=!this.enabled;break;case 27:this.reset()}}),this.engine=t,this.addEventListener("change",e=>{t.requestRender()}),this.addEventListener("objectChange",e=>{t.requestRender()}),this.addEventListener("dragging-changed",e=>{e.value?t.map.disableControl():t.map.enableControl()})}dispose(){super.dispose(),this.enableKeyboardEvent=!1}set enableKeyboardEvent(t){t!==this._enableKeyboardEvent&&(this._enableKeyboardEvent=t,t?window.addEventListener("keydown",this.handleKeyboardEvent):window.removeEventListener("keydown",this.handleKeyboardEvent))}}class lS extends Ji{constructor(t,e={}){super(),g(this,"_engine"),g(this,"_boundingBoxHelper"),g(this,"_selectedObject"),g(this,"_transformControl"),this._engine=t}isSelected(t){return t===this._selectedObject}select(t){t.__engine_selected||(this._selectedObject&&(this._selectedObject.__engine_selected=!1),this._boundingBoxHelper||(this._boundingBoxHelper=new iS,this._engine.add(this._boundingBoxHelper)),this._boundingBoxHelper.attach(t),this._selectedObject=t,t.__engine_selected=!0,this._engine.requestRender())}deselect(t){this.isSelected(t)&&(this._boundingBoxHelper.detach(),this._selectedObject=null,t.__engine_selected=!1,this._engine.requestRender())}get transformControl(){return this._transformControl||(this._transformControl=new Wv(this._engine),this._transformControl.enableKeyboardEvent=!0),this._transformControl}attachTransform(t){const e=this._engine,i=this.transformControl;e.add(i),i.attach(t),i.updateMatrixWorld(),e.requestRender()}detachTransform(){const t=this._engine,e=this.transformControl;t.remove(e),e.detach()}dispose(){}}_t.mvt_uniform_zoomunits_pars=`#define GLSLIFY 1
`,_t.mvt_selective_pars_vertex=`#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
attribute float objectIndex;
uniform float selectedObjectIndex;
varying float isSelected;
#endif`,_t.mvt_selective_vertex=`#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
if (objectIndex == selectedObjectIndex) {
	isSelected = 1.0;
} else {
	isSelected = 0.0;
}
#endif`,_t.mvt_selective_pars_fragment=`#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
varying float isSelected;
uniform vec4 selectedObjectColor;
uniform float selectedObjectColorMode;
#endif`,_t.mvt_selective_fragment=`#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
if (isSelected == 1.0) {
	if (selectedObjectColorMode == 1.) {
		gl_FragColor = selectedObjectColor;
	} else {
		gl_FragColor.rgb = selectedObjectColor.rgb * selectedObjectColor.a + gl_FragColor.rgb * (1.0 - selectedObjectColor.a);
	}
	
}
#endif`,_t.mvt_keepsize_pars_vertex=`#define GLSLIFY 1
uniform bool keepSize;
#ifndef UNIFORM_ZOOMUNITS
uniform float zoomUnits;
#endif`,_t.mvt_keepsize_vertex=`#define GLSLIFY 1
if (keepSize) {
    transformed *= zoomUnits;
}
`,_t.mvt_emissive_pars_fragment=`#define GLSLIFY 1
#define MVT_EMISSIVE_SHADER

uniform vec3 emissive;`,_t.mvt_emissive_fragment=`#define GLSLIFY 1
#ifdef MVT_EMISSIVE_SHADER
    vec4 out_emissive = vec4(emissive.rgb, 1.0);
#endif`,_t.mvt_override_standard_emissivemap_pars_fragment=`#define GLSLIFY 1
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
uniform bool isEmissive;`,_t.mvt_override_standard_emissivemap_fragment=`#define GLSLIFY 1
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

    
#endif

if (isEmissive) {
    gl_FragColor = vec4(totalEmissiveRadiance, 1.0);
	#if defined( TONE_MAPPING )
	    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
    #endif
    return;
}`,_t.mvt_override_basic_color_pars_fragment=`#define GLSLIFY 1
uniform bool isEmissive;
uniform vec3 emissive;
#ifdef USE_COLOR

	varying vec3 vColor;

#endif`,_t.mvt_override_basic_color_fragment=`#define GLSLIFY 1
if (isEmissive) {
    gl_FragColor = vec4(emissive, 1.0);
    #if defined( TONE_MAPPING )
	    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
    #endif
    return;
}
#ifdef USE_COLOR

	diffuseColor.rgb *= vColor;

#endif`,_t.mvt_animation_pars_vertex=`#define GLSLIFY 1
uniform bool animationPeriodOffset;
#ifdef ENABLE_ANIMATION_ROTATE
uniform float animationRotatePeriod;
#endif

#ifdef ENABLE_ANIMATION_JUMP
uniform float animationJumpPeriod;
uniform float animationJumpHeight;
#endif
`,_t.mvt_animation_vertex=`#define GLSLIFY 1
#ifdef ENABLE_ANIMATION_ROTATE
    float rotateRatio = mod(elapsedTime, animationRotatePeriod) / animationRotatePeriod;
    if (animationPeriodOffset) {
        rotateRatio = mod(rotateRatio + instancedRandomFactor, 1.0);
    }
    float rotation = rotateRatio * 6.28;
    vec2 rotatedPosition;
    rotatedPosition.x = cos( rotation ) * transformed.x - sin( rotation ) * transformed.y;
    rotatedPosition.y = sin( rotation ) * transformed.x + cos( rotation ) * transformed.y;
    transformed.xy = rotatedPosition;
#endif

#ifdef ENABLE_ANIMATION_JUMP
    float jumpRatio = mod(elapsedTime, animationJumpPeriod) / animationJumpPeriod;
    if (animationPeriodOffset) {
        jumpRatio = mod(jumpRatio + instancedRandomFactor, 1.0);
    }
    if (jumpRatio <= 0.5) {
        jumpRatio *= 2.0;
        jumpRatio = jumpRatio * jumpRatio * jumpRatio;
    } else {
        jumpRatio = (1.0 - jumpRatio) * 2.0;
        jumpRatio = jumpRatio * jumpRatio * jumpRatio;
    }
    #ifdef USE_SIZE3
        transformed.z += jumpRatio * animationJumpHeight / size3.z;
    #else
        transformed.z += jumpRatio * animationJumpHeight / size;
    #endif
    
#endif
`,_t.mvt_mrt_output_pars_fragment=`#define GLSLIFY 1
#ifndef DISABLE_MRT
    layout(location = 1) out highp vec4 pc_fragColor1;
    layout(location = 2) out highp vec4 pc_fragColor2;
    layout(location = 3) out highp vec4 pc_fragColor3;
    // layout(location = 4) out highp vec4 pc_fragColor4;
    // layout(location = 5) out highp vec4 pc_fragColor5;
    // layout(location = 6) out highp vec4 pc_fragColor6;
    // layout(location = 7) out highp vec4 pc_fragColor7;
#endif

#if defined(MVT_EMISSIVE_UNIFORM)
// 发光颜色自定义
    #if defined(MVT_EMISSIVE_COLOR)
        uniform vec3 mvt_emissive;
    #endif  
    uniform float mvt_emissiveIntensity;
#endif`,_t.mvt_mrt_output_fragment=`#define GLSLIFY 1
#ifndef DISABLE_MRT
    // 自定义发光颜色，完全由着色器控制 在着色器中输出 vec4 out_emissive;
    #if defined(MVT_EMISSIVE_SHADER)
        pc_fragColor1 = out_emissive;
    #elif defined(STANDARD)
        pc_fragColor1.rgb = totalEmissiveRadiance;
        pc_fragColor1.a = pc_fragColor.a;
    #elif defined(BASIC)
        pc_fragColor1.rgb = emissive;
        pc_fragColor1.a = pc_fragColor.a;
    // 通过传入的uniform变量颜色自发光
    #elif defined(MVT_EMISSIVE_UNIFORM)
        // 发光颜色自定义
        #if defined(MVT_EMISSIVE_COLOR)
            pc_fragColor1.rgb = mvt_emissive * mvt_emissiveIntensity;
            pc_fragColor1.a = pc_fragColor.a;
        #else  
            pc_fragColor1 = pc_fragColor * mvt_emissiveIntensity;
        #endif
    #else
        pc_fragColor1 = vec4(0, 0, 0, 0);
      
    #endif

    #if defined(STANDARD)
        #ifndef FLAT_SHADED
            pc_fragColor2 = vec4(packNormalToRGB(vNormal), gl_FragCoord.z);
        #else
            pc_fragColor2 = vec4(0, 0, 0, 0);
        #endif
        pc_fragColor3 = vec4(1.0 - material.roughness, 0.0, 0.0, 1.0);
    #else
        #if defined(MVT_FRAG_NORMAL)
            pc_fragColor2 = vec4(packNormalToRGB(mvt_frag_normal), 1.0);
        #else
            pc_fragColor2 = vec4(0.0, 0.0, 0.0, 0.0);
        #endif
        
        float temp_reflectionFactor = 0.0;
        #if defined(MVT_FRAG_REFLECTION_FACTOR)
            temp_reflectionFactor = mvt_frag_reflectionFactor;
        #endif
        pc_fragColor3 = vec4(temp_reflectionFactor, 0.0, 0.0, 0.0);
    #endif
    
    // pc_fragColor4 = vec4(1.0, 0.0, 1.0, 1.0);
    // pc_fragColor5 = vec4(0.0, 1.0, 0.0, 1.0);
    // pc_fragColor6 = vec4(0.0, 1.0, 0.0, 1.0);
    // pc_fragColor7 = vec4(0.0, 1.0, 0.0, 1.0);
#endif
`,_t.mvt_extra_meshbasic_frag_pars=`#define GLSLIFY 1
#define BASIC
uniform vec3 emissive;`,Zt.prototype.emissiveIntensity=1,ai.basic.uniforms.emissive={value:new nt(0)};class qv extends Gf{constructor(t){super(t),this.type=1016}parse(t){const e=function(l,h){switch(l){case 1:console.error("THREE.RGBELoader Read Error: "+(h||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(h||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(h||""));break;default:console.error("THREE.RGBELoader: Error: "+(h||""))}return-1},i=function(l,h,c){h=h||1024;let u=l.pos,d=-1,p=0,m="",f=String.fromCharCode.apply(null,new Uint16Array(l.subarray(u,u+128)));for(;0>(d=f.indexOf(`
`))&&p<h&&u<l.byteLength;)m+=f,p+=f.length,u+=128,f+=String.fromCharCode.apply(null,new Uint16Array(l.subarray(u,u+128)));return-1<d&&(c!==!1&&(l.pos+=p+d+1),m+f.slice(0,d))},s=function(l,h,c,u){const d=l[h+3],p=Math.pow(2,d-128)/255;c[u+0]=l[h+0]*p,c[u+1]=l[h+1]*p,c[u+2]=l[h+2]*p,c[u+3]=1},r=function(l,h,c,u){const d=l[h+3],p=Math.pow(2,d-128)/255;c[u+0]=Za.toHalfFloat(Math.min(l[h+0]*p,65504)),c[u+1]=Za.toHalfFloat(Math.min(l[h+1]*p,65504)),c[u+2]=Za.toHalfFloat(Math.min(l[h+2]*p,65504)),c[u+3]=Za.toHalfFloat(1)},a=new Uint8Array(t);a.pos=0;const o=function(l){const h=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,c=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,u=/^\s*FORMAT=(\S+)\s*$/,d=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,p={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let m,f;if(l.pos>=l.byteLength||!(m=i(l)))return e(1,"no header found");if(!(f=m.match(/^#\?(\S+)/)))return e(3,"bad initial token");for(p.valid|=1,p.programtype=f[1],p.string+=m+`
`;m=i(l),m!==!1;)if(p.string+=m+`
`,m.charAt(0)!=="#"){if((f=m.match(h))&&(p.gamma=parseFloat(f[1])),(f=m.match(c))&&(p.exposure=parseFloat(f[1])),(f=m.match(u))&&(p.valid|=2,p.format=f[1]),(f=m.match(d))&&(p.valid|=4,p.height=parseInt(f[1],10),p.width=parseInt(f[2],10)),2&p.valid&&4&p.valid)break}else p.comments+=m+`
`;return 2&p.valid?4&p.valid?p:e(3,"missing image size specifier"):e(3,"missing format specifier")}(a);if(o!==-1){const l=o.width,h=o.height,c=function(u,d,p){const m=d;if(m<8||m>32767||u[0]!==2||u[1]!==2||128&u[2])return new Uint8Array(u);if(m!==(u[2]<<8|u[3]))return e(3,"wrong scanline width");const f=new Uint8Array(4*d*p);if(!f.length)return e(4,"unable to allocate buffer space");let v=0,_=0;const y=4*m,x=new Uint8Array(4),b=new Uint8Array(y);let w=p;for(;w>0&&_<u.byteLength;){if(_+4>u.byteLength)return e(1);if(x[0]=u[_++],x[1]=u[_++],x[2]=u[_++],x[3]=u[_++],x[0]!=2||x[1]!=2||(x[2]<<8|x[3])!=m)return e(3,"bad rgbe scanline format");let M,T=0;for(;T<y&&_<u.byteLength;){M=u[_++];const E=M>128;if(E&&(M-=128),M===0||T+M>y)return e(3,"bad scanline data");if(E){const A=u[_++];for(let z=0;z<M;z++)b[T++]=A}else b.set(u.subarray(_,_+M),T),T+=M,_+=M}const R=m;for(let E=0;E<R;E++){let A=0;f[v]=b[E+A],A+=m,f[v+1]=b[E+A],A+=m,f[v+2]=b[E+A],A+=m,f[v+3]=b[E+A],v+=4}w--}return f}(a.subarray(a.pos),l,h);if(c!==-1){let u,d,p;switch(this.type){case 1015:p=c.length/4;const m=new Float32Array(4*p);for(let v=0;v<p;v++)s(c,4*v,m,4*v);u=m,d=1015;break;case 1016:p=c.length/4;const f=new Uint16Array(4*p);for(let v=0;v<p;v++)r(c,4*v,f,4*v);u=f,d=1016;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:l,height:h,data:u,header:o.string,gamma:o.gamma,exposure:o.exposure,type:d}}}return null}setDataType(t){return this.type=t,this}load(t,e,i,s){return super.load(t,function(r,a){switch(r.type){case 1015:case 1016:r.encoding=3e3,r.minFilter=1006,r.magFilter=1006,r.generateMipmaps=!1,r.flipY=!0}e&&e(r,a)},i,s)}}class hS extends Ge{constructor(t){super(t),this.hdrLoader=new qv,this.type=1016}load(t,e,i,s){Array.isArray(t)||(console.warn("THREE.HDRCubeTextureLoader signature has changed. Use .setDataType() instead."),this.setDataType(t),t=e,e=i,i=s,s=arguments[4]);const r=new mr;switch(r.type=this.type,r.type){case 1015:case 1016:r.encoding=3e3,r.minFilter=1006,r.magFilter=1006,r.generateMipmaps=!1}const a=this;let o=0;function l(h,c,u,d){new _i(a.manager).setPath(a.path).setResponseType("arraybuffer").setWithCredentials(a.withCredentials).load(t[h],function(p){o++;const m=a.hdrLoader.parse(p);if(m){if(m.data!==void 0){const f=new _s(m.data,m.width,m.height);f.type=r.type,f.encoding=r.encoding,f.format=r.format,f.minFilter=r.minFilter,f.magFilter=r.magFilter,f.generateMipmaps=r.generateMipmaps,r.images[h]=f}o===6&&(r.needsUpdate=!0,c&&c(r))}},u,d)}for(let h=0;h<t.length;h++)l(h,e,i,s);return r}setDataType(t){return this.type=t,this.hdrLoader.setDataType(t),this}}class Ro extends ot{constructor(){super(Ro.Geometry,new Zt({opacity:0,transparent:!0})),this.isLensflare=!0,this.type="Lensflare",this.frustumCulled=!1,this.renderOrder=1/0;const t=new S,e=new S,i=new xu(16,16,1023),s=new xu(16,16,1023),r=Ro.Geometry,a=new qa({uniforms:{scale:{value:null},screenPosition:{value:null}},vertexShader:`

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,fragmentShader:`

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`,depthTest:!0,depthWrite:!1,transparent:!1}),o=new qa({uniforms:{map:{value:i},scale:{value:null},screenPosition:{value:null}},vertexShader:`

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,fragmentShader:`

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`,depthTest:!1,depthWrite:!1,transparent:!1}),l=new ot(r,a),h=[],c=oa.Shader,u=new qa({uniforms:{map:{value:null},occlusionMap:{value:s},color:{value:new nt(16777215)},scale:{value:new V},screenPosition:{value:new S}},vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,blending:2,transparent:!0,depthWrite:!1}),d=new ot(r,u);this.addElement=function(_){h.push(_)};const p=new V,m=new V,f=new ug,v=new Ot;this.onBeforeRender=function(_,y,x){_.getCurrentViewport(v);const b=v.w/v.z,w=v.z/2,M=v.w/2;let T=16/v.w;if(p.set(T*b,T),f.min.set(v.x,v.y),f.max.set(v.x+(v.z-16),v.y+(v.w-16)),e.setFromMatrixPosition(this.matrixWorld),e.applyMatrix4(x.matrixWorldInverse),!(e.z>0)&&(t.copy(e).applyMatrix4(x.projectionMatrix),m.x=v.x+t.x*w+w-8,m.y=v.y+t.y*M+M-8,f.containsPoint(m))){_.copyFramebufferToTexture(m,i);let R=a.uniforms;R.scale.value=p,R.screenPosition.value=t,_.renderBufferDirect(x,null,r,a,l,null),_.copyFramebufferToTexture(m,s),R=o.uniforms,R.scale.value=p,R.screenPosition.value=t,_.renderBufferDirect(x,null,r,o,l,null);const E=2*-t.x,A=2*-t.y;for(let z=0,F=h.length;z<F;z++){const G=h[z],U=u.uniforms;U.color.value.copy(G.color),U.map.value=G.texture,U.screenPosition.value.x=t.x+E*G.distance,U.screenPosition.value.y=t.y+A*G.distance,T=G.size/v.w;const k=v.w/v.z;U.scale.value.set(T*k,T),u.uniformsNeedUpdate=!0,_.renderBufferDirect(x,null,r,u,d,null)}}},this.dispose=function(){a.dispose(),o.dispose(),u.dispose(),i.dispose(),s.dispose();for(let _=0,y=h.length;_<y;_++)h[_].texture.dispose()}}}class oa{constructor(t,e=1,i=0,s=new nt(16777215)){this.texture=t,this.size=e,this.distance=i,this.color=s}}oa.Shader={uniforms:{map:{value:null},occlusionMap:{value:null},color:{value:null},scale:{value:null},screenPosition:{value:null}},vertexShader:`

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`,fragmentShader:`

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`},Ro.Geometry=function(){const n=new gt,t=new Float32Array([-1,-1,0,0,0,1,-1,0,1,0,1,1,0,1,1,-1,1,0,0,1]),e=new xr(t,5);return n.setIndex([0,1,2,0,2,3]),n.setAttribute("position",new Ki(e,3,0,!1)),n.setAttribute("uv",new Ki(e,2,3,!1)),n}();const cS={rayleighFactor:{value:.0025},mieFactor:{value:5e-4},miePhase:{value:-.65},cloudMap:{value:null},nightMap:{value:null},cloudsMap:{value:null},weatherMap:{value:null},lightDir:{value:new S},timeRatio:{value:0},cloudIntensity:{value:.1},groundColor:{value:new nt(16777215)},clipUnderground:{value:!1}},Xv=[[`#define GLSLIFY 1
uniform vec3 lightDir;

varying vec4 worldPosition;
varying vec3 vSunDirection;
varying float vSunE;
varying vec2 vUv;

const float e = 2.71828182845904523536028747135266249775724709369995957;
// earth shadow hack
// cutoffAngle = pi / 1.95;
const float cutoffAngle = 1.6110731556870734;
const float steepness = 1.5;
const float EE = 1000.0;

float sunIntensity( float zenithAngleCos ) {
    zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
    return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
}

void main() {
    #include <begin_vertex>
    worldPosition = modelMatrix * vec4(position, 1.0);
    // vec4 viewPos = modelViewMatrix * vec4(position, 1.0);

    vSunDirection = normalize(lightDir);

    vSunE = sunIntensity( dot( vSunDirection, vec3(0, 0, 1.0) ) );

    vUv = uv;
    #include <project_vertex>
    gl_Position.z = gl_Position.w;
}
`,`#define GLSLIFY 1
#include <common>
#define NUM_SAMPLES 3
const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

varying vec4 worldPosition;
varying vec3 vSunDirection;
varying float vSunE;
varying vec2 vUv;

uniform vec3 groundColor;
uniform vec3 lightDir;
uniform float cloudIntensity;
uniform float rayleighFactor;
uniform float mieFactor;
uniform float miePhase;

#ifdef CLOUD_MAP
uniform samplerCube cloudMap;
#endif

uniform sampler2D cloudsMap;
uniform sampler2D weatherMap;

#ifdef NIGHT_MAP
uniform sampler2D nightMap;
#endif

uniform float timeRatio;
uniform bool clipUnderground;
float getRayleighPhase(float dot)
{
    //原值为0.75
	return 0.9 + 0.75 * dot * dot;
}

float getMiePhase(float dot, float g)
{
    float g2 = g * g;
	return pow(1.0 - g, 2.0) / pow(1.0 + g2 - 2.0 * g * dot, 1.5);
}

float scale(float fCos)
{
	float x = 1.0 - fCos;
	return 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
}
float linearstep(float edge0, float edge1, float x) {
    float t = (x - edge0)/(edge1 - edge0);
    return clamp(t, 0.0, 1.0);
}
vec3 erot(vec3 p, vec3 ax, float ro) {
  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax, p)*sin(ro);
}
#define MVT_EMISSIVE_SHADER

void main() {

    if (clipUnderground && worldPosition.z < 0.0) {
        discard;
    }

// how much atmosphere to get through when we\\'re on the floor?
    // Get intersection with outer atmosphere
    const float earthRadius = 10.0;
    float atmosphereRadius = 10.25;
    // const float rayleighFactor = 0.0025;
    // const float mieFactor = 0.0005;
    float rayleighFactor4PI = rayleighFactor * 4.0 * PI;
    float mieFactor4PI = mieFactor * 4.0 * PI;
    float miePhaseFactor = miePhase;

// in earth space:
// assume camera is in centre
    vec3 origin = vec3(0.0, 0.0, earthRadius);
    vec3 origViewDir = normalize(worldPosition.xyz);
    vec3 viewDir = origViewDir;

    vec3 cloudInfo = texture2D(weatherMap, vUv).xyz;

    #ifdef CLOUD_MAP
        vec3 cloudPos = erot(origViewDir, vec3(0,0,1.0), timeRatio); 
        // float cloudThickness = textureCube(cloudMap, cloudPos).x;
        float cloudThickness = max(cloudInfo.x, clamp(cloudIntensity - 0.5, 0.0, 1.0) * cloudInfo.y * 2.0);
      atmosphereRadius -= 0.024 * cloudThickness;
        float cloudMieTickness = cloudThickness * cloudIntensity;
        viewDir.z *= cloudMieTickness * .03 + .97;
        viewDir = normalize(viewDir.xyz);
        miePhaseFactor -= cloudMieTickness * .2;
        rayleighFactor4PI += cloudMieTickness * .1;
    #endif

    float atmosphereThickness = atmosphereRadius - earthRadius;

    vec4 out_emissive = vec4(0.0, 0.0, 0.0, 0.0);
    float dotLO = dot(viewDir, origin);
    // this is the distance the ray travels through the atmosphere from the origin
    float scatterDistance = -dotLO + sqrt(dotLO * dotLO - dot(origin, origin) + atmosphereRadius * atmosphereRadius);

    // vec3 waveLen = vec3(0.650, 0.570, 0.475);
    vec3 waveLen = vec3(0.700, 0.546, 0.4358);
    vec3 rcpWaveLen4 = 1.0 / (waveLen * waveLen * waveLen * waveLen);

    // Initialize the scattering loop variables
    float stepLength = scatterDistance / float(NUM_SAMPLES);
    vec3 rayStep = viewDir * stepLength;

    float LdotV = dot(-lightDir, viewDir);
    float rayleighPhase = getRayleighPhase(LdotV);
    float miePhase = getMiePhase(LdotV, miePhaseFactor);
    miePhase = min(miePhase, 70.0);

    vec3 samplePoint = rayStep * 0.5 + origin;
    scatterDistance -= stepLength * .5;
    vec3 attenuate = exp(-(rayleighFactor4PI * rcpWaveLen4 + mieFactor4PI) * stepLength);
    vec3 lightColor = vec3(1.0); // + max(1.0 - lightDir.y, 0.0);
    vec3 accum = vec3(0.0);

    for (int i = 0; i < NUM_SAMPLES; ++i) {
        float dotLS = dot(lightDir, samplePoint);
        float f = dotLS * dotLS - dot(samplePoint, samplePoint);
        float sunTravelDistance = -dotLS + sqrt(f + atmosphereRadius * atmosphereRadius);

        vec3 attenuatedLight = lightColor * exp(-(rayleighFactor4PI * rcpWaveLen4 + mieFactor4PI) * sunTravelDistance);
        vec3 inScatter = attenuatedLight * (rayleighFactor4PI * rcpWaveLen4 * rayleighPhase + mieFactor4PI * miePhase) * stepLength;

        accum = accum * attenuate + inScatter;
        scatterDistance -= stepLength;

        samplePoint += rayStep;
    }

    // TODO: Could implement a different raytrace target point when we\\'re hitting the floor to simulate scattering from the floor?

    float isAboveHorizon = linearstep(-0.04, 0.01, origViewDir.z);
    vec3 ground = groundColor * max(lightDir.z, 0.01) /*+ vec3(0.02, 0.02, 0.025)*/;
    accum = mix(ground, accum, isAboveHorizon);

    float cosTheta = dot( origViewDir, vSunDirection );
    vec3 L0 = vec3( 0.1 );
    // composition + solar disc
    float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
    L0 += ( vSunE * 1.0 ) * sundisk;
    // float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, -LdotV);
    if (L0.r > 0.5) {
        // L0 = clamp(L0, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
        accum *= L0;
        accum = clamp(accum, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
        
    }
    else {
        // accum += L0;
    }
    if (L0.r > 0.5 && vSunDirection.z > 0.0) {
        out_emissive = vec4(clamp(L0.r, 0.0, 1.0) * 0.3);
    }
    #ifdef NIGHT_MAP
        if (vSunDirection.z < 0.0 && origViewDir.z > 0.0) {
            float nightPhase = mix(0.0, 1.0, clamp(-vSunDirection.z * 12.0, 0.0, 1.0));
            vec3 nightPos = erot(origViewDir, vec3(0.0, 1.0, 0.0), timeRatio); 
            vec3 nightColor = texture2D(nightMap, equirectUv(nightPos) * 1.8).xyz;
            // float nightColorIntensity = mix(0.0, 1.0, clamp(0.0, 0.8, nightColor.x * 5.0));
            if (nightColor.x > 0.01) {
                accum += nightColor * nightColor.x * nightPhase * mix(0.0, 1.0, clamp(origViewDir.z * 4.0, 0.0, 1.0));
            }
            // accum = nightPos;
            // accum = mix(accum, nightColor, nightPhase);
            // gl_FragColor = vec4(nightColor, 1.0);
        }
    #endif
    
    #ifdef CLOUD_MAP
        if (origViewDir.z >= -0.04) {
            // vec2 cloudUv = equirectUv(origViewDir);
            // cloudUv.x *= 10.0;
            // cloudUv.y *= 5.0;
            // float cloudsThickness = texture2D(cloudsMap, cloudUv).w;
            // 云的总体强度,

            // if (cloudIntensity > 0.3) {
            //     vec3 cloudPos2 = erot(origViewDir, vec3(0,0,1.0), mod(timeRatio + 0.5, 1.0)); 
            //     cloudThickness += textureCube(cloudMap, cloudPos2).x
            //          * clamp((cloudIntensity - 0.3) * 3.3, 0.0, 1.0);
            // }
            float cloudTotalIntensity = cloudThickness * cloudIntensity * 2.0;
            if (cloudIntensity > 0.5) {
                cloudTotalIntensity += (cloudIntensity - 0.5) * 2.5;
            }

            // cloudTotalIntensity *= clamp((origViewDir.z + 0.1) * 100.0, 0.0, 1.0);
            // // 遵循先变白再逐渐变黑，但这个阈值随时间变换
            // // 白天是强度大于1后才变黑，晚上则是强度大于0就变黑
            float brightenFactor = sqrt(clamp(lightDir.z * 3.0, 0.0, 1.0));
            if (brightenFactor > cloudTotalIntensity) {
                brightenFactor = cloudTotalIntensity;
            }

            vec3 oldAccum = vec3(accum);
            float darkenFactor = clamp(cloudTotalIntensity - brightenFactor, 0.0, 1.0);
            float cloudDarkColor = clamp(lightDir.z, 0.01, 0.6);
            accum = mix(accum, vec3(1.0, 1.0, 1.0), brightenFactor);
            // accum = vec3(brightenFactor);
            accum = mix(accum, vec3(cloudDarkColor), darkenFactor);
            out_emissive.w *= clamp(1.0 - cloudTotalIntensity, 0.0, 1.0);

            if (origViewDir.z > -0.04 && origViewDir.z < -0.02) {
                accum = mix(oldAccum, accum, clamp((origViewDir.z + 0.04) * 50.0 * max(1.0, cloudTotalIntensity * 2.0), 0.0, 1.0));
            }
            // accum = vec3(1.0, 1.0, 1.0);
            // // 云的基础颜色, 白天是白色，晚上是黑色
            // float cloudBaseColor = clamp(0.1, 0.9, lightDir.z * 3.0);
            // cloudBaseColor *= clamp(0.6, 1.0, (1.0 - cloudIntensity));

            // accum = mix(accum, vec3(cloudBaseColor), cloudThickness * cloudIntensity);
            // cloudBaseColor *= (1.0 - cloudThickness);
            // accum = mix(accum, vec3(cloudBaseColor), cloudIntensity);
            // float cloudColor = mix(1.0, 0.4, clamp(0.0, 1.0, cloudThickness + 0.6));
            // accum = mix(accum, vec3(cloudColor), clamp(0.0, 1.0, cloudThickness * 2.0));
            // accum = vec3(cloudColor);
        }
    #endif
    gl_FragColor = vec4(accum, 1.0);
    
    #include <tonemapping_fragment>
	#include <encodings_fragment>
    
//    gl_FragColor = encodeHDRE(sqrt(accum));

}
`],[`#define GLSLIFY 1
varying vec3 vWorldPosition;
void main() {
    #include <begin_vertex>
    vWorldPosition = normalize(vec3(modelMatrix * vec4(position, 1.0)) - cameraPosition);
    #include <project_vertex>
    gl_Position.z = gl_Position.w;
}
`,`#define GLSLIFY 1
#include <common>
varying vec3 vWorldPosition;
uniform vec3 lightDir;

vec3 skybox(vec3 dir, vec3 sun_pos)
{

    vec3 col = vec3(0.);
    
    vec3 p_sunset_dark[4] = vec3[4](
        vec3(0.3720705374951474, 0.3037080684557225, 0.26548632969565816),
        vec3(0.446163834012046, 0.39405890487346595, 0.425676737673072),
        vec3(0.16514907579431481, 0.40461292460006665, 0.8799446225003938),
        vec3(-7.057075230154481e-17, -0.08647963850488945, -0.269042973306185)
    );

    vec3 p_sunset_bright[4] = vec3[4](
        vec3( 0.38976745480184677, 0.31560358280318124,  0.27932656874),
        vec3( 1.2874522895367628,  1.0100154283349794,   0.862325457544),
        vec3( 0.12605043174959588, 0.23134451619328716,  0.526179948359),
        vec3(-0.0929868539256387, -0.07334463258550537, -0.192877259333)
    );

    vec3 p_day[4] = vec3[4](
        vec3(0.051010496458305694, 0.09758747153634058, 0.14233364823001612),
        vec3(0.7216045769411271, 0.8130766810405122, 0.9907063181559062),
        vec3(0.23738746590578705, 0.6037047603190588, 1.279274525377467),
        vec3(-4.834172446370963e-16, 0.1354589259524697, -1.4694301190050114e-15)
    );

    /* Sky */
    {
        float brightness_a = acos(dot(dir, sun_pos));
        float brightness_d = 1.5 * smoothstep(radians(80.), radians(0.), brightness_a) - .5;
    
        vec3 p_sunset[4] = vec3[4](
            mix(p_sunset_dark[0], p_sunset_bright[0], brightness_d),
            mix(p_sunset_dark[1], p_sunset_bright[1], brightness_d),
            mix(p_sunset_dark[2], p_sunset_bright[2], brightness_d),
            mix(p_sunset_dark[3], p_sunset_bright[3], brightness_d)
        );

        float sun_a = acos(dot(sun_pos, vec3(0., 1., 0.)));
        float sun_d = smoothstep(radians(100.), radians(60.), sun_a);

        vec3 a = mix(p_sunset[0], p_day[0], sun_d);
        vec3 b = mix(p_sunset[1], p_day[1], sun_d);
        vec3 c = mix(p_sunset[2], p_day[2], sun_d);
        vec3 d = mix(p_sunset[3], p_day[3], sun_d);

        float sky_a = acos(dot(dir, vec3(0., 1., 0.)));
        float sky_d = smoothstep(radians(90.), radians(60.), sky_a);

        // sin(1/x) suggested by Phillip Trudeau
        col += (b - d) * sin(1. / (vec3(sky_d) / c + 2. / radians(180.) - a)) + d;
    }

    /* Sun */
    float sun_a = acos(dot(sun_pos, dir));
    vec3 sun_col = .01 * vec3(1., .95, .95) / sun_a;
    col = max(col + .5 * sun_col, sun_col);

    return col;
}

void main() {
    vec3 origViewDir = normalize(vWorldPosition);
    gl_FragColor.xyz = skybox(vec3(origViewDir.x, origViewDir.z, origViewDir.y), vec3(lightDir.x, lightDir.z, lightDir.y));
    gl_FragColor.w = 1.0;
    #include <tonemapping_fragment>
	// #include <encodings_fragment>

}
`],[`#define GLSLIFY 1
varying vec3 vWorldPosition;
void main() {
    #include <begin_vertex>
    vWorldPosition = normalize(vec3(modelMatrix * vec4(position, 1.0)) - cameraPosition);
    #include <project_vertex>
    gl_Position.z = gl_Position.w;
}
`,`#define GLSLIFY 1
#include <common>
varying vec3 vWorldPosition;
uniform vec3 lightDir;

// first, lets define some constants to use (planet radius, position, and scattering coefficients)
#define PLANET_POS vec3(0.0) /* the position of the planet */
#define PLANET_RADIUS 6371e3 /* radius of the planet */
#define ATMOS_RADIUS 6471e3 /* radius of the atmosphere */
// scattering coeffs
#define RAY_BETA vec3(5.5e-6, 13.0e-6, 22.4e-6) /* rayleigh, affects the color of the sky */
#define MIE_BETA vec3(21e-6) /* mie, affects the color of the blob around the sun */
#define AMBIENT_BETA vec3(0.0) /* ambient, affects the scattering color when there is no lighting from the sun */
#define ABSORPTION_BETA vec3(2.04e-5, 4.97e-5, 1.95e-6) /* what color gets absorbed by the atmosphere (Due to things like ozone) */
#define G 0.7 /* mie scattering direction, or how big the blob around the sun is */
// and the heights (how far to go up before the scattering has no effect)
#define HEIGHT_RAY 8e3 /* rayleigh height */
#define HEIGHT_MIE 1.2e3 /* and mie */
#define HEIGHT_ABSORPTION 30e3 /* at what height the absorption is at it's maximum */
#define ABSORPTION_FALLOFF 4e3 /* how much the absorption decreases the further away it gets from the maximum height */
// and the steps (more looks better, but is slower)
// the primary step has the most effect on looks

#define PRIMARY_STEPS 32 /* primary steps, affects quality the most */
#define LIGHT_STEPS 8 /* light steps, how much steps in the light direction are taken */

// camera mode, 0 is on the ground, 1 is in space, 2 is moving, 3 is moving from ground to space
#define CAMERA_MODE 0

/*
Next we'll define the main scattering function.
This traces a ray from start to end and takes a certain amount of samples along this ray, in order to calculate the color.
For every sample, we'll also trace a ray in the direction of the light, 
because the color that reaches the sample also changes due to scattering
*/
vec3 calculate_scattering(
	vec3 start, 				// the start of the ray (the camera position)
    vec3 dir, 					// the direction of the ray (the camera vector)
    float max_dist, 			// the maximum distance the ray can travel (because something is in the way, like an object)
    vec3 scene_color,			// the color of the scene
    vec3 light_dir, 			// the direction of the light
    vec3 light_intensity,		// how bright the light is, affects the brightness of the atmosphere
    vec3 planet_position, 		// the position of the planet
    float planet_radius, 		// the radius of the planet
    float atmo_radius, 			// the radius of the atmosphere
    vec3 beta_ray, 				// the amount rayleigh scattering scatters the colors (for earth: causes the blue atmosphere)
    vec3 beta_mie, 				// the amount mie scattering scatters colors
    vec3 beta_absorption,   	// how much air is absorbed
    vec3 beta_ambient,			// the amount of scattering that always occurs, cna help make the back side of the atmosphere a bit brighter
    float g, 					// the direction mie scatters the light in (like a cone). closer to -1 means more towards a single direction
    float height_ray, 			// how high do you have to go before there is no rayleigh scattering?
    float height_mie, 			// the same, but for mie
    float height_absorption,	// the height at which the most absorption happens
    float absorption_falloff,	// how fast the absorption falls off from the absorption height
    int steps_i, 				// the amount of steps along the 'primary' ray, more looks better but slower
    int steps_l 				// the amount of steps along the light ray, more looks better but slower
) {
    // add an offset to the camera position, so that the atmosphere is in the correct position
    start -= planet_position;
    // calculate the start and end position of the ray, as a distance along the ray
    // we do this with a ray sphere intersect
    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, start);
    float c = dot(start, start) - (atmo_radius * atmo_radius);
    float d = (b * b) - 4.0 * a * c;
    
    // stop early if there is no intersect
    if (d < 0.0) return scene_color;
    
    // calculate the ray length
    vec2 ray_length = vec2(
        max((-b - sqrt(d)) / (2.0 * a), 0.0),
        min((-b + sqrt(d)) / (2.0 * a), max_dist)
    );
    
    // if the ray did not hit the atmosphere, return a black color
    if (ray_length.x > ray_length.y) return scene_color;
    // prevent the mie glow from appearing if there's an object in front of the camera
    bool allow_mie = max_dist > ray_length.y;
    // make sure the ray is no longer than allowed
    ray_length.y = min(ray_length.y, max_dist);
    ray_length.x = max(ray_length.x, 0.0);
    // get the step size of the ray
    float step_size_i = (ray_length.y - ray_length.x) / float(steps_i);
    
    // next, set how far we are along the ray, so we can calculate the position of the sample
    // if the camera is outside the atmosphere, the ray should start at the edge of the atmosphere
    // if it's inside, it should start at the position of the camera
    // the min statement makes sure of that
    float ray_pos_i = ray_length.x + step_size_i * 0.5;
    
    // these are the values we use to gather all the scattered light
    vec3 total_ray = vec3(0.0); // for rayleigh
    vec3 total_mie = vec3(0.0); // for mie
    
    // initialize the optical depth. This is used to calculate how much air was in the ray
    vec3 opt_i = vec3(0.0);
    
    // also init the scale height, avoids some vec2's later on
    vec2 scale_height = vec2(height_ray, height_mie);
    
    // Calculate the Rayleigh and Mie phases.
    // This is the color that will be scattered for this ray
    // mu, mumu and gg are used quite a lot in the calculation, so to speed it up, precalculate them
    float mu = dot(dir, light_dir);
    float mumu = mu * mu;
    float gg = g * g;
    float phase_ray = 3.0 / (50.2654824574 /* (16 * pi) */) * (1.0 + mumu);
    float phase_mie = allow_mie ? 3.0 / (25.1327412287 /* (8 * pi) */) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;
    
    // now we need to sample the 'primary' ray. this ray gathers the light that gets scattered onto it
    for (int i = 0; i < steps_i; ++i) {
        
        // calculate where we are along this ray
        vec3 pos_i = start + dir * ray_pos_i;
        
        // and how high we are above the surface
        float height_i = length(pos_i) - planet_radius;
        
        // now calculate the density of the particles (both for rayleigh and mie)
        vec3 density = vec3(exp(-height_i / scale_height), 0.0);
        
        // and the absorption density. this is for ozone, which scales together with the rayleigh, 
        // but absorbs the most at a specific height, so use the sech function for a nice curve falloff for this height
        // clamp it to avoid it going out of bounds. This prevents weird black spheres on the night side
        float denom = (height_absorption - height_i) / absorption_falloff;
        density.z = (1.0 / (denom * denom + 1.0)) * density.x;
        
        // multiply it by the step size here
        // we are going to use the density later on as well
        density *= step_size_i;
        
        // Add these densities to the optical depth, so that we know how many particles are on this ray.
        opt_i += density;
        
        // Calculate the step size of the light ray.
        // again with a ray sphere intersect
        // a, b, c and d are already defined
        a = dot(light_dir, light_dir);
        b = 2.0 * dot(light_dir, pos_i);
        c = dot(pos_i, pos_i) - (atmo_radius * atmo_radius);
        d = (b * b) - 4.0 * a * c;

        // no early stopping, this one should always be inside the atmosphere
        // calculate the ray length
        float step_size_l = (-b + sqrt(d)) / (2.0 * a * float(steps_l));

        // and the position along this ray
        // this time we are sure the ray is in the atmosphere, so set it to 0
        float ray_pos_l = step_size_l * 0.5;

        // and the optical depth of this ray
        vec3 opt_l = vec3(0.0);
            
        // now sample the light ray
        // this is similar to what we did before
        for (int l = 0; l < steps_l; ++l) {

            // calculate where we are along this ray
            vec3 pos_l = pos_i + light_dir * ray_pos_l;

            // the heigth of the position
            float height_l = length(pos_l) - planet_radius;

            // calculate the particle density, and add it
            // this is a bit verbose
            // first, set the density for ray and mie
            vec3 density_l = vec3(exp(-height_l / scale_height), 0.0);
            
            // then, the absorption
            float denom = (height_absorption - height_l) / absorption_falloff;
            density_l.z = (1.0 / (denom * denom + 1.0)) * density_l.x;
            
            // multiply the density by the step size
            density_l *= step_size_l;
            
            // and add it to the total optical depth
            opt_l += density_l;
            
            // and increment where we are along the light ray.
            ray_pos_l += step_size_l;
            
        }
        
        // Now we need to calculate the attenuation
        // this is essentially how much light reaches the current sample point due to scattering
        vec3 attn = exp(-beta_ray * (opt_i.x + opt_l.x) - beta_mie * (opt_i.y + opt_l.y) - beta_absorption * (opt_i.z + opt_l.z));

        // accumulate the scattered light (how much will be scattered towards the camera)
        total_ray += density.x * attn;
        total_mie += density.y * attn;

        // and increment the position on this ray
        ray_pos_i += step_size_i;
    	
    }
    
    // calculate how much light can pass through the atmosphere
    vec3 opacity = exp(-(beta_mie * opt_i.y + beta_ray * opt_i.x + beta_absorption * opt_i.z));
    
	// calculate and return the final color
    return (
        	phase_ray * beta_ray * total_ray // rayleigh color
       		+ phase_mie * beta_mie * total_mie // mie
            + opt_i.x * beta_ambient // and ambient
    ) * light_intensity + scene_color * opacity; // now make sure the background is rendered correctly
}

/*
A ray-sphere intersect
This was previously used in the atmosphere as well, but it's only used for the planet intersect now, since the atmosphere has this
ray sphere intersect built in
*/

vec2 ray_sphere_intersect(
    vec3 start, // starting position of the ray
    vec3 dir, // the direction of the ray
    float radius // and the sphere radius
) {
    // ray-sphere intersection that assumes
    // the sphere is centered at the origin.
    // No intersection when result.x > result.y
    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, start);
    float c = dot(start, start) - (radius * radius);
    float d = (b*b) - 4.0*a*c;
    if (d < 0.0) return vec2(1e5,-1e5);
    return vec2(
        (-b - sqrt(d))/(2.0*a),
        (-b + sqrt(d))/(2.0*a)
    );
}

/*
To make the planet we're rendering look nicer, we implemented a skylight function here

Essentially it just takes a sample of the atmosphere in the direction of the surface normal
*/
vec3 skylight(vec3 sample_pos, vec3 surface_normal, vec3 light_dir, vec3 background_col) {

    // slightly bend the surface normal towards the light direction
    surface_normal = normalize(mix(surface_normal, light_dir, 0.6));
    
    // and sample the atmosphere
    return calculate_scattering(
    	sample_pos,						// the position of the camera
        surface_normal, 				// the camera vector (ray direction of this pixel)
        3.0 * ATMOS_RADIUS, 			// max dist, since nothing will stop the ray here, just use some arbitrary value
        background_col,					// scene color, just the background color here
        light_dir,						// light direction
        vec3(40.0),						// light intensity, 40 looks nice
        PLANET_POS,						// position of the planet
        PLANET_RADIUS,                  // radius of the planet in meters
        ATMOS_RADIUS,                   // radius of the atmosphere in meters
        RAY_BETA,						// Rayleigh scattering coefficient
        MIE_BETA,                       // Mie scattering coefficient
        ABSORPTION_BETA,                // Absorbtion coefficient
        AMBIENT_BETA,					// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it
        G,                          	// Mie preferred scattering direction
        HEIGHT_RAY,                     // Rayleigh scale height
        HEIGHT_MIE,                     // Mie scale height
        HEIGHT_ABSORPTION,				// the height at which the most absorption happens
        ABSORPTION_FALLOFF,				// how fast the absorption falls off from the absorption height
        LIGHT_STEPS, 					// steps in the ray direction
        LIGHT_STEPS 					// steps in the light direction
    );
}

/*
The following function returns the scene color and depth 
(the color of the pixel without the atmosphere, and the distance to the surface that is visible on that pixel)

in this case, the function renders a green sphere on the place where the planet should be
color is in .xyz, distance in .w

I won't explain too much about how this works, since that's not the aim of this shader
*/
vec4 render_scene(vec3 pos, vec3 dir, vec3 light_dir) {
    
    // the color to use, w is the scene depth
    vec4 color = vec4(0.0, 0.0, 0.0, 1e12);
    
    // add a sun, if the angle between the ray direction and the light direction is small enough, color the pixels white
    color.xyz = vec3(dot(dir, light_dir) > 0.9998 ? 3.0 : 0.0);
    
    // get where the ray intersects the planet
    vec2 planet_intersect = ray_sphere_intersect(pos - PLANET_POS, dir, PLANET_RADIUS); 
    
    // if the ray hit the planet, set the max distance to that ray
    if (0.0 < planet_intersect.y) {
    	color.w = max(planet_intersect.x, 0.0);
        
        // sample position, where the pixel is
        vec3 sample_pos = pos + (dir * planet_intersect.x) - PLANET_POS;
        
        // and the surface normal
        vec3 surface_normal = normalize(sample_pos);
        
        // get the color of the sphere
        color.xyz = vec3(0.0, 0.25, 0.05); 
        
        // get wether this point is shadowed, + how much light scatters towards the camera according to the lommel-seelinger law
        vec3 N = surface_normal;
        vec3 V = -dir;
        vec3 L = light_dir;
        float dotNV = max(1e-6, dot(N, V));
        float dotNL = max(1e-6, dot(N, L));
        float shadow = dotNL / (dotNL + dotNV);
        
        // apply the shadow
        color.xyz *= shadow;
        
        // apply skylight
        color.xyz += clamp(skylight(sample_pos, surface_normal, light_dir, vec3(0.0)) * vec3(0.0, 0.25, 0.05), 0.0, 1.0);
    }
    
	return color;
}

void main() {
    vec3 camera_vector = normalize(vWorldPosition);
    camera_vector = vec3(camera_vector.x, camera_vector.z, camera_vector.y);
     vec3 camera_position = vec3(0.0, PLANET_RADIUS + 100.0, 0.0);
     vec3 transformedLightDir = vec3(lightDir.x, lightDir.z, lightDir.y);
     vec4 scene = render_scene(camera_position, camera_vector, transformedLightDir);
    
    // the color of this pixel
    vec3 col = vec3(0.0);//scene.xyz;
    
    // get the atmosphere color
    col += calculate_scattering(
    	camera_position,				// the position of the camera
        camera_vector, 					// the camera vector (ray direction of this pixel)
        scene.w, 						// max dist, essentially the scene depth
        scene.xyz,						// scene color, the color of the current pixel being rendered
        transformedLightDir,						// light direction
        vec3(40.0),						// light intensity, 40 looks nice
        PLANET_POS,						// position of the planet
        PLANET_RADIUS,                  // radius of the planet in meters
        ATMOS_RADIUS,                   // radius of the atmosphere in meters
        RAY_BETA,						// Rayleigh scattering coefficient
        MIE_BETA,                       // Mie scattering coefficient
        ABSORPTION_BETA,                // Absorbtion coefficient
        AMBIENT_BETA,					// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it
        G,                          	// Mie preferred scattering direction
        HEIGHT_RAY,                     // Rayleigh scale height
        HEIGHT_MIE,                     // Mie scale height
        HEIGHT_ABSORPTION,				// the height at which the most absorption happens
        ABSORPTION_FALLOFF,				// how fast the absorption falls off from the absorption height 
        PRIMARY_STEPS, 					// steps in the ray direction 
        LIGHT_STEPS 					// steps in the light direction
    );
        
    // apply exposure, removing this makes the brighter colors look ugly
    // you can play around with removing this
    col = 1.0 - exp(-col);

    // Output to screen
    gl_FragColor = vec4(col, 1.0);

    #include <tonemapping_fragment>
	// #include <encodings_fragment>

}
`]];class Yv extends Qt{constructor(t){super(),g(this,"_shaderIndex",-1),this.defines={},this.uniforms=ft.clone(cS),this.side=2,this.shaderIndex=0,this.depthWrite=!1,this.depthTest=!1,this.envMap=null,this.clipping=!0,Jt(this,["cloudIntensity","rayleighFactor","mieFactor","miePhase","weatherMap","clipUnderground"]),Object.defineProperties(this,{cloudMap:{get:function(){return this.uniforms.cloudMap.value},set:function(e){e?(this.defines.CLOUD_MAP=!0,this.uniforms.cloudMap.value=e):(delete this.defines.CLOUD_MAP,this.uniforms.cloudMap.value=null)}},cloudsMap:{get:function(){return this.uniforms.cloudsMap.value},set:function(e){this.uniforms.cloudsMap.value=e}},nightMap:{get:function(){return this.uniforms.nightMap.value},set:function(e){e?(this.defines.NIGHT_MAP=!0,this.uniforms.nightMap.value=e):(delete this.defines.NIGHT_MAP,this.uniforms.nightMap.value=null)}},groundColor:{get:function(){return this.uniforms.groundColor.value},set:function(e){this.uniforms.groundColor.value.copy(e)}}})}get shaderIndex(){return this._shaderIndex}set shaderIndex(t){if(this._shaderIndex===t||!Xv[t])return;const e=Xv[t];this.vertexShader=e[0],this.fragmentShader=e[1],this.needsUpdate=!0,this._shaderIndex=t}dispose(){let t=["weatherMap","nightMap","cloudMap","cloudsMap"];for(let e=0;e<t.length;e++){const i=t[e];this.uniforms[i]&&this.uniforms[i].value&&this.uniforms[i].value.dispose()}super.dispose()}}class uS extends ot{constructor(){super(),this.geometry=new Wt(1,1,1),this.material=new Yv,this.frustumCulled=!1}}class Bs extends Ge{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(e){return new gS(e)}),this.register(function(e){return new wS(e)}),this.register(function(e){return new SS(e)}),this.register(function(e){return new _S(e)}),this.register(function(e){return new yS(e)}),this.register(function(e){return new xS(e)}),this.register(function(e){return new bS(e)}),this.register(function(e){return new fS(e)}),this.register(function(e){return new MS(e)}),this.register(function(e){return new vS(e)}),this.register(function(e){return new pS(e)}),this.register(function(e){return new TS(e)})}load(t,e,i,s){const r=this;let a;a=this.resourcePath!==""?this.resourcePath:this.path!==""?this.path:nn.extractUrlBase(t),this.manager.itemStart(t);const o=function(h){s?s(h):console.error(h),r.manager.itemError(t),r.manager.itemEnd(t)},l=new _i(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(t,function(h){try{r.parse(h,a,function(c){e(c),r.manager.itemEnd(t)},o)}catch(c){o(c)}},i,o)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return this.pluginCallbacks.indexOf(t)===-1&&this.pluginCallbacks.push(t),this}unregister(t){return this.pluginCallbacks.indexOf(t)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,i,s){let r;const a={},o={};if(typeof t=="string")r=t;else if(nn.decodeText(new Uint8Array(t,0,4))===Zv){try{a[zt.KHR_BINARY_GLTF]=new AS(t)}catch(c){return void(s&&s(c))}r=a[zt.KHR_BINARY_GLTF].content}else r=nn.decodeText(new Uint8Array(t));const l=JSON.parse(r);if(l.asset===void 0||l.asset.version[0]<2)return void(s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const h=new qS(l,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});h.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const u=this.pluginCallbacks[c](h);o[u.name]=u,a[u.name]=!0}if(l.extensionsUsed)for(let c=0;c<l.extensionsUsed.length;++c){const u=l.extensionsUsed[c],d=l.extensionsRequired||[];switch(u){case zt.KHR_MATERIALS_UNLIT:a[u]=new mS;break;case zt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:a[u]=new LS;break;case zt.KHR_DRACO_MESH_COMPRESSION:a[u]=new PS(l,this.dracoLoader);break;case zt.KHR_TEXTURE_TRANSFORM:a[u]=new RS;break;case zt.KHR_MESH_QUANTIZATION:a[u]=new IS;break;default:d.indexOf(u)>=0&&o[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}h.setExtensions(a),h.setPlugins(o),h.parse(i,s)}parseAsync(t,e){const i=this;return new Promise(function(s,r){i.parse(t,e,s,r)})}}function dS(){let n={};return{get:function(t){return n[t]},add:function(t,e){n[t]=e},remove:function(t){delete n[t]},removeAll:function(){n={}}}}const zt={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class pS{constructor(t){this.parser=t,this.name=zt.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,e=this.parser.json.nodes||[];for(let i=0,s=e.length;i<s;i++){const r=e[i];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&t._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(t){const e=this.parser,i="light:"+t;let s=e.cache.get(i);if(s)return s;const r=e.json,a=((r.extensions&&r.extensions[this.name]||{}).lights||[])[t];let o;const l=new nt(16777215);a.color!==void 0&&l.fromArray(a.color);const h=a.range!==void 0?a.range:0;switch(a.type){case"directional":o=new Ql(l),o.target.position.set(0,0,-1),o.add(o.target);break;case"point":o=new Bu(l),o.distance=h;break;case"spot":o=new Nu(l),o.distance=h,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,o.angle=a.spot.outerConeAngle,o.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,o.target.position.set(0,0,-1),o.add(o.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return o.position.set(0,0,0),o.decay=2,a.intensity!==void 0&&(o.intensity=a.intensity),o.name=e.createUniqueName(a.name||"light_"+t),s=Promise.resolve(o),e.cache.add(i,s),s}createNodeAttachment(t){const e=this,i=this.parser,s=i.json.nodes[t],r=(s.extensions&&s.extensions[this.name]||{}).light;return r===void 0?null:this._loadLight(r).then(function(a){return i._getNodeRef(e.cache,r,a)})}}class mS{constructor(){this.name=zt.KHR_MATERIALS_UNLIT}getMaterialType(){return Zt}extendParams(t,e,i){const s=[];t.color=new nt(1,1,1),t.opacity=1;const r=e.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const a=r.baseColorFactor;t.color.fromArray(a),t.opacity=a[3]}r.baseColorTexture!==void 0&&s.push(i.assignTexture(t,"map",r.baseColorTexture,3001))}return Promise.all(s)}}class fS{constructor(t){this.parser=t,this.name=zt.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(t,e){const i=this.parser.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name].emissiveStrength;return s!==void 0&&(e.emissiveIntensity=s),Promise.resolve()}}class gS{constructor(t){this.parser=t,this.name=zt.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?wn:null}extendMaterialParams(t,e){const i=this.parser,s=i.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],a=s.extensions[this.name];if(a.clearcoatFactor!==void 0&&(e.clearcoat=a.clearcoatFactor),a.clearcoatTexture!==void 0&&r.push(i.assignTexture(e,"clearcoatMap",a.clearcoatTexture)),a.clearcoatRoughnessFactor!==void 0&&(e.clearcoatRoughness=a.clearcoatRoughnessFactor),a.clearcoatRoughnessTexture!==void 0&&r.push(i.assignTexture(e,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),a.clearcoatNormalTexture!==void 0&&(r.push(i.assignTexture(e,"clearcoatNormalMap",a.clearcoatNormalTexture)),a.clearcoatNormalTexture.scale!==void 0)){const o=a.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new V(o,o)}return Promise.all(r)}}class vS{constructor(t){this.parser=t,this.name=zt.KHR_MATERIALS_IRIDESCENCE}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?wn:null}extendMaterialParams(t,e){const i=this.parser,s=i.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],a=s.extensions[this.name];return a.iridescenceFactor!==void 0&&(e.iridescence=a.iridescenceFactor),a.iridescenceTexture!==void 0&&r.push(i.assignTexture(e,"iridescenceMap",a.iridescenceTexture)),a.iridescenceIor!==void 0&&(e.iridescenceIOR=a.iridescenceIor),e.iridescenceThicknessRange===void 0&&(e.iridescenceThicknessRange=[100,400]),a.iridescenceThicknessMinimum!==void 0&&(e.iridescenceThicknessRange[0]=a.iridescenceThicknessMinimum),a.iridescenceThicknessMaximum!==void 0&&(e.iridescenceThicknessRange[1]=a.iridescenceThicknessMaximum),a.iridescenceThicknessTexture!==void 0&&r.push(i.assignTexture(e,"iridescenceThicknessMap",a.iridescenceThicknessTexture)),Promise.all(r)}}class _S{constructor(t){this.parser=t,this.name=zt.KHR_MATERIALS_SHEEN}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?wn:null}extendMaterialParams(t,e){const i=this.parser,s=i.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[];e.sheenColor=new nt(0,0,0),e.sheenRoughness=0,e.sheen=1;const a=s.extensions[this.name];return a.sheenColorFactor!==void 0&&e.sheenColor.fromArray(a.sheenColorFactor),a.sheenRoughnessFactor!==void 0&&(e.sheenRoughness=a.sheenRoughnessFactor),a.sheenColorTexture!==void 0&&r.push(i.assignTexture(e,"sheenColorMap",a.sheenColorTexture,3001)),a.sheenRoughnessTexture!==void 0&&r.push(i.assignTexture(e,"sheenRoughnessMap",a.sheenRoughnessTexture)),Promise.all(r)}}class yS{constructor(t){this.parser=t,this.name=zt.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?wn:null}extendMaterialParams(t,e){const i=this.parser,s=i.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],a=s.extensions[this.name];return a.transmissionFactor!==void 0&&(e.transmission=a.transmissionFactor),a.transmissionTexture!==void 0&&r.push(i.assignTexture(e,"transmissionMap",a.transmissionTexture)),Promise.all(r)}}class xS{constructor(t){this.parser=t,this.name=zt.KHR_MATERIALS_VOLUME}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?wn:null}extendMaterialParams(t,e){const i=this.parser,s=i.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],a=s.extensions[this.name];e.thickness=a.thicknessFactor!==void 0?a.thicknessFactor:0,a.thicknessTexture!==void 0&&r.push(i.assignTexture(e,"thicknessMap",a.thicknessTexture)),e.attenuationDistance=a.attenuationDistance||0;const o=a.attenuationColor||[1,1,1];return e.attenuationColor=new nt(o[0],o[1],o[2]),Promise.all(r)}}class bS{constructor(t){this.parser=t,this.name=zt.KHR_MATERIALS_IOR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?wn:null}extendMaterialParams(t,e){const i=this.parser.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name];return e.ior=s.ior!==void 0?s.ior:1.5,Promise.resolve()}}class MS{constructor(t){this.parser=t,this.name=zt.KHR_MATERIALS_SPECULAR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?wn:null}extendMaterialParams(t,e){const i=this.parser,s=i.json.materials[t];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],a=s.extensions[this.name];e.specularIntensity=a.specularFactor!==void 0?a.specularFactor:1,a.specularTexture!==void 0&&r.push(i.assignTexture(e,"specularIntensityMap",a.specularTexture));const o=a.specularColorFactor||[1,1,1];return e.specularColor=new nt(o[0],o[1],o[2]),a.specularColorTexture!==void 0&&r.push(i.assignTexture(e,"specularColorMap",a.specularColorTexture,3001)),Promise.all(r)}}class wS{constructor(t){this.parser=t,this.name=zt.KHR_TEXTURE_BASISU}loadTexture(t){const e=this.parser,i=e.json,s=i.textures[t];if(!s.extensions||!s.extensions[this.name])return null;const r=s.extensions[this.name],a=e.options.ktx2Loader;if(!a){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(t,r.source,a)}}class SS{constructor(t){this.parser=t,this.name=zt.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const e=this.name,i=this.parser,s=i.json,r=s.textures[t];if(!r.extensions||!r.extensions[e])return null;const a=r.extensions[e],o=s.images[a.source];let l=i.textureLoader;if(o.uri){const h=i.options.manager.getHandler(o.uri);h!==null&&(l=h)}return this.detectSupport().then(function(h){if(h)return i.loadTextureImage(t,a.source,l);if(s.extensionsRequired&&s.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return i.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(t){const e=new Image;e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.onload=e.onerror=function(){t(e.height===1)}})),this.isSupported}}class TS{constructor(t){this.name=zt.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const e=this.parser.json,i=e.bufferViews[t];if(i.extensions&&i.extensions[this.name]){const s=i.extensions[this.name],r=this.parser.getDependency("buffer",s.buffer),a=this.parser.options.meshoptDecoder;if(!a||!a.supported){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([r,a.ready]).then(function(o){const l=s.byteOffset||0,h=s.byteLength||0,c=s.count,u=s.byteStride,d=new ArrayBuffer(c*u),p=new Uint8Array(o[0],l,h);return a.decodeGltfBuffer(new Uint8Array(d),c,u,p,s.mode,s.filter),d})}return null}}const Zv="glTF",ES=1313821514,CS=5130562;class AS{constructor(t){this.name=zt.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(t,0,12);if(this.header={magic:nn.decodeText(new Uint8Array(t.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==Zv)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-12,s=new DataView(t,12);let r=0;for(;r<i;){const a=s.getUint32(r,!0);r+=4;const o=s.getUint32(r,!0);if(r+=4,o===ES){const l=new Uint8Array(t,12+r,a);this.content=nn.decodeText(l)}else if(o===CS){const l=12+r;this.body=t.slice(l,l+a)}r+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class PS{constructor(t,e){if(!e)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=zt.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=e,this.dracoLoader.preload()}decodePrimitive(t,e){const i=this.json,s=this.dracoLoader,r=t.extensions[this.name].bufferView,a=t.extensions[this.name].attributes,o={},l={},h={};for(const c in a){const u=np[c]||c.toLowerCase();o[u]=a[c]}for(const c in t.attributes){const u=np[c]||c.toLowerCase();if(a[c]!==void 0){const d=i.accessors[t.attributes[c]],p=Lo[d.componentType];h[u]=p,l[u]=d.normalized===!0}}return e.getDependency("bufferView",r).then(function(c){return new Promise(function(u){s.decodeDracoFile(c,function(d){for(const p in d.attributes){const m=d.attributes[p],f=l[p];f!==void 0&&(m.normalized=f)}u(d)},o,h)})})}}class RS{constructor(){this.name=zt.KHR_TEXTURE_TRANSFORM}extendTexture(t,e){return e.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),e.offset===void 0&&e.rotation===void 0&&e.scale===void 0||(t=t.clone(),e.offset!==void 0&&t.offset.fromArray(e.offset),e.rotation!==void 0&&(t.rotation=e.rotation),e.scale!==void 0&&t.repeat.fromArray(e.scale),t.needsUpdate=!0),t}}class ep extends en{constructor(t){super(),this.isGLTFSpecularGlossinessMaterial=!0;const e=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),i=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),s=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),r=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),a=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),o={specular:{value:new nt().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=o,this.onBeforeCompile=function(l){for(const h in o)l.uniforms[h]=o[h];l.fragmentShader=l.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",e).replace("#include <metalnessmap_pars_fragment>",i).replace("#include <roughnessmap_fragment>",s).replace("#include <metalnessmap_fragment>",r).replace("#include <lights_physical_fragment>",a)},Object.defineProperties(this,{specular:{get:function(){return o.specular.value},set:function(l){o.specular.value=l}},specularMap:{get:function(){return o.specularMap.value},set:function(l){o.specularMap.value=l,l?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return o.glossiness.value},set:function(l){o.glossiness.value=l}},glossinessMap:{get:function(){return o.glossinessMap.value},set:function(l){o.glossinessMap.value=l,l?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(t)}copy(t){return super.copy(t),this.specularMap=t.specularMap,this.specular.copy(t.specular),this.glossinessMap=t.glossinessMap,this.glossiness=t.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class LS{constructor(){this.name=zt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return ep}extendParams(t,e,i){const s=e.extensions[this.name];t.color=new nt(1,1,1),t.opacity=1;const r=[];if(Array.isArray(s.diffuseFactor)){const a=s.diffuseFactor;t.color.fromArray(a),t.opacity=a[3]}if(s.diffuseTexture!==void 0&&r.push(i.assignTexture(t,"map",s.diffuseTexture,3001)),t.emissive=new nt(0,0,0),t.glossiness=s.glossinessFactor!==void 0?s.glossinessFactor:1,t.specular=new nt(1,1,1),Array.isArray(s.specularFactor)&&t.specular.fromArray(s.specularFactor),s.specularGlossinessTexture!==void 0){const a=s.specularGlossinessTexture;r.push(i.assignTexture(t,"glossinessMap",a)),r.push(i.assignTexture(t,"specularMap",a,3001))}return Promise.all(r)}createMaterial(t){const e=new ep(t);return e.fog=!0,e.color=t.color,e.map=t.map===void 0?null:t.map,e.lightMap=null,e.lightMapIntensity=1,e.aoMap=t.aoMap===void 0?null:t.aoMap,e.aoMapIntensity=1,e.emissive=t.emissive,e.emissiveIntensity=t.emissiveIntensity===void 0?1:t.emissiveIntensity,e.emissiveMap=t.emissiveMap===void 0?null:t.emissiveMap,e.bumpMap=t.bumpMap===void 0?null:t.bumpMap,e.bumpScale=1,e.normalMap=t.normalMap===void 0?null:t.normalMap,e.normalMapType=0,t.normalScale&&(e.normalScale=t.normalScale),e.displacementMap=null,e.displacementScale=1,e.displacementBias=0,e.specularMap=t.specularMap===void 0?null:t.specularMap,e.specular=t.specular,e.glossinessMap=t.glossinessMap===void 0?null:t.glossinessMap,e.glossiness=t.glossiness,e.alphaMap=null,e.envMap=t.envMap===void 0?null:t.envMap,e.envMapIntensity=1,e}}class IS{constructor(){this.name=zt.KHR_MESH_QUANTIZATION}}class ip extends Nr{constructor(t,e,i,s){super(t,e,i,s)}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,s=this.valueSize,r=t*s*3+s;for(let a=0;a!==s;a++)e[a]=i[r+a];return e}}ip.prototype.interpolate_=function(n,t,e,i){const s=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=2*a,l=3*a,h=i-t,c=(e-t)/h,u=c*c,d=u*c,p=n*l,m=p-l,f=-2*d+3*u,v=d-u,_=1-f,y=v-u+c;for(let x=0;x!==a;x++){const b=r[m+x+a],w=r[m+x+o]*h,M=r[p+x+a],T=r[p+x]*h;s[x]=_*b+y*w+f*M+v*T}return s};const DS=new Ft;class OS extends ip{interpolate_(t,e,i,s){const r=super.interpolate_(t,e,i,s);return DS.fromArray(r).normalize().toArray(r),r}}const zS=0,US=1,FS=2,NS=3,kS=4,Jv=5,Kv=6,Lo={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Qv={9728:1003,9729:1006,9984:1004,9985:1007,9986:1005,9987:1008},$v={33071:1001,33648:1002,10497:1e3},t_={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},np={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},la={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},BS={CUBICSPLINE:void 0,LINEAR:2301,STEP:2300},VS="OPAQUE",GS="MASK",jS="BLEND";function Io(n,t,e){for(const i in e.extensions)n[i]===void 0&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[i]=e.extensions[i])}function Vs(n,t){t.extras!==void 0&&(typeof t.extras=="object"?Object.assign(n.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function HS(n,t){if(n.updateMorphTargets(),t.weights!==void 0)for(let e=0,i=t.weights.length;e<i;e++)n.morphTargetInfluences[e]=t.weights[e];if(t.extras&&Array.isArray(t.extras.targetNames)){const e=t.extras.targetNames;if(n.morphTargetInfluences.length===e.length){n.morphTargetDictionary={};for(let i=0,s=e.length;i<s;i++)n.morphTargetDictionary[e[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function WS(n){const t=n.extensions&&n.extensions[zt.KHR_DRACO_MESH_COMPRESSION];let e;return e=t?"draco:"+t.bufferView+":"+t.indices+":"+e_(t.attributes):n.indices+":"+e_(n.attributes)+":"+n.mode,e}function e_(n){let t="";const e=Object.keys(n).sort();for(let i=0,s=e.length;i<s;i++)t+=e[i]+":"+n[e[i]]+";";return t}function sp(n){switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class qS{constructor(t={},e={}){this.json=t,this.extensions={},this.plugins={},this.options=e,this.cache=new dS,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};const i=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,s=navigator.userAgent.indexOf("Firefox")>-1,r=s?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;typeof createImageBitmap>"u"||i||s&&r<98?this.textureLoader=new Te(this.options.manager):this.textureLoader=new tg(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new _i(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,e){const i=this,s=this.json,r=this.extensions;this.cache.removeAll(),this._invokeAll(function(a){return a._markDefs&&a._markDefs()}),Promise.all(this._invokeAll(function(a){return a.beforeRoot&&a.beforeRoot()})).then(function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])}).then(function(a){const o={scene:a[0][s.scene||0],scenes:a[0],animations:a[1],cameras:a[2],asset:s.asset,parser:i,userData:{}};Io(r,o,s),Vs(o,s),Promise.all(i._invokeAll(function(l){return l.afterRoot&&l.afterRoot(o)})).then(function(){t(o)})}).catch(e)}_markDefs(){const t=this.json.nodes||[],e=this.json.skins||[],i=this.json.meshes||[];for(let s=0,r=e.length;s<r;s++){const a=e[s].joints;for(let o=0,l=a.length;o<l;o++)t[a[o]].isBone=!0}for(let s=0,r=t.length;s<r;s++){const a=t[s];a.mesh!==void 0&&(this._addNodeRef(this.meshCache,a.mesh),a.skin!==void 0&&(i[a.mesh].isSkinnedMesh=!0)),a.camera!==void 0&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(t,e){e!==void 0&&(t.refs[e]===void 0&&(t.refs[e]=t.uses[e]=0),t.refs[e]++)}_getNodeRef(t,e,i){if(t.refs[e]<=1)return i;const s=i.clone(),r=(a,o)=>{const l=this.associations.get(a);l!=null&&this.associations.set(o,l);for(const[h,c]of a.children.entries())r(c,o.children[h])};return r(i,s),s.name+="_instance_"+t.uses[e]++,s}_invokeOne(t){const e=Object.values(this.plugins);e.push(this);for(let i=0;i<e.length;i++){const s=t(e[i]);if(s)return s}return null}_invokeAll(t){const e=Object.values(this.plugins);e.unshift(this);const i=[];for(let s=0;s<e.length;s++){const r=t(e[s]);r&&i.push(r)}return i}getDependency(t,e){const i=t+":"+e;let s=this.cache.get(i);if(!s){switch(t){case"scene":s=this.loadScene(e);break;case"node":s=this.loadNode(e);break;case"mesh":s=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(e)});break;case"accessor":s=this.loadAccessor(e);break;case"bufferView":s=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(e)});break;case"buffer":s=this.loadBuffer(e);break;case"material":s=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(e)});break;case"texture":s=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(e)});break;case"skin":s=this.loadSkin(e);break;case"animation":s=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(e)});break;case"camera":s=this.loadCamera(e);break;default:throw new Error("Unknown type: "+t)}this.cache.add(i,s)}return s}getDependencies(t){let e=this.cache.get(t);if(!e){const i=this,s=this.json[t+(t==="mesh"?"es":"s")]||[];e=Promise.all(s.map(function(r,a){return i.getDependency(t,a)})),this.cache.add(t,e)}return e}loadBuffer(t){const e=this.json.buffers[t],i=this.fileLoader;if(e.type&&e.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+e.type+" buffer type is not supported.");if(e.uri===void 0&&t===0)return Promise.resolve(this.extensions[zt.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(r,a){i.load(nn.resolveURL(e.uri,s.path),r,void 0,function(){a(new Error('THREE.GLTFLoader: Failed to load buffer "'+e.uri+'".'))})})}loadBufferView(t){const e=this.json.bufferViews[t];return this.getDependency("buffer",e.buffer).then(function(i){const s=e.byteLength||0,r=e.byteOffset||0;return i.slice(r,r+s)})}loadAccessor(t){const e=this,i=this.json,s=this.json.accessors[t];if(s.bufferView===void 0&&s.sparse===void 0)return Promise.resolve(null);const r=[];return s.bufferView!==void 0?r.push(this.getDependency("bufferView",s.bufferView)):r.push(null),s.sparse!==void 0&&(r.push(this.getDependency("bufferView",s.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",s.sparse.values.bufferView))),Promise.all(r).then(function(a){const o=a[0],l=t_[s.type],h=Lo[s.componentType],c=h.BYTES_PER_ELEMENT,u=c*l,d=s.byteOffset||0,p=s.bufferView!==void 0?i.bufferViews[s.bufferView].byteStride:void 0,m=s.normalized===!0;let f,v;if(p&&p!==u){const _=Math.floor(d/p),y="InterleavedBuffer:"+s.bufferView+":"+s.componentType+":"+_+":"+s.count;let x=e.cache.get(y);x||(f=new h(o,_*p,s.count*p/c),x=new xr(f,p/c),e.cache.add(y,x)),v=new Ki(x,l,d%p/c,m)}else f=o===null?new h(s.count*l):new h(o,d,s.count*l),v=new Lt(f,l,m);if(s.sparse!==void 0){const _=t_.SCALAR,y=Lo[s.sparse.indices.componentType],x=s.sparse.indices.byteOffset||0,b=s.sparse.values.byteOffset||0,w=new y(a[1],x,s.sparse.count*_),M=new h(a[2],b,s.sparse.count*l);o!==null&&(v=new Lt(v.array.slice(),v.itemSize,v.normalized));for(let T=0,R=w.length;T<R;T++){const E=w[T];if(v.setX(E,M[T*l]),l>=2&&v.setY(E,M[T*l+1]),l>=3&&v.setZ(E,M[T*l+2]),l>=4&&v.setW(E,M[T*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return v})}loadTexture(t){const e=this.json,i=this.options,s=e.textures[t].source,r=e.images[s];let a=this.textureLoader;if(r.uri){const o=i.manager.getHandler(r.uri);o!==null&&(a=o)}return this.loadTextureImage(t,s,a)}loadTextureImage(t,e,i){const s=this,r=this.json,a=r.textures[t],o=r.images[e],l=(o.uri||o.bufferView)+":"+a.sampler;if(this.textureCache[l])return this.textureCache[l];const h=this.loadImageSource(e,i).then(function(c){c.flipY=!1,a.name&&(c.name=a.name);const u=(r.samplers||{})[a.sampler]||{};return c.magFilter=Qv[u.magFilter]||1006,c.minFilter=Qv[u.minFilter]||1008,c.wrapS=$v[u.wrapS]||1e3,c.wrapT=$v[u.wrapT]||1e3,s.associations.set(c,{textures:t}),c}).catch(function(){return null});return this.textureCache[l]=h,h}loadImageSource(t,e){const i=this,s=this.json,r=this.options;if(this.sourceCache[t]!==void 0)return this.sourceCache[t].then(u=>u.clone());const a=s.images[t],o=self.URL||self.webkitURL;let l=a.uri||"",h=!1;if(a.bufferView!==void 0)l=i.getDependency("bufferView",a.bufferView).then(function(u){h=!0;const d=new Blob([u],{type:a.mimeType});return l=o.createObjectURL(d),l});else if(a.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const c=Promise.resolve(l).then(function(u){return new Promise(function(d,p){let m=d;e.isImageBitmapLoader===!0&&(m=function(f){const v=new Gt(f);v.needsUpdate=!0,d(v)}),e.load(nn.resolveURL(u,r.path),m,void 0,p)})}).then(function(u){var d;return h===!0&&o.revokeObjectURL(l),u.userData.mimeType=a.mimeType||((d=a.uri).search(/\.jpe?g($|\?)/i)>0||d.search(/^data\:image\/jpeg/)===0?"image/jpeg":d.search(/\.webp($|\?)/i)>0||d.search(/^data\:image\/webp/)===0?"image/webp":"image/png"),u}).catch(function(u){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),u});return this.sourceCache[t]=c,c}assignTexture(t,e,i,s){const r=this;return this.getDependency("texture",i.index).then(function(a){if(i.texCoord===void 0||i.texCoord==0||e==="aoMap"&&i.texCoord==1||console.warn("THREE.GLTFLoader: Custom UV set "+i.texCoord+" for texture "+e+" not yet supported."),r.extensions[zt.KHR_TEXTURE_TRANSFORM]){const o=i.extensions!==void 0?i.extensions[zt.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const l=r.associations.get(a);a=r.extensions[zt.KHR_TEXTURE_TRANSFORM].extendTexture(a,o),r.associations.set(a,l)}}return s!==void 0&&(a.encoding=s),t[e]=a,a})}assignFinalMaterial(t){const e=t.geometry;let i=t.material;const s=e.attributes.tangent===void 0,r=e.attributes.color!==void 0,a=e.attributes.normal===void 0;if(t.isPoints){const o="PointsMaterial:"+i.uuid;let l=this.cache.get(o);l||(l=new Tr,ae.prototype.copy.call(l,i),l.color.copy(i.color),l.map=i.map,l.sizeAttenuation=!1,this.cache.add(o,l)),i=l}else if(t.isLine){const o="LineBasicMaterial:"+i.uuid;let l=this.cache.get(o);l||(l=new _e,ae.prototype.copy.call(l,i),l.color.copy(i.color),this.cache.add(o,l)),i=l}if(s||r||a){let o="ClonedMaterial:"+i.uuid+":";i.isGLTFSpecularGlossinessMaterial&&(o+="specular-glossiness:"),s&&(o+="derivative-tangents:"),r&&(o+="vertex-colors:"),a&&(o+="flat-shading:");let l=this.cache.get(o);l||(l=i.clone(),r&&(l.vertexColors=!0),a&&(l.flatShading=!0),s&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(o,l),this.associations.set(l,this.associations.get(i))),i=l}i.aoMap&&e.attributes.uv2===void 0&&e.attributes.uv!==void 0&&e.setAttribute("uv2",e.attributes.uv),t.material=i}getMaterialType(){return en}loadMaterial(t){const e=this,i=this.json,s=this.extensions,r=i.materials[t];let a;const o={},l=r.extensions||{},h=[];if(l[zt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const u=s[zt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];a=u.getMaterialType(),h.push(u.extendParams(o,r,e))}else if(l[zt.KHR_MATERIALS_UNLIT]){const u=s[zt.KHR_MATERIALS_UNLIT];a=u.getMaterialType(),h.push(u.extendParams(o,r,e))}else{const u=r.pbrMetallicRoughness||{};if(o.color=new nt(1,1,1),o.opacity=1,Array.isArray(u.baseColorFactor)){const d=u.baseColorFactor;o.color.fromArray(d),o.opacity=d[3]}u.baseColorTexture!==void 0&&h.push(e.assignTexture(o,"map",u.baseColorTexture,3001)),o.metalness=u.metallicFactor!==void 0?u.metallicFactor:1,o.roughness=u.roughnessFactor!==void 0?u.roughnessFactor:1,u.metallicRoughnessTexture!==void 0&&(h.push(e.assignTexture(o,"metalnessMap",u.metallicRoughnessTexture)),h.push(e.assignTexture(o,"roughnessMap",u.metallicRoughnessTexture))),a=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(t)}),h.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(t,o)})))}r.doubleSided===!0&&(o.side=2);const c=r.alphaMode||VS;if(c===jS?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,c===GS&&(o.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&a!==Zt&&(h.push(e.assignTexture(o,"normalMap",r.normalTexture)),o.normalScale=new V(1,1),r.normalTexture.scale!==void 0)){const u=r.normalTexture.scale;o.normalScale.set(u,u)}return r.occlusionTexture!==void 0&&a!==Zt&&(h.push(e.assignTexture(o,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&a!==Zt&&(o.emissive=new nt().fromArray(r.emissiveFactor)),r.emissiveTexture!==void 0&&a!==Zt&&h.push(e.assignTexture(o,"emissiveMap",r.emissiveTexture,3001)),Promise.all(h).then(function(){let u;return u=a===ep?s[zt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o):new a(o),r.name&&(u.name=r.name),Vs(u,r),e.associations.set(u,{materials:t}),r.extensions&&Io(s,u,r),u})}createUniqueName(t){const e=Nt.sanitizeNodeName(t||"");let i=e;for(let s=1;this.nodeNamesUsed[i];++s)i=e+"_"+s;return this.nodeNamesUsed[i]=!0,i}loadGeometries(t){const e=this,i=this.extensions,s=this.primitiveCache;function r(o){return i[zt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,e).then(function(l){return n_(l,o,e)})}const a=[];for(let o=0,l=t.length;o<l;o++){const h=t[o],c=WS(h),u=s[c];if(u)a.push(u.promise);else{let d;d=h.extensions&&h.extensions[zt.KHR_DRACO_MESH_COMPRESSION]?r(h):n_(new gt,h,e),s[c]={primitive:h,promise:d},a.push(d)}}return Promise.all(a)}loadMesh(t){const e=this,i=this.json,s=this.extensions,r=i.meshes[t],a=r.primitives,o=[];for(let h=0,c=a.length;h<c;h++){const u=a[h].material===void 0?((l=this.cache).DefaultMaterial===void 0&&(l.DefaultMaterial=new en({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:0})),l.DefaultMaterial):this.getDependency("material",a[h].material);o.push(u)}var l;return o.push(e.loadGeometries(a)),Promise.all(o).then(function(h){const c=h.slice(0,h.length-1),u=h[h.length-1],d=[];for(let m=0,f=u.length;m<f;m++){const v=u[m],_=a[m];let y;const x=c[m];if(_.mode===kS||_.mode===Jv||_.mode===Kv||_.mode===void 0)y=r.isSkinnedMesh===!0?new gu(v,x):new ot(v,x),y.isSkinnedMesh!==!0||y.geometry.attributes.skinWeight.normalized||y.normalizeSkinWeights(),_.mode===Jv?y.geometry=s_(y.geometry,1):_.mode===Kv&&(y.geometry=s_(y.geometry,2));else if(_.mode===US)y=new vi(v,x);else if(_.mode===NS)y=new we(v,x);else if(_.mode===FS)y=new _u(v,x);else{if(_.mode!==zS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+_.mode);y=new ka(v,x)}Object.keys(y.geometry.morphAttributes).length>0&&HS(y,r),y.name=e.createUniqueName(r.name||"mesh_"+t),Vs(y,r),_.extensions&&Io(s,y,_),e.assignFinalMaterial(y),d.push(y)}for(let m=0,f=d.length;m<f;m++)e.associations.set(d[m],{meshes:t,primitives:m});if(d.length===1)return d[0];const p=new Me;e.associations.set(p,{meshes:t});for(let m=0,f=d.length;m<f;m++)p.add(d[m]);return p})}loadCamera(t){let e;const i=this.json.cameras[t],s=i[i.type];if(s)return i.type==="perspective"?e=new ee(Ie.radToDeg(s.yfov),s.aspectRatio||1,s.znear||1,s.zfar||2e6):i.type==="orthographic"&&(e=new vr(-s.xmag,s.xmag,s.ymag,-s.ymag,s.znear,s.zfar)),i.name&&(e.name=this.createUniqueName(i.name)),Vs(e,i),Promise.resolve(e);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(t){const e=this.json.skins[t],i={joints:e.joints};return e.inverseBindMatrices===void 0?Promise.resolve(i):this.getDependency("accessor",e.inverseBindMatrices).then(function(s){return i.inverseBindMatrices=s,i})}loadAnimation(t){const e=this.json.animations[t],i=[],s=[],r=[],a=[],o=[];for(let l=0,h=e.channels.length;l<h;l++){const c=e.channels[l],u=e.samplers[c.sampler],d=c.target,p=d.node!==void 0?d.node:d.id,m=e.parameters!==void 0?e.parameters[u.input]:u.input,f=e.parameters!==void 0?e.parameters[u.output]:u.output;i.push(this.getDependency("node",p)),s.push(this.getDependency("accessor",m)),r.push(this.getDependency("accessor",f)),a.push(u),o.push(d)}return Promise.all([Promise.all(i),Promise.all(s),Promise.all(r),Promise.all(a),Promise.all(o)]).then(function(l){const h=l[0],c=l[1],u=l[2],d=l[3],p=l[4],m=[];for(let v=0,_=h.length;v<_;v++){const y=h[v],x=c[v],b=u[v],w=d[v],M=p[v];if(y===void 0)continue;let T;switch(y.updateMatrix(),y.matrixAutoUpdate=!0,la[M.path]){case la.weights:T=kr;break;case la.rotation:T=Wn;break;default:T=Br}const R=y.name?y.name:y.uuid,E=w.interpolation!==void 0?BS[w.interpolation]:2301,A=[];la[M.path]===la.weights?y.traverse(function(F){F.morphTargetInfluences&&A.push(F.name?F.name:F.uuid)}):A.push(R);let z=b.array;if(b.normalized){const F=sp(z.constructor),G=new Float32Array(z.length);for(let U=0,k=z.length;U<k;U++)G[U]=z[U]*F;z=G}for(let F=0,G=A.length;F<G;F++){const U=new T(A[F]+"."+la[M.path],x.array,z,E);w.interpolation==="CUBICSPLINE"&&(U.createInterpolant=function(k){return new(this instanceof Wn?OS:ip)(this.times,this.values,this.getValueSize()/3,k)},U.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),m.push(U)}}const f=e.name?e.name:"animation_"+t;return new Vr(f,void 0,m)})}createNodeMesh(t){const e=this.json,i=this,s=e.nodes[t];return s.mesh===void 0?null:i.getDependency("mesh",s.mesh).then(function(r){const a=i._getNodeRef(i.meshCache,s.mesh,r);return s.weights!==void 0&&a.traverse(function(o){if(o.isMesh)for(let l=0,h=s.weights.length;l<h;l++)o.morphTargetInfluences[l]=s.weights[l]}),a})}loadNode(t){const e=this.json,i=this.extensions,s=this,r=e.nodes[t],a=r.name?s.createUniqueName(r.name):"";return function(){const o=[],l=s._invokeOne(function(h){return h.createNodeMesh&&h.createNodeMesh(t)});return l&&o.push(l),r.camera!==void 0&&o.push(s.getDependency("camera",r.camera).then(function(h){return s._getNodeRef(s.cameraCache,r.camera,h)})),s._invokeAll(function(h){return h.createNodeAttachment&&h.createNodeAttachment(t)}).forEach(function(h){o.push(h)}),Promise.all(o)}().then(function(o){let l;if(l=r.isBone===!0?new zl:o.length>1?new Me:o.length===1?o[0]:new Mt,l!==o[0])for(let h=0,c=o.length;h<c;h++)l.add(o[h]);if(r.name&&(l.userData.name=r.name,l.name=a),Vs(l,r),r.extensions&&Io(i,l,r),r.matrix!==void 0){const h=new at;h.fromArray(r.matrix),l.applyMatrix4(h)}else r.translation!==void 0&&l.position.fromArray(r.translation),r.rotation!==void 0&&l.quaternion.fromArray(r.rotation),r.scale!==void 0&&l.scale.fromArray(r.scale);return s.associations.has(l)||s.associations.set(l,{}),s.associations.get(l).nodes=t,l})}loadScene(t){const e=this.json,i=this.extensions,s=this.json.scenes[t],r=this,a=new Me;s.name&&(a.name=r.createUniqueName(s.name)),Vs(a,s),s.extensions&&Io(i,a,s);const o=s.nodes||[],l=[];for(let h=0,c=o.length;h<c;h++)l.push(i_(o[h],a,e,r));return Promise.all(l).then(function(){return r.associations=(h=>{const c=new Map;for(const[u,d]of r.associations)(u instanceof ae||u instanceof Gt)&&c.set(u,d);return h.traverse(u=>{const d=r.associations.get(u);d!=null&&c.set(u,d)}),c})(a),a})}}function i_(n,t,e,i){const s=e.nodes[n];return i.getDependency("node",n).then(function(r){if(s.skin===void 0)return r;let a;return i.getDependency("skin",s.skin).then(function(o){a=o;const l=[];for(let h=0,c=a.joints.length;h<c;h++)l.push(i.getDependency("node",a.joints[h]));return Promise.all(l)}).then(function(o){return r.traverse(function(l){if(!l.isMesh)return;const h=[],c=[];for(let u=0,d=o.length;u<d;u++){const p=o[u];if(p){h.push(p);const m=new at;a.inverseBindMatrices!==void 0&&m.fromArray(a.inverseBindMatrices.array,16*u),c.push(m)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',a.joints[u])}l.bind(new Fa(h,c),l.matrixWorld)}),r})}).then(function(r){t.add(r);const a=[];if(s.children){const o=s.children;for(let l=0,h=o.length;l<h;l++){const c=o[l];a.push(i_(c,r,e,i))}}return Promise.all(a)})}function n_(n,t,e){const i=t.attributes,s=[];function r(a,o){return e.getDependency("accessor",a).then(function(l){n.setAttribute(o,l)})}for(const a in i){const o=np[a]||a.toLowerCase();o in n.attributes||s.push(r(i[a],o))}if(t.indices!==void 0&&!n.index){const a=e.getDependency("accessor",t.indices).then(function(o){n.setIndex(o)});s.push(a)}return Vs(n,t),function(a,o,l){const h=o.attributes,c=new Ne;if(h.POSITION===void 0)return;{const p=l.json.accessors[h.POSITION],m=p.min,f=p.max;if(m===void 0||f===void 0)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(c.set(new S(m[0],m[1],m[2]),new S(f[0],f[1],f[2])),p.normalized){const v=sp(Lo[p.componentType]);c.min.multiplyScalar(v),c.max.multiplyScalar(v)}}const u=o.targets;if(u!==void 0){const p=new S,m=new S;for(let f=0,v=u.length;f<v;f++){const _=u[f];if(_.POSITION!==void 0){const y=l.json.accessors[_.POSITION],x=y.min,b=y.max;if(x!==void 0&&b!==void 0){if(m.setX(Math.max(Math.abs(x[0]),Math.abs(b[0]))),m.setY(Math.max(Math.abs(x[1]),Math.abs(b[1]))),m.setZ(Math.max(Math.abs(x[2]),Math.abs(b[2]))),y.normalized){const w=sp(Lo[y.componentType]);m.multiplyScalar(w)}p.max(m)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}c.expandByVector(p)}a.boundingBox=c;const d=new ii;c.getCenter(d.center),d.radius=c.min.distanceTo(c.max)/2,a.boundingSphere=d}(n,t,e),Promise.all(s).then(function(){return t.targets!==void 0?function(a,o,l){let h=!1,c=!1,u=!1;for(let f=0,v=o.length;f<v;f++){const _=o[f];if(_.POSITION!==void 0&&(h=!0),_.NORMAL!==void 0&&(c=!0),_.COLOR_0!==void 0&&(u=!0),h&&c&&u)break}if(!h&&!c&&!u)return Promise.resolve(a);const d=[],p=[],m=[];for(let f=0,v=o.length;f<v;f++){const _=o[f];if(h){const y=_.POSITION!==void 0?l.getDependency("accessor",_.POSITION):a.attributes.position;d.push(y)}if(c){const y=_.NORMAL!==void 0?l.getDependency("accessor",_.NORMAL):a.attributes.normal;p.push(y)}if(u){const y=_.COLOR_0!==void 0?l.getDependency("accessor",_.COLOR_0):a.attributes.color;m.push(y)}}return Promise.all([Promise.all(d),Promise.all(p),Promise.all(m)]).then(function(f){const v=f[0],_=f[1],y=f[2];return h&&(a.morphAttributes.position=v),c&&(a.morphAttributes.normal=_),u&&(a.morphAttributes.color=y),a.morphTargetsRelative=!0,a})}(n,t.targets,e):n})}function s_(n,t){let e=n.getIndex();if(e===null){const a=[],o=n.getAttribute("position");if(o===void 0)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n;for(let l=0;l<o.count;l++)a.push(l);n.setIndex(a),e=n.getIndex()}const i=e.count-2,s=[];if(t===2)for(let a=1;a<=i;a++)s.push(e.getX(0)),s.push(e.getX(a)),s.push(e.getX(a+1));else for(let a=0;a<i;a++)a%2==0?(s.push(e.getX(a)),s.push(e.getX(a+1)),s.push(e.getX(a+2))):(s.push(e.getX(a+2)),s.push(e.getX(a+1)),s.push(e.getX(a)));s.length/3!==i&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=n.clone();return r.setIndex(s),r}const XS={map:{value:null}};class YS extends Qt{constructor(t){super(),this.defines={},this.uniforms=ft.clone(XS),this.side=2,this.vertexShader=`#define GLSLIFY 1
varying vec2 vUv;

void main()
{
    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);
    vUv = uv;
    gl_Position = projectionMatrix * viewPos;
    gl_Position.z = gl_Position.w;
}
`,this.fragmentShader=`#define GLSLIFY 1
#include <common>
varying vec2 vUv;
uniform sampler2D map;
void main() {

    gl_FragColor = texture2D(map, vUv);

    #include <encodings_fragment>
}
`,this.depthWrite=!1,this.depthTest=!1,this.envMap=null,Object.defineProperties(this,{map:{get:function(){return this.uniforms.map.value},set:function(e){this.uniforms.map.value=e,this.needsUpdate=!0}}})}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class r_ extends jr{constructor(t={}){super(),g(this,"isCustomStaticSky",!0),g(this,"_textureIsCube",!1),g(this,"_textureIsHDR",!1),g(this,"_textureURL",null),g(this,"_textureNames",null),g(this,"_affectWorld",!0),g(this,"_isVerticalTexture",null),g(this,"_mesh",null),g(this,"_material",null),g(this,"_sphereGeometry",null),g(this,"_envTexture",null),g(this,"_engine",null),g(this,"_PMREMGenerator",null),t.texture;const e=this._sphereGeometry=new tn(1,32,32);this.isVerticalTexture=t.isVerticalTexture||!1;const i=this._mesh=new ot(e,this._material);i.frustumCulled=!1,i.collisionDisabled=!0,i.scale.setScalar(1e4),i.rotateX(Math.PI/2),this.add(i)}afterAddToEngine(t){super.afterAddToEngine(t),this._engine=t,this._PMREMGenerator=new vs(t.renderer),this._loadSkyTexture()}onBeforeScenePrepareRender(t,e,i){this._mesh.position.copy(i.position),super.onBeforeScenePrepareRender(t)}_loadSkyTexture(){if(!this._engine||!this._textureURL)return;let t=null;t=this._textureIsHDR?this._textureIsCube?new hS:new qv:this._textureIsCube?new zu:new Te;const e=this._engine.rendering.scene;let i=null;this._textureIsCube?(t.setPath(this._textureURL),i=this._textureNames?this._textureNames:this._textureIsHDR?["nz.HDR","pz.HDR","px.HDR","nx.HDR","py.HDR","ny.HDR"]:["nz.jpg","pz.jpg","px.jpg","nx.jpg","py.jpg","ny.jpg"]):i=this._textureURL,t.load(i,s=>{this._textureIsCube?(this._envTexture=this._PMREMGenerator.fromCubemap(s).texture,this._affectWorld&&(e.environment=this._envTexture)):(s.encoding=3001,this._material.map=s,this._material.needsUpdate=!0,this._isVerticalTexture?e.environment=null:(this._envTexture=this._PMREMGenerator.fromEquirectangular(s).texture,this._affectWorld&&(e.environment=this._envTexture))),this._engine.requestRender()})}get isVerticalTexture(){return this._verticalTexture}set isVerticalTexture(t){t!==this._isVerticalTexture&&(this._material&&this._material.dispose(),this._material=new YS,this._isVerticalTexture=t,this._mesh&&(this._mesh.material=this._material))}get textureURL(){return this._textureURL}set textureURL(t){this._textureURL=t,this._loadSkyTexture()}get affectWorld(){return this._affectWorld}set affectWorld(t){const e=this._engine.rendering.scene;t?(this._affectWorld=!0,e.environment=this._envTexture):(this._affectWorld=!1,e.environment===this._envTexture&&(e.environment=null))}}const rp=`#define GLSLIFY 1
varying vec2 vUv;
void main() {

    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}`,Zh=`#define GLSLIFY 1
const float PI = 3.14159265358;

// Units are in megameters.
const float groundRadiusMM = 6.371;
const float atmosphereRadiusMM = 6.471;

const vec2 tLUTRes = vec2(256.0, 64.0)*1.;
const vec2 msLUTRes = vec2(32.0, 32.0)*1.;
const vec2 skyLUTRes = vec2(200.0, 200.0)*2.;

const vec3 groundAlbedo = vec3(0.1);

// These are per megameter.
const vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);
const float rayleighAbsorptionBase = 0.0;

const float mieScatteringBase = 3.996;
const float mieAbsorptionBase = 4.4;

const vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, .085);

// Quality
const float sunTransmittanceSteps = 40.0;
const float mulScattSteps = 20.0;
const int sqrtSamples = 8;

const int numScatteringSteps = 16;

uniform float altitude;
uniform float viewHeight;
/*
 * Animates the sun movement.
 */
float getSunAltitude(float time)
{
    const float periodSec = 10.0;
    return (PI)*time/periodSec - PI/24.;
}
vec3 getSunDir(float time)
{
    // float altitude = getSunAltitude(time);
    // altitude = 2.8;
    return normalize(vec3(cos(altitude), sin(altitude), 0.0));
}

/* Animate camera */
vec3 getViewPos(float time){

    vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0002 + viewHeight, 0.0);

    // anything beyond about 7 falls apart because the skyview lut doesn't have enough resolution
    float alt_range = 50.0;

    // viewPos.y += (sin(time/10.0 - PI/2.)*.5+.5) * (atmosphereRadiusMM - groundRadiusMM) * alt_range;

    return viewPos;
}

float getMiePhase(float cosTheta) {
    const float g = 0.8;
    const float scale = 3.0/(8.0*PI);

    float num = (1.0-g*g)*(1.0+cosTheta*cosTheta);
    float denom = (2.0+g*g)*pow((1.0 + g*g - 2.0*g*cosTheta), 1.5);

    return scale*num/denom;
}

float getRayleighPhase(float cosTheta) {
    const float k = 3.0/(16.0*PI);
    return k*(1.0+cosTheta*cosTheta);
}

void getScatteringValues(vec3 pos,
                         out vec3 rayleighScattering,
                         out float mieScattering,
                         out vec3 extinction) {
    float altitudeKM = (length(pos)-groundRadiusMM)*1000.0;
    // Note: Paper gets these switched up.
    float rayleighDensity = exp(-altitudeKM/8.0);
    float mieDensity = exp(-altitudeKM/1.2);

    rayleighScattering = rayleighScatteringBase*rayleighDensity;
    float rayleighAbsorption = rayleighAbsorptionBase*rayleighDensity;

    mieScattering = mieScatteringBase*mieDensity;
    float mieAbsorption = mieAbsorptionBase*mieDensity;

    vec3 ozoneAbsorption = ozoneAbsorptionBase*max(0.0, 1.0 - abs(altitudeKM-25.0)/15.0);

    extinction = rayleighScattering + rayleighAbsorption + mieScattering + mieAbsorption + ozoneAbsorption;
}

float safeacos(const float x) {
    return acos(clamp(x, -1.0, 1.0));
}

// From https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code.
float rayIntersectSphere(vec3 ro, vec3 rd, float rad) {
    float b = dot(ro, rd);
    float c = dot(ro, ro) - rad*rad;
    if (c > 0.0f && b > 0.0) return -1.0;
    float discr = b*b - c;
    if (discr < 0.0) return -1.0;
    // Special case: inside sphere, use far discriminant
    if (discr > b*b) return (-b + sqrt(discr));
    return -b - sqrt(discr);
}

// From https://www.shadertoy.com/view/wlBXWK
vec2 rayIntersectSphere2D(
    vec3 start, // starting position of the ray
    vec3 dir, // the direction of the ray
    float radius // and the sphere radius
) {
    // ray-sphere intersection that assumes
    // the sphere is centered at the origin.
    // No intersection when result.x > result.y
    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, start);
    float c = dot(start, start) - (radius * radius);
    float d = (b*b) - 4.0*a*c;
    if (d < 0.0) return vec2(1e5,-1e5);
    return vec2(
        (-b - sqrt(d))/(2.0*a),
        (-b + sqrt(d))/(2.0*a)
    );
}

/*
 * Same parameterization here.
 */
vec3 getValFromTLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {
    float height = length(pos);
    vec3 up = pos / height;
	float sunCosZenithAngle = dot(sunDir, up);
    vec2 uv = vec2(tLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),
                   tLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));
    uv /= bufferRes;
    // return pos;
    return texture(tex, uv).rgb;
}
vec3 getValFromMultiScattLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {
    float height = length(pos);
    vec3 up = pos / height;
	float sunCosZenithAngle = dot(sunDir, up);
    vec2 uv = vec2(msLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),
                   msLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));
    uv /= bufferRes;
    return texture(tex, uv).rgb;
}

/* 
 * Do raymarching : builds skyview lut inside atmoshpere, raymarches directly outside atmosphere
*/

vec3 raymarchScattering(sampler2D TLUT, vec2 TLUT_size, sampler2D MSLUT, vec2 MSLUT_size,
                              vec3 viewPos,
                              vec3 rayDir,
                              vec3 sunDir,
                              float numSteps) {
                              
                              
    vec2 atmos_intercept = rayIntersectSphere2D(viewPos, rayDir, atmosphereRadiusMM);
    float terra_intercept = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);

    float mindist, maxdist;

    if (atmos_intercept.x < atmos_intercept.y){
        // there is an atmosphere intercept!
        // start at the closest atmosphere intercept
        // trace the distance between the closest and farthest intercept
        mindist = atmos_intercept.x > 0.0 ? atmos_intercept.x : 0.0;
		maxdist = atmos_intercept.y > 0.0 ? atmos_intercept.y : 0.0;
    } else {
        // no atmosphere intercept means no atmosphere!
        return vec3(0.0);
    }

    // if in the atmosphere start at the camera
    if (length(viewPos) < atmosphereRadiusMM) mindist=0.0;

    // if there's a terra intercept that's closer than the atmosphere one,
    // use that instead!
    if (terra_intercept > 0.0){ // confirm valid intercepts			
        maxdist = terra_intercept;
    }

    // start marching at the min dist
    vec3 pos = viewPos + mindist * rayDir;
                              
    float cosTheta = dot(rayDir, sunDir);

	float miePhaseValue = getMiePhase(cosTheta);
	float rayleighPhaseValue = getRayleighPhase(-cosTheta);

    vec3 lum = vec3(0.0);
    vec3 transmittance = vec3(1.0);
    float t = 0.0;
    for (float i = 0.0; i < numSteps; i += 1.0) {
        float newT = ((i + 0.3)/numSteps)*(maxdist-mindist);
        float dt = newT - t;
        t = newT;

        vec3 newPos = pos + t*rayDir;

        vec3 rayleighScattering, extinction;
        float mieScattering;
        
        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

        vec3 sampleTransmittance = exp(-dt*extinction);

        vec3 sunTransmittance = getValFromTLUT(TLUT, TLUT_size, newPos, sunDir);
        vec3 psiMS = 0.0*getValFromMultiScattLUT(MSLUT, MSLUT_size, newPos, sunDir);

        vec3 rayleighInScattering = rayleighScattering*(rayleighPhaseValue*sunTransmittance + psiMS);
        vec3 mieInScattering = mieScattering*(miePhaseValue*sunTransmittance + psiMS);
        vec3 inScattering = (rayleighInScattering + mieInScattering);

        // Integrated scattering within path segment.
        vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

        lum += scatteringIntegral*transmittance;

        transmittance *= sampleTransmittance;
    }
    return lum;
}
`,ap={uniforms:{altitude:{value:2.8},iChannel0:{value:null},iChannelResolution0:{value:[256,256]},iChannel1:{value:null},iChannelResolution1:{value:[256,256]},iChannel2:{value:null},iChannelResolution2:{value:[256,256]},cameraDirection:{value:new S(0,.27,-1)},viewHeight:{value:2e-4},upDirection:{value:new S(0,1,0)},tWeather:{value:null},mixGrayFactor:{value:0}},vertexShader:`#define GLSLIFY 1
varying vec3 vWorldPosition;
varying vec2 vUv;
void main() {
    vUv = uv;
    //vWorldPosition = normalize(vec3(modelMatrix * vec4(position, 1.0)) - cameraPosition);
    vWorldPosition = normalize(vec3(position.x, position.y, position.z));
    // vWorldPosition = normalize(position);
    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    // gl_Position = vec4(position.x * 2.0, position.y * 2.0, 1.0, 1.0);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    gl_Position.z = gl_Position.w;
}
`,fragmentShader:Zh+`
#define GLSLIFY 1
/*
 * Modified version of Andrew Helmer's https://www.shadertoy.com/view/slSXRW 
 * implementation of Sebastian Hillare's Unreal engine sky-atmosphere
 * ... still doesn't implement aerial perspective lut, just makes space views possible
* TODO: replace sunflare with something new that works
        allow density profiles, and thicker atmospheres (fails beyond 7.1 right now)
 */

/*
 * Final output basically looks up the value from the skyLUT, and then adds a sun on top,
 * does some tonemapping.
 */
#include <common>
varying vec2 vUv;
varying vec3 vWorldPosition;
uniform sampler2D iChannel0;
uniform vec2 iChannelResolution0;
uniform sampler2D iChannel1;
uniform vec2 iChannelResolution1;
uniform sampler2D iChannel2;
uniform vec2 iChannelResolution2;
uniform vec2 iResolution;
uniform vec3 cameraDirection;
uniform vec3 upDirection;

const vec3 grayColor = vec3(0.5, 0.5, 0.5);

vec3 getValFromSkyLUT(vec3 rayDir, vec3 sunDir) {

    vec3 viewPos = getViewPos(0.);
    float height = length(viewPos);
    vec3 up = viewPos / height;

    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height);
    float altitudeAngle = horizonAngle - acos(dot(rayDir, up)); // Between -PI/2 and PI/2
    float azimuthAngle; // Between 0 and 2*PI

    vec3 right = cross(sunDir, up);
    vec3 forward = cross(up, right);

    vec3 projectedDir = normalize(rayDir - up*(dot(rayDir, up)));
    float sinTheta = dot(projectedDir, right);
    float cosTheta = dot(projectedDir, forward);
    azimuthAngle = atan(sinTheta, cosTheta) + PI;

    // Non-linear mapping of altitude angle. See Section 5.3 of the paper.
    float v = 0.5 + 0.5*sign(altitudeAngle)*sqrt(abs(altitudeAngle)*2.0/PI);
    vec2 uv = vec2(azimuthAngle / (2.0*PI), v);
    // uv *= skyLUTRes;
    // uv /= iChannelResolution1.xy;

    // return rayDir; // vec3(rayDir.x, 0.0, 0.0);;
    return texture(iChannel1, uv).rgb;
}

vec3 jodieReinhardTonemap(vec3 c){
    // From: https://www.shadertoy.com/view/tdSXzD
    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
    vec3 tc = c / (c + 1.0);
    return mix(c / (l + 1.0), tc, tc);
}

vec3 sunWithBloom(vec3 rayDir, vec3 sunDir) {
    const float sunSolidAngle = 0.53*PI/180.0;
    const float minSunCosTheta = cos(sunSolidAngle);

    float cosTheta = dot(rayDir, sunDir);
    if (cosTheta >= minSunCosTheta) return vec3(1.0);

    float offset = minSunCosTheta - cosTheta;
    float gaussianBloom = exp(-offset*50000.0)*0.5;
    float invBloom = 1.0/(0.02 + offset*300.0)*0.01;
    return vec3(gaussianBloom+invBloom);
}

vec4 toLinear(vec4 sRGB)
{
	bvec4 cutoff = lessThan(sRGB, vec4(0.04045));
	vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));
	vec4 lower = sRGB/vec4(12.92);

	return mix(higher, lower, cutoff);
}

void main() {
    vec3 sunDir = getSunDir(0.);
    vec3 viewPos = getViewPos(0.);

    vec3 camDir = normalize(cameraDirection);
    float camFOVWidth = PI/3.0;
    // vec2 iResolution = vec2(1102, 1246);
    float camWidthScale = 2.0*tan(camFOVWidth/2.0);
    float camHeightScale = camWidthScale*iResolution.y/iResolution.x;

    vec3 camRight = normalize(cross(camDir, upDirection));
    vec3 camUp = normalize(cross(camRight, camDir));

    // camRight = viewMatrix[0].xzy;
    // camUp = viewMatrix[1].xzy;
    // camDir = viewMatrix[2].xzy;
    // vec2 xy = 2.0 * vWorldPosition.xy; // 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;
    vec2 xy = vWorldPosition.xy; // 2.0 * (gl_FragCoord.xy / iResolution.xy / 2.0) - 1.0;
    // vec3 rayDir = normalize(camDir + camRight*xy.x*camWidthScale + camUp*xy.y*camHeightScale);
    vec3 rayDir = normalize(vWorldPosition.xzy);
    vec3 lum;

    if (length(viewPos) < atmosphereRadiusMM * 1.0){
        lum = getValFromSkyLUT(rayDir, sunDir);
    } else {
    
        // As mentioned in section 7 of the paper, switch to direct raymarching outside atmosphere
        lum = raymarchScattering(iChannel0, iChannelResolution0.xy,
                                 iChannel2, iChannelResolution2.xy,
                                 viewPos, rayDir, sunDir, float(numScatteringSteps));
        
        // This little bit of red helps to debug when the rendering switches to pure raymarching
        //lum += vec3(1e-3,0.0,0.0);
    }

    // Tonemapping and gamma. Super ad-hoc, probably a better way to do this.
    lum *= 100.0;
    lum = jodieReinhardTonemap(lum);
    lum = pow(lum, vec3(1.0/2.2));

    // lum += sunWithBloom(rayDir, sunDir);
     // Bloom should be added at the end, but this is subtle and works well.
    vec3 sunLum = sunWithBloom(rayDir, sunDir);
    // Use smoothstep to limit the effect, so it drops off to actual zero.
    sunLum = smoothstep(0.002, 1.0, sunLum);
    if (length(sunLum) > 0.0) {
        if (rayIntersectSphere(viewPos, rayDir, groundRadiusMM) >= 0.0) {
            sunLum *= 0.0;
        } else {
            // If the sun value is applied to this pixel, we need to calculate the transmittance to obscure it.
            sunLum *= getValFromTLUT(iChannel0, iChannelResolution0.xy, viewPos, sunDir);
        }
    }
    lum += sunLum;

    gl_FragColor = vec4(lum,1.0);
    gl_FragColor = toLinear(gl_FragColor);

    // gl_FragColor.rgb = vWorldPosition;
    // float viewDistance = sqrt(length(vec3(rayDir.x * 10., 0.1, rayDir.z * 10.)));
    // vec2 cloudUV = rayDir.xz * viewDistance; //rayDir.xy * length(rayDir);
    // // cloudUV *= mix(1., 10., clamp(sqrt(rayDir.x * rayDir.x + rayDir.y * rayDir.y), 0.0, 1.0));
    // float cloudDensity = texture2D(tWeather, cloudUV * 10.0).x;
    // gl_FragColor.xy = (rayDir.xy + 1.0) * 0.5;
    // gl_FragColor.z += cloudDensity;
    // Peek at the Transmittance LUT
    // if (gl_FragCoord.x < skyLUTRes.x && gl_FragCoord.y < skyLUTRes.y) {
        // gl_FragColor = vec4(8.*texture(iChannel1, gl_FragCoord.xy/skyLUTRes * 0.2).rgb,1.0);
    // }
    // fragColor = vec4(100.*texture(iChannel0, fragCoord.xy/iResolution.xy).rgb,1.0);
       
    // Peek at the Sky View LUT
    // gl_FragColor = vec4(8.*texture(iChannel1, gl_FragCoord.xy/iResolution.xy / 2.).rgb,1.0);

    // Peek at the Multiscattering LUT
    //fragColor = vec4(100.*texture(iChannel2, fragCoord.xy/iResolution.xy).rgb,1.0);
//if (gl_FragCoord.x < msLUTRes.x && gl_FragCoord.y < msLUTRes.y) {
     // gl_FragColor = vec4(100.*texture(iChannel2, gl_FragCoord.xy/iResolution / 2.).rgb,1.0);
// }
    // gl_FragColor = vec4(100.*texture(iChannel0, gl_FragCoord.xy/iChannelResolution0 * 0.1).rgb,1.0);
    #include <tonemapping_fragment>
	#include <encodings_fragment>
}
`},op={uniforms:{altitude:{value:2.8},viewHeight:{value:2e-4}},vertexShader:rp,fragmentShader:Zh+`
#define GLSLIFY 1
// Buffer A generates the Transmittance LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and
// the value is the transmittance from that point to sun, through the atmosphere.
varying vec2 vUv;
vec3 getSunTransmittance(vec3 pos, vec3 sunDir) {
    if (rayIntersectSphere(pos, sunDir, groundRadiusMM) > 0.0) {
        return vec3(0.0);
    }

    float atmoDist = rayIntersectSphere(pos, sunDir, atmosphereRadiusMM);
    float t = 0.0;

    vec3 transmittance = vec3(1.0);
    for (float i = 0.0; i < sunTransmittanceSteps; i += 1.0) {
        float newT = ((i + 0.3)/sunTransmittanceSteps)*atmoDist;
        float dt = newT - t;
        t = newT;

        vec3 newPos = pos + t*sunDir;

        vec3 rayleighScattering, extinction;
        float mieScattering;
        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

        transmittance *= exp(-dt*extinction);
    }
    return transmittance;
}

void main()
{
    // if (gl_FragCoord.x >= (tLUTRes.x+1.5) || gl_FragCoord.y >= (tLUTRes.y+1.5)) {
    //     return;
    // }
    float u = vUv.x; // clamp(gl_FragCoord.x, 0.0, tLUTRes.x-1.0)/tLUTRes.x;
    float v = vUv.y; // clamp(gl_FragCoord.y, 0.0, tLUTRes.y-1.0)/tLUTRes.y;

    float sunCosTheta = 2.0*u - 1.0;
    float sunTheta = safeacos(sunCosTheta);
    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);

    vec3 pos = vec3(0.0, height, 0.0);
    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));

    gl_FragColor = vec4(getSunTransmittance(pos, sunDir), 1.0);
}
`},lp={uniforms:{altitude:{value:2.8},iChannel0:{value:null},iChannelResolution0:{value:[256,256]},viewHeight:{value:2e-4}},vertexShader:rp,fragmentShader:Zh+`
#define GLSLIFY 1
// Buffer B is the multiple-scattering LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and
// the value is the multiple scattering approximation (Psi_ms from the paper, Eq. 10).
varying vec2 vUv;
uniform sampler2D iChannel0;
uniform vec2 iChannelResolution0;
vec3 getSphericalDir(float theta, float phi) {
     float cosPhi = cos(phi);
     float sinPhi = sin(phi);
     float cosTheta = cos(theta);
     float sinTheta = sin(theta);
     return vec3(sinPhi*sinTheta, cosPhi, sinPhi*cosTheta);
}

// Calculates Equation (5) and (7) from the paper.
void getMulScattValues(vec3 pos, vec3 sunDir, out vec3 lumTotal, out vec3 fms) {
    lumTotal = vec3(0.0);
    fms = vec3(0.0);

    float invSamples = 1.0/float(sqrtSamples*sqrtSamples);
    for (int i = 0; i < sqrtSamples; i++) {
        for (int j = 0; j < sqrtSamples; j++) {
            // This integral is symmetric about theta = 0 (or theta = PI), so we
            // only need to integrate from zero to PI, not zero to 2*PI.
            float theta = PI * (float(i) + 0.5) / float(sqrtSamples);
            float phi = safeacos(1.0 - 2.0*(float(j) + 0.5) / float(sqrtSamples));
            vec3 rayDir = getSphericalDir(theta, phi);

            float atmoDist = rayIntersectSphere(pos, rayDir, atmosphereRadiusMM);
            float groundDist = rayIntersectSphere(pos, rayDir, groundRadiusMM);
            float tMax = atmoDist;
            if (groundDist > 0.0) {
                tMax = groundDist;
            }

            float cosTheta = dot(rayDir, sunDir);

            float miePhaseValue = getMiePhase(cosTheta);
            float rayleighPhaseValue = getRayleighPhase(-cosTheta);

            vec3 lum = vec3(0.0), lumFactor = vec3(0.0), transmittance = vec3(1.0);
            float t = 0.0;
            for (float stepI = 0.0; stepI < mulScattSteps; stepI += 1.0) {
                float newT = ((stepI + 0.3)/mulScattSteps)*tMax;
                float dt = newT - t;
                t = newT;

                vec3 newPos = pos + t*rayDir;

                vec3 rayleighScattering, extinction;
                float mieScattering;
                getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

                vec3 sampleTransmittance = exp(-dt*extinction);

                // Integrate within each segment.
                vec3 scatteringNoPhase = rayleighScattering + mieScattering;
                vec3 scatteringF = (scatteringNoPhase - scatteringNoPhase * sampleTransmittance) / extinction;
                lumFactor += transmittance*scatteringF;

                // This is slightly different from the paper, but I think the paper has a mistake?
                // In equation (6), I think S(x,w_s) should be S(x-tv,w_s).
                vec3 sunTransmittance = getValFromTLUT(iChannel0, iChannelResolution0.xy, newPos, sunDir);

                vec3 rayleighInScattering = rayleighScattering*rayleighPhaseValue;
                float mieInScattering = mieScattering*miePhaseValue;
                vec3 inScattering = (rayleighInScattering + mieInScattering)*sunTransmittance;

                // Integrated scattering within path segment.
                vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

                lum += scatteringIntegral*transmittance;
                transmittance *= sampleTransmittance;
            }

            if (groundDist > 0.0) {
                vec3 hitPos = pos + groundDist*rayDir;
                if (dot(pos, sunDir) > 0.0) {
                    hitPos = normalize(hitPos)*groundRadiusMM;
                    lum += transmittance*groundAlbedo*getValFromTLUT(iChannel0, iChannelResolution0.xy, hitPos, sunDir);
                }
            }

            fms += lumFactor*invSamples;
            lumTotal += lum*invSamples;
        }
    }
}

void main()
{
    // if (fragCoord.x >= (msLUTRes.x+1.5) || fragCoord.y >= (msLUTRes.y+1.5)) {
    //     return;
    // }
    float u = vUv.x; // clamp(fragCoord.x, 0.0, msLUTRes.x-1.0)/msLUTRes.x;
    float v = vUv.y; // clamp(fragCoord.y, 0.0, msLUTRes.y-1.0)/msLUTRes.y;

    float sunCosTheta = 2.0*u - 1.0;
    float sunTheta = safeacos(sunCosTheta);
    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);

    vec3 pos = vec3(0.0, height, 0.0);
    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));

    vec3 lum, f_ms;
    getMulScattValues(pos, sunDir, lum, f_ms);

    // Equation 10 from the paper.
    vec3 psi = lum  / (1.0 - f_ms);
    gl_FragColor = vec4(1. * psi, 1.0);
    // gl_FragColor = vec4(vUv/ 1., 0.0, 1.0);
}
`},hp={uniforms:{altitude:{value:2.8},iChannel0:{value:null},iChannelResolution0:{value:[256,256]},iChannel1:{value:null},iChannelResolution1:{value:[256,256]},viewHeight:{value:2e-4},mixGrayFactor:{value:0}},vertexShader:rp,fragmentShader:Zh+`
#define GLSLIFY 1
// Buffer C calculates the actual sky-view! It's a lat-long map (or maybe altitude-azimuth is the better term),
// but the latitude/altitude is non-linear to get more resolution near the horizon.
varying vec2 vUv;
uniform sampler2D iChannel0;
uniform vec2 iChannelResolution0;
uniform sampler2D iChannel1;
uniform vec2 iChannelResolution1;
uniform float mixGrayFactor;

void main() {
    // if (fragCoord.x >= (skyLUTRes.x+1.5) || fragCoord.y >= (skyLUTRes.y+1.5)) {
    //     return;
    // }
    float u = vUv.x; // clamp(fragCoord.x, 0.0, skyLUTRes.x-1.0)/skyLUTRes.x;
    float v = vUv.y; // clamp(fragCoord.y, 0.0, skyLUTRes.y-1.0)/skyLUTRes.y;

    float azimuthAngle = (u - 0.5)*2.0*PI;

    // Non-linear mapping of altitude. See Section 5.3 of the paper.

    float adjV;
    if (v < 0.5) {
		float coord = 1.0 - 2.0*v;
		adjV = -coord*coord;
	} else {
		float coord = v*2.0 - 1.0;
		adjV = coord*coord;
	}

    vec3 viewPos = getViewPos(0.);

    float height = length(viewPos); vec3 up = viewPos / height;
    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height) - 0.5*PI;
    float altitudeAngle = adjV*0.5*PI - horizonAngle;

    float cosAltitude = cos(altitudeAngle);
    vec3 rayDir = vec3(cosAltitude*sin(azimuthAngle), sin(altitudeAngle), -cosAltitude*cos(azimuthAngle));

    float sunAltitude = (0.5*PI) - acos(dot(getSunDir(0.), up));
    vec3 sunDir = vec3(0.0, sin(sunAltitude), -cos(sunAltitude));

    vec3 lum = raymarchScattering(iChannel0, iChannelResolution0.xy,
                                  iChannel1, iChannelResolution1.xy,
                                  viewPos, rayDir, sunDir, float(numScatteringSteps));
    gl_FragColor = vec4(lum, 1.0);

    if (mixGrayFactor > 0.0) {
        lum = gl_FragColor.xyz;
        vec3 gray = vec3((lum.x + lum.y + lum.z) / 3.0);
        lum = mix(lum, gray, mixGrayFactor);
        gl_FragColor = vec4(lum, 1.0);
    }
}
`};class a_ extends ot{constructor(){super(),g(this,"_fsQuad"),g(this,"_hasPaintedScatterBuffer"),g(this,"_scatteringMaterial"),g(this,"_scatteringRenderTarget"),g(this,"_transmittanceMaterial"),g(this,"_transmittanceRenderTarget"),g(this,"_viewMaterial"),g(this,"_viewRenderTarget"),this.geometry=new tn(1,32,32),this.frustumCulled=!1;const t=[256,64],e=[32,32],i=[400,400],s=this._transmittanceRenderTarget=new Yt(t[0],t[1],{type:1016});s.texture.name="SkyAtomsphere.transmittance",this._transmittanceMaterial=new Qt({uniforms:ft.clone(op.uniforms),vertexShader:op.vertexShader,fragmentShader:op.fragmentShader});const r=this._scatteringRenderTarget=new Yt(e[0],e[1],{type:1016});r.texture.name="SkyAtomsphere.scattering",this._scatteringMaterial=new Qt({uniforms:ft.clone(lp.uniforms),vertexShader:lp.vertexShader,fragmentShader:lp.fragmentShader}),this._scatteringMaterial.uniforms.iChannel0.value=s.texture,this._scatteringMaterial.uniforms.iChannelResolution0.value=[t[0],t[1]],this._fsQuad=new co(null);const a=this._viewRenderTarget=new Yt(i[0],i[1],{type:1016});a.texture.name="SkyAtomsphere.view";const o=this._viewMaterial=new Qt({uniforms:ft.clone(hp.uniforms),vertexShader:hp.vertexShader,fragmentShader:hp.fragmentShader});o.uniforms.iChannel0.value=s.texture,o.uniforms.iChannelResolution0.value=[t[0],t[1]],o.uniforms.iChannel1.value=r.texture,o.uniforms.iChannelResolution1.value=[e[0],e[1]];const l=this.material=new Qt({uniforms:ft.clone(ap.uniforms),vertexShader:ap.vertexShader,fragmentShader:ap.fragmentShader,side:2});l.uniforms.iChannel0.value=s.texture,l.uniforms.iChannelResolution0.value=[t[0],t[1]],l.uniforms.iChannel2.value=r.texture,l.uniforms.iChannelResolution2.value=[e[0],e[1]],l.uniforms.iChannel1.value=a.texture,l.uniforms.iChannelResolution1.value=[i[0],i[1]],this._fsQuad=new co(null),this.scale.multiplyScalar(1e4),this.altitude=0}onBeforeRender(t,e,i){}updateRenderTargets(t,e){const i=this._fsQuad;this._hasPaintedScatterBuffer||(i.material=this._transmittanceMaterial,t.setRenderTarget(this._transmittanceRenderTarget),t.clear(),i.render(t),i.material=this._scatteringMaterial,t.setRenderTarget(this._scatteringRenderTarget),t.clear(),i.render(t),this._hasPaintedScatterBuffer=!0),i.material=this._viewMaterial,t.setRenderTarget(this._viewRenderTarget),t.clear(),i.render(t),t.setRenderTarget(null)}dispose(){this.geometry.dispose(),this._transmittanceRenderTarget.dispose(),this._scatteringRenderTarget.dispose(),this._viewRenderTarget.dispose(),this._transmittanceMaterial.dispose(),this._scatteringMaterial.dispose(),this._viewMaterial.dispose(),this.material.dispose(),this._fsQuad.dispose()}get altitude(){return this.material.uniforms.altitude.value}set altitude(t){this._transmittanceMaterial.uniforms.altitude.value=t,this._scatteringMaterial.uniforms.altitude.value=t,this._viewMaterial.uniforms.altitude.value=t,this.material.uniforms.altitude.value=t}get mixGrayFactor(){return this._viewMaterial.uniforms.mixGrayFactor.value}set mixGrayFactor(t){this._viewMaterial.uniforms.mixGrayFactor.value=t}}const ZS={weatherMap:{value:null},noiseMap:{value:null},coverage:{value:.8},time:{value:0},speed:{value:1},sizeScale:{value:.5},skyMap:{value:null},sunLightMap:{value:null},skyAltitude:{value:2.8},thicknessBias:{value:0},thicknessScale:{value:1},mixGrayFactor:{value:0}},JS=`#define GLSLIFY 1
varying vec3 vWorldPosition;
varying vec2 vUv;
void main() {
    vUv = uv;
    // vWorldPosition = normalize(position);
    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    // gl_Position = vec4(position.x * 2.0, position.y * 2.0, 1.0, 1.0);
    float skyZ = mix(0.1, -0.012, clamp(length(position.xy) * 1.0, 0.0, 1.0));
    vWorldPosition = (modelMatrix * vec4(position.x, position.y, skyZ, 1.0)).xyz - vec3(cameraPosition.xy, cameraPosition.z);
    vWorldPosition = normalize(vWorldPosition);
    
    // float radiusZ = clamp(sqrt(0.5 * 0.5 - pow(length(position.xy), 2.0)), 0.0, 0.5);
    // vWorldPosition.z = clamp(sqrt(1.0 - pow(length(vWorldPosition.xy), 2.0)), 0.0, 1.0);
    // vWorldPosition = normalize(vec3(position.x, position.y, skyZ * 1.));
    gl_Position = projectionMatrix * modelViewMatrix * vec4(vec3(position.x, position.y, skyZ), 1.0);
    // gl_Position.z = gl_Position.w;
}
`,KS=`#define GLSLIFY 1
#include <common>
varying vec2 vUv;
varying vec3 vWorldPosition;

uniform sampler2D weatherMap;
uniform sampler2D noiseMap;
uniform sampler2D skyMap;
uniform sampler2D sunLightMap;
uniform float coverage;
uniform float time;
uniform float speed;
uniform float sizeScale;
// uniform float thinkness;
uniform float thicknessBias;
uniform float thicknessScale;

uniform float skyAltitude;
uniform float mixGrayFactor;

const float groundRadiusMM = 6.371;

float safeacos(const float x) {
    return acos(clamp(x, -1.0, 1.0));
}

vec3 getSunDir() {
    return normalize(vec3(cos(skyAltitude), sin(skyAltitude), 0.0));
}

vec3 getValFromSkyLUT(vec3 rayDir, vec3 sunDir) {

    vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0004, 0.0);
    float height = length(viewPos);
    vec3 up = viewPos / height;

    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height);
    float altitudeAngle = horizonAngle - acos(dot(rayDir, up)); // Between -PI/2 and PI/2
    float azimuthAngle; // Between 0 and 2*PI

    vec3 right = cross(sunDir, up);
    vec3 forward = cross(up, right);

    vec3 projectedDir = normalize(rayDir - up*(dot(rayDir, up)));
    float sinTheta = dot(projectedDir, right);
    float cosTheta = dot(projectedDir, forward);
    azimuthAngle = atan(sinTheta, cosTheta) + PI;

    // Non-linear mapping of altitude angle. See Section 5.3 of the paper.
    float v = 0.5 + 0.5*sign(altitudeAngle)*sqrt(abs(altitudeAngle)*2.0/PI);
    vec2 uv = vec2(azimuthAngle / (2.0*PI), v);

    // return rayDir; // vec3(rayDir.x, 0.0, 0.0);
    return texture(skyMap, uv).rgb;
}

vec3 jodieReinhardTonemap(vec3 c){
    // From: https://www.shadertoy.com/view/tdSXzD
    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
    vec3 tc = c / (c + 1.0);
    return mix(c / (l + 1.0), tc, tc);
}

vec4 toLinear(vec4 sRGB)
{
	bvec4 cutoff = lessThan(sRGB, vec4(0.04045));
	vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));
	vec4 lower = sRGB/vec4(12.92);

	return mix(higher, lower, cutoff);
}

float remap(float v, float l0, float h0, float ln, float hn) {
    return ln + (v - l0) * (hn - ln) / (h0 - l0);
}
void main() {
    vec2 cloudUV = vUv * 1.0;
    float uvOffset = time / 1000000.0 * speed;
    vec4 weatherColor = texture2D(weatherMap, cloudUV * sizeScale + uvOffset);
    float wmc = max(weatherColor.x, saturate(coverage - 0.5) * weatherColor.y * 2.0);
    // clouDensity = max(clouDensity, texture2D(noiseMap, cloudUV).x);
    // SNsample = R(snr, (sng ×0.625+snb ×0.25+sna ×0.125)−1, 1, 0, 1)
    vec4 noiseColor = texture2D(noiseMap, (cloudUV + uvOffset) * 10.0);
    float sn_sample = remap(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);
    float sn = saturate(remap(sn_sample, 1.0 - coverage * wmc, 1.0, 0.0, 1.0));
    float thickness = clamp(sn * thicknessScale + thicknessBias, 0.0, 1.0);
    float cloudAlpha = sn * 2.0; // remap(clamp(sn, 0.0, 1. - thickness), 0.0, 1. - thickness, 0.0, 1.0);
    vec3 cloudColor = vec3(remap(sn, 0.0, 1.0, 1.0, 0.8));

    // 太阳散射，根据厚度发生变化
    vec3 sunLightColor = texture(sunLightMap, vec2((1.0 + sin(skyAltitude)) * 0.5, 0.5)).xyz;
    if (mixGrayFactor > 0.0) {
        vec3 gray = vec3((sunLightColor.x + sunLightColor.y + sunLightColor.z) / 3.0);
        sunLightColor = mix(sunLightColor, gray, mixGrayFactor);
    }
    cloudColor = sunLightColor;
    cloudColor = sunLightColor * (remap(thickness, 0.0, 1.0, 1.5, 0.5));

    // 天空大气颜色
    vec3 sunDir = getSunDir();
    vec3 rayDir = normalize(vWorldPosition.xzy);
    vec3 atmosphereColor = getValFromSkyLUT(rayDir, sunDir);
    atmosphereColor *= 100.0;
    atmosphereColor = jodieReinhardTonemap(atmosphereColor);
    atmosphereColor = pow(atmosphereColor, vec3(1.0/2.2));
    atmosphereColor = toLinear(vec4(atmosphereColor, 1.0)).xyz;

    float atmosphereColorFactor = remap(clamp(thickness, 0.5, 1.0), 0.5, 1.0, 0.0, 1.0);
    atmosphereColorFactor = 0.5 - abs(0.5 - atmosphereColorFactor);
    cloudColor = mix(cloudColor, atmosphereColor, atmosphereColorFactor);

    // 和天空大气混合
    cloudColor = mix(cloudColor, atmosphereColor, 1.0 - clamp((vWorldPosition.z + 0.02) * 10.0, 0.0, 1.0));
    // cloudColor = vec3(thickness);
    // if (thickness < 0.5) {
    //     cloudColor
    // }
    // else if (thickness < 0.9) {

    // }
    // else {

    // }

    // cloudColor = atmosphereColor; // lum;
    // vec3 cloudColor = texture2D(skyMap, cloudUV * 2.0).xyz * 10.0;
    gl_FragColor = vec4(cloudColor, cloudAlpha);
    #include <tonemapping_fragment>
	#include <encodings_fragment>
}
`;class QS extends ot{constructor(){super(),this.geometry=new gi(2,2,12,12),this.frustumCulled=!1,(this.material=new Qt({uniforms:ft.clone(ZS),vertexShader:JS,fragmentShader:KS,side:2,transparent:!0})).uniforms.sunLightMap.value=this.createGradientMap(),this.scale.multiplyScalar(1e4)}createGradientMap(){let t=document.createElement("canvas");t.width=64,t.height=2;let e=t.getContext("2d"),i=e.createLinearGradient(0,0,64,0);return i.addColorStop(0,"rgb(0,0,0)"),i.addColorStop(.45,"rgb(0,0,0)"),i.addColorStop(.5,"rgb(200,30,0)"),i.addColorStop(.52,"rgb(200,120,0)"),i.addColorStop(.58,"rgb(255,255,255)"),i.addColorStop(1,"rgb(255,255,255)"),e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap=new Se(t),this._cachedGradientMap}dispose(){this._cachedGradientMap.dispose()}get speed(){return this.material.uniforms.speed.value}set speed(t){this.material.uniforms.speed.value=t}get coverage(){return this.material.uniforms.coverage.value}set coverage(t){this.material.uniforms.coverage.value=t}get sizeScale(){return this.material.uniforms.sizeScale.value}set sizeScale(t){this.material.uniforms.sizeScale.value=t}get skyAltitude(){return this.material.uniforms.skyAltitude.value}set skyAltitude(t){this.material.uniforms.skyAltitude.value=t}get thicknessBias(){return this.material.uniforms.thicknessBias.value}set thicknessBias(t){this.material.uniforms.thicknessBias.value=t}get thicknessScale(){return this.material.uniforms.thicknessScale.value}set thicknessScale(t){this.material.uniforms.thicknessScale.value=t}get mixGrayFactor(){return this.material.uniforms.mixGrayFactor.value}set mixGrayFactor(t){this.material.uniforms.mixGrayFactor.value=t}}class Jh{constructor(){this.name="",this.minZoom=0,this.maxZoom=20,this.bounds=[],this.center=[]}fetchTile(t,e,i){return null}getMetaData(){}}class $S extends Jh{constructor(t="https://a.tile.openstreetmap.org/"){super(),this.address=t,this.format="png"}fetchTile(t,e,i){return new Promise((s,r)=>{const a=document.createElement("img");a.onload=function(){s(a)},a.onerror=function(){r()},a.crossOrigin="Anonymous",a.src=this.address+t+"/"+e+"/"+i+"."+this.format})}}class on extends gt{constructor(t=1,e=1,i=1,s=1,r=!1,a=10){super();const o=[],l=[],h=[],c=[];on.buildPlane(t,e,i,s,o,l,h,c),r&&on.buildSkirt(t,e,i,s,a,o,l,h,c),this.setIndex(o),this.setAttribute("position",new Z(l,3)),this.setAttribute("normal",new Z(h,3)),this.setAttribute("uv",new Z(c,2))}static buildPlane(t=1,e=1,i=1,s=1,r,a,o,l){const h=t/2,c=e/2,u=i+1,d=s+1,p=t/i,m=e/s;for(let f=0;f<d;f++){const v=f*m-c;for(let _=0;_<u;_++){const y=_*p-h;a.push(y,0,v),o.push(0,1,0),l.push(_/i,1-f/s)}}for(let f=0;f<s;f++)for(let v=0;v<i;v++){const _=v+u*f,y=v+u*(f+1),x=v+1+u*(f+1),b=v+1+u*f;r.push(_,y,b,y,x,b)}}static buildSkirt(t=1,e=1,i=1,s=1,r,a,o,l,h){const c=t/2,u=e/2,d=i+1,p=s+1,m=t/i,f=e/s;let v=o.length/3;for(let y=0;y<d;y++){const x=y*m-c,b=-u;o.push(x,-r,b),l.push(0,1,0),h.push(y/i,1)}for(let y=0;y<i;y++){const x=y,b=y+1,w=y+v,M=y+v+1;a.push(b,w,x,b,M,w)}v=o.length/3;for(let y=0;y<d;y++){const x=y*m-c,b=s*f-u;o.push(x,-r,b),l.push(0,1,0),h.push(y/i,0)}let _=d*p-i-1;for(let y=0;y<i;y++){const x=_+y,b=_+y+1,w=y+v,M=y+v+1;a.push(x,w,b,w,M,b)}v=o.length/3;for(let y=0;y<p;y++){const x=y*f-u,b=-c;o.push(b,-r,x),l.push(0,1,0),h.push(0,1-y/s)}for(let y=0;y<s;y++){const x=y*p,b=(y+1)*p,w=y+v,M=y+v+1;a.push(x,w,b,w,M,b)}v=o.length/3;for(let y=0;y<p;y++){const x=y*f-u,b=i*m-c;o.push(b,-r,x),l.push(0,1,0),h.push(1,1-y/s)}for(let y=0;y<s;y++){const x=y*p+s,b=(y+1)*p+s,w=y+v,M=y+v+1;a.push(b,w,x,b,M,w)}}}class cp{static createOffscreenCanvas(t,e){if(OffscreenCanvas)return new OffscreenCanvas(t,e);{let i=document.createElement("canvas");return i.width=t,i.height=e,i}}}class Dt extends ot{constructor(t=null,e=null,i=Dt.root,s=0,r=0,a=0,o=null,l=null){super(o,l),this.mapView=null,this.parentNode=null,this.nodesLoaded=0,this.subdivided=!1,this.childrenCache=null,this.cacheChild=!1,this.isMesh=!0,this.mapView=e,this.parentNode=t,this.location=i,this.level=s,this.x=r,this.y=a,e.overrideMaterial&&(this.material=e.overrideMaterial,this.textureLoaded=!0),this.initialize()}initialize(){this.mapView.onNodeCreated&&this.mapView.onNodeCreated(this)}createChildNodes(){}subdivide(){const t=Math.min(this.mapView.provider.maxZoom,this.mapView.heightProvider.maxZoom);this.children.length>0||this.level+1>t||this.parentNode!==null&&this.parentNode.nodesLoaded<Dt.childrens||(this.subdivided=!0,this.cacheChild&&this.childrenCache!==null?(this.isMesh=!1,this.children=this.childrenCache):this.createChildNodes(),this.mapView.onNodeSubdivided&&this.mapView.onNodeSubdivided())}simplify(){this.cacheChild&&this.children.length>0&&(this.childrenCache=this.children),this.subdivided=!1,this.isMesh=!0,this.children=[]}loadTexture(){this.mapView.provider.fetchTile(this.level,this.x,this.y).then(t=>{const e=new Gt(t);e.generateMipmaps=!1,e.format=1023,e.magFilter=1006,e.minFilter=1006,e.needsUpdate=!0,this.material.map=e,this.nodeReady()}).catch(()=>{const t=cp.createOffscreenCanvas(1,1),e=t.getContext("2d");e.fillStyle="#FF0000",e.fillRect(0,0,1,1);const i=new Gt(t);i.generateMipmaps=!1,i.needsUpdate=!0,this.material.map=i,this.nodeReady()})}nodeReady(){if(this.parentNode!==null){if(this.parentNode.nodesLoaded++,this.parentNode.nodesLoaded>=Dt.childrens){this.parentNode.subdivided===!0&&(this.parentNode.isMesh=!1);for(let t=0;t<this.parentNode.children.length;t++)this.parentNode.children[t].visible=!0}}else this.visible=!0;this.mapView.onNodeReady&&this.mapView.onNodeReady()}getNeighborsDirection(t){return null}getNeighbors(){return[]}}Dt.baseGeometry=null,Dt.baseScale=null,Dt.childrens=4,Dt.root=-1,Dt.topLeft=0,Dt.topRight=1,Dt.bottomLeft=2,Dt.bottomRight=3;class ce{static get(t,e){navigator.geolocation.getCurrentPosition(function(i){t(i.coords,i.timestamp)},e)}static datumsToSpherical(t,e){const i=e*ce.EARTH_ORIGIN/180;let s=Math.log(Math.tan((90+t)*Math.PI/360))/(Math.PI/180);return s=s*ce.EARTH_ORIGIN/180,new V(i,s)}static sphericalToDatums(t,e){const i=t/ce.EARTH_ORIGIN*180;let s=e/ce.EARTH_ORIGIN*180;return s=180/Math.PI*(2*Math.atan(Math.exp(s*Math.PI/180))-Math.PI/2),{latitude:s,longitude:i}}static quadtreeToDatums(t,e,i){const s=Math.pow(2,t),r=e/s*360-180;return{latitude:Math.atan(Math.sinh(Math.PI*(1-2*i/s)))/Math.PI*180,longitude:r}}}ce.EARTH_RADIUS=6378137,ce.EARTH_PERIMETER=2*Math.PI*ce.EARTH_RADIUS,ce.EARTH_ORIGIN=ce.EARTH_PERIMETER/2;class Hi extends Dt{constructor(t=null,e=null,i=Dt.root,s=0,r=0,a=0){super(t,e,i,s,r,a,Hi.geometry,new Zt({wireframe:!1})),this.matrixAutoUpdate=!1,this.isMesh=!0,this.visible=!1}initialize(){super.initialize(),this.loadTexture()}createChildNodes(){const t=this.level+1,e=2*this.x,i=2*this.y,s=Object.getPrototypeOf(this).constructor;let r=new s(this,this.mapView,Dt.topLeft,t,e,i);r.scale.set(.5,1,.5),r.position.set(-.25,0,-.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new s(this,this.mapView,Dt.topRight,t,e+1,i),r.scale.set(.5,1,.5),r.position.set(.25,0,-.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new s(this,this.mapView,Dt.bottomLeft,t,e,i+1),r.scale.set(.5,1,.5),r.position.set(-.25,0,.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new s(this,this.mapView,Dt.bottomRight,t,e+1,i+1),r.scale.set(.5,1,.5),r.position.set(.25,0,.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0)}raycast(t,e){return this.isMesh===!0&&super.raycast(t,e)}}Hi.geometry=new on(1,1,1,1,!1),Hi.baseGeometry=Hi.geometry,Hi.baseScale=new S(ce.EARTH_PERIMETER,1,ce.EARTH_PERIMETER);class o_ extends gt{constructor(t=1,e=1,i=1,s=1,r=!1,a=10,o=null,l=!0){super();const h=[],c=[],u=[],d=[];on.buildPlane(t,e,i,s,h,c,u,d);const p=o.data;for(let m=0,f=0;m<p.length&&f<c.length;m+=4,f+=3){const v=p[m],_=p[m+1],y=p[m+2];if(v===0&&_===0&&y===0)c[f+1]=0;else{const x=.1*(65536*v+256*_+y)-1e4;c[f+1]=x}}r&&on.buildSkirt(t,e,i,s,a,h,c,u,d),this.setIndex(h),this.setAttribute("position",new Z(c,3)),this.setAttribute("normal",new Z(u,3)),this.setAttribute("uv",new Z(d,2)),l&&this.computeNormals(i,s)}computeNormals(t,e){const i=this.getAttribute("position");if(i!==void 0){let s=this.getAttribute("normal");const r=e*t;for(let f=0;f<r;f++)s.setXYZ(f,0,0,0);const a=new S,o=new S,l=new S,h=new S,c=new S,u=new S,d=new S,p=new S,m=e*t*6;for(let f=0;f<m;f+=3){const v=this.index.getX(f+0),_=this.index.getX(f+1),y=this.index.getX(f+2);a.fromBufferAttribute(i,v),o.fromBufferAttribute(i,_),l.fromBufferAttribute(i,y),d.subVectors(l,o),p.subVectors(a,o),d.cross(p),h.fromBufferAttribute(s,v),c.fromBufferAttribute(s,_),u.fromBufferAttribute(s,y),h.add(d),c.add(d),u.add(d),s.setXYZ(v,h.x,h.y,h.z),s.setXYZ(_,c.x,c.y,c.z),s.setXYZ(y,u.x,u.y,u.z)}this.normalizeNormals(),s.needsUpdate=!0}}}class Wi extends Dt{constructor(t=null,e=null,i=Dt.root,s=0,r=0,a=0,o=Wi.geometry,l=new en({wireframe:!1,color:16777215})){super(t,e,i,s,r,a,o,l),this.heightLoaded=!1,this.geometrySize=16,this.geometryNormals=!1,l.alphaTest=.1,this.isMesh=!0,this.visible=!1,this.matrixAutoUpdate=!1}initialize(){super.initialize(),this.textureLoaded?setTimeout(()=>{this.textureLoaded=!0},0):this.loadTexture(),this.loadHeightGeometry()}loadTexture(){this.mapView.provider.fetchTile(this.level,this.x,this.y).then(t=>{const e=new Gt(t);e.generateMipmaps=!1,e.format=1023,e.magFilter=1006,e.minFilter=1006,e.needsUpdate=!0,this.material.map=e}).catch(()=>{console.log("texture error")}).finally(()=>{this.textureLoaded=!0,this.nodeReady()})}nodeReady(){this.heightLoaded&&this.textureLoaded&&(this.visible=!0,super.nodeReady())}createChildNodes(){const t=this.level+1,e=Object.getPrototypeOf(this).constructor,i=2*this.x,s=2*this.y;let r=new e(this,this.mapView,Dt.topLeft,t,i,s);r.scale.set(.5,1,.5),r.position.set(-.25,0,-.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new e(this,this.mapView,Dt.topRight,t,i+1,s),r.scale.set(.5,1,.5),r.position.set(.25,0,-.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new e(this,this.mapView,Dt.bottomLeft,t,i,s+1),r.scale.set(.5,1,.5),r.position.set(-.25,0,.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new e(this,this.mapView,Dt.bottomRight,t,i+1,s+1),r.scale.set(.5,1,.5),r.position.set(.25,0,.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0)}loadHeightGeometry(){if(this.mapView.heightProvider===null)throw new Error("GeoThree: MapView.heightProvider provider is null.");return this.mapView.heightProvider.fetchTile(this.level,this.x,this.y).then(t=>{const e=cp.createOffscreenCanvas(this.geometrySize+1,this.geometrySize+1),i=e.getContext("2d");i.imageSmoothingEnabled=!1,i.drawImage(t,0,0,Wi.tileSize,Wi.tileSize,0,0,e.width,e.height);const s=i.getImageData(0,0,e.width,e.height),r=new o_(1,1,this.geometrySize,this.geometrySize,!0,10,s,!0);this.geometry=r}).catch(()=>{}).finally(()=>{this.heightLoaded=!0,this.nodeReady()})}raycast(t,e){return this.isMesh===!0&&super.raycast(t,e)}}Wi.tileSize=256,Wi.geometry=new on(1,1,1,1),Wi.baseGeometry=Hi.geometry,Wi.baseScale=new S(ce.EARTH_PERIMETER,1,ce.EARTH_PERIMETER);class l_ extends gt{constructor(t,e,i,s,r,a,o){super();const l=a+o;let h=0;const c=[],u=new S,d=new S,p=[],m=[],f=[],v=[];for(let _=0;_<=i;_++){const y=[],x=_/i;for(let b=0;b<=e;b++){const w=b/e;u.x=-t*Math.cos(s+w*r)*Math.sin(a+x*o),u.y=t*Math.cos(a+x*o),u.z=t*Math.sin(s+w*r)*Math.sin(a+x*o),m.push(u.x,u.y,u.z),d.set(u.x,u.y,u.z).normalize(),f.push(d.x,d.y,d.z),v.push(w,1-x),y.push(h++)}c.push(y)}for(let _=0;_<i;_++)for(let y=0;y<e;y++){const x=c[_][y+1],b=c[_][y],w=c[_+1][y],M=c[_+1][y+1];(_!==0||a>0)&&p.push(x,b,M),(_!==i-1||l<Math.PI)&&p.push(b,w,M)}this.setIndex(p),this.setAttribute("position",new Z(m,3)),this.setAttribute("normal",new Z(f,3)),this.setAttribute("uv",new Z(v,2))}}class Gs extends Dt{constructor(t=null,e=null,i=Dt.root,s=0,r=0,a=0){super(t,e,i,s,r,a,Gs.createGeometry(s,r,a),new Zt({wireframe:!1})),this.applyScaleNode(),this.matrixAutoUpdate=!1,this.isMesh=!0,this.visible=!1}initialize(){super.initialize(),this.loadTexture()}static createGeometry(t,e,i){const s=Math.pow(2,t),r=Math.floor(Gs.segments*(40/(t+1))/40),a=1/s*2*Math.PI,o=e*a,l=1/s*Math.PI;return new l_(1,r,r,o,a,i*l,l)}applyScaleNode(){this.geometry.computeBoundingBox();const t=this.geometry.boundingBox.clone().getCenter(new S),e=new at;e.compose(new S(-t.x,-t.y,-t.z),new Ft,new S(ce.EARTH_RADIUS,ce.EARTH_RADIUS,ce.EARTH_RADIUS)),this.geometry.applyMatrix4(e),this.position.copy(t),this.updateMatrix(),this.updateMatrixWorld()}updateMatrix(){this.matrix.setPosition(this.position),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t=!1){(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorld.copy(this.matrix),this.matrixWorldNeedsUpdate=!1)}createChildNodes(){const t=this.level+1,e=2*this.x,i=2*this.y,s=Object.getPrototypeOf(this).constructor;let r=new s(this,this.mapView,Dt.topLeft,t,e,i);this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new s(this,this.mapView,Dt.topRight,t,e+1,i),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new s(this,this.mapView,Dt.bottomLeft,t,e,i+1),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new s(this,this.mapView,Dt.bottomRight,t,e+1,i+1),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0)}raycast(t,e){return this.isMesh===!0&&super.raycast(t,e)}}Gs.baseGeometry=new l_(ce.EARTH_RADIUS,64,64,0,2*Math.PI,0,Math.PI),Gs.baseScale=new S(1,1,1),Gs.segments=80;class Ke extends Wi{constructor(t=null,e=null,i=Dt.root,s=0,r=0,a=0){const o=Ke.prepareMaterial(new Jl({map:Ke.emptyTexture,color:16777215}));super(t,e,i,s,r,a,Ke.geometry,o),this.frustumCulled=!1}static prepareMaterial(t){return t.userData={heightMap:{value:Ke.emptyTexture}},t.onBeforeCompile=e=>{for(const i in t.userData)e.uniforms[i]=t.userData[i];e.vertexShader=`
			uniform sampler2D heightMap;
			`+e.vertexShader,e.vertexShader=e.vertexShader.replace("#include <fog_vertex>",`
			#include <fog_vertex>
	
			// Calculate height of the title
			vec4 _theight = texture2D(heightMap, vUv);
			float _height = ((_theight.r * 255.0 * 65536.0 + _theight.g * 255.0 * 256.0 + _theight.b * 255.0) * 0.1) - 10000.0;
			vec3 _transformed = position + _height * normal;
	
			// Vertex position based on height
			gl_Position = projectionMatrix * modelViewMatrix * vec4(_transformed, 1.0);
			`)},t}loadTexture(){this.mapView.provider.fetchTile(this.level,this.x,this.y).then(t=>{const e=new Gt(t);e.generateMipmaps=!1,e.format=1023,e.magFilter=1006,e.minFilter=1006,e.needsUpdate=!0,this.material.map=e,this.textureLoaded=!0,this.nodeReady()}).catch(t=>{console.error("GeoThree: Failed to load color node data.",t)}).finally(()=>{this.textureLoaded=!0,this.nodeReady()}),this.loadHeightGeometry()}loadHeightGeometry(){if(this.mapView.heightProvider===null)throw new Error("GeoThree: MapView.heightProvider provider is null.");return this.mapView.heightProvider.fetchTile(this.level,this.x,this.y).then(t=>{const e=new Gt(t);e.generateMipmaps=!1,e.format=1023,e.magFilter=1003,e.minFilter=1003,e.needsUpdate=!0,this.material.userData.heightMap.value=e}).catch(t=>{console.error("GeoThree: Failed to load height node data.",t)}).finally(()=>{this.heightLoaded=!0,this.nodeReady()})}raycast(t,e){if(this.isMesh===!0){this.geometry=Hi.geometry;const i=super.raycast(t,e);return this.geometry=Ke.geometry,i}return!1}}Ke.emptyTexture=new Gt,Ke.geometrySize=256,Ke.geometry=new on(1,1,Ke.geometrySize,Ke.geometrySize,!0),Ke.baseGeometry=Hi.geometry,Ke.baseScale=new S(ce.EARTH_PERIMETER,1,ce.EARTH_PERIMETER);const h_=new S,c_=new S,u_=new at,d_=new S,up=new gr,dp=new S;class t2 extends class{constructor(){this.subdivideDistance=50,this.simplifyDistance=300}updateLOD(t,e,i,s){e.getWorldPosition(h_),t.children[0].traverse(r=>{r.getWorldPosition(c_);let a=h_.distanceTo(c_);a/=Math.pow(2,t.provider.maxZoom-r.level),a<this.subdivideDistance?r.subdivide():a>this.simplifyDistance&&r.parentNode&&r.parentNode.simplify()})}}{constructor(){super(...arguments),this.subdivideDistance=120,this.simplifyDistance=400,this.testCenter=!0,this.pointOnly=!1,this.lodOffset=0}updateLOD(t,e,i,s){u_.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),up.setFromProjectionMatrix(u_),e.getWorldPosition(d_),t.children[0].traverse(r=>{r.getWorldPosition(dp);let a=d_.distanceTo(dp);a/=Math.pow(2,t.provider.maxZoom-r.level+this.lodOffset);const o=this.pointOnly?up.containsPoint(dp):up.intersectsObject(r);a<this.subdivideDistance&&o?r.subdivide():a>this.simplifyDistance&&r.parentNode&&r.parentNode.simplify()})}}/*! *****************************************************************************
  	Copyright (c) Microsoft Corporation.
  
  	Permission to use, copy, modify, and/or distribute this software for any
  	purpose with or without fee is hereby granted.
  
  	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  	PERFORMANCE OF THIS SOFTWARE.
  	***************************************************************************** */function p_(n,t,e,i){return new(e||(e=Promise))(function(s,r){function a(h){try{l(i.next(h))}catch(c){r(c)}}function o(h){try{l(i.throw(h))}catch(c){r(c)}}function l(h){var c;h.done?s(h.value):(c=h.value,c instanceof e?c:new e(function(u){u(c)})).then(a,o)}l((i=i.apply(n,t||[])).next())})}class e2{constructor(t=257){this.gridSize=t;const e=t-1;if(e&e-1)throw new Error(`Expected grid size to be 2^n+1, got ${t}.`);this.numTriangles=e*e*2-2,this.numParentTriangles=this.numTriangles-e*e,this.indices=new Uint32Array(this.gridSize*this.gridSize),this.coords=new Uint16Array(4*this.numTriangles);for(let i=0;i<this.numTriangles;i++){let s=i+2,r=0,a=0,o=0,l=0,h=0,c=0;for(1&s?o=l=h=e:r=a=c=e;(s>>=1)>1;){const d=r+o>>1,p=a+l>>1;1&s?(o=r,l=a,r=h,a=c):(r=o,a=l,o=h,l=c),h=d,c=p}const u=4*i;this.coords[u+0]=r,this.coords[u+1]=a,this.coords[u+2]=o,this.coords[u+3]=l}}createTile(t){return new i2(t,this)}}class i2{constructor(t,e){const i=e.gridSize;if(t.length!==i*i)throw new Error(`Expected terrain data of length ${i*i} (${i} x ${i}), got ${t.length}.`);this.terrain=t,this.martini=e,this.errors=new Float32Array(t.length),this.update()}update(){const{numTriangles:t,numParentTriangles:e,coords:i,gridSize:s}=this.martini,{terrain:r,errors:a}=this;for(let o=t-1;o>=0;o--){const l=4*o,h=i[l+0],c=i[l+1],u=i[l+2],d=i[l+3],p=h+u>>1,m=c+d>>1,f=p+m-c,v=m+h-p,_=(r[c*s+h]+r[d*s+u])/2,y=m*s+p,x=Math.abs(_-r[y]);if(a[y]=Math.max(a[y],x),o<e){const b=(c+v>>1)*s+(h+f>>1),w=(d+v>>1)*s+(u+f>>1);a[y]=Math.max(a[y],a[b],a[w])}}}getMesh(t=0,e=!1){const{gridSize:i,indices:s}=this.martini,{errors:r}=this;let a=0,o=0;const l=i-1;let h,c,u=0;const d=[],p=[],m=[],f=[];function v(T,R,E,A,z,F){const G=T+E>>1,U=R+A>>1;Math.abs(T-z)+Math.abs(R-F)>1&&r[U*i+G]>t?(v(z,F,T,R,G,U),v(E,A,z,F,G,U)):(h=R*i+T,c=A*i+E,u=F*i+z,s[h]===0&&(e&&(T===0?d.push(a):T===l&&p.push(a),R===0?m.push(a):R===l&&f.push(a)),s[h]=++a),s[c]===0&&(e&&(E===0?d.push(a):E===l&&p.push(a),A===0?m.push(a):A===l&&f.push(a)),s[c]=++a),s[u]===0&&(e&&(z===0?d.push(a):z===l&&p.push(a),F===0?m.push(a):F===l&&f.push(a)),s[u]=++a),o++)}s.fill(0),v(0,0,l,l,l,0),v(l,l,0,0,0,l);let _=2*a,y=3*o;e&&(_+=2*(d.length+p.length+m.length+f.length),y+=3*(2*(d.length-1)+2*(p.length-1)+2*(m.length-1)+2*(f.length-1)));const x=new Uint16Array(_),b=new Uint32Array(y);let w=0;function M(T,R,E,A,z,F){const G=T+E>>1,U=R+A>>1;if(Math.abs(T-z)+Math.abs(R-F)>1&&r[U*i+G]>t)M(z,F,T,R,G,U),M(E,A,z,F,G,U);else{const k=s[R*i+T]-1,H=s[A*i+E]-1,W=s[F*i+z]-1;x[2*k]=T,x[2*k+1]=R,x[2*H]=E,x[2*H+1]=A,x[2*W]=z,x[2*W+1]=F,b[w++]=k,b[w++]=H,b[w++]=W}}if(M(0,0,l,l,l,0),M(l,l,0,0,0,l),e){let T=function(E){const A=E.length;for(let z=0;z<A-1;z++){const F=E[z],G=E[z+1],U=R/2,k=(R+2)/2;x[R++]=x[2*F],x[R++]=x[2*F+1],b[w++]=F,b[w++]=U,b[w++]=G,b[w++]=U,b[w++]=k,b[w++]=G}x[R++]=x[2*E[A-1]],x[R++]=x[2*E[A-1]+1]};d.sort((E,A)=>x[2*E+1]-x[2*A+1]),p.sort((E,A)=>x[2*A+1]-x[2*E+1]),m.sort((E,A)=>x[2*A]-x[2*E]),f.sort((E,A)=>x[2*E]-x[2*A]);let R=2*a;T(d),T(p),T(m),T(f)}return{vertices:x,triangles:b,numVerticesWithoutSkirts:a}}}class wi extends Wi{constructor(t=null,e=null,i=Dt.root,s=0,r=0,a=0,{elevationDecoder:o=null,meshMaxError:l=10,exageration:h=1}={}){super(t,e,i,s,r,a,wi.geometry,wi.prepareMaterial(new Jl({map:wi.emptyTexture,color:16777215,side:2}),s,h)),this.elevationDecoder={rScaler:256,gScaler:1,bScaler:1/256,offset:-32768},this.exageration=1,this.meshMaxError=10,o&&(this.elevationDecoder=o),this.meshMaxError=l,this.exageration=h,this.frustumCulled=!1}static prepareMaterial(t,e,i=1){return t.userData={heightMap:{value:wi.emptyTexture},drawNormals:{value:0},drawBlack:{value:0},zoomlevel:{value:e},computeNormals:{value:1},drawTexture:{value:1}},t.onBeforeCompile=s=>{for(let r in t.userData)s.uniforms[r]=t.userData[r];s.vertexShader=`
				uniform bool computeNormals;
				uniform float zoomlevel;
				uniform sampler2D heightMap;
				`+s.vertexShader,s.fragmentShader=`
				uniform bool drawNormals;
				uniform bool drawTexture;
				uniform bool drawBlack;
				`+s.fragmentShader,s.fragmentShader=s.fragmentShader.replace("#include <dithering_fragment>",`
				if(drawBlack) {
					gl_FragColor = vec4( 0.0,0.0,0.0, 1.0 );
				} else if(drawNormals) {
					gl_FragColor = vec4( ( 0.5 * vNormal + 0.5 ), 1.0 );
				} else if (!drawTexture) {
					gl_FragColor = vec4( 0.0,0.0,0.0, 0.0 );
				}`),s.vertexShader=s.vertexShader.replace("#include <fog_vertex>",`
				#include <fog_vertex>

				// queried pixels:
				// +-----------+
				// |   |   |   |
				// | a | b | c |
				// |   |   |   |
				// +-----------+
				// |   |   |   |
				// | d | e | f |
				// |   |   |   |
				// +-----------+
				// |   |   |   |
				// | g | h | i |
				// |   |   |   |
				// +-----------+

				if (computeNormals) {
					float e = getElevation(vUv, 0.0);
					ivec2 size = textureSize(heightMap, 0);
					float offset = 1.0 / float(size.x);
					float a = getElevation(vUv + vec2(-offset, -offset), 0.0);
					float b = getElevation(vUv + vec2(0, -offset), 0.0);
					float c = getElevation(vUv + vec2(offset, -offset), 0.0);
					float d = getElevation(vUv + vec2(-offset, 0), 0.0);
					float f = getElevation(vUv + vec2(offset, 0), 0.0);
					float g = getElevation(vUv + vec2(-offset, offset), 0.0);
					float h = getElevation(vUv + vec2(0, offset), 0.0);
					float i = getElevation(vUv + vec2(offset,offset), 0.0);


					float normalLength = 500.0 / zoomlevel;

					vec3 v0 = vec3(0.0, 0.0, 0.0);
					vec3 v1 = vec3(0.0, normalLength, 0.0);
					vec3 v2 = vec3(normalLength, 0.0, 0.0);
					v0.z = (e + d + g + h) / 4.0;
					v1.z = (e+ b + a + d) / 4.0;
					v2.z = (e+ h + i + f) / 4.0;
					vNormal = (normalize(cross(v2 - v0, v1 - v0))).rbg;
				}
				`)},t}static getTerrain(t,e,i){const{rScaler:s,bScaler:r,gScaler:a,offset:o}=i,l=e+1,h=new Float32Array(l*l);for(let c=0,u=0;u<e;u++)for(let d=0;d<e;d++,c++){const p=4*c,m=t[p+0],f=t[p+1],v=t[p+2];h[c+u]=m*s+f*a+v*r+o}for(let c=l*(l-1),u=0;u<l-1;u++,c++)h[c]=h[c-l];for(let c=l-1,u=0;u<l;u++,c+=l)h[c]=h[c-1];return h}static getMeshAttributes(t,e,i,s,r){const a=i+1,o=t.length/2,l=new Float32Array(3*o),h=new Float32Array(2*o),[c,u,d,p]=s||[0,0,i,i],m=(d-c)/i,f=(p-u)/i;for(let v=0;v<o;v++){const _=t[2*v],y=t[2*v+1],x=y*a+_;l[3*v+0]=_*m+c,l[3*v+1]=-e[x]*r,l[3*v+2]=-y*f+p,h[2*v+0]=_/i,h[2*v+1]=y/i}return{position:{value:l,size:3},uv:{value:h,size:2}}}onHeightImage(t){return p_(this,void 0,void 0,function*(){const e=t.width,i=e+1;var s=cp.createOffscreenCanvas(e,e),r=s.getContext("2d");r.imageSmoothingEnabled=!1,r.drawImage(t,0,0,e,e,0,0,s.width,s.height);var a=r.getImageData(0,0,s.width,s.height).data;const o=wi.getTerrain(a,e,this.elevationDecoder),l=new e2(i).createTile(o),{vertices:h,triangles:c}=l.getMesh(typeof this.meshMaxError=="function"?this.meshMaxError(this.level):this.meshMaxError),u=wi.getMeshAttributes(h,o,e,[-.5,-.5,.5,.5],this.exageration);this.geometry=new gt,this.geometry.setIndex(new pl(c,1)),this.geometry.setAttribute("position",new Z(u.position.value,u.position.size)),this.geometry.setAttribute("uv",new Z(u.uv.value,u.uv.size)),this.geometry.rotateX(Math.PI);var d=new Gt(t);d.generateMipmaps=!1,d.format=1023,d.magFilter=1003,d.minFilter=1003,d.needsUpdate=!0,this.material.userData.heightMap.value=d})}loadHeightGeometry(){if(this.mapView.heightProvider===null)throw new Error("GeoThree: MapView.heightProvider provider is null.");return this.mapView.heightProvider.fetchTile(this.level,this.x,this.y).then(t=>p_(this,void 0,void 0,function*(){this.onHeightImage(t)})).finally(()=>{this.heightLoaded=!0,this.nodeReady()})}}wi.geometrySize=16,wi.emptyTexture=new Gt,wi.geometry=new on(1,1,1,1),wi.tileSize=256;class js extends Dt{constructor(t=null,e=null,i=Dt.root,s=0,r=0,a=0,o=js.geometry,l=new en({wireframe:!1,color:16777215})){super(t,e,i,s,r,a,o,l),this.heightLoaded=!1,this.textureLoaded=!1,this.geometrySize=16,this.geometryNormals=!1,this.isMesh=!0,this.visible=!1,this.matrixAutoUpdate=!1}initialize(){super.initialize(),this.loadTexture(),this.loadHeightGeometry()}loadTexture(){this.mapView.provider.fetchTile(this.level,this.x,this.y).then(t=>{const e=new Gt(t);e.generateMipmaps=!1,e.format=1023,e.magFilter=1006,e.minFilter=1006,e.needsUpdate=!0,this.material.map=e}).finally(()=>{this.textureLoaded=!0,this.nodeReady()})}nodeReady(){this.heightLoaded&&this.textureLoaded&&(this.visible=!0,super.nodeReady())}createChildNodes(){const t=this.level+1,e=Object.getPrototypeOf(this).constructor,i=2*this.x,s=2*this.y;let r=new e(this,this.mapView,Dt.topLeft,t,i,s);r.scale.set(.5,1,.5),r.position.set(-.25,0,-.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new e(this,this.mapView,Dt.topRight,t,i+1,s),r.scale.set(.5,1,.5),r.position.set(.25,0,-.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new e(this,this.mapView,Dt.bottomLeft,t,i,s+1),r.scale.set(.5,1,.5),r.position.set(-.25,0,.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0),r=new e(this,this.mapView,Dt.bottomRight,t,i+1,s+1),r.scale.set(.5,1,.5),r.position.set(.25,0,.25),this.add(r),r.updateMatrix(),r.updateMatrixWorld(!0)}loadHeightGeometry(){if(this.mapView.heightProvider===null)throw new Error("GeoThree: MapView.heightProvider provider is null.");return this.mapView.heightProvider.fetchTile(this.level,this.x,this.y).then(t=>{const e=new o_(1,1,this.geometrySize,this.geometrySize,!0,10,imageData,!0);this.geometry=e}).catch(()=>{console.error("GeoThree: Failed to load height node data.",this)}).finally(()=>{this.heightLoaded=!0,this.nodeReady()})}raycast(t,e){return this.isMesh===!0&&super.raycast(t,e)}}js.tileSize=256,js.geometry=new on(1,1,1,1),js.baseGeometry=Hi.geometry,js.baseScale=new S(ce.EARTH_PERIMETER,1,ce.EARTH_PERIMETER);class xe extends ot{constructor(t=xe.PLANAR,e=new $S,i=null,s=null){super(void 0,new Zt({transparent:!0,opacity:0})),this.lod=null,this.onNodeReady=null,this.provider=null,this.heightProvider=null,this.root=null,this.overrideMaterial=s,this.lod=new t2,this.provider=e,this.heightProvider=i,this.setRoot(t)}update(t,e,i){this.lod.updateLOD(this,t,e,i)}setRoot(t){if(typeof t=="number"){if(!xe.mapModes.has(t))throw new Error("Map mode "+t+" does is not registered.");t=new(xe.mapModes.get(t))(null,this)}this.root!==null&&(this.remove(this.root),this.root=null),this.root=t,this.root!==null&&(this.geometry=this.root.constructor.baseGeometry,this.scale.copy(this.root.constructor.baseScale),this.root.mapView=this,this.add(this.root))}setProvider(t){t!==this.provider&&(this.provider=t,this.clear())}setHeightProvider(t){t!==this.heightProvider&&(this.heightProvider=t,this.clear())}clear(){return this.traverse(function(t){t.childrenCache&&(t.childrenCache=null),t.initialize&&t.initialize()}),this}getMetaData(){this.provider.getMetaData()}raycast(t,e){return!1}}xe.PLANAR=200,xe.SPHERICAL=201,xe.HEIGHT=202,xe.HEIGHT_SHADER=203,xe.MARTINI=204,xe.TERRAIN=205,xe.mapModes=new Map([[xe.PLANAR,Hi],[xe.SPHERICAL,Gs],[xe.HEIGHT,Wi],[xe.HEIGHT_SHADER,Ke],[xe.MARTINI,wi],[xe.TERRAIN,js]]);class m_{static get(t,e,i){const s=new XMLHttpRequest;return s.overrideMimeType("text/plain"),s.open("GET",t,!0),e!==void 0&&(s.onload=function(){e(s.response)}),i!==void 0&&(s.onerror=i),s.send(null),s}static getRaw(t,e,i){var s=new XMLHttpRequest;return s.responseType="arraybuffer",s.open("GET",t,!0),e!==void 0&&(s.onload=function(){e(s.response)}),i!==void 0&&(s.onerror=i),s.send(null),s}static request(t,e,i,s,r,a,o){const l=new XMLHttpRequest;if(l.overrideMimeType("text/plain"),l.open(e,t,!0),i!=null)for(const h in i)l.setRequestHeader(h,i[h]);return r!==void 0&&(l.onload=function(h){r(function(c){try{return JSON.parse(c)}catch{return c}}(l.response),l)}),a!==void 0&&(l.onerror=a),o!==void 0&&(l.onprogress=o),s!==void 0?l.send(s):l.send(null),l}}class An extends Jh{constructor(t="",e=An.AERIAL){super(),this.maxZoom=19,this.format="jpeg",this.mapSize=512,this.subdomain="t1",this.apiKey=t,this.type=e}getMetaData(){const t="http://dev.virtualearth.net/REST/V1/Imagery/Metadata/RoadOnDemand?output=json&include=ImageryProviders&key="+this.apiKey;m_.get(t,function(e){JSON.parse(e)})}static quadKey(t,e,i){let s="";for(let r=t;r>0;r--){const a=1<<r-1;let o=0;e&a&&o++,i&a&&(o+=2),s+=o}return s}fetchTile(t,e,i){return new Promise((s,r)=>{const a=document.createElement("img");if(a.onload=function(){s(a)},a.onerror=function(){r()},a.crossOrigin="Anonymous",this.getUrl){const o=this.getUrl(t,e,i);if(o!==!1)return void(a.src=o)}a.src="http://ecn."+this.subdomain+".tiles.virtualearth.net/tiles/"+this.type+An.quadKey(t,e,i)+".jpeg?g=1173"})}}An.AERIAL="a",An.ROAD="r",An.AERIAL_LABELS="h",An.OBLIQUE="o",An.OBLIQUE_LABELS="b",class extends Jh{constructor(n,t,e,i,s,r){super(),this.appId=n!==void 0?n:"",this.appCode=t!==void 0?t:"",this.style=e!==void 0?e:"base",this.scheme=i!==void 0?i:"normal.day",this.format=s!==void 0?s:"png",this.size=r!==void 0?r:512,this.version="newest",this.server=1}nextServer(){this.server=this.server%4==0?1:this.server+1}getMetaData(){}fetchTile(n,t,e){return this.nextServer(),new Promise((i,s)=>{const r=document.createElement("img");r.onload=function(){i(r)},r.onerror=function(){s()},r.crossOrigin="Anonymous",r.src="https://"+this.server+"."+this.style+".maps.api.here.com/maptile/2.1/maptile/"+this.version+"/"+this.scheme+"/"+n+"/"+t+"/"+e+"/"+this.size+"/"+this.format+"?app_id="+this.appId+"&app_code="+this.appCode})}}.PATH="/maptile/2.1/";class ln extends Jh{constructor(t="",e="",i=ln.STYLE,s="png",r=!1,a="v4"){super(),this.apiToken=t,this.format=s,this.useHDPI=r,this.mode=i,this.mapId=e,this.style=e,this.version=a}getMetaData(){const t=ln.ADDRESS+this.version+"/"+this.mapId+".json?access_token="+this.apiToken;m_.get(t,e=>{const i=JSON.parse(e);this.name=i.name,this.minZoom=i.minZoom,this.maxZoom=i.maxZoom,this.bounds=i.bounds,this.center=i.center})}fetchTile(t,e,i){return new Promise((s,r)=>{const a=document.createElement("img");if(a.onload=function(){s(a)},a.onerror=function(){r()},a.crossOrigin="Anonymous",this.getUrl){const o=this.getUrl(t,e,i);if(o!==!1)return void(a.src=o)}this.mode===ln.STYLE?a.src=ln.ADDRESS+"styles/v1/"+this.style+"/tiles/"+t+"/"+e+"/"+i+(this.useHDPI?"@2x?access_token=":"?access_token=")+this.apiToken:a.src=ln.ADDRESS+"v4/"+this.mapId+"/"+t+"/"+e+"/"+i+(this.useHDPI?"@2x.":".")+this.format+"?access_token="+this.apiToken})}}ln.ADDRESS="https://api.mapbox.com/",ln.STYLE=100,ln.MAP_ID=101;const pp={};function hn(n){if(typeof n!="string")throw new TypeError("Path must be a string. Received "+JSON.stringify(n))}function f_(n,t){for(var e,i="",s=0,r=-1,a=0,o=0;o<=n.length;++o){if(o<n.length)e=n.charCodeAt(o);else{if(e===47)break;e=47}if(e===47){if(!(r===o-1||a===1))if(r!==o-1&&a===2){if(i.length<2||s!==2||i.charCodeAt(i.length-1)!==46||i.charCodeAt(i.length-2)!==46){if(i.length>2){var l=i.lastIndexOf("/");if(l!==i.length-1){l===-1?(i="",s=0):s=(i=i.slice(0,l)).length-1-i.lastIndexOf("/"),r=o,a=0;continue}}else if(i.length===2||i.length===1){i="",s=0,r=o,a=0;continue}}t&&(i.length>0?i+="/..":i="..",s=2)}else i.length>0?i+="/"+n.slice(r+1,o):i=n.slice(r+1,o),s=o-r-1;r=o,a=0}else e===46&&a!==-1?++a:a=-1}return i}var ha={resolve:function(){for(var n,t="",e=!1,i=arguments.length-1;i>=-1&&!e;i--){var s;i>=0?s=arguments[i]:(n===void 0&&(n=process.cwd()),s=n),hn(s),s.length!==0&&(t=s+"/"+t,e=s.charCodeAt(0)===47)}return t=f_(t,!e),e?t.length>0?"/"+t:"/":t.length>0?t:"."},normalize:function(n){if(hn(n),n.length===0)return".";var t=n.charCodeAt(0)===47,e=n.charCodeAt(n.length-1)===47;return(n=f_(n,!t)).length!==0||t||(n="."),n.length>0&&e&&(n+="/"),t?"/"+n:n},isAbsolute:function(n){return hn(n),n.length>0&&n.charCodeAt(0)===47},join:function(){if(arguments.length===0)return".";for(var n,t=0;t<arguments.length;++t){var e=arguments[t];hn(e),e.length>0&&(n===void 0?n=e:n+="/"+e)}return n===void 0?".":ha.normalize(n)},relative:function(n,t){if(hn(n),hn(t),n===t||(n=ha.resolve(n))===(t=ha.resolve(t)))return"";for(var e=1;e<n.length&&n.charCodeAt(e)===47;++e);for(var i=n.length,s=i-e,r=1;r<t.length&&t.charCodeAt(r)===47;++r);for(var a=t.length-r,o=s<a?s:a,l=-1,h=0;h<=o;++h){if(h===o){if(a>o){if(t.charCodeAt(r+h)===47)return t.slice(r+h+1);if(h===0)return t.slice(r+h)}else s>o&&(n.charCodeAt(e+h)===47?l=h:h===0&&(l=0));break}var c=n.charCodeAt(e+h);if(c!==t.charCodeAt(r+h))break;c===47&&(l=h)}var u="";for(h=e+l+1;h<=i;++h)h!==i&&n.charCodeAt(h)!==47||(u.length===0?u+="..":u+="/..");return u.length>0?u+t.slice(r+l):(r+=l,t.charCodeAt(r)===47&&++r,t.slice(r))},_makeLong:function(n){return n},dirname:function(n){if(hn(n),n.length===0)return".";for(var t=n.charCodeAt(0),e=t===47,i=-1,s=!0,r=n.length-1;r>=1;--r)if((t=n.charCodeAt(r))===47){if(!s){i=r;break}}else s=!1;return i===-1?e?"/":".":e&&i===1?"//":n.slice(0,i)},basename:function(n,t){if(t!==void 0&&typeof t!="string")throw new TypeError('"ext" argument must be a string');hn(n);var e,i=0,s=-1,r=!0;if(t!==void 0&&t.length>0&&t.length<=n.length){if(t.length===n.length&&t===n)return"";var a=t.length-1,o=-1;for(e=n.length-1;e>=0;--e){var l=n.charCodeAt(e);if(l===47){if(!r){i=e+1;break}}else o===-1&&(r=!1,o=e+1),a>=0&&(l===t.charCodeAt(a)?--a==-1&&(s=e):(a=-1,s=o))}return i===s?s=o:s===-1&&(s=n.length),n.slice(i,s)}for(e=n.length-1;e>=0;--e)if(n.charCodeAt(e)===47){if(!r){i=e+1;break}}else s===-1&&(r=!1,s=e+1);return s===-1?"":n.slice(i,s)},extname:function(n){hn(n);for(var t=-1,e=0,i=-1,s=!0,r=0,a=n.length-1;a>=0;--a){var o=n.charCodeAt(a);if(o!==47)i===-1&&(s=!1,i=a+1),o===46?t===-1?t=a:r!==1&&(r=1):t!==-1&&(r=-1);else if(!s){e=a+1;break}}return t===-1||i===-1||r===0||r===1&&t===i-1&&t===e+1?"":n.slice(t,i)},format:function(n){if(n===null||typeof n!="object")throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof n);return function(t,e){var i=e.dir||e.root,s=e.base||(e.name||"")+(e.ext||"");return i?i===e.root?i+s:i+t+s:s}("/",n)},parse:function(n){hn(n);var t={root:"",dir:"",base:"",ext:"",name:""};if(n.length===0)return t;var e,i=n.charCodeAt(0),s=i===47;s?(t.root="/",e=1):e=0;for(var r=-1,a=0,o=-1,l=!0,h=n.length-1,c=0;h>=e;--h)if((i=n.charCodeAt(h))!==47)o===-1&&(l=!1,o=h+1),i===46?r===-1?r=h:c!==1&&(c=1):r!==-1&&(c=-1);else if(!l){a=h+1;break}return r===-1||o===-1||c===0||c===1&&r===o-1&&r===a+1?o!==-1&&(t.base=t.name=a===0&&s?n.slice(1,o):n.slice(a,o)):(a===0&&s?(t.name=n.slice(1,r),t.base=n.slice(1,o)):(t.name=n.slice(a,r),t.base=n.slice(a,o)),t.ext=n.slice(r,o)),a>0?t.dir=n.slice(0,a-1):s&&(t.dir="/"),t},sep:"/",delimiter:":",win32:null,posix:null};ha.posix=ha;var mp=ha;function g_(n){let t;try{t=new URL(n,"http://fakehost.com/")}catch{return null}const e=t.pathname.split("/").pop(),i=e.lastIndexOf(".");return i===-1||i===e.length-1?null:e.substring(i+1)}class n2{constructor(){this.maxSize=800,this.minSize=600,this.unloadPercent=.05,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.unloadPriorityCallback=null;const t=this.itemSet;this.defaultPriorityCallback=e=>t.get(e)}isFull(){return this.itemSet.size>=this.maxSize}add(t,e){const i=this.itemSet;if(i.has(t)||this.isFull())return!1;const s=this.usedSet,r=this.itemList,a=this.callbacks;return r.push(t),s.add(t),i.set(t,Date.now()),a.set(t,e),!0}remove(t){const e=this.usedSet,i=this.itemSet,s=this.itemList,r=this.callbacks;if(i.has(t)){r.get(t)(t);const a=s.indexOf(t);return s.splice(a,1),e.delete(t),i.delete(t),r.delete(t),!0}return!1}markUsed(t){const e=this.itemSet,i=this.usedSet;e.has(t)&&!i.has(t)&&(e.set(t,Date.now()),i.add(t))}markAllUnused(){this.usedSet.clear()}unloadUnusedContent(){const t=this.unloadPercent,e=this.minSize,i=this.itemList,s=this.itemSet,r=this.usedSet,a=this.callbacks,o=i.length-r.size,l=i.length-e,h=this.unloadPriorityCallback||this.defaultPriorityCallback;if(l>0&&o>0){i.sort((m,f)=>{const v=r.has(m),_=r.has(f);return v&&_?0:v||_?v?1:-1:h(f)-h(m)});const c=Math.min(l,o),u=Math.max(e*t,c*t);let d=Math.min(u,o);d=Math.ceil(d);const p=i.splice(0,d);for(let m=0,f=p.length;m<f;m++){const v=p[m];a.get(v)(v),s.delete(v),a.delete(v)}}}scheduleUnload(t=!0){var e;this.scheduled||(this.scheduled=!0,e=()=>{this.scheduled=!1,this.unloadUnusedContent(),t&&this.markAllUnused()},Promise.resolve().then(e))}}class v_{constructor(){this.maxJobs=6,this.items=[],this.callbacks=new Map,this.currJobs=0,this.scheduled=!1,this.autoUpdate=!0,this.priorityCallback=()=>{throw new Error("PriorityQueue: PriorityCallback function not defined.")},this.schedulingCallback=t=>{requestAnimationFrame(t)},this._runjobs=()=>{this.tryRunJobs(),this.scheduled=!1}}sort(){const t=this.priorityCallback;this.items.sort(t)}add(t,e){return new Promise((i,s)=>{const r=this.items,a=this.callbacks;r.push(t),a.set(t,(...o)=>e(...o).then(i).catch(s)),this.autoUpdate&&this.scheduleJobRun()})}remove(t){const e=this.items,i=this.callbacks,s=e.indexOf(t);s!==-1&&(e.splice(s,1),i.delete(t))}tryRunJobs(){this.sort();const t=this.items,e=this.callbacks,i=this.maxJobs;let s=this.currJobs;for(;i>s&&t.length>0;){s++;const r=t.pop(),a=e.get(r);e.delete(r),a(r).then(()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()}).catch(()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()})}this.currJobs=s}scheduleJobRun(){this.scheduled||(this.schedulingCallback(this._runjobs),this.scheduled=!0)}}function fp(n){return n===3||n===4}function Hs(n,t){return n.__lastFrameVisited===t&&n.__used}function __(n,t){n.__lastFrameVisited!==t&&(n.__lastFrameVisited=t,n.__used=!1,n.__inFrustum=!1,n.__isLeaf=!1,n.__visible=!1,n.__active=!1,n.__error=1/0,n.__distanceFromCamera=1/0,n.__childrenWereVisible=!1,n.__allChildrenLoaded=!1)}function y_(n,t,e){if(__(n,t),n.__used=!0,e.markUsed(n),n.__contentEmpty){const i=n.children;for(let s=0,r=i.length;s<r;s++)y_(i[s],t,e)}}function x_(n,t,e){if(n.__contentEmpty&&(!n.__externalTileSet||fp(n.__loadingState))){const i=n.children;for(let s=0,r=i.length;s<r;s++){const a=i[s];a.__depthFromRenderedParent=t,x_(a,t,e)}}else e.requestTileContents(n)}function gp(n,t=null,e=null,i=null,s=0){if(t&&t(n,i,s))return void(e&&e(n,i,s));const r=n.children;for(let a=0,o=r.length;a<o;a++)gp(r[a],t,e,n,s+1);e&&e(n,i,s)}function b_(n,t){const e=t.stats,i=t.frameCount,s=t.errorTarget,r=t.maxDepth,a=t.loadSiblings,o=t.lruCache,l=t.stopAtEmptyTiles;if(__(n,i),t.tileInView(n)===!1)return!1;if(n.__used=!0,o.markUsed(n),n.__inFrustum=!0,e.inFrustum++,(l||!n.__contentEmpty)&&!n.__externalTileSet&&(t.calculateError(n),n.__error<=s||t.maxDepth>0&&n.__depth+1>=r))return!0;let h=!1;const c=n.children;for(let u=0,d=c.length;u<d;u++){const p=b_(c[u],t);h=h||p}if(h&&a)for(let u=0,d=c.length;u<d;u++)y_(c[u],i,o);return!0}function M_(n,t){const e=t.stats,i=t.frameCount;if(!Hs(n,i))return;e.used++;const s=n.children;let r=!1;for(let a=0,o=s.length;a<o;a++){const l=s[a];r=r||Hs(l,i)}if(r){let a=!1,o=!0;for(let l=0,h=s.length;l<h;l++){const c=s[l];if(M_(c,t),a=a||c.__wasSetVisible||c.__childrenWereVisible,Hs(c,i)){const u=c.__allChildrenLoaded||!c.__contentEmpty&&fp(c.__loadingState)||c.__externalTileSet&&c.__loadingState===4;o=o&&u}}n.__childrenWereVisible=a,n.__allChildrenLoaded=o}else n.__isLeaf=!0}function w_(n,t){const e=t.stats,i=t.frameCount;if(!Hs(n,i))return;const s=n.parent,r=s?s.__depthFromRenderedParent:-1;n.__depthFromRenderedParent=r;const a=t.lruCache;if(n.__isLeaf)return n.__depthFromRenderedParent++,void(n.__loadingState===3?(n.__inFrustum&&(n.__visible=!0,e.visible++),n.__active=!0,e.active++):a.isFull()||n.__contentEmpty&&!n.__externalTileSet||t.requestTileContents(n));const o=(t.errorTarget+1)*t.errorThreshold,l=n.__error<=o,h=l||n.refine==="ADD",c=!n.__contentEmpty,u=c||n.__externalTileSet,d=fp(n.__loadingState)&&u,p=n.__childrenWereVisible,m=n.children;let f=n.__allChildrenLoaded;if(h&&c&&n.__depthFromRenderedParent++,h&&!d&&!a.isFull()&&u&&t.requestTileContents(n),(l&&!f&&!p&&d||n.refine==="ADD"&&d)&&(n.__inFrustum&&(n.__visible=!0,e.visible++),n.__active=!0,e.active++),n.refine!=="ADD"&&l&&!f&&d)for(let v=0,_=m.length;v<_;v++){const y=m[v];Hs(y,i)&&!a.isFull()&&(y.__depthFromRenderedParent=n.__depthFromRenderedParent+1,x_(y,y.__depthFromRenderedParent,t))}else for(let v=0,_=m.length;v<_;v++){const y=m[v];Hs(y,i)&&w_(y,t)}}function S_(n,t){const e=Hs(n,t.frameCount);if(e||n.__usedLastFrame){let i=!1,s=!1;e&&(i=n.__active,s=t.displayActiveTiles&&n.__active||n.__visible),n.__contentEmpty||n.__loadingState!==3||(n.__wasSetActive!==i&&t.setTileActive(n,i),n.__wasSetVisible!==s&&t.setTileVisible(n,s)),n.__wasSetActive=i,n.__wasSetVisible=s,n.__usedLastFrame=e;const r=n.children;for(let a=0,o=r.length;a<o;a++)S_(r[a],t)}}const T_=(n,t)=>n.__depth!==t.__depth?n.__depth>t.__depth?-1:1:n.__inFrustum!==t.__inFrustum?n.__inFrustum?1:-1:n.__used!==t.__used?n.__used?1:-1:n.__error!==t.__error?n.__error>t.__error?1:-1:n.__distanceFromCamera!==t.__distanceFromCamera?n.__distanceFromCamera>t.__distanceFromCamera?-1:1:0,s2=n=>1/(n.__depthFromRenderedParent+1);function E_(n){return new TextDecoder().decode(n)}class Kh{constructor(t,e,i,s){this.buffer=t,this.binOffset=e+i,this.binLength=s;let r=null;if(i!==0){const a=new Uint8Array(t,e,i);r=JSON.parse(E_(a))}else r={};this.header=r}getKeys(){return Object.keys(this.header)}getData(t,e,i=null,s=null){const r=this.header;if(!(t in r))return null;const a=r[t];if(a instanceof Object){if(Array.isArray(a))return a;{const{buffer:o,binOffset:l,binLength:h}=this,c=a.byteOffset||0,u=a.type||s,d=a.componentType||i;if("type"in a&&s&&a.type!==s)throw new Error("FeatureTable: Specified type does not match expected type.");let p,m;switch(u){case"SCALAR":p=1;break;case"VEC2":p=2;break;case"VEC3":p=3;break;case"VEC4":p=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${t}".`)}const f=l+c,v=e*p;switch(d){case"BYTE":m=new Int8Array(o,f,v);break;case"UNSIGNED_BYTE":m=new Uint8Array(o,f,v);break;case"SHORT":m=new Int16Array(o,f,v);break;case"UNSIGNED_SHORT":m=new Uint16Array(o,f,v);break;case"INT":m=new Int32Array(o,f,v);break;case"UNSIGNED_INT":m=new Uint32Array(o,f,v);break;case"FLOAT":m=new Float32Array(o,f,v);break;case"DOUBLE":m=new Float64Array(o,f,v);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${t}".`)}if(f+v*m.BYTES_PER_ELEMENT>l+h)throw new Error("FeatureTable: Feature data read outside binary body length.");return m}}return a}}class vp extends Kh{constructor(t,e,i,s,r){super(t,i,s,r),this.batchSize=e}getData(t,e=null,i=null){return super.getData(t,this.batchSize,e,i)}}class Do{constructor(){this.fetchOptions={},this.workingPath=""}load(t){return fetch(t,this.fetchOptions).then(e=>{if(!e.ok)throw new Error(`Failed to load file "${t}" with status ${e.status} : ${e.statusText}`);return e.arrayBuffer()}).then(e=>(this.workingPath===""&&(this.workingPath=this.workingPathForURL(t)),this.parse(e)))}resolveExternalURL(t){return/^[^\\/]/.test(t)?this.workingPath+"/"+t:t}workingPathForURL(t){const e=t.split(/[\\/]/g);return e.pop(),e.join("/")+"/"}parse(t){throw new Error("LoaderBase: Parse not implemented.")}}class r2 extends Do{parse(t){const e=new DataView(t),i=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3));console.assert(i==="b3dm");const s=e.getUint32(4,!0);console.assert(s===1);const r=e.getUint32(8,!0);console.assert(r===t.byteLength);const a=e.getUint32(12,!0),o=e.getUint32(16,!0),l=e.getUint32(20,!0),h=e.getUint32(24,!0),c=t.slice(28,28+a+o),u=new Kh(c,0,a,o),d=28+a+o,p=t.slice(d,d+l+h),m=new vp(p,u.getData("BATCH_LENGTH"),0,l,h),f=d+l+h;return{version:s,featureTable:u,batchTable:m,glbBytes:new Uint8Array(t,f,r-f)}}}class C_ extends r2{constructor(t=Ss){super(),this.manager=t}parse(t){const e=super.parse(t),i=e.glbBytes.slice().buffer;return new Promise((s,r)=>{const a=this.manager,o=this.fetchOptions,l=a.getHandler("path.gltf")||new Bs(a);o.credentials==="include"&&o.mode==="cors"&&l.setCrossOrigin("use-credentials"),"credentials"in o&&l.setWithCredentials(o.credentials==="include"),o.headers&&l.setRequestHeader(o.headers);let h=this.workingPath;!/[\\/]$/.test(h)&&h.length&&(h+="/"),l.parse(i,h,c=>{const{batchTable:u,featureTable:d}=e,{scene:p}=c,m=d.getData("RTC_CENTER");m&&(p.position.x+=m[0],p.position.y+=m[1],p.position.z+=m[2]),c.batchTable=u,c.featureTable=d,p.batchTable=u,p.featureTable=d,s(c)},r)})}}class a2 extends Do{parse(t){const e=new DataView(t),i=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3));console.assert(i==="pnts");const s=e.getUint32(4,!0);console.assert(s===1);const r=e.getUint32(8,!0);console.assert(r===t.byteLength);const a=e.getUint32(12,!0),o=e.getUint32(16,!0),l=e.getUint32(20,!0),h=e.getUint32(24,!0),c=t.slice(28,28+a+o),u=new Kh(c,0,a,o),d=28+a+o,p=t.slice(d,d+l+h),m=new vp(p,u.getData("BATCH_LENGTH")||u.getData("POINTS_LENGTH"),0,l,h);return Promise.resolve({version:s,featureTable:u,batchTable:m})}}class A_ extends a2{constructor(t=Ss){super(),this.manager=t}parse(t){return super.parse(t).then(e=>{const{featureTable:i}=e,s=i.getData("POINTS_LENGTH"),r=i.getData("POSITION",s,"FLOAT","VEC3"),a=i.getData("RGB",s,"UNSIGNED_BYTE","VEC3");["RTC_CENTER","QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","CONSTANT_RGBA","BATCH_LENGTH","POSITION_QUANTIZED","RGBA","RGB565","NORMAL","NORMAL_OCT16P"].forEach(u=>{u in i.header&&console.warn(`PNTSLoader: Unsupported FeatureTable feature "${u}" detected.`)});const o=new gt;o.setAttribute("position",new Lt(r,3,!1));const l=new Tr;l.size=2,l.sizeAttenuation=!1,a!==null&&(o.setAttribute("color",new Lt(a,3,!0)),l.vertexColors=!0);const h=new ka(o,l);e.scene=h,e.scene.featureTable=i;const c=i.getData("RTC_CENTER");return c&&(e.scene.position.x+=c[0],e.scene.position.y+=c[1],e.scene.position.z+=c[2]),e})}}class o2 extends Do{parse(t){const e=new DataView(t),i=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3));console.assert(i==="i3dm");const s=e.getUint32(4,!0);console.assert(s===1);const r=e.getUint32(8,!0);console.assert(r===t.byteLength);const a=e.getUint32(12,!0),o=e.getUint32(16,!0),l=e.getUint32(20,!0),h=e.getUint32(24,!0),c=e.getUint32(28,!0),u=t.slice(32,32+a+o),d=new Kh(u,0,a,o),p=32+a+o,m=t.slice(p,p+l+h),f=new vp(m,d.getData("INSTANCES_LENGTH"),0,l,h),v=p+l+h,_=new Uint8Array(t,v,r-v);let y=null,x=null;if(c)y=_,x=Promise.resolve();else{const b=this.resolveExternalURL(E_(_));x=fetch(b,this.fetchOptions).then(w=>{if(!w.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${b}" with status ${w.status} : ${w.statusText}`);return w.arrayBuffer()}).then(w=>{y=new Uint8Array(w)})}return x.then(()=>({version:s,featureTable:d,batchTable:f,glbBytes:y}))}}const P_=new S,_p=new S,yp=new S,R_=new S,xp=new Ft,Qh=new S,$h=new at;class L_ extends o2{constructor(t=Ss){super(),this.manager=t}resolveExternalURL(t){return this.manager.resolveURL(super.resolveExternalURL(t))}parse(t){return super.parse(t).then(e=>{const{featureTable:i,batchTable:s}=e,r=e.glbBytes.slice().buffer;return new Promise((a,o)=>{const l=this.fetchOptions,h=this.manager,c=h.getHandler("path.gltf")||new Bs(h);l.credentials==="include"&&l.mode==="cors"&&c.setCrossOrigin("use-credentials"),"credentials"in l&&c.setWithCredentials(l.credentials==="include"),l.headers&&c.setRequestHeader(l.headers);let u=this.workingPath;/[\\/]$/.test(u)||(u+="/"),c.parse(r,u,d=>{const p=i.getData("INSTANCES_LENGTH"),m=i.getData("POSITION",p,"FLOAT","VEC3"),f=i.getData("NORMAL_UP",p,"FLOAT","VEC3"),v=i.getData("NORMAL_RIGHT",p,"FLOAT","VEC3"),_=i.getData("SCALE_NON_UNIFORM",p,"FLOAT","VEC3"),y=i.getData("SCALE",p,"FLOAT","SCALAR");["RTC_CENTER","QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","EAST_NORTH_UP","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(M=>{M in i.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${M}" detected.`)});const x=new Map,b=[];d.scene.traverse(M=>{if(M.isMesh){const{geometry:T,material:R}=M,E=new Fl(T,R,p);E.position.copy(M.position),E.rotation.copy(M.rotation),E.scale.copy(M.scale),b.push(E),x.set(M,E)}});const w=new S;for(let M=0;M<p;M++)w.x+=m[3*M+0]/p,w.y+=m[3*M+1]/p,w.z+=m[3*M+2]/p;x.forEach((M,T)=>{const R=T.parent;R&&(R.remove(T),R.add(M),M.updateMatrixWorld(),M.position.copy(w).applyMatrix4(M.matrixWorld))});for(let M=0;M<p;M++){R_.set(m[3*M+0]-w.x,m[3*M+1]-w.y,m[3*M+2]-w.z),f?(_p.set(f[3*M+0],f[3*M+1],f[3*M+2]),yp.set(v[3*M+0],v[3*M+1],v[3*M+2]),P_.crossVectors(yp,_p).normalize(),$h.makeBasis(yp,_p,P_),xp.setFromRotationMatrix($h)):xp.set(0,0,0,1),y?Qh.setScalar(y[M]):_?Qh.set(_[3*M+0],_[3*M+1],_[3*M+2]):Qh.set(1,1,1),$h.compose(R_,xp,Qh);for(let T=0,R=b.length;T<R;T++)b[T].setMatrixAt(M,$h)}d.batchTable=s,d.featureTable=i,d.scene.batchTable=s,d.scene.featureTable=i,a(d)},o)})})}}class l2 extends Do{parse(t){const e=new DataView(t),i=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3));console.assert(i==="cmpt",'CMPTLoader: The magic bytes equal "cmpt".');const s=e.getUint32(4,!0);console.assert(s===1,'CMPTLoader: The version listed in the header is "1".');const r=e.getUint32(8,!0);console.assert(r===t.byteLength,"CMPTLoader: The contents buffer length listed in the header matches the file.");const a=e.getUint32(12,!0),o=[];let l=16;for(let h=0;h<a;h++){const c=new DataView(t,l,12),u=String.fromCharCode(c.getUint8(0))+String.fromCharCode(c.getUint8(1))+String.fromCharCode(c.getUint8(2))+String.fromCharCode(c.getUint8(3)),d=c.getUint32(4,!0),p=c.getUint32(8,!0),m=new Uint8Array(t,l,p);o.push({type:u,buffer:m,version:d}),l+=p}return{version:s,tiles:o}}}class h2 extends l2{constructor(t=Ss){super(),this.manager=t}parse(t){const e=super.parse(t),i=this.manager,s=[];for(const r in e.tiles){const{type:a,buffer:o}=e.tiles[r];switch(a){case"b3dm":{const l=o.slice(),h=new C_(i);h.workingPath=this.workingPath,h.fetchOptions=this.fetchOptions;const c=h.parse(l.buffer);s.push(c);break}case"pnts":{const l=o.slice(),h=new A_(i);h.workingPath=this.workingPath,h.fetchOptions=this.fetchOptions;const c=h.parse(l.buffer);s.push(c);break}case"i3dm":{const l=o.slice(),h=new L_(i);h.workingPath=this.workingPath,h.fetchOptions=this.fetchOptions;const c=h.parse(l.buffer);s.push(c);break}}}return Promise.all(s).then(r=>{const a=new Me;return r.forEach(o=>{a.add(o.scene)}),{tiles:r,scene:a}})}}class c2 extends Do{constructor(t=Ss){super(),this.manager=t}parse(t){return new Promise((e,i)=>{const s=this.manager,r=this.fetchOptions;let a=s.getHandler("path.gltf")||s.getHandler("path.glb");a||(a=new Bs(s),r.credentials==="include"&&r.mode==="cors"&&a.setCrossOrigin("use-credentials"),"credentials"in r&&a.setWithCredentials(r.credentials==="include"),r.headers&&a.setRequestHeader(r.headers));let o=a.resourcePath||a.path||this.workingPath;!/[\\/]$/.test(o)&&o.length&&(o+="/"),a.parse(t,o,l=>{e(l)},i)})}}const tc=new at;class u2 extends Me{constructor(t){super(),this.name="TilesRenderer.TilesGroup",this.tilesRenderer=t}raycast(t,e){this.tilesRenderer.optimizeRaycast&&this.tilesRenderer.raycast(t,e)}updateMatrixWorld(t){if(this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldNeedsUpdate||t){this.parent===null?tc.copy(this.matrix):tc.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1;const e=tc.elements,i=this.matrixWorld.elements;let s=!1;for(let r=0;r<16;r++){const a=e[r],o=i[r];if(Math.abs(a-o)>Number.EPSILON){s=!0;break}}if(s){this.matrixWorld.copy(tc);const r=this.children;for(let a=0,o=r.length;a<o;a++)r[a].updateMatrixWorld()}}}}const ca=new ii,Pn=new at,I_=new S,ua=new S,da=new kn,Si=[];function bp(n,t){return n.distance-t.distance}function Mp(n,t,e){n.traverse(i=>{Object.getPrototypeOf(i).raycast.call(i,t,e)})}function D_(n,t,e,i){if(e.has(n)){if(Mp(n.cached.scene,i,Si),Si.length>0){Si.length>1&&Si.sort(bp);const l=Si[0];return Si.length=0,l}return null}const s=[],r=n.children;for(let l=0,h=r.length;l<h;l++){const c=r[l],u=c.cached,d=t.matrixWorld;Pn.copy(d);const p=u.sphere;if(p&&(ca.copy(p),ca.applyMatrix4(Pn),!i.ray.intersectsSphere(ca)))continue;const m=u.box,f=u.boxTransform;if(m){if(Pn.multiply(f).invert(),da.copy(i.ray),da.applyMatrix4(Pn),!da.intersectBox(m,I_))continue;{let v;ua.setFromMatrixScale(Pn),v=ua.x,Math.abs(Math.max(ua.x-ua.y,ua.x-ua.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when raycasting.");let _={distance:1/0,tile:null};s.push(_),_.distance=I_.distanceToSquared(da.origin)*v*v,_.tile=c}}}s.sort(bp);let a=1/0,o=null;for(let l=0,h=s.length;l<h;l++){const c=s[l];if(c.distance>a)break;{const u=c.tile,d=u.cached.scene;let p=null;if(e.has(u)?(Mp(d,i,Si),Si.length>0&&(Si.length>1&&Si.sort(bp),p=Si[0])):p=D_(u,t,e,i),p){const m=p.distance*p.distance;m<a&&(a=m,o=p),Si.length=0}}}return o}function O_(n,t,e,i,s){const r=n.cached,a=t.matrixWorld;Pn.copy(a);const o=r.sphere;if(o&&(ca.copy(o),ca.applyMatrix4(Pn),!i.ray.intersectsSphere(ca)))return;const l=r.box,h=r.boxTransform;if(l&&(Pn.multiply(h).invert(),da.copy(i.ray).applyMatrix4(Pn),!da.intersectsBox(l)))return;const c=r.scene;if(e.has(n))return void Mp(c,i,s);const u=n.children;for(let d=0,p=u.length;d<p;d++)O_(u[d],t,e,i,s)}const z_=Symbol("INITIAL_FRUSTUM_CULLED"),ss=new at,wp=new at,qi=new S,Rn=new S,Ln=new S,In=new S,d2=new S(1,0,0),p2=new S(0,1,0);function U_(n,t){n.traverse(e=>{e.frustumCulled=e[z_]&&t})}class Sp extends class{get rootTileSet(){const t=this.tileSets[this.rootURL];return!t||t instanceof Promise?null:t}get root(){const t=this.rootTileSet;return t?t.root:null}constructor(t){this.tileSets={},this.rootURL=t,this.fetchOptions={},this.preprocessURL=null;const e=new n2;e.unloadPriorityCallback=s2;const i=new v_;i.maxJobs=4,i.priorityCallback=T_;const s=new v_;s.maxJobs=1,s.priorityCallback=T_,this.lruCache=e,this.downloadQueue=i,this.parseQueue=s,this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0,this.errorTarget=6,this.errorThreshold=1/0,this.loadSiblings=!0,this.displayActiveTiles=!1,this.maxDepth=1/0,this.stopAtEmptyTiles=!0}traverse(t,e){const i=this.tileSets[this.rootURL];i&&i.root&&gp(i.root,t,e)}update(){const t=this.stats,e=this.lruCache,i=this.tileSets,s=i[this.rootURL];if(!(this.rootURL in i))return void this.loadRootTileSet(this.rootURL);if(!s||!s.root)return;const r=s.root;t.inFrustum=0,t.used=0,t.active=0,t.visible=0,this.frameCount++,b_(r,this),M_(r,this),w_(r,this),S_(r,this),e.scheduleUnload()}parseTile(t,e,i){return null}disposeTile(t){}preprocessNode(t,e,i){if(t.content&&(!("uri"in t.content)&&"url"in t.content&&(t.content.uri=t.content.url,delete t.content.url),t.content.uri&&(t.content.uri=function(...s){const r=/^[a-zA-Z]+:\/\//;let a=-1;for(let o=0,l=s.length;o<l;o++)r.test(s[o])&&(a=o);if(a===-1)return mp.join(...s).replace(/\\/g,"/");{const o=a<=0?s:s.slice(a),l=o[0].match(r)[0];return o[0]=o[0].substring(l.length),(l+mp.join(...o)).replace(/\\/g,"/")}}(i,t.content.uri)),t.content.boundingVolume&&!("box"in t.content.boundingVolume||"sphere"in t.content.boundingVolume||"region"in t.content.boundingVolume)&&delete t.content.boundingVolume),t.parent=e,t.children=t.children||[],t.content&&t.content.uri){const s=g_(t.content.uri),r=!!(s&&s.toLowerCase()==="json");t.__externalTileSet=r,t.__contentEmpty=r}else t.__externalTileSet=!1,t.__contentEmpty=!0;t.__distanceFromCamera=1/0,t.__error=1/0,t.__inFrustum=!1,t.__isLeaf=!1,t.__usedLastFrame=!1,t.__used=!1,t.__wasSetVisible=!1,t.__visible=!1,t.__childrenWereVisible=!1,t.__allChildrenLoaded=!1,t.__wasSetActive=!1,t.__active=!1,t.__loadingState=0,t.__loadIndex=0,t.__loadAbort=null,t.__depthFromRenderedParent=-1,e===null?(t.__depth=0,t.refine=t.refine||"REPLACE"):(t.__depth=e.__depth+1,t.refine=t.refine||e.refine)}setTileActive(t,e){}setTileVisible(t,e){}calculateError(t){return 0}tileInView(t){return!0}fetchTileSet(t,e,i=null){return fetch(t,e).then(s=>{if(s.ok)return s.json();throw new Error(`TilesRenderer: Failed to load tileset "${t}" with status ${s.status} : ${s.statusText}`)}).then(s=>{const r=s.asset.version;console.assert(r==="1.0"||r==="0.0",'asset.version is expected to be a string of "1.0" or "0.0"');const a=mp.dirname(t);return gp(s.root,(o,l)=>this.preprocessNode(o,l,a),null,i,i?i.__depth:0),s})}loadRootTileSet(t){const e=this.tileSets;if(t in e)return e[t]instanceof Error?Promise.reject(e[t]):Promise.resolve(e[t]);{const i=this.fetchTileSet(this.preprocessURL?this.preprocessURL(t):t,this.fetchOptions).then(s=>{e[t]=s});return i.catch(s=>{console.error(s),e[t]=s}),e[t]=i,i}}requestTileContents(t){if(t.__loadingState!==0)return;const e=this.stats,i=this.lruCache,s=this.downloadQueue,r=this.parseQueue,a=t.__externalTileSet;i.add(t,u=>{u.__loadingState===1?(u.__loadAbort.abort(),u.__loadAbort=null):a?u.children.length=0:this.disposeTile(u),u.__loadingState===1?e.downloading--:u.__loadingState===2&&e.parsing--,u.__loadingState=0,u.__loadIndex++,r.remove(u),s.remove(u)}),t.__loadIndex++;const o=t.__loadIndex,l=new AbortController,h=l.signal;e.downloading++,t.__loadAbort=l,t.__loadingState=1;const c=u=>{t.__loadIndex===o&&(u.name!=="AbortError"?(r.remove(t),s.remove(t),t.__loadingState===2?e.parsing--:t.__loadingState===1&&e.downloading--,e.failed++,console.error(`TilesRenderer : Failed to load tile at url "${t.content.uri}".`),console.error(u),t.__loadingState=4):i.remove(t))};a?s.add(t,u=>{if(u.__loadIndex!==o)return Promise.resolve();const d=this.preprocessURL?this.preprocessURL(u.content.uri):u.content.uri;return this.fetchTileSet(d,Object.assign({signal:h},this.fetchOptions),u)}).then(u=>{t.__loadIndex===o&&(e.downloading--,t.__loadAbort=null,t.__loadingState=3,t.children.push(u.root))}).catch(c):s.add(t,u=>{if(u.__loadIndex!==o)return Promise.resolve();const d=this.preprocessURL?this.preprocessURL(u.content.uri):u.content.uri;return fetch(d,Object.assign({signal:h},this.fetchOptions))}).then(u=>{if(t.__loadIndex===o){if(u.ok)return u.arrayBuffer();throw new Error(`Failed to load model with error code ${u.status}`)}}).then(u=>{if(t.__loadIndex===o)return e.downloading--,e.parsing++,t.__loadAbort=null,t.__loadingState=2,r.add(t,d=>{if(d.__loadIndex!==o)return Promise.resolve();const p=g_(d.content.uri);return this.parseTile(u,d,p)})}).then(()=>{t.__loadIndex===o&&(e.parsing--,t.__loadingState=3,t.__wasSetVisible&&this.setTileVisible(t,!0),t.__wasSetActive&&this.setTileActive(t,!0))}).catch(c)}dispose(){const t=this.lruCache;this.traverse(e=>{t.remove(e)})}}{get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(t){this._autoDisableRendererCulling!==t&&(super._autoDisableRendererCulling=t,this.forEachLoadedModel(e=>{U_(e,!t)}))}constructor(...t){super(...t),this.group=new u2(this),this.cameras=[],this.cameraMap=new Map,this.cameraInfo=[],this.activeTiles=new Set,this.visibleTiles=new Set,this._autoDisableRendererCulling=!0,this.optimizeRaycast=!0,this.onLoadTileSet=null,this.onLoadModel=null,this.onDisposeModel=null,this.onTileVisibilityChange=null;const e=new Kl;e.setURLModifier(s=>this.preprocessURL?this.preprocessURL(s):s),this.manager=e;const i=this;this._overridenRaycast=function(s,r){i.optimizeRaycast||Object.getPrototypeOf(this).raycast.call(this,s,r)}}getBounds(t){if(!this.root)return!1;const e=this.root.cached,i=e.box,s=e.boxTransform;return!!i&&(t.copy(i),t.applyMatrix4(s),!0)}getOrientedBounds(t,e){if(!this.root)return!1;const i=this.root.cached,s=i.box,r=i.boxTransform;return!!s&&(t.copy(s),e.copy(r),!0)}getBoundingSphere(t){if(!this.root)return!1;const e=this.root.cached.sphere;return!!e&&(t.copy(e),!0)}forEachLoadedModel(t){this.traverse(e=>{const i=e.cached.scene;i&&t(i,e)})}raycast(t,e){if(this.root)if(t.firstHitOnly){const i=D_(this.root,this.group,this.activeTiles,t);i&&e.push(i)}else O_(this.root,this.group,this.activeTiles,t,e)}hasCamera(t){return this.cameraMap.has(t)}setCamera(t){const e=this.cameras,i=this.cameraMap;return!i.has(t)&&(i.set(t,new V),e.push(t),!0)}setResolution(t,e,i){const s=this.cameraMap;return!!s.has(t)&&(e instanceof V?s.get(t).copy(e):s.get(t).set(e,i),!0)}setResolutionFromRenderer(t,e){const i=this.cameraMap;if(!i.has(t))return!1;const s=i.get(t);return e.getSize(s),s.multiplyScalar(e.getPixelRatio()),!0}deleteCamera(t){const e=this.cameras,i=this.cameraMap;if(i.has(t)){const s=e.indexOf(t);return e.splice(s,1),i.delete(t),!0}return!1}fetchTileSet(t,...e){const i=super.fetchTileSet(t,...e);return i.then(s=>{this.onLoadTileSet&&Promise.resolve().then(()=>{this.onLoadTileSet(s,t)})}),i}update(){const t=this.group,e=this.cameras,i=this.cameraMap,s=this.cameraInfo;if(e.length===0)return void console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.");for(;s.length>e.length;)s.pop();for(;s.length<e.length;)s.push({frustum:new gr,isOrthographic:!1,sseDenominator:-1,position:new S,invScale:-1,pixelSize:0});let r;wp.copy(t.matrixWorld).invert(),qi.setFromMatrixScale(wp),r=qi.x,Math.abs(Math.max(qi.x-qi.y,qi.x-qi.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");for(let a=0,o=s.length;a<o;a++){const l=e[a],h=s[a],c=h.frustum,u=h.position,d=i.get(l);d.width!==0&&d.height!==0||console.warn("TilesRenderer: resolution for camera error calculation is not set.");const p=l.projectionMatrix.elements;if(h.isOrthographic=p[15]===1,h.isOrthographic){const m=2/p[0],f=2/p[5];h.pixelSize=Math.max(f/d.height,m/d.width)}else h.sseDenominator=2/p[5]/d.height;h.invScale=r,ss.copy(t.matrixWorld),ss.premultiply(l.matrixWorldInverse),ss.premultiply(l.projectionMatrix),c.setFromProjectionMatrix(ss),u.set(0,0,0),u.applyMatrix4(l.matrixWorld),u.applyMatrix4(wp)}super.update()}preprocessNode(t,e,i){super.preprocessNode(t,e,i);const s=new at;if(t.transform){const c=t.transform;for(let u=0;u<16;u++)s.elements[u]=c[u]}else s.identity();e&&s.premultiply(e.cached.transform);const r=new at().copy(s).invert();let a=null,o=null,l=null;if("box"in t.boundingVolume){const c=t.boundingVolume.box;a=new Ne,o=new at,l=new at,Rn.set(c[3],c[4],c[5]),Ln.set(c[6],c[7],c[8]),In.set(c[9],c[10],c[11]);const u=Rn.length(),d=Ln.length(),p=In.length();Rn.normalize(),Ln.normalize(),In.normalize(),u===0&&Rn.crossVectors(Ln,In),d===0&&Ln.crossVectors(Rn,In),p===0&&In.crossVectors(Rn,Ln),o.set(Rn.x,Ln.x,In.x,c[0],Rn.y,Ln.y,In.y,c[1],Rn.z,Ln.z,In.z,c[2],0,0,0,1),o.premultiply(s),l.copy(o).invert(),a.min.set(-u,-d,-p),a.max.set(u,d,p)}let h=null;if("sphere"in t.boundingVolume){const c=t.boundingVolume.sphere;h=new ii,h.center.set(c[0],c[1],c[2]),h.radius=c[3],h.applyMatrix4(s)}else if("box"in t.boundingVolume){const c=t.boundingVolume.box;h=new ii,a.getBoundingSphere(h),h.center.set(c[0],c[1],c[2]),h.applyMatrix4(s)}"region"in t.boundingVolume&&console.warn("ThreeTilesRenderer: region bounding volume not supported."),t.cached={loadIndex:0,transform:s,transformInverse:r,active:!1,inFrustum:[],box:a,boxTransform:o,boxTransformInverse:l,sphere:h,region:null,scene:null,geometry:null,material:null}}parseTile(t,e,i){e._loadIndex=e._loadIndex||0,e._loadIndex++;const s=e.content.uri.split(/[\\\/]/g);s.pop();const r=s.join("/"),a=this.fetchOptions,o=this.manager,l=e._loadIndex;let h=null;switch(i){case"b3dm":{const u=new C_(o);u.workingPath=r,u.fetchOptions=a,h=u.parse(t).then(d=>d.scene);break}case"pnts":{const u=new A_(o);u.workingPath=r,u.fetchOptions=a,h=u.parse(t).then(d=>d.scene);break}case"i3dm":{const u=new L_(o);u.workingPath=r,u.fetchOptions=a,h=u.parse(t).then(d=>d.scene);break}case"cmpt":{const u=new h2(o);u.workingPath=r,u.fetchOptions=a,h=u.parse(t).then(d=>d.scene);break}case"gltf":case"glb":const c=new c2(o);c.workingPath=r,c.fetchOptions=a,h=c.parse(t).then(u=>u.scene);break;default:console.warn(`TilesRenderer: Content type "${i}" not supported.`),h=Promise.resolve(null)}return h.then(c=>{if(e._loadIndex!==l)return;const u=this.rootTileSet.asset&&this.rootTileSet.asset.gltfUpAxis||"y",d=e.cached,p=d.transform;switch(u.toLowerCase()){case"x":ss.makeRotationAxis(p2,-Math.PI/2);break;case"y":ss.makeRotationAxis(d2,Math.PI/2);break;case"z":ss.identity()}c.updateMatrix(),i!=="pnts"&&c.matrix.multiply(ss),c.matrix.premultiply(p),c.matrix.decompose(c.position,c.quaternion,c.scale),c.traverse(_=>{_[z_]=_.frustumCulled}),U_(c,!this.autoDisableRendererCulling),d.scene=c,c.traverse(_=>{_.raycast=this._overridenRaycast});const m=[],f=[],v=[];c.traverse(_=>{if(_.geometry&&f.push(_.geometry),_.material){const y=_.material;m.push(_.material);for(const x in y){const b=y[x];b&&b.isTexture&&v.push(b)}}}),d.materials=m,d.geometry=f,d.textures=v,this.onLoadModel&&this.onLoadModel(c,e)})}disposeTile(t){const e=t.cached;if(e.scene){const i=e.materials,s=e.geometry,r=e.textures;for(let a=0,o=s.length;a<o;a++)s[a].dispose();for(let a=0,o=i.length;a<o;a++)i[a].dispose();for(let a=0,o=r.length;a<o;a++)r[a].dispose();this.onDisposeModel&&this.onDisposeModel(e.scene,t),e.scene=null,e.materials=null,e.textures=null,e.geometry=null}t._loadIndex++}setTileVisible(t,e){const i=t.cached.scene,s=this.visibleTiles,r=this.group;e?(r.add(i),s.add(t),i.updateMatrixWorld(!0)):(r.remove(i),s.delete(t)),this.onTileVisibilityChange&&this.onTileVisibilityChange(i,t,e)}setTileActive(t,e){const i=this.activeTiles;e?i.add(t):i.delete(t)}calculateError(t){const e=t.cached,i=e.inFrustum,s=this.cameras,r=this.cameraInfo,a=t.boundingVolume;if("box"in a||"sphere"in a){const o=e.sphere,l=e.box,h=e.boxTransformInverse,c=e.transformInverse,u=l&&h;let d=-1/0,p=1/0;for(let m=0,f=s.length;m<f;m++){if(!i[m])continue;const v=r[m],_=v.invScale;let y;if(v.isOrthographic){const x=v.pixelSize;y=t.geometricError/(x*_)}else{let x;qi.copy(v.position),u?(qi.applyMatrix4(h),x=l.distanceToPoint(qi)):(qi.applyMatrix4(c),x=Math.max(o.distanceToPoint(qi),0));const b=x*_,w=v.sseDenominator;y=t.geometricError/(b*w),p=Math.min(p,b)}d=Math.max(d,y)}t.__distanceFromCamera=p,t.__error=d}else"region"in a&&console.warn("ThreeTilesRenderer : Region bounds not supported.")}tileInView(t){const e=t.cached,i=e.sphere,s=e.inFrustum;if(i){const r=this.cameraInfo;let a=!1;for(let o=0,l=r.length;o<l;o++)r[o].frustum.intersectsSphere(i)?(a=!0,s[o]=!0):s[o]=!1;return a}return!0}}const Xi=new S,F_=["x","y","z"];class m2 extends vi{constructor(t,e=16776960,i=40){const s=new gt,r=[];for(let a=0;a<3;a++){const o=F_[a],l=F_[(a+1)%3];Xi.set(0,0,0);for(let h=0;h<i;h++){let c;c=2*Math.PI*h/(i-1),Xi[o]=Math.sin(c),Xi[l]=Math.cos(c),r.push(Xi.x,Xi.y,Xi.z),c=2*Math.PI*(h+1)/(i-1),Xi[o]=Math.sin(c),Xi[l]=Math.cos(c),r.push(Xi.x,Xi.y,Xi.z)}}s.setAttribute("position",new Lt(new Float32Array(r),3)),s.computeBoundingSphere(),super(s,new _e({color:e,toneMapped:!1})),this.sphere=t,this.type="SphereHelper"}updateMatrixWorld(t){const e=this.sphere;this.position.copy(e.center),this.scale.setScalar(e.radius),super.updateMatrixWorld(t)}}const Tp=Symbol("ORIGINAL_MATERIAL"),Ep=Symbol("HAS_RANDOM_COLOR"),Cp=Symbol("HAS_RANDOM_NODE_COLOR");function N_(){}class f2 extends Sp{constructor(...t){super(...t);const e=this.group,i=new Me;i.name="DebugTilesRenderer.boxGroup",e.add(i);const s=new Me;s.name="DebugTilesRenderer.sphereGroup",e.add(s),this.displayBoxBounds=!1,this.displaySphereBounds=!1,this.colorMode=0,this.customColorCallback=null,this.boxGroup=i,this.sphereGroup=s,this.maxDebugDepth=-1,this.maxDebugDistance=-1,this.maxDebugError=-1,this.getDebugColor=(r,a)=>{a.setRGB(r,r,r)},this.extremeDebugDepth=-1,this.extremeDebugError=-1}initExtremes(){let t=-1;this.traverse(i=>{t=Math.max(t,i.__depth)});let e=-1;this.traverse(i=>{e=Math.max(e,i.geometricError)}),this.extremeDebugDepth=t,this.extremeDebugError=e}fetchTileSet(...t){const e=super.fetchTileSet(...t);return e.then(()=>{Promise.resolve().then(()=>{this.initExtremes()})}).catch(()=>{}),e}getTileInformationFromActiveObject(t){let e=null;return this.activeTiles.forEach(i=>{if(e)return!0;const s=i.cached.scene;s&&s.traverse(r=>{r===t&&(e=i)})}),e?{distanceToCamera:e.__distanceFromCamera,geometricError:e.geometricError,screenSpaceError:e.__error,depth:e.__depth,isLeaf:e.__isLeaf}:null}update(){if(super.update(),!this.root)return;this.boxGroup.visible=this.displayBoxBounds,this.sphereGroup.visible=this.displaySphereBounds;let t=-1;t=this.maxDebugDepth===-1?this.extremeDebugDepth:this.maxDebugDepth;let e=-1;e=this.maxDebugError===-1?this.extremeDebugError:this.maxDebugError;let i=-1;i=this.maxDebugDistance===-1?this.root.cached.sphere.radius:this.maxDebugDistance;const s=this.errorTarget,r=this.colorMode;this.visibleTiles.forEach(a=>{const o=a.cached.scene;let l,h,c;r===7&&(l=Math.random(),h=.5+.5*Math.random(),c=.375+.25*Math.random()),o.traverse(u=>{r===8&&(l=Math.random(),h=.5+.5*Math.random(),c=.375+.25*Math.random());const d=u.material;if(d){const p=u[Tp];if(r===0&&d!==p)u.material.dispose(),u.material=u[Tp];else if(r!==0&&d===p)if(u.isPoints){const m=new Tr;m.size=p.size,m.sizeAttenuation=p.sizeAttenuation,u.material=m}else u.material=new en,u.material.flatShading=!0;switch(r!==7&&delete u.material[Ep],r!==8&&delete u.material[Cp],r){case 4:{const m=a.__depth/t;this.getDebugColor(m,u.material.color);break}case 5:{const m=a.__depthFromRenderedParent/t;this.getDebugColor(m,u.material.color);break}case 1:{const m=a.__error/s;m>1?u.material.color.setRGB(1,0,0):this.getDebugColor(m,u.material.color);break}case 2:{const m=Math.min(a.geometricError/e,1);this.getDebugColor(m,u.material.color);break}case 3:{const m=Math.min(a.__distanceFromCamera/i,1);this.getDebugColor(m,u.material.color);break}case 6:a.children&&a.children.length!==0?this.getDebugColor(0,u.material.color):this.getDebugColor(1,u.material.color);break;case 8:u.material[Cp]||(u.material.color.setHSL(l,h,c),u.material[Cp]=!0);break;case 7:u.material[Ep]||(u.material.color.setHSL(l,h,c),u.material[Ep]=!0);break;case 9:this.customColorCallback?this.customColorCallback(a,u):console.warn("DebugTilesRenderer: customColorCallback not defined")}}})})}setTileVisible(t,e){super.setTileVisible(t,e);const i=t.cached,s=this.sphereGroup,r=this.boxGroup,a=i.boxHelperGroup,o=i.sphereHelper;e?(a&&(r.add(a),a.updateMatrixWorld(!0)),o&&(s.add(o),o.updateMatrixWorld(!0))):(a&&r.remove(a),o&&s.remove(o))}parseTile(t,e,i){return super.parseTile(t,e,i).then(()=>{const s=e.cached,r=s.scene;if(r){if(s.box&&s.boxTransform){const a=s.box,o=s.boxTransform,l=new Me;l.name="DebugTilesRenderer.boxHelperGroup",l.matrix.copy(o),l.matrixAutoUpdate=!1;const h=new yg(a,function(c){if(!pp[c]){const u=Math.random(),d=.5+.5*Math.random(),p=.375+.25*Math.random();pp[c]=new nt().setHSL(u,d,p)}return pp[c]}(e.__depth));h.raycast=N_,l.add(h),s.boxHelperGroup=l,this.visibleTiles.has(e)&&this.displayBoxBounds&&(this.boxGroup.add(l),l.updateMatrixWorld(!0))}if(s.sphere){const a=s.sphere,o=new m2(a);o.raycast=N_,s.sphereHelper=o,this.visibleTiles.has(e)&&this.displaySphereBounds&&(this.sphereGroup.add(o),o.updateMatrixWorld(!0))}r.traverse(a=>{const o=a.material;o&&(a[Tp]=o)})}})}disposeTile(t){super.disposeTile(t);const e=t.cached;e.boxHelperGroup&&(e.boxHelperGroup.children[0].geometry.dispose(),delete e.boxHelperGroup),e.sphereHelper&&(e.sphereHelper.geometry.dispose(),delete e.sphereHelper)}}class g2{constructor(t){g(this,"_tileMaxLevel",19),g(this,"_subscribedMaxLodLevel",1),g(this,"_elementHandlers",[]),g(this,"_objectParent",null),g(this,"subscribedDataTypeMap",{}),g(this,"_active",!1),g(this,"_configVersion",0),g(this,"shouldIgnoreTile",e=>e.__lodLevel>this._subscribedMaxLodLevel),g(this,"parseElements",e=>{const i=e.cached.scene,s=i.batchTable&&i.batchTable.header;if(!s||!s.id||!s.dataType)return;const r=s.id,a=s.dataType,o={},l=new Map;let h=null,c=null,u=null;for(let d=0,p=a.length;d<p;d++){if(!this.subscribedDataTypeMap[a[d]])continue;h=a[d],c=this.subscribedDataTypeMap[h],u=r[d];const m={id:u,dataType:h,position:[],uv:[],normal:[],index:[]};o[d]=m;const f=l.get(c);f?f.push(m):l.set(c,[m])}for(const d of i.children)this.findElementInMesh(d,o,l);for(const d of l.keys()){const p=l.get(d);d.addTileElementObjects(e,p)}}),g(this,"getInterleavedBufferValue2",(e,i)=>{const s=e.data.array,r=e.data.stride*i+e.offset;return[s[r],s[r+1]]}),g(this,"getInterleavedBufferValue3",(e,i)=>{const s=e.data.array,r=e.data.stride*i+e.offset;return[s[r],s[r+1],s[r+2]]}),g(this,"findElementInMesh",(e,i,s)=>{if(!e||!e.geometry)return;const r=e.geometry.getAttribute("_batchid");if(!r)return;const a=e.geometry.getAttribute("normal");if(!a)return;const o=e.geometry.getAttribute("position"),l=e.geometry.getAttribute("uv"),h=r.data.count,c={};let u=null;for(let p=0;p<h;p++){if(u=r.getX(p),!i[u])continue;let m=i[u],f=this.getInterleavedBufferValue3(o,p),v=this.getInterleavedBufferValue3(a,p),_=this.getInterleavedBufferValue2(l,p);m.position.push(f[0],f[1],f[2]),m.normal.push(v[0],v[1],v[2]),m.uv.push(_[0],_[1]),c[p]={batchId:u,index:m.position.length/3-1}}const d=e.geometry.index.array;for(let p=0,m=d.length-2;p<m;p+=3){let f=d[p];if(c[f]===void 0)continue;let v=d[p+1],_=d[p+2],y=c[f],x=y.batchId,b=y.index,w=c[v]&&c[v].index,M=c[_]&&c[_].index;if(w===void 0||M===void 0){console.warn("one face includes more than one object");continue}i[x].index.push(b,w,M)}for(const p of Object.keys(i)){const m=i[p],f=new gt;f.setAttribute("position",new Lt(new Float32Array(m.position),3)),f.setAttribute("normal",new Lt(new Float32Array(m.normal),3)),f.setAttribute("uv",new Lt(new Float32Array(m.uv),2)),f.setIndex(m.index),m.geometry=f}}),g(this,"onTileLoad",(e,i)=>{this.parseTileInfo(e),this.shouldIgnoreTile(e)}),g(this,"onTileDispose",(e,i)=>{if(!this.shouldIgnoreTile(e))for(const s of this._elementHandlers)s.disposeTileElementObjects(e)}),g(this,"onTileShow",e=>{this._active&&!this.shouldIgnoreTile(e)&&this.refreshTile(e)}),g(this,"onTileHide",e=>{if(this._active&&!this.shouldIgnoreTile(e))for(const i of this._elementHandlers)i.hideTileElementObjects(e)}),g(this,"parseTileInfo",e=>{const i=e.content.uri,s=i.substring(i.lastIndexOf("/")+1).split(".")[0],r=s.split("-");e.__id=s,e.__level=parseInt(r[0],10),e.__lodLevel=this._tileMaxLevel-e.__level}),g(this,"refreshTile",e=>{if(e.__elementsConfigVersion!==this._configVersion){for(const i of this._elementHandlers)i.disposeTileElementObjects(e);this.parseElements(e),e.__elementsConfigVersion=this._configVersion}for(const i of this._elementHandlers)i.showTileElementObjects(e)}),g(this,"refreshTiles",()=>{this.tilesRenderer.forEachLoadedModel((e,i)=>{i.__visible&&!this.shouldIgnoreTile(i)&&this.refreshTile(i)}),this.engine.requestRender()}),this._objectParent=t}registerElement(t){t.parent=this._objectParent,t.engine=this.engine;for(const e of t.subscribedDataTypeIds)this.subscribedDataTypeMap[e]=t;return this._elementHandlers.push(t),this._configVersion++,this._active=!0,this.refreshTiles(),t}unregisterElement(t){for(let i of Object.keys(this.subscribedDataTypeMap))this.subscribedDataTypeMap[i]===t&&delete this.subscribedDataTypeMap[i];let e=this._elementHandlers.indexOf(t);e>-1&&(t.dispose(),this._elementHandlers.splice(e,1)),this._configVersion++,this._active=this._elementHandlers.length>0,this.refreshTiles()}tick(t){if(this._active)for(const e of this._elementHandlers)e.tick(t)}get subscribedMaxLodLevel(){return this._subscribedMaxLodLevel}set subscribedMaxLodLevel(t){this._subscribedMaxLodLevel=t}}class ec extends Mt{constructor(t){if(super(),g(this,"isEventEntitySupported",!0),g(this,"_expandStepSize",100),g(this,"_meshes",[]),g(this,"_attributes",[]),g(this,"_idIndexMap",{}),g(this,"_indexIdMap",{}),g(this,"_instanceMatrixArray",new Float32Array(1600)),g(this,"_instanceMatrixArraySize",100),g(this,"_currentCount",0),g(this,"_rtc",null),g(this,"updateRenderingMesh",()=>{const e=this._meshes,i=e.length,s=this.children;for(let r=0;r<i;++r){const a=e[r],o=new Fl(a.geometry,a.material);o.__eventProxyByParent=!0,o.castShadow=a.castShadow,o.receiveShadow=a.receiveShadow,o.parent=this,s[r]=o}if(s.length>i)for(let r=s.length-1;r>=i;--r)this.remove(this.children[r])}),g(this,"expandInstanceArray",e=>{const i=this._instanceMatrixArraySize+this._expandStepSize*Math.ceil(e/this._expandStepSize),s=new Float32Array(16*i);s.set(this._instanceMatrixArray),this._instanceMatrixArray=s,this._instanceMatrixArraySize=i}),g(this,"copyArrayData",(e,i,s,r,a)=>{for(let o=0;o<a;o++)e[i+o]=s[r+o]}),t)this.meshes=t;else{const e=new ot(new Wt(1,1,1),new Zt({color:16777215}));this._meshes=[e]}this.updateRenderingMesh()}getEntityByIndex(t){const e=this._indexIdMap[t];if(e===void 0)return null;const i={id:e};return i.matrix=this._instanceMatrixArray.slice(16*t,16*(t+1)),i}has(t){return this._idIndexMap[t]!==void 0}clear(){this._idIndexMap={},this._indexIdMap={},this._instanceMatrixArray=new Float32Array(1600),this._instanceMatrixArraySize=100,this._currentCount=0,this._rtc=null}setBufferData(t){this.clear(),this.addInstances(t)}addInstances(t){if(!t)return;const e=t.id,i=e.length;if(i!==0)if(this._currentCount+i>this._instanceMatrixArraySize&&this.expandInstanceArray(i),t.instanceMatrix)this._instanceMatrixArray.set(t.instanceMatrix,16*this._currentCount),this._currentCount+=i;else{const s=t.translation,r=t.scale,a=t.rotation,o=this._instanceMatrixArray;let l=new at,h=new S,c=new S,u=new yn,d=new Ft,p=null,m=null,f=this._rtc;f||(s?(f=[s[0],s[1],s[2]],this._rtc=f,this.position.set(f[0],f[1],f[2])):f=[0,0,0]);for(let v=0;v<i;v++){let _=3*v;r?c.set(r[_],r[_+1],r[_+2]):c.set(1,1,1),s?h.set(s[_]-f[0],s[_+1]-f[1],s[_+2]-f[2]):h.set(0,0,0),a?u.set(a[_],a[_+1],a[_+2],"XYZ"):u.set(0,0,0,"XYZ"),d.setFromEuler(u),l.compose(h,d,c),_=16*(this._currentCount+v);const y=l.elements;for(let x=0;x<16;x++)o[_+x]=y[x];p=e[v],m=this._currentCount+v,this._idIndexMap[p]=m,this._indexIdMap[m]=p}this._currentCount+=i}}removeInstance(t){this.removeInstances({id:[t]})}removeInstances(t){const e=t.id,i=e.length;if(i!==0)for(let s=0;s<i;++s){const r=e[s],a=this._idIndexMap[r];if(a===void 0){console.warn(`remove an item ${r} not exist`);continue}const o=this._currentCount-1;if(!(a>o)){if(a<o){this.copyArrayData(this._instanceMatrixArray,16*a,this._instanceMatrixArray,16*o,16);const l=this._indexIdMap[o];this._indexIdMap[a]=l,this._idIndexMap[l]=a,delete this._idIndexMap[r]}this._currentCount--}}}update(){const t=this.children;for(const e of t)e.instanceMatrix=new Di(this._instanceMatrixArray,16),e.count=this._currentCount}set meshes(t){t&&(Array.isArray(t)?this._meshes=t:t.isMesh?this._meshes=[t]:t.isGroup&&(this._meshes=t.children),this.updateRenderingMesh(),this.update())}set needsUpdate(t){t&&this.update()}get meshes(){return this._meshes}}class k_ extends Mt{constructor(t){super(),g(this,"_lodMeshes",[]),g(this,"_lodChildren",{}),this._lodMeshes=t||[]}addInstances(t,e=0){let i=this._lodChildren[e];if(!i){let s=this._lodMeshes[e];s||(s=this._lodMeshes[this._lodMeshes.length-1]),i=new ec(s),this._lodChildren[e]=i,this.add(i)}i&&i.addInstances(t)}removeInstances(t,e=0){const i=this._lodChildren[e];i&&i.removeInstances(t)}setMeshesAt(t,e=0){this._lodMeshes[e]=t;const i=this._lodChildren;i[e]&&(i[e].meshes=t)}setLODMeshes(t){for(let e=0;e<t.length;e++){const i=t[e];this.setMeshesAt(i,e)}}set needsUpdate(t){if(t){const e=this.children;for(const i of e)i&&(i.needsUpdate=!0)}}}const v2={pars:"",main_before:"",main_after:"",project_after:"",worldpos_after:""},_2={pars:"",main_before:"",color_after:"",custom_map:""};class ic extends Qt{constructor(t){super(),g(this,"getShaderSource",(a,o,l,h)=>{const c=Object.assign({},o,l);for(const u of Object.keys(c)){const d=c[u];a=a.replace("#chunk <"+h+"_"+u+">",d)}return a}),g(this,"setCommonUniforms",a=>{for(const o of Object.keys(a))this.uniforms[o]=a[o]}),this.lights=!0,this.fog=!0,this.type="ExtendMeshStandardMaterial",this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.defineMaterialNormalProperties=Jt,this.defineMaterialAliasProperties=rn,Jt(this,["roughness","metalness","map","lightMap","aoMap","emissive","emissiveMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","alphaMap","envMap"]),rn(this,[["color","diffuse"]]),this.uniforms=ft.clone(ft.merge([ai.standard.uniforms,t.uniforms])),this.color=new nt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new V(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1;const{vertexShaderChunks:e,fragmentShaderChunks:i,uniforms:s,...r}=t;this.setValues(r),this.vertexShaderChunks=e,this.fragmentShaderChunks=i}set vertexShaderChunks(t){this.vertexShader=this.getShaderSource(`#define GLSLIFY 1
#define STANDARD

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

	varying vec3 vWorldPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#chunk <vertex_pars>

void main() {

    #chunk <vertex_main_before>

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#chunk <vertex_project_after>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#chunk <vertex_worldpos_after>
	#include <shadowmap_vertex>
	#include <fog_vertex>

#ifdef USE_TRANSMISSION

	vWorldPosition = worldPosition.xyz;

#endif
    #chunk <vertex_main_after>
}`,v2,t,"vertex"),this.needsUpdate=!0}set fragmentShaderChunks(t){this.fragmentShader=this.getShaderSource(`#define GLSLIFY 1
#define STANDARD

#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
	uniform float ior;
#endif

#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;

	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif

	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif

#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;

	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif

	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif

varying vec3 vViewPosition;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

#chunk <fragment_pars>

void main() {

	#ifdef USE_MAP
    	vec2 uv = vec2(vUv);
	#endif
    #chunk <fragment_main_before>
	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#ifdef USE_MAP

		#ifdef USE_CUSTOM_MAP
			 #chunk <fragment_custom_map>
		#else
			vec4 sampledDiffuseColor = texture2D( map, uv );
		#endif

        #ifdef DECODE_VIDEO_TEXTURE

            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)

            sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );

        #endif

        diffuseColor *= sampledDiffuseColor;

    #endif
	#include <color_fragment>
    #chunk <fragment_color_after>
	#ifdef USE_ALPHAMAP

        diffuseColor.a *= texture2D( alphaMap, uv ).g;

    #endif
	#include <alphatest_fragment>
	float roughnessFactor = roughness;

    #ifdef USE_ROUGHNESSMAP

        vec4 texelRoughness = texture2D( roughnessMap, uv );

        // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
        roughnessFactor *= texelRoughness.g;

    #endif
	float metalnessFactor = metalness;

    #ifdef USE_METALNESSMAP

        vec4 texelMetalness = texture2D( metalnessMap, uv );

        // reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
        metalnessFactor *= texelMetalness.b;

    #endif
	#include <normal_fragment_begin>
	#ifdef OBJECTSPACE_NORMALMAP

	normal = texture2D( normalMap, uv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	normal = normalize( normalMatrix * normal );

    #elif defined( TANGENTSPACE_NORMALMAP )

        vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;
        mapN.xy *= normalScale;

        #ifdef USE_TANGENT

            normal = normalize( vTBN * mapN );

        #else

            normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );

        #endif

    #elif defined( USE_BUMPMAP )

        normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );

    #endif
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#ifdef USE_EMISSIVEMAP

        vec4 emissiveColor = texture2D( emissiveMap, uv );

        totalEmissiveRadiance *= emissiveColor.rgb;

    #endif

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

	#include <transmission_fragment>

	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

	#ifdef USE_SHEEN

		// Sheen energy compensation approximation calculation can be found at the end of
		// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;

	#endif

	#ifdef USE_CLEARCOAT

		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;

	#endif

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}`,_2,t,"fragment"),this.needsUpdate=!0}dispose(){let t=["map","lightMap","aoMap","emissiveMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","alphaMap","envMap","specularIntensityMap","specularColorMap","sheenColorMap","sheenRoughnessMap"];for(let e=0;e<t.length;e++){const i=t[e];this[i]&&this[i].dispose()}super.dispose()}}const y2={pars:`
        uniform float elapsedTime;
        uniform vec3 windDirection;
        uniform float windStrength;
    `,main_after:`
        
    `,project_after:`
    vec4 modelPosition = vec4( transformed, 1.0 );
    #ifdef USE_INSTANCING
        modelPosition = instanceMatrix * modelPosition;
    #endif
    modelPosition = modelMatrix * modelPosition;

    float dirDot = abs(dot(windDirection, normal));
    float period = 1500.0 * dirDot + 500.0;
    period = sin(mod(elapsedTime, period) / period * PI * 2.0);
    period = (period + 1.0) / 2.0;
    vec3 worldPositionOffset = windDirection * windStrength * period * dirDot;
    modelPosition.xyz += worldPositionOffset;

    mvPosition = viewMatrix * modelPosition;
    gl_Position = projectionMatrix * mvPosition;
    `,worldpos_after:`
    #if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
        worldPosition.xyz += worldPositionOffset;
    #endif
    `},x2={pars:`
    `,main_before:`
    `,color_after:`
    `};class nc extends ic{constructor(t={}){super({uniforms:{windDirection:{value:[1,0,0]},windStrength:{value:.5}}}),this.vertexShaderChunks=y2,this.fragmentShaderChunks=x2,this.setValues(t)}get windDirection(){return this.uniforms.windDirection.value}set windDirection(t){this.uniforms.windDirection.value=t}get windStrength(){return this.uniforms.windStrength.value}set windStrength(t){this.uniforms.windStrength.value=t}static fromMaterial(t,e){const i=new nc(e);return i.map=t.map,i.alphaTest=t.alphaTest,i.metalness=t.metalness,i.roughness=t.roughness,i.side=t.side,i.vertexColors=t.vertexColors,i}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}const B_=n=>{if(n.isMesh)n.geometry.applyMatrix4(n.matrixWorld);else if(n.children.length>0)for(const t of n.children)B_(t);n.position.set(0,0,0),n.scale.set(1,1,1),n.quaternion.set(0,0,0,1)},V_=(n,t)=>{if(n.isMesh)t.push(n);else if(n.children.length>0)for(const e of n.children)V_(e,t)},Oo=(n,t,e)=>{t&&(s=>{const r=new Ne;r.setFromObject(s);const a=Math.max(r.max.x-r.min.x,r.max.y-r.min.y,r.max.z-r.min.z);s.scale.multiplyScalar(1/a)})(n),e&&(n.rotation.x=Math.PI/2),n.updateMatrixWorld(),B_(n),n.updateMatrixWorld();const i=[];return V_(n,i),i},G_=(n,t,e)=>{const i=[];for(const s of n){const r=s.name;if(!r.startsWith("lod"))continue;const a=parseInt(r.substring(3),10);if(isNaN(a))continue;const o=Oo(s,t,e);i[a]=o}return i},b2=Object.freeze(Object.defineProperty({__proto__:null,parseLODModel:G_,parseScene:Oo},Symbol.toStringTag,{value:"Module"})),M2=new Bs;class w2{constructor(){g(this,"_lastUpdateTime",0),g(this,"_updateDelayTimerHander",null),g(this,"_configVersion",0),g(this,"_treeEnabled",!0),g(this,"_labelEnabled",!1),g(this,"_idEnabled",!1),g(this,"_dataTypeEnabled",!1),g(this,"markNeedsUpdate",()=>{this._updateDelayTimerHander||(this._updateDelayTimerHander=setTimeout(()=>{this._tree.needsUpdate=!0,this.engine.requestRender(),this._updateDelayTimerHander=null},100))}),g(this,"parseInstancedData",(e,i)=>{const s=e.geometry,r=i.__id,a=s.attributes.position,o=a.count;if(o===0)return;const l=[];i.__lodLevel;const h=s.attributes.scale,c=s.attributes.rotation,u=new Float32Array(3*o),d=new Float32Array(3*o),p=new Float32Array(3*o),m=i.cached.scene.matrix,f=new S;for(let _=0;_<o;_++)f.set(a.getX(_),a.getY(_),a.getZ(_)),f.applyMatrix4(m),u[3*_]=f.x,u[3*_+1]=f.y,u[3*_+2]=f.z,d[3*_]=h.getX(_),d[3*_+1]=h.getY(_),d[3*_+2]=h.getZ(_),p[3*_]=c.getX(_),p[3*_+1]=c.getY(_),p[3*_+2]=c.getZ(_),l.push(r+"-"+_);const v={translation:u,scale:d,rotation:p,id:l};i.__instanceData=v}),g(this,"parseLabelData",(e,i)=>{const s=e.geometry,r=i.__id,a=s.attributes.position,o=a.count;if(o===0)return;const l=s.attributes.rotation,h=i.cached.scene,c=h.matrix,u=h.batchTable.header.text,d=[],p=new S;for(let m=0;m<o;m++)p.set(a.getX(m),a.getY(m),a.getZ(m)),p.applyMatrix4(c),d.push(new vo([p.x,p.y,p.z],{id:r+"-"+m,text:u[m],rotateZ:l.getZ(m)}));i.__labelData=d}),g(this,"remapBatchValueToNumber",e=>e?isFinite(e)?e=Math.round(e%100):typeof e=="string"?(e=e.charCodeAt(3)||0)%100:0:0),g(this,"parseBatchTableAttribute",(e,i,s)=>{const r=e.cached.scene,a=r.children,o=r.batchTable&&r.batchTable.header;if(!o)return;const l=o[i];if(l)for(const h of a){if(h.originalMaterialName==="_tree"||h.originalMaterialName==="_label")continue;const c=h.geometry,u=c.getAttribute("_batchid");if(!u)continue;const d=u.data.count;let p=-1,m=0;const f=[];for(let v=0;v<d;v++)p=u.getX(v),m=this.remapBatchValueToNumber(l[p]),f.push(m);c.attributes[s]=new Lt(new Float32Array(f),1)}}),g(this,"onTileLoad",(e,i)=>{}),g(this,"onTileDispose",(e,i)=>{}),g(this,"onTileShow",e=>{this.refreshTile(e)}),g(this,"onTileHide",e=>{const i=e.__instanceData;e.__hasAddInstancedData&&i&&(this._tree.removeInstances(i,e.__lodLevel),e.__hasAddInstancedData=!1,this.markNeedsUpdate());const s=e.__labelData;e.__hasAddLabelData&&s&&(this.engine.rendering.label.removeLabels(s),e.__hasAddLabelData=!1)}),g(this,"refreshTile",e=>{const i=e.cached.scene.children;if(e.__instanceConfigVersion!==this._configVersion){for(const a of i)a.originalMaterialName==="_tree"?(a.visible=!1,this._treeEnabled&&!e.__instanceTreeParsed&&(this.parseInstancedData(a,e),e.__instanceTreeParsed=!0)):a.originalMaterialName==="_label"&&(a.visible=!1,this._labelEnabled&&!e.__instanceLabelParsed&&(this.parseLabelData(a,e),e.__instanceLabelParsed=!0));this._idEnabled&&!e.__instanceIdParsed&&(this.parseBatchTableAttribute(e,"id","_id"),e.__instanceIdParsed=!0),this._dataTypeEnabled&&!e.__instanceDataTypeParsed&&(this.parseBatchTableAttribute(e,"dataType","_dataType"),e.__instanceDataTypeParsed=!0),e.__instanceConfigVersion=this._configVersion}const s=e.__instanceData;s&&(this._treeEnabled&&!e.__hasAddInstancedData&&(this._tree.addInstances(s,e.__lodLevel),this.markNeedsUpdate(),e.__hasAddInstancedData=!0),!this._treeEnabled&&e.__hasAddInstancedData&&(this._tree.removeInstances(s,e.__lodLevel),this.markNeedsUpdate(),e.__hasAddInstancedData=!1));const r=e.__labelData;r&&(this._labelEnabled&&!e.__hasAddLabelData&&(this.engine.rendering.label.addLabels(r,e.__lodLevel),e.__hasAddLabelData=!0),!this._labelEnabled&&e.__hasAddLabelData&&(this.engine.rendering.label.removeLabels(r,e.__lodLevel),e.__hasAddLabelData=!1))}),g(this,"refreshTiles",()=>{this.tilesRenderer.forEachLoadedModel((e,i)=>{i.__visible&&this.refreshTile(i)}),this.engine.requestRender()}),g(this,"updateTreeModelPath",e=>{M2.load(e,i=>{const s=G_(i.scenes,!0,!0);for(const r of s)for(const a of r){if(a.material.name==="__foliage_leaf"){const o=nc.fromMaterial(a.material);o.setCommonUniforms(this.engine.rendering.uniforms),a.material=o}a.castShadow=!0,a.receiveShadow=!0}this._tree.setLODMeshes(s)})}),this.group=new Me;const t=this._tree=new k_;this.updateTreeModelPath(me("assets/models/tree/tree18.glb")),this.group.add(t)}set treeModelPath(t){this.updateTreeModelPath(t)}set treeEnabled(t){this._treeEnabled=t,this._configVersion++,this.refreshTiles()}get treeEnabled(){return this._treeEnabled}set labelEnabled(t){this._labelEnabled=t,this._configVersion++,this.refreshTiles()}get labelEnabled(){return this._labelEnabled}set idEnabled(t){this._idEnabled=t,this._configVersion++,this.refreshTiles()}get idEnabled(){return this._idEnabled}set dataTypeEnabled(t){this._dataTypeEnabled=t,this._configVersion++,this.refreshTiles()}get dataTypeEnabled(){return this._dataTypeEnabled}}class S2{constructor(){g(this,"_enabled",!1),g(this,"_configVersion",0),g(this,"_hiddenIds",new Set),g(this,"_needsRefreshAll",!1),g(this,"updateEditableAttribute",t=>{const e=t.cached.scene,i=e.children,s=e.batchTable&&e.batchTable.header;if(!s)return;const r=s.id;if(!r)return;const a=this._hiddenIds;for(const o of i){const l=o.geometry,h=l.getAttribute("_batchid");if(!h)continue;const c=h.data.count;let u=-1,d=0;const p=[];for(let m=0;m<c;m++)u=h.getX(m),d=r[u]+"",a.has(d)?p.push(1):p.push(0);l.attributes._tileEditableValue=new Lt(new Float32Array(p),1)}}),g(this,"onTileLoad",(t,e)=>{}),g(this,"onTileDispose",(t,e)=>{}),g(this,"onTileShow",t=>{this.refreshTile(t)}),g(this,"onTileHide",t=>{}),g(this,"refreshTile",t=>{t.cached.scene.children,t.__editableConfigVersion!==this._configVersion&&(this.updateEditableAttribute(t),t.__editableConfigVersion=this._configVersion)}),g(this,"refreshTiles",()=>{this._enabled&&this._needsRefreshAll&&this.tilesRenderer.forEachLoadedModel((t,e)=>{e.__visible&&this.refreshTile(e)})})}addHiddenId(t){this._enabled?(t+="",this._hiddenIds.add(t),this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()):console.warn("edit mode is not enabled")}removeHiddenId(t){this._enabled?(t+="",this._hiddenIds.delete(t),this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()):console.warn("edit mode is not enabled")}set enabled(t){this._enabled=t,this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()}get enabled(){return this._enabled}}class j_{constructor(t){g(this,"_parent",null),g(this,"_material",null),g(this,"subscribedDataTypeIds",[]),g(this,"_positionScaleFactor",1.3),g(this,"_tileObjectMap",new Map),g(this,"_idObjectMap",new Map),g(this,"_objectDataMap",new Map),g(this,"_visibleIdMap",new Map),g(this,"_scaleSize",.05),g(this,"_tickInterval",500),g(this,"_lastTickTime",0),this._parent=t}set parent(t){this._parent=t}createMeshFromGeometry(t){return this._material||(this._material=new Zt({color:16777130}),this._material.emissive=new nt(16777130)),new ot(t,this._material)}addTileElementObjects(t,e){const i=t.cached.scene,s=[];for(const r of e){const a=this.createMeshFromGeometry(r.geometry,r);a.userData.id=r.id;const o=r.geometry.getAttribute("position").array,l=r.geometry.getAttribute("normal").array;for(let h=0,c=o.length-2;h<c;h+=3)o[h]=o[h]+this._scaleSize*l[h],o[h+1]=o[h+1]+this._scaleSize*l[h+1],o[h+2]=o[h+2]+this._scaleSize*l[h+2];a.position.copy(i.position),a.rotation.copy(i.rotation),a.scale.copy(i.scale),a.__tile=t,s.push(a),this._objectDataMap.set(a,r)}this._tileObjectMap.set(t,s)}onEntityShow(t,e){}showTileElementObjects(t){const e=this._tileObjectMap.get(t);if(e)for(const i of e){const s=i.userData.id;this._visibleIdMap.set(s,i),this.onEntityShow(s,i),this._parent.add(i)}}hideTileElementObjects(t){const e=this._tileObjectMap.get(t);if(e)for(const i of e){const s=i.userData.id;this._visibleIdMap.get(s)===i&&this._visibleIdMap.delete(s),this._parent.remove(i)}}disposeTileElementObjects(t){const e=this._tileObjectMap.get(t);if(e){for(const i of e)i.parent&&i.parent.remove(i),this._objectDataMap.delete(i),i.geometry.dispose();this._tileObjectMap.delete(t)}}doTick(t){for(const e of this._visibleIdMap.keys()){const i=this._visibleIdMap.get(e);this.tickObject(i,t)}}tickObject(t,e){}tick(t){this._tickInterval<=0||t-this._lastTickTime>this._tickInterval&&(this._lastTickTime=t,this.doTick(t))}dispose(){this._material&&this._material.dispose(),this._tileObjectMap.forEach((t,e)=>{for(const i of t)this._parent.remove(i)})}}class T2 extends Mt{constructor(t){super(),this.geometry=t;const e=this.material=new Zt({color:16777130});e.emissive=new nt(16777130);const i=this.mesh=new ot(t,e);this.add(i)}set color(t){t.isColor||(t=new nt(t)),this.material.color=t,this.material.emissive=t}get color(){return this.material.color}}const H_=new Te,sc=H_.load(me("assets/textures/element/traffic_light_mask.jpg"));sc.flipY=!1,sc.magFilter=sc.minFilter=1003;const rc=H_.load(me("assets/textures/element/traffic_light_number_mask.jpg"));rc.flipY=!1,rc.magFilter=rc.minFilter=1003;const E2=ft.merge([rt.fog.uniforms,fo,{spriteCount:{value:16},slotCount:{value:3},slotSpriteOffset0:{value:0},slotSpriteOffset1:{value:0},slotSpriteOffset2:{value:0},slotSpriteOffset3:{value:0},slotState0:{value:0},slotState1:{value:0},slotState2:{value:0},slotState3:{value:0},maskMap:{value:null},numberMaskMap:{value:null},number:0,redColor:{value:[1,.1,.1]},greenColor:{value:[.1,1,.1]},yellowColor:{value:[1,.6,.1]}}]);class C2 extends Fe{constructor(t={}){super(),this.type="TrafficLightMaterial",this.vertexShader=`#define GLSLIFY 1
#include <common>

#include <logdepthbuf_pars_vertex>

varying vec2 vUv;
void main() { 
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

#include <logdepthbuf_pars_fragment>
uniform sampler2D maskMap;
uniform sampler2D numberMaskMap;
uniform float spriteCount;

// 最多4个槽位，
uniform float slotCount;
// 每个槽位图标的偏移位置， -1代表当前槽位是倒数读秒数
uniform float slotSpriteOffset0;
uniform float slotSpriteOffset1;
uniform float slotSpriteOffset2;
uniform float slotSpriteOffset3;

// 每个slot的状态，0，1，2，3 分别代表关、红、黄、绿，后续考虑合并到一个变量中
uniform float slotState0;
uniform float slotState1;
uniform float slotState2;
uniform float slotState3;

uniform float number;
varying vec2 vUv;

uniform vec3 redColor;
uniform vec3 greenColor;
uniform vec3 yellowColor;

//#include <mvt_mrt_output_pars_fragment>

void main() {

    // 当前像素落在哪个槽位
    float slotIndex = floor(vUv.y * slotCount);
    float currentSlotState = 0.0;
    float spriteIndex = 0.0;
    if (slotIndex == 0.0) {
        currentSlotState = slotState0;
        spriteIndex = slotSpriteOffset0;
    }
    else if (slotIndex == 1.0) {
        currentSlotState = slotState1;
        spriteIndex = slotSpriteOffset1;
    }
    else if (slotIndex == 2.0) {
        currentSlotState = slotState2;
        spriteIndex = slotSpriteOffset2;
    }
    else if (slotIndex == 3.0) {
        currentSlotState = slotState3;
        spriteIndex = slotSpriteOffset3;
    }
    if (currentSlotState == 0.0) {
        discard;
    }
    vec3 outColor;
    if (currentSlotState == 1.0) {
        outColor = redColor;
    }
    else if (currentSlotState == 2.0) {
        outColor = yellowColor;
    }
    else if (currentSlotState == 3.0) {
        outColor = greenColor;
    }
    //float slotRatio = 1.0 / spriteCount;
    // 将高亮区域的v缩放到0-1
    float v = (vUv.y - float(slotIndex) / slotCount) * slotCount;
    // v = v * 0.98 + 0.01;

    float u = 0.0;
    float spriteUnit = 1.0 / spriteCount;

    // 数字
    if (spriteIndex == -1.0) {
        // gl_FragColor = vec4(1.0, 0, 0, 1.0);
        float i1 = floor((number + 0.001) / 10.0);
        float i2 = floor(mod(number, 10.0));
        if (vUv.x < 0.5) {
            u = mix(i1 * 0.1, i1 * 0.1 + 0.1, vUv.x * 2.0);
        }
        else {
            u = mix(i2 * 0.1, i2 * 0.1 + 0.1, (vUv.x - 0.5) * 2.0);
        }
        float r = texture2D(numberMaskMap, vec2(u, v)).r;
        if (r < 0.05) {
            discard;
        }
    }
    else {
        u = mix(spriteIndex * spriteUnit, (spriteIndex + 1.0) * spriteUnit, vUv.x);
        float r = texture2D(maskMap, vec2(u, v)).r;
        if (r < 0.05) {
            discard;
        }
    }
    
    // gl_FragColor = vec4(texture2D(maskMap, vec2(u, v)).xyz, 1.0);
    gl_FragColor = vec4(outColor, 1.0);
    #include <logdepthbuf_fragment> 
	//#include <mvt_mrt_output_fragment>
}`,this.isTrafficLightMaterial=!0,this.transparent=!0,Object.assign(this.uniforms,ft.clone(E2)),Jt(this,["slotState0","slotState1","slotState2","slotState3","number","redColor","greenColor","yellowColor"]),go(this),Object.defineProperties(this,{slotConfig:{get:function(){return this._slotConfig},set:function(e){this._slotConfig=e,this.uniforms.slotCount.value=e.length,this.uniforms.slotSpriteOffset0.value=e[0],this.uniforms.slotSpriteOffset1.value=e[1]||0,this.uniforms.slotSpriteOffset2.value=e[2]||0,this.uniforms.slotSpriteOffset3.value=e[3]||0}}}),this.uniforms.maskMap.value=sc,this.uniforms.numberMaskMap.value=rc,this.emissiveEnabled=!0,this.emissiveIntensity=.8,this.setValues(t)}dispose(){this.uniforms.maskMap&&this.uniforms.maskMap.value&&this.uniforms.maskMap.value.dispose(),this.uniforms.numberMaskMap&&this.uniforms.numberMaskMap.value&&this.uniforms.numberMaskMap.value.dispose(),super.dispose()}}class W_ extends Mt{constructor(t){super(),g(this,"isMesh",!0),g(this,"_slots",[]),g(this,"_slotCount",3),g(this,"_numberSlot",-1),g(this,"_timeTable",null),g(this,"_channelCount",3),this.geometry=t,this.material=new C2,this.number=0}set slots(t){this._slots=t,this._slotCount=t.length;let e=-1,i=0;for(let s=0,r=t.length;s<r;s++)t[s]===-1?e=s:i++;this._numberSlot=e,this._channelCount=i,this.material.slotConfig=t}get slots(){return this._slots}get slotCount(){return this._slotCount}get numberSlot(){return this._numberSlot}get number(){return this._number}set number(t){this._number=t,this.material.number=t}set timeTable(t){this._number=0,this._lightState=0,this._timeTable=t}get timeTable(){return this.timeTable}set lightState(t){this._lightState=t}get lightState(){return this._lightState}updateState(t){if(this._timeTable){const e=this._timeTable,i=(t/1e3-e.startTime)%e.period;for(let s=e.states.length-1,r=s;r>=0;--r)if(e.states[r][0]<=i){this._lightState=e.states[r][1],this._number=(r===s?e.period:e.states[r+1][0])-i+1;break}this._active=!0,this.updateMaterial()}else this._lightState!==void 0&&this._lightState!==null?(this._active=!0,this.updateMaterial()):this._active&&(this.updateMaterial(),this._active=!1)}updateMaterial(){const t=this.material;this._channelCount===3?(t.slotState0=this._lightState===1?1:0,t.slotState1=this._lightState===2?2:0,t.slotState2=this._lightState===3?3:0,this._numberSlot!==-1&&(t.number=this._number,t.slotState3=this._lightState)):this._channelCount===2?(t.slotState0=this._lightState===1?1:0,t.slotState1=this._lightState===3?3:0,this._numberSlot!==-1&&(t.number=this._number,t.slotState2=this._lightState)):this._channelCount===1?(t.slotState0=this._lightState,this._numberSlot!==-1&&(t.number=this._number,t.slotState1=this._lightState)):this._channelCount===0?this._numberSlot!==-1&&(t.number=this._number,t.slotState0=this._lightState):console.warn("invalid channel count:",this._channelCount)}}const q_=new W_,ci={},Ap={up:{south:"east",north:"west",west:"south",east:"north"},down:{south:"west",north:"east",west:"north",east:"south"},south:{up:"west",down:"east",west:"down",east:"up"},north:{up:"east",down:"west",west:"up",east:"down"},west:{up:"north",down:"south",north:"down",south:"up"},east:{up:"south",down:"north",north:"up",south:"down"}};let pa={north:[-1,0,0],east:[0,1,0],up:[0,0,1],south:[1,0,0],west:[0,-1,0],down:[0,0,-1]},Pp={},Qe={east:new S,north:new S,up:new S,west:new S,south:new S,down:new S},Ws=new S,qs=new S,Xs=new S;const ac=n=>n!==void 0,A2=new S,P2=new S(1/40680631590769,1/40680631590769,1/40408299984661445e-3),rs=new S,oc=new S,X_=function(n,t,e=0,i){const s=new S(40680631590769,40680631590769,40408299984661445e-3),r=Math.cos(t);rs.x=r*Math.cos(n),rs.y=r*Math.sin(n),rs.z=Math.sin(t),rs.normalize(),oc.multiplyVectors(s,rs);const a=Math.sqrt(rs.dot(oc));return oc.divideScalar(a),rs.multiplyScalar(e),ac(i)||(i=new S),i.addVectors(oc,rs)};ci.lnglatToEcef=(n,t,e=0,i)=>X_(n*Math.PI/180,t*Math.PI/180,e,i),ci.radianToEcef=X_,ci.localFrameToFixedFrameGenerator=function(n,t){if(!Ap.hasOwnProperty(n)||!Ap[n].hasOwnProperty(t))throw new Error("firstAxis and secondAxis must be east, north, up, west, south or down.");let e,i=Ap[n][t],s=n+t;return ac(Pp[s])?e=Pp[s]:(e=function(r,a){if(!ac(r))throw new Error("origin is required.");if(ac(a)||(a=new at),r.equals(A2))Ws.fromArray(pa[n]),qs.fromArray(pa[t]),Xs.fromArray(pa[i]);else if(Math.abs(r.x)<1e-14&&Math.abs(r.y)<1e-14){let h=(o=+(o=r.z))==0?o:o>0?1:-1;Ws.fromArray(pa[n]),n!=="east"&&n!=="west"&&Ws.multiplyScalar(h),qs.fromArray(pa[t]),t!=="east"&&t!=="west"&&qs.multiplyScalar(h),Xs.fromArray(pa[i]),i!=="east"&&i!=="west"&&Xs.multiplyScalar(h)}else{((u,d)=>{d.multiplyVectors(u,P2).normalize()})(r,Qe.up);let h=Qe.up,c=Qe.east;c.x=-r.y,c.y=r.x,c.z=0,Qe.east.copy(c).normalize(),Qe.north.crossVectors(h,c),Qe.down.copy(Qe.up).multiplyScalar(-1),Qe.west.copy(Qe.east).multiplyScalar(-1),Qe.south.copy(Qe.north).multiplyScalar(-1),Ws=Qe[n],qs=Qe[t],Xs=Qe[i]}var o;const l=a.elements;return l[0]=Ws.x,l[1]=Ws.y,l[2]=Ws.z,l[3]=0,l[4]=qs.x,l[5]=qs.y,l[6]=qs.z,l[7]=0,l[8]=Xs.x,l[9]=Xs.y,l[10]=Xs.z,l[11]=0,l[12]=r.x,l[13]=r.y,l[14]=r.z,l[15]=1,a},Pp[s]=e),e},ci.eastNorthUpToFixedFrame=ci.localFrameToFixedFrameGenerator("east","north"),ci.northEastDownToFixedFrame=ci.localFrameToFixedFrameGenerator("north","east"),ci.northUpEastToFixedFrame=ci.localFrameToFixedFrameGenerator("north","up"),ci.northWestUpToFixedFrame=ci.localFrameToFixedFrameGenerator("north","west"),Sp.prototype.setTileVisible=function(n,t){const e=n.cached.scene,i=this.visibleTiles,s=this.group;t?(s.add(e),i.add(n),e.updateMatrixWorld(!0)):(s.remove(e),i.delete(n)),this.onTileVisibleChanged&&this.onTileVisibleChanged(n,t)};class Y_ extends Mt{constructor(t){super(),g(this,"options",null),g(this,"_tilesRenderer",null),g(this,"_elementsManager",null),g(this,"_elementsGroup",null),g(this,"_editableElementManager",null),g(this,"engine",null),g(this,"_tileMaxLevel",19),g(this,"is3DTiles",!0),g(this,"_materialManager",null),g(this,"_debugTilesRenderer",null),g(this,"_freezeUpdate",!1),g(this,"_excludeCastShadowMaterials",{road:!0,green:!0,isolation:!0}),g(this,"_instancedElementManager",null),g(this,"_identityType",1),g(this,"_visibile",!0),g(this,"_loaders",[]),g(this,"handleBeforeRender",(r,a)=>{this._debugTilesRenderer||(!this._freezeUpdate&&this._visibile&&(this._elementsManager&&this._elementsManager.tick(a),this._tilesRenderer.update()),this._editableElementManager.refreshTiles())}),g(this,"handleLoadTileSet",(r,a,o)=>{this.engine.requestRender()}),g(this,"handleUpdateModel",r=>{this._materialManager?r.traverse(a=>{if(a.originalMaterial){const o=a.originalMaterialName,l=this._materialManager.getMaterialByKey(o);a.material=l||a.originalMaterial}}):r.traverse(a=>{a.originalMaterial&&(a.material=a.originalMaterial)}),this.engine.requestRender()}),g(this,"parseTileInfo",r=>{const a=r.content.uri,o=a.substring(a.lastIndexOf("/")+1).split(".")[0],l=o.split("-");r.__id=o,r.__level=parseInt(l[0],10),r.__lodLevel=this._tileMaxLevel-r.__level}),g(this,"handleLoadModel",(r,a)=>{this._materialManager&&r.traverse(o=>{if(o.material){const l=o.material.name;o.originalMaterial=o.material,o.originalMaterialName=l;const h=this._materialManager.getMaterialByKey(l);h&&(o.material=h),this._excludeCastShadowMaterials[l]||(o.castShadow=!0),o.receiveShadow=!0}}),r._tileUri=a.content.uri,this.parseTileInfo(a),this._instancedElementManager.onTileLoad(a,r),this._elementsManager.onTileLoad(a,r),this.engine.requestRender()}),g(this,"handleDisposeModel",(r,a)=>{this._instancedElementManager.onTileDispose(a,r),this._elementsManager.onTileDispose(a,r)}),g(this,"handleTileVisibleChanged",(r,a)=>{a?(this._editableElementManager.onTileShow(r),this._instancedElementManager.onTileShow(r),this._elementsManager.onTileShow(r)):(this._editableElementManager.onTileHide(r),this._instancedElementManager.onTileHide(r),this._elementsManager.onTileHide(r))}),g(this,"handleDebugBeforeengineRender",()=>{this._freezeUpdate||this._debugTilesRenderer.update()}),g(this,"_updateTilesCustomLoaders",r=>{for(const a of this._loaders)r.manager.addHandler(a[0],a[1])}),g(this,"handleDebugLoadTileSet",()=>{this.engine.requestRender()}),g(this,"handleDebugLoadModel",()=>{this.engine.requestRender()}),g(this,"transformFromEcefToPlane",(r,a,o=0)=>{let l=ci.eastNorthUpToFixedFrame(ci.lnglatToEcef(r,a,o));l.invert();const h=new at,c=$r([r,a]);h.makeTranslation(c[0],c[1],0);const u=new at;u.multiplyMatrices(h,l),u.decompose(this.position,this.quaternion,this.scale)}),g(this,"disposeTilesRender",r=>{r.forEachLoadedModel((a,o)=>{r.disposeTile(o)})}),this.options=t;const e=this._tilesRenderer=new Sp(this.options.url);e.errorTarget=t.errorTarget||64,this.add(e.group);const i=this._elementsGroup=new Me;this.add(i),(this._elementsManager=new g2(this._elementsGroup)).tilesRenderer=e;const s=this._instancedElementManager=new w2;s.tilesRenderer=e,this.add(s.group),(this._editableElementManager=new S2).tilesRenderer=e,Array.isArray(t.loaders)&&(this._loaders=t.loaders),this._updateTilesCustomLoaders(e)}afterAddToEngine(t){this.engine=t;const e=this._tilesRenderer;e.setCamera(t.camera),e.setResolutionFromRenderer(t.camera,t.renderer),e.onLoadTileSet=this.handleLoadTileSet,e.onLoadModel=this.handleLoadModel,e.onDisposeModel=this.handleDisposeModel,e.onTileVisibleChanged=this.handleTileVisibleChanged,t.addBeforeRenderListener(this.handleBeforeRender),this._instancedElementManager.engine=t,this._elementsManager.engine=t,this._editableElementManager.engine=t}getBounds(){const t=new Ne,e=this._tilesRenderer.getBounds(t);return e&&t.applyMatrix4(this.matrixWorld),e?t:null}createDebugTilesRenderer(){this._tilesRenderer.group.visible=!1;const t=this._debugTilesRenderer=new f2(this.options.url),e=this.engine;t.setCamera(e.camera),t.setResolutionFromRenderer(e.camera,e.renderer),t.errorTarget=this._tilesRenderer.errorTarget,t.displayBoxBounds=!0,t.onLoadTileSet=this.handleLoadTileSet,t.onLoadModel=this.handleLoadModel,e.addBeforeRenderListener(this.handleDebugBeforeengineRender),this._updateTilesCustomLoaders(t),this.add(this._debugTilesRenderer.group)}destoryDebugTilesRenderer(){this.remove(this._debugTilesRenderer.group),this.engine.removeBeforeRenderListener(this.handleDebugBeforeengineRender),this.disposeTilesRender(this._debugTilesRenderer),this._debugTilesRenderer.dispose(),this._tilesRenderer.group.visible=!0}dispose(){this.disposeTilesRender(this._tilesRenderer),this._tilesRenderer.dispose(),this._debugTilesRenderer&&(this.disposeTilesRender(this._debugTilesRenderer),this._debugTilesRenderer.dispose())}set materialManager(t){t&&(t.engine=this.engine,t.tiles=this,t.init(),t.Identity3DTilesMaterialManager&&(t.type=this._identityType)),this._materialManager=t,this._tilesRenderer.forEachLoadedModel(this.handleUpdateModel)}get materialManager(){return this._materialManager}set showDebug(t){t?this._debugTilesRenderer||this.createDebugTilesRenderer():this._debugTilesRenderer&&(this.destoryDebugTilesRenderer(),this._debugTilesRenderer=null),this.engine.requestRender()}get showDebug(){return!!this._debugTilesRenderer}get debugTilesRenderer(){return this._debugTilesRenderer}get elementsManager(){return this._elementsManager}get freezeUpdate(){return this._freezeUpdate}set freezeUpdate(t){this._freezeUpdate=t}get errorTarget(){return this._tilesRenderer.errorTarget}set errorTarget(t){this._tilesRenderer.errorTarget=t,this._debugTilesRenderer&&(this._debugTilesRenderer.errorTarget=t),this.engine.requestRender()}get tilesGroup(){return this._tilesRenderer.group}get tilesRenderer(){return this._tilesRenderer}get instancedElementManager(){return this._instancedElementManager}get editableElementManager(){return this._editableElementManager}get identityType(){return this._identityType}set identityType(t){this._identityType=t,this._materialManager&&this._materialManager.isIdentity3DTilesMaterialManager&&(this._materialManager.type=t)}set visible(t){this._visibile=t,this._tilesRenderer&&(this._tilesRenderer.group.visible=t)}get visible(){return this._visibile}}class R2{constructor(){g(this,"_retryTimes",3),g(this,"_queued",{}),g(this,"_cached",{})}async generate(t){return{}}async get(t){if(this._cached[t])return this._cached[t];let e=!1;this._queued[t]||(this._queued[t]=[],e=!0);const i=new Promise((r,a)=>{this._queued[t].push([r,a])}),s=this._queued[t];if(e){for(let r=0;r<this._retryTimes;r++)try{const a=await this.generate(t);this._cached[t]=a;for(const o of s)o[0](a);break}catch(a){console.warn(a)}for(const r of s)r[1]()}return i}}const L2=new Bs;class I2 extends Ji{constructor(t){super(),g(this,"_enabled",!1),g(this,"_apiHost","http://bjyz-map-bdi-01.bjyz.baidu.com:8219"),g(this,"_selectedEntity",null),g(this,"_proxyBox",null),g(this,"_enableClickSelect",!0),g(this,"_hasLoadInitialInfo",!1),g(this,"_cachedModelAssetsInfo",null),g(this,"_cachedElementInfo",new Map),g(this,"_modelsCache",{}),g(this,"_generateModelMesh",async e=>{await this.loadModelAssetsInfo();const i=this._cachedModelAssetsMap[e];return i?new Promise((s,r)=>{L2.load(i.path,a=>{const o=Oo(a.scene,!1,!0),l=new ec(o);this._tiles.add(l),this._modelsCache[e]=a.scene,s(l)},null,r)}):null}),g(this,"_syncProxyObject",(e,i,s)=>{const r=this._tiles.engine,a=e.geometry.coordinates,o=e.properties,l=r.map.projectPointArr(a),h=this._getElementTypeKey({properties:o}),c=this._cachedModelAssetsMap[h],u=(-o.angle||0)+90,d=o.width||1,p=o.length||1,m=this._getScaleFactor(a);i.position.set(l[0],l[1],l[2]||0),i.quaternion.setFromAxisAngle(new S(0,0,1),u/180*Math.PI),c.scaleByXY?i.scale.set(d*m/s[0]||1,p*m/(s[1]||1),1):c.scaleByZ?i.scale.set(d*m/s[2]||1,p*m/(s[2]||1),o.height/s[2]):i.scale.set(d*m/s[0]||1,p*m/(s[1]||1),o.height/s[2])}),g(this,"_loadChangeInfo",async()=>{const e=await this._request("/hdmap/v1/util/getChangeEquipment",{equipmentType:"lane_obj_box,lane_marking_pg_center",status:"1,2,3"});for(const s of e.delete||[])this._tiles.editableElementManager.addHiddenId(s);let i=[];if(e.update&&e.update.length>0)for(const s of e.update)this._tiles.editableElementManager.addHiddenId(s),i.push(s);if(e.add&&e.add.length>0)for(const s of e.add)i.push(s);if(i.length>0){const s=await this.findElementsById(i);for(const r of s)this._addElementModel(r)}}),g(this,"_handleTransformChanged",e=>{this._updateTransformingElement()}),g(this,"_updateTransformingElement",async()=>{const e=this._proxyModelObject,i=this._transformingElement,s=this._getElementTypeKey(i),r=this._cachedModelAssetsMap[s].dimension,a=this._getScaleFactor(i.geometry.coordinates),o=new S,l=new S,h=new Ft,c=new yn;e.matrixWorld.decompose(o,h,l),c.setFromQuaternion(h);const u=this._engine.map.unprojectPointArr([o.x,o.y,o.z]),d=90-c.z/Math.PI*180,p=l.x*r[0]/a,m=l.y*r[1]/a,f=l.z*r[2],v={type:i.properties.type,subtype:i.properties.subtype,subtype2:i.properties.subtype2,width:p,height:f,length:m,angle:d},_=await this.updateElementById(i.properties.equipmentId,u,v);return _&&(i.geometry.coordinates=u,Object.assign(i.properties,v)),_}),g(this,"_addElementModel",async e=>{const i=this._getElementTypeKey(e),s=await this._modelMeshSingleton.get(i),r=this._getModelInstanceDataFromElement(e),a=this._cachedModelAssetsMap[i],o=this._getScaleFactor(e.geometry.coordinates);a.scaleByXY?(r.scale[0]/=a.dimension[0],r.scale[1]/=a.dimension[1]||1):a.scaleByZ?(r.scale[0]/=a.dimension[2],r.scale[1]/=a.dimension[2]||1):(r.scale[0]/=a.dimension[0],r.scale[1]/=a.dimension[1]||1,r.scale[2]/=a.dimension[2]),r.scale[0]*=o,r.scale[1]*=o,s.addInstances(r),s.needsUpdate=!0}),g(this,"_getModelInstanceDataFromElement",e=>{const i=e.properties,s=this._engine.map.projectPointArr(e.geometry.coordinates);return{id:[i.equipmentId],translation:s,scale:[i.width,i.length,i.height>0?i.height:1],rotation:[0,0,Math.PI*((-i.angle||0)+90)/180]}}),g(this,"_getModelInfoKey",e=>{let i=e.type+"-"+e.subtype;return e.subtype2!==void 0&&(i+="-"+e.subtype2),i}),g(this,"_getElementTypeKey",e=>{const i=e.properties,s=i.type,r=i.subtype,a=i.subtype2;let o=s;return r!==void 0&&(o+="-"+r),a!==void 0&&(o+="-"+a),o}),g(this,"_decodeResponse",e=>{const i=Uint8Array.from(e,r=>r.charCodeAt(0));for(let r=0,a=i.length;r<a;r++)i[r]^=23;const s=String.fromCharCode.apply(null,i);return JSON.parse(s)}),this._tiles=t,this._engine=t.engine,this._modelMeshSingleton=new R2,this._modelMeshSingleton.generate=this._generateModelMesh}_setup(){const t=this._tiles;this._proxyBox=new we(new Wt(1,1,1),new _e({color:16776960,transparent:!0,opacity:0})),t.editableElementManager.enabled=!0,this._hasLoadInitialInfo||this._loadChangeInfo().then(()=>{this._hasLoadInitialInfo=!0})}_destory(){const t=this._tiles;t.engine,this._proxyBox.geometry.dispose(),this._proxyBox.material.dispose(),this._proxyBox=null,t.editableElementManager.enabled=!1}_getScaleFactor(t){return 1/Math.cos(Math.PI*t[1]/180)}_showSelectedObjectEntity(t){const e=this._tiles.engine;new at;const i=t.geometry.coordinates,s=t.properties,r=e.map.projectPointArr(i),a=90-s.angle||0,o=s.width||1,l=s.length||1,h=this._getScaleFactor(i);this._proxyBox.position.set(r[0],r[1],r[2]||0),this._proxyBox.quaternion.setFromAxisAngle(new S(0,0,1),a/180*Math.PI),this._proxyBox.scale.set(o*h,l*h,s.height>0?s.height:1),e.add(this._proxyBox)}_hideSelectedObjectEntity(){this._engine.remove(this._proxyBox)}async selectElementById(t){const e=await this.findElementById(t);return e&&(this._transformingElement&&this.detachElementTransform(),this._showSelectedObjectEntity(e),this._selectedEntity=e,this._engine.selection.select(this._proxyBox)),e}async deselect(){this._engine.selection.deselect(this._proxyBox),this._selectedEntity=null,this._hideSelectedObjectEntity()}async attachElementTransformById(t){let e=await this.findElementById(t);if(!e)return;if(this._transformingElement){if(this._transformingElement.properties.equipmentId===t)return;this.detachElementTransform()}this._selectedEntity&&this.deselect();const i=this._getElementTypeKey(e),s=await this._modelMeshSingleton.get(i);if(!s)return void console.warn("缺少对应的模型");s.has(t)||(this._tiles.editableElementManager.addHiddenId(t),await this._addElementModel(e));const r=this._engine;s.removeInstance(t),s.needsUpdate=!0;const a=this._proxyModelObject=this._modelsCache[i];this._syncProxyObject(e,a,this._cachedModelAssetsMap[i].dimension),r.add(a),r.selection.attachTransform(a),r.selection.transformControl.addEventListener("mouseUp",this._handleTransformChanged),this._transformingElement=e,r.requestRender()}async detachElementTransform(){if(!this._transformingElement)return;const t=this._engine;t.remove(this._proxyModelObject),t.selection.detachTransform(),t.selection.transformControl.removeEventListener("mouseUp",this._handleTransformChanged);const e=this._transformingElement;await this._addElementModel(e),this._transformingElement=null}async findElementById(t){if(this._cachedElementInfo.has(t))return this._cachedElementInfo.get(t);const e=await this.findElementsById(t);return e&&e.length>0?e[0]:null}async findElementsById(...t){const e=await this._request("/hdmap/v1/util/equipmentInfoById",{equipmentId:t.join(",")});if(e){const i=this._decodeResponse(e);for(const s of i)this._cachedElementInfo.set(s.properties.equipmentId,s);return i}return[]}async deleteElementById(t){const e=await this.findElementById(t);if(!e)return;const i=await this._request("/hdmap/v1/util/deleteEquipment",{equipmentId:t});if(i){const s=this._getElementTypeKey(e),r=await this._modelMeshSingleton.get(s);r&&r.has(t)?(r.removeInstance(t),r.needsUpdate=!0):this._tiles.editableElementManager.addHiddenId(t),this.deselect(),this.detachElementTransform(),this._cachedElementInfo.delete(t),this._engine.requestRender()}return i}async addElement(t,e){const i={type:"Point",coordinates:[t[0],t[1],t[2]||0]},s=this._getElementTypeKey({properties:e}),r=this._cachedModelAssetsMap[s];r||console.warn(`model info of ${s} does not exist`);const a=Object.assign({angle:0,width:r.dimension[0],length:r.dimension[1],height:r.dimension[2]},e);let o;o=e.type===10003?"lane_marking_pg_center":"lane_obj_box";const l={equipmentType:o,doc:JSON.stringify({...a,geometry:i})},h=await this._request("/hdmap/v1/util/addEquipment",l);return a.equipmentId=h.equipmentId,await this._addElementModel({geometry:i,properties:a}),this._engine.requestRender(),h}async loadModelAssetsInfo(){if(this._cachedModelAssetsInfo)return this._cachedModelAssetsInfo;const t=this._tiles.tilesRenderer.rootURL,e=t.substring(0,t.lastIndexOf("/"));try{const i=await fetch(`${e}/model_meta.json`).then(a=>a.json()),s=i.list||[],r={};for(const a of s)a.path=e+"/"+a.path,r[this._getModelInfoKey(a)]=a;return this._cachedModelAssetsInfo=i,this._cachedModelAssetsMap=r,i}catch(i){console.warn(i)}}async updateElementById(t,e=null,i={}){const s={...i};if(e){const r={type:"Point",coordinates:[e[0],e[1],e[2]||0]};s.geometry=r}return await this._request("/hdmap/v1/util/updateEquipment",{equipmentId:t,doc:JSON.stringify(s)})}async _request(t,e){let i=new FormData;if(e)for(const r of Object.keys(e))i.append(r,e[r]);const s=await fetch(this._apiHost+t,{method:"POST",headers:{},body:i}).then(r=>r.json());if(s.status===0)return s.result;console.warn("request failed")}set enabled(t){this._enabled!==t&&(this._enabled=t,t?this._setup():this._destory())}get enabled(){return this._enabled}set apiHost(t){this._apiHost=t}get apiHost(){return this._apiHost}}class lc{constructor(){g(this,"_materrialMap",new Map),g(this,"_inited",!1)}init(){this._inited||(this.onInit(),this._inited=!0)}onInit(){}getMaterialByKey(t){return this._materrialMap.get(t)}dispose(){this.beforeDispose();for(const t of Object.keys(this._materrialMap))this._materrialMap[t].dispose()}beforeDispose(){}}const Rp=new Te().load(me("assets/textures/water/waternormal.jpg"));Rp.wrapS=Rp.wrapT=1e3;const D2=ft.merge([rt.fog.uniforms,{normalMap:{value:null},alpha:{value:1},time:{value:0},size:{value:10},distortionScale:{value:2},textureMatrix:{value:new at},sunColor:{value:new nt(16777215)},sunDirection:{value:new S(.70707,.70707,0)},eye:{value:new S},waterColor:{value:new nt(8956603)},reflectionColor:{value:new nt(8956603)},envMap:{value:null},mvt_normalMatrix:{value:new De}}]);class Z_ extends Fe{constructor(t={}){super(),g(this,"_timeScaleFactor",1e-4),this.type="WaterMaterial",this.vertexShader=`#define GLSLIFY 1
uniform mat4 textureMatrix;
uniform float time;

varying vec4 mirrorCoord;
varying vec4 worldPosition;

#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>

void main() {
    mirrorCoord = modelMatrix * vec4(position, 1.0);
    worldPosition = mirrorCoord.xyzw;
    mirrorCoord = textureMatrix * mirrorCoord;
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * mvPosition;

    #include <beginnormal_vertex>
    #include <defaultnormal_vertex>
    #include <logdepthbuf_vertex>
    #include <fog_vertex>
    #include <shadowmap_vertex>
}`,this.fragmentShader=`precision highp float;
precision highp int;
#define GLSLIFY 1

// uniform sampler2D mirrorSampler;
uniform float alpha;
uniform float time;
uniform float size;
uniform float distortionScale;
uniform sampler2D normalMap;
uniform vec3 sunColor;
uniform vec3 sunDirection;
uniform vec3 eye;
uniform vec3 waterColor;
#ifdef USE_ENVMAP
    uniform sampler2D envMap;
#else
    uniform vec3 reflectionColor;
#endif
uniform mat3 mvt_normalMatrix;

varying vec4 mirrorCoord;
varying vec4 worldPosition;

vec4 getNoise(vec2 uv) {
    vec2 uv0 = (uv / 103.0) + vec2(time / 17.0, time / 29.0);
    vec2 uv1 = uv / 107.0 - vec2(time / -19.0, time / 31.0);
    vec2 uv2 = uv / vec2(8907.0, 9803.0) + vec2(time / 101.0, time / 97.0);
    vec2 uv3 = uv / vec2(1091.0, 1027.0) - vec2(time / 109.0, time / -113.0);
    vec4 noise = texture2D(normalMap, uv0) +
        texture2D(normalMap, uv1) +
        texture2D(normalMap, uv2) +
        texture2D(normalMap, uv3);
    return noise * 0.5 - 1.0;
}

void sunLight(const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor) {
    vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));
    float direction = max(0.0, dot(eyeDirection, reflection));
    specularColor += pow(direction, shiny) * sunColor * spec;
    diffuseColor += max(dot(sunDirection, surfaceNormal), 0.0) * sunColor * diffuse;
}

#define ENVMAP_TYPE_CUBE_UV

#include <common>
#include <packing>

#include <bsdfs>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

#include <cube_uv_reflection_fragment>

#define MVT_FRAG_REFLECTION_FACTOR
#define MVT_FRAG_NORMAL

void main() {

	#include <logdepthbuf_fragment>
    vec4 noise = getNoise(worldPosition.xy * size);
    vec3 surfaceNormal = normalize(noise.xyz * vec3(1.5, 1.5, 1.0));

    vec3 diffuseLight = vec3(0.0);
    vec3 specularLight = vec3(0.0);

    vec3 worldToEye = cameraPosition - worldPosition.xyz;
    vec3 eyeDirection = normalize(worldToEye);
    sunLight(surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight);

    float distance = length(worldToEye);

    vec2 distortion = surfaceNormal.xy * (0.001 + 1.0 / distance) * distortionScale;
    // vec3 reflectionSample = vec3(texture2D(mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion));
    vec3 reflectDir = reflect(vec3(-worldToEye.x, -worldToEye.y, -worldToEye.z), vec3(0.0, 0.0, 1.0));
    reflectDir.xy += distortion;

    #ifdef USE_ENVMAP
        vec3 reflectionSample = textureCubeUV(envMap, reflectDir, 0.0).xyz;
    #else
        vec3 reflectionSample = reflectionColor;
    #endif

    float theta = max(dot(eyeDirection, surfaceNormal), 0.0);
    float rf0 = 0.3;
    float reflectance = rf0 + (1.0 - rf0) * pow((1.0 - theta), 5.0);
    vec3 scatter = max(0.0, dot(surfaceNormal, eyeDirection)) * waterColor;
    vec3 albedo = mix((sunColor * diffuseLight * 0.3 + scatter) * getShadowMask(), (vec3(0.1) + reflectionSample * 0.9 + reflectionSample * specularLight), reflectance);
    vec3 outgoingLight = albedo;
    gl_FragColor = vec4(outgoingLight, alpha);
    float mvt_frag_reflectionFactor = 1.0;
    // vec3 mvt_frag_normal = vec3(0., 0., 1.0) * mvt_normalMatrix;
    vec3 mvt_frag_normal = normalize(noise.xyz * vec3(0.2, 0.2, 1.0)) * mvt_normalMatrix;
    // gl_FragColor = worldPosition;
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
}`,this.isWaterMaterial=!0,Object.assign(this.uniforms,ft.clone(D2)),this.defines={CUBEUV_TEXEL_WIDTH:.0003255208333333333,CUBEUV_TEXEL_HEIGHT:.000244140625,CUBEUV_MAX_MIP:"10.0"},Jt(this,["sunColor","waterColor","reflectionColor","size","alpha","distortionScale"]),Object.defineProperties(this,{}),this.uniforms.normalMap.value=Rp,this.setValues(t)}onBeforeSceneRender(t,e,i){if(this.uniforms.eye.value.copy(i.position),this.uniforms.time.value=t.rendering.uniforms.elapsedTime.value*this._timeScaleFactor,this.uniforms.envMap.value!==e.environment){this.uniforms.envMap.value=e.environment;const r=lv(e.environment);r&&(this.defines.CUBEUV_TEXEL_WIDTH=r.texelWidth,this.defines.CUBEUV_TEXEL_HEIGHT=r.texelHeight,this.defines.CUBEUV_MAX_MIP=r.maxMip+".0"),e.environment?this.defines.USE_ENVMAP=!0:delete this.defines.USE_ENVMAP}this.uniforms.mvt_normalMatrix.value.getNormalMatrix(i.matrixWorld);const s=t.rendering.sky;s&&this.uniforms.sunDirection.value.copy(s.sunDirection)}get timeScaleFactor(){return this._timeScaleFactor}set timeScaleFactor(t){this._timeScaleFactor=t}dispose(){let t=["envMap","normalMap"];for(let e=0;e<t.length;e++){const i=t[e];this.uniforms[i]&&this.uniforms[i].value&&this.uniforms[i].value.dispose()}super.dispose()}}const ma=new Te,O2=new nt(16777215);class z2 extends Qt{constructor(t){super(),this.fragmentShader=`#define GLSLIFY 1
#include <common>
varying vec3 vIdColor;
#include <logdepthbuf_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>
    gl_FragColor = vec4(vIdColor.xyz, 1.0);

}`,this.vertexShader=`#define GLSLIFY 1
#include <common>
#ifdef MVT_TYPE_DATATYPE
attribute float _dataType;
#else 
attribute float _id;
#endif

varying vec3 vIdColor;
#include <logdepthbuf_pars_vertex>
void main() { 
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    #ifdef MVT_TYPE_DATATYPE
         float value = _dataType * 0.2536789535;
         vIdColor = vec3(mod(value, 0.1) * 9.0, mod(value, 0.01) * 90.0, mod(value, 0.001) * 900.0);
        // vIdColor = vec3(mod(_dataType * 0.2, 0.7), mod(1.0 - mod(_dataType * 0.835, 1.0), 0.4) + 0.4, mod(_dataType * 0.57245, 0.2) + 0.2);
    #else 
        float value = (_id + 9.3234242) * 0.2536789535;
         vIdColor = vec3(mod(value, 0.1) * 10.0, mod(value, 0.01) * 100.0, mod(value, 0.001) * 1000.0);
        // vIdColor = vec3(mod(_id * 0.2, 0.7), mod(1.0 - mod(_id * 0.835, 1.0), 0.7), mod(_id * 0.57245, 0.5));
    #endif
    
    #include <logdepthbuf_vertex>
}`,this.defines={MVT_TYPE_ID:!0},this.type=1,this.setValues(t)}set type(t){t===1?(this.defines.MVT_TYPE_ID=!0,delete this.defines.MVT_TYPE_DATATYPE):t===2&&(this.defines.MVT_TYPE_DATATYPE=!0,delete this.defines.MVT_TYPE_ID),this.needsUpdate=!0}get type(){return this.defines.MVT_TYPE_DATATYPE?2:1}}const Lp=class extends _o{constructor(n){super(n),g(this,"_geoDataType"),g(this,"_geoFeatures",[]),g(this,"_geoIndexMap",[]),this.type="GeoJSONDataSource"}getOriginDataIndex(n){return n<this._templateDataLength?this._geoIndexMap[n]:[n-this._templateDataLength+this._geoFeatures.length,0]}getOriginData(n){if(n<this._templateDataLength){const t=this._geoIndexMap[n];return this._geoFeatures[t[0]]}return this._addCache[n-this._templateDataLength]}async _getFetchData(n){return await n.json()}onClear(){this._geoDataType=void 0,this._geoFeatures=[]}_onProcessTemplateData(n){return this._prepareFeatures(),this._parseFeatures(n),n}_parseFeatures(n){let t=0;for(let e=0;e<this._geoFeatures.length;e++){const i=this._geoFeatures[e],s=this._onDecomposeFeature(i);for(let r=0;r<s.length;r++){const a=s[r];n.position.push(a.geometry[this.projectionName]),r>0&&t++,n.index.push(e+t),this._geoIndexMap[e+t]=[e,r];for(const o of this._attributeMap.keys())a.properties&&a.properties[this._attributeMap.get(o)]?n[o].push(a.properties[this._attributeMap.get(o)]):this._attributeMap.get(o)instanceof Function?n[o].push(this._attributeMap.get(o)(a.properties)):n[o].push(void 0)}}}_onDecomposeFeature(n){let t=e=>[e];return this._geoDataType==="Point"?t=mv:this._geoDataType==="LineString"?t=fv:this._geoDataType==="Polygon"&&(t=gv),t(n,this.projectionName)}_prepareFeatures(){var n,t,e,i,s,r;this._geoFeatures=Vd(this._origin,this.projectionName),/Point/.test((t=(n=this._geoFeatures[0])==null?void 0:n.geometry)==null?void 0:t.type)?this._geoDataType="Point":/LineString/.test((i=(e=this._geoFeatures[0])==null?void 0:e.geometry)==null?void 0:i.type)?this._geoDataType="LineString":/Polygon/.test((r=(s=this._geoFeatures[0])==null?void 0:s.geometry)==null?void 0:r.type)&&(this._geoDataType="Polygon")}get geoDataType(){return this._geoDataType}};let hc=Lp;g(hc,"fromGeoJSON",async function(n){let t=new Lp;return await t.load(n),t}),g(hc,"fromGeoJSONObject",function(n){let t=new Lp;return t.setData(n),t});var J_=typeof Xo<"u"?Xo:typeof self<"u"?self:typeof window<"u"?window:{},cn=[],Ti=[],U2=typeof Uint8Array<"u"?Uint8Array:Array,Ip=!1;function K_(){Ip=!0;for(var n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t=0,e=n.length;t<e;++t)cn[t]=n[t],Ti[n.charCodeAt(t)]=t;Ti["-".charCodeAt(0)]=62,Ti["_".charCodeAt(0)]=63}function F2(n,t,e){for(var i,s,r=[],a=t;a<e;a+=3)i=(n[a]<<16)+(n[a+1]<<8)+n[a+2],r.push(cn[(s=i)>>18&63]+cn[s>>12&63]+cn[s>>6&63]+cn[63&s]);return r.join("")}function Q_(n){var t;Ip||K_();for(var e=n.length,i=e%3,s="",r=[],a=16383,o=0,l=e-i;o<l;o+=a)r.push(F2(n,o,o+a>l?l:o+a));return i===1?(t=n[e-1],s+=cn[t>>2],s+=cn[t<<4&63],s+="=="):i===2&&(t=(n[e-2]<<8)+n[e-1],s+=cn[t>>10],s+=cn[t>>4&63],s+=cn[t<<2&63],s+="="),r.push(s),r.join("")}function cc(n,t,e,i,s){var r,a,o=8*s-i-1,l=(1<<o)-1,h=l>>1,c=-7,u=e?s-1:0,d=e?-1:1,p=n[t+u];for(u+=d,r=p&(1<<-c)-1,p>>=-c,c+=o;c>0;r=256*r+n[t+u],u+=d,c-=8);for(a=r&(1<<-c)-1,r>>=-c,c+=i;c>0;a=256*a+n[t+u],u+=d,c-=8);if(r===0)r=1-h;else{if(r===l)return a?NaN:1/0*(p?-1:1);a+=Math.pow(2,i),r-=h}return(p?-1:1)*a*Math.pow(2,r-i)}function $_(n,t,e,i,s,r){var a,o,l,h=8*r-s-1,c=(1<<h)-1,u=c>>1,d=s===23?Math.pow(2,-24)-Math.pow(2,-77):0,p=i?0:r-1,m=i?1:-1,f=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,a=c):(a=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-a))<1&&(a--,l*=2),(t+=a+u>=1?d/l:d*Math.pow(2,1-u))*l>=2&&(a++,l/=2),a+u>=c?(o=0,a=c):a+u>=1?(o=(t*l-1)*Math.pow(2,s),a+=u):(o=t*Math.pow(2,u-1)*Math.pow(2,s),a=0));s>=8;n[e+p]=255&o,p+=m,o/=256,s-=8);for(a=a<<s|o,h+=s;h>0;n[e+p]=255&a,p+=m,a/=256,h-=8);n[e+p-m]|=128*f}var N2={}.toString,ty=Array.isArray||function(n){return N2.call(n)=="[object Array]"};function uc(){return J.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function Dn(n,t){if(uc()<t)throw new RangeError("Invalid typed array length");return J.TYPED_ARRAY_SUPPORT?(n=new Uint8Array(t)).__proto__=J.prototype:(n===null&&(n=new J(t)),n.length=t),n}function J(n,t,e){if(!(J.TYPED_ARRAY_SUPPORT||this instanceof J))return new J(n,t,e);if(typeof n=="number"){if(typeof t=="string")throw new Error("If encoding is specified then the first argument must be a string");return Dp(this,n)}return ey(this,n,t,e)}function ey(n,t,e,i){if(typeof t=="number")throw new TypeError('"value" argument must not be a number');return typeof ArrayBuffer<"u"&&t instanceof ArrayBuffer?function(s,r,a,o){if(r.byteLength,a<0||r.byteLength<a)throw new RangeError("'offset' is out of bounds");if(r.byteLength<a+(o||0))throw new RangeError("'length' is out of bounds");return r=a===void 0&&o===void 0?new Uint8Array(r):o===void 0?new Uint8Array(r,a):new Uint8Array(r,a,o),J.TYPED_ARRAY_SUPPORT?(s=r).__proto__=J.prototype:s=Op(s,r),s}(n,t,e,i):typeof t=="string"?function(s,r,a){if(typeof a=="string"&&a!==""||(a="utf8"),!J.isEncoding(a))throw new TypeError('"encoding" must be a valid string encoding');var o=0|ny(r,a),l=(s=Dn(s,o)).write(r,a);return l!==o&&(s=s.slice(0,l)),s}(n,t,e):function(s,r){if(un(r)){var a=0|zp(r.length);return(s=Dn(s,a)).length===0||r.copy(s,0,0,a),s}if(r){if(typeof ArrayBuffer<"u"&&r.buffer instanceof ArrayBuffer||"length"in r)return typeof r.length!="number"||(o=r.length)!=o?Dn(s,0):Op(s,r);if(r.type==="Buffer"&&ty(r.data))return Op(s,r.data)}var o;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(n,t)}function iy(n){if(typeof n!="number")throw new TypeError('"size" argument must be a number');if(n<0)throw new RangeError('"size" argument must not be negative')}function Dp(n,t){if(iy(t),n=Dn(n,t<0?0:0|zp(t)),!J.TYPED_ARRAY_SUPPORT)for(var e=0;e<t;++e)n[e]=0;return n}function Op(n,t){var e=t.length<0?0:0|zp(t.length);n=Dn(n,e);for(var i=0;i<e;i+=1)n[i]=255&t[i];return n}function zp(n){if(n>=uc())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+uc().toString(16)+" bytes");return 0|n}function un(n){return!(n==null||!n._isBuffer)}function ny(n,t){if(un(n))return n.length;if(typeof ArrayBuffer<"u"&&typeof ArrayBuffer.isView=="function"&&(ArrayBuffer.isView(n)||n instanceof ArrayBuffer))return n.byteLength;typeof n!="string"&&(n=""+n);var e=n.length;if(e===0)return 0;for(var i=!1;;)switch(t){case"ascii":case"latin1":case"binary":return e;case"utf8":case"utf-8":case void 0:return mc(n).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*e;case"hex":return e>>>1;case"base64":return dy(n).length;default:if(i)return mc(n).length;t=(""+t).toLowerCase(),i=!0}}function k2(n,t,e){var i=!1;if((t===void 0||t<0)&&(t=0),t>this.length||((e===void 0||e>this.length)&&(e=this.length),e<=0)||(e>>>=0)<=(t>>>=0))return"";for(n||(n="utf8");;)switch(n){case"hex":return Y2(this,t,e);case"utf8":case"utf-8":return oy(this,t,e);case"ascii":return q2(this,t,e);case"latin1":case"binary":return X2(this,t,e);case"base64":return W2(this,t,e);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Z2(this,t,e);default:if(i)throw new TypeError("Unknown encoding: "+n);n=(n+"").toLowerCase(),i=!0}}function Ys(n,t,e){var i=n[t];n[t]=n[e],n[e]=i}function sy(n,t,e,i,s){if(n.length===0)return-1;if(typeof e=="string"?(i=e,e=0):e>2147483647?e=2147483647:e<-2147483648&&(e=-2147483648),e=+e,isNaN(e)&&(e=s?0:n.length-1),e<0&&(e=n.length+e),e>=n.length){if(s)return-1;e=n.length-1}else if(e<0){if(!s)return-1;e=0}if(typeof t=="string"&&(t=J.from(t,i)),un(t))return t.length===0?-1:ry(n,t,e,i,s);if(typeof t=="number")return t&=255,J.TYPED_ARRAY_SUPPORT&&typeof Uint8Array.prototype.indexOf=="function"?s?Uint8Array.prototype.indexOf.call(n,t,e):Uint8Array.prototype.lastIndexOf.call(n,t,e):ry(n,[t],e,i,s);throw new TypeError("val must be string, number or Buffer")}function ry(n,t,e,i,s){var r,a=1,o=n.length,l=t.length;if(i!==void 0&&((i=String(i).toLowerCase())==="ucs2"||i==="ucs-2"||i==="utf16le"||i==="utf-16le")){if(n.length<2||t.length<2)return-1;a=2,o/=2,l/=2,e/=2}function h(p,m){return a===1?p[m]:p.readUInt16BE(m*a)}if(s){var c=-1;for(r=e;r<o;r++)if(h(n,r)===h(t,c===-1?0:r-c)){if(c===-1&&(c=r),r-c+1===l)return c*a}else c!==-1&&(r-=r-c),c=-1}else for(e+l>o&&(e=o-l),r=e;r>=0;r--){for(var u=!0,d=0;d<l;d++)if(h(n,r+d)!==h(t,d)){u=!1;break}if(u)return r}return-1}function B2(n,t,e,i){e=Number(e)||0;var s=n.length-e;i?(i=Number(i))>s&&(i=s):i=s;var r=t.length;if(r%2!=0)throw new TypeError("Invalid hex string");i>r/2&&(i=r/2);for(var a=0;a<i;++a){var o=parseInt(t.substr(2*a,2),16);if(isNaN(o))return a;n[e+a]=o}return a}function V2(n,t,e,i){return fc(mc(t,n.length-e),n,e,i)}function ay(n,t,e,i){return fc(function(s){for(var r=[],a=0;a<s.length;++a)r.push(255&s.charCodeAt(a));return r}(t),n,e,i)}function G2(n,t,e,i){return ay(n,t,e,i)}function j2(n,t,e,i){return fc(dy(t),n,e,i)}function H2(n,t,e,i){return fc(function(s,r){for(var a,o,l,h=[],c=0;c<s.length&&!((r-=2)<0);++c)o=(a=s.charCodeAt(c))>>8,l=a%256,h.push(l),h.push(o);return h}(t,n.length-e),n,e,i)}function W2(n,t,e){return t===0&&e===n.length?Q_(n):Q_(n.slice(t,e))}function oy(n,t,e){e=Math.min(n.length,e);for(var i=[],s=t;s<e;){var r,a,o,l,h=n[s],c=null,u=h>239?4:h>223?3:h>191?2:1;if(s+u<=e)switch(u){case 1:h<128&&(c=h);break;case 2:(192&(r=n[s+1]))==128&&(l=(31&h)<<6|63&r)>127&&(c=l);break;case 3:r=n[s+1],a=n[s+2],(192&r)==128&&(192&a)==128&&(l=(15&h)<<12|(63&r)<<6|63&a)>2047&&(l<55296||l>57343)&&(c=l);break;case 4:r=n[s+1],a=n[s+2],o=n[s+3],(192&r)==128&&(192&a)==128&&(192&o)==128&&(l=(15&h)<<18|(63&r)<<12|(63&a)<<6|63&o)>65535&&l<1114112&&(c=l)}c===null?(c=65533,u=1):c>65535&&(c-=65536,i.push(c>>>10&1023|55296),c=56320|1023&c),i.push(c),s+=u}return function(d){var p=d.length;if(p<=ly)return String.fromCharCode.apply(String,d);for(var m="",f=0;f<p;)m+=String.fromCharCode.apply(String,d.slice(f,f+=ly));return m}(i)}J.TYPED_ARRAY_SUPPORT=J_.TYPED_ARRAY_SUPPORT===void 0||J_.TYPED_ARRAY_SUPPORT,uc(),J.poolSize=8192,J._augment=function(n){return n.__proto__=J.prototype,n},J.from=function(n,t,e){return ey(null,n,t,e)},J.TYPED_ARRAY_SUPPORT&&(J.prototype.__proto__=Uint8Array.prototype,J.__proto__=Uint8Array,typeof Symbol<"u"&&Symbol.species&&J[Symbol.species]),J.alloc=function(n,t,e){return function(i,s,r,a){return iy(s),s<=0?Dn(i,s):r!==void 0?typeof a=="string"?Dn(i,s).fill(r,a):Dn(i,s).fill(r):Dn(i,s)}(null,n,t,e)},J.allocUnsafe=function(n){return Dp(null,n)},J.allocUnsafeSlow=function(n){return Dp(null,n)},J.isBuffer=Ei,J.compare=function(n,t){if(!un(n)||!un(t))throw new TypeError("Arguments must be Buffers");if(n===t)return 0;for(var e=n.length,i=t.length,s=0,r=Math.min(e,i);s<r;++s)if(n[s]!==t[s]){e=n[s],i=t[s];break}return e<i?-1:i<e?1:0},J.isEncoding=function(n){switch(String(n).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},J.concat=function(n,t){if(!ty(n))throw new TypeError('"list" argument must be an Array of Buffers');if(n.length===0)return J.alloc(0);var e;if(t===void 0)for(t=0,e=0;e<n.length;++e)t+=n[e].length;var i=J.allocUnsafe(t),s=0;for(e=0;e<n.length;++e){var r=n[e];if(!un(r))throw new TypeError('"list" argument must be an Array of Buffers');r.copy(i,s),s+=r.length}return i},J.byteLength=ny,J.prototype._isBuffer=!0,J.prototype.swap16=function(){var n=this.length;if(n%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<n;t+=2)Ys(this,t,t+1);return this},J.prototype.swap32=function(){var n=this.length;if(n%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<n;t+=4)Ys(this,t,t+3),Ys(this,t+1,t+2);return this},J.prototype.swap64=function(){var n=this.length;if(n%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<n;t+=8)Ys(this,t,t+7),Ys(this,t+1,t+6),Ys(this,t+2,t+5),Ys(this,t+3,t+4);return this},J.prototype.toString=function(){var n=0|this.length;return n===0?"":arguments.length===0?oy(this,0,n):k2.apply(this,arguments)},J.prototype.equals=function(n){if(!un(n))throw new TypeError("Argument must be a Buffer");return this===n||J.compare(this,n)===0},J.prototype.inspect=function(){var n="";return this.length>0&&(n=this.toString("hex",0,50).match(/.{2}/g).join(" "),this.length>50&&(n+=" ... ")),"<Buffer "+n+">"},J.prototype.compare=function(n,t,e,i,s){if(!un(n))throw new TypeError("Argument must be a Buffer");if(t===void 0&&(t=0),e===void 0&&(e=n?n.length:0),i===void 0&&(i=0),s===void 0&&(s=this.length),t<0||e>n.length||i<0||s>this.length)throw new RangeError("out of range index");if(i>=s&&t>=e)return 0;if(i>=s)return-1;if(t>=e)return 1;if(this===n)return 0;for(var r=(s>>>=0)-(i>>>=0),a=(e>>>=0)-(t>>>=0),o=Math.min(r,a),l=this.slice(i,s),h=n.slice(t,e),c=0;c<o;++c)if(l[c]!==h[c]){r=l[c],a=h[c];break}return r<a?-1:a<r?1:0},J.prototype.includes=function(n,t,e){return this.indexOf(n,t,e)!==-1},J.prototype.indexOf=function(n,t,e){return sy(this,n,t,e,!0)},J.prototype.lastIndexOf=function(n,t,e){return sy(this,n,t,e,!1)},J.prototype.write=function(n,t,e,i){if(t===void 0)i="utf8",e=this.length,t=0;else if(e===void 0&&typeof t=="string")i=t,e=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(e)?(e|=0,i===void 0&&(i="utf8")):(i=e,e=void 0)}var s=this.length-t;if((e===void 0||e>s)&&(e=s),n.length>0&&(e<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");i||(i="utf8");for(var r=!1;;)switch(i){case"hex":return B2(this,n,t,e);case"utf8":case"utf-8":return V2(this,n,t,e);case"ascii":return ay(this,n,t,e);case"latin1":case"binary":return G2(this,n,t,e);case"base64":return j2(this,n,t,e);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return H2(this,n,t,e);default:if(r)throw new TypeError("Unknown encoding: "+i);i=(""+i).toLowerCase(),r=!0}},J.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var ly=4096;function q2(n,t,e){var i="";e=Math.min(n.length,e);for(var s=t;s<e;++s)i+=String.fromCharCode(127&n[s]);return i}function X2(n,t,e){var i="";e=Math.min(n.length,e);for(var s=t;s<e;++s)i+=String.fromCharCode(n[s]);return i}function Y2(n,t,e){var i=n.length;(!t||t<0)&&(t=0),(!e||e<0||e>i)&&(e=i);for(var s="",r=t;r<e;++r)s+=K2(n[r]);return s}function Z2(n,t,e){for(var i=n.slice(t,e),s="",r=0;r<i.length;r+=2)s+=String.fromCharCode(i[r]+256*i[r+1]);return s}function Ce(n,t,e){if(n%1!=0||n<0)throw new RangeError("offset is not uint");if(n+t>e)throw new RangeError("Trying to access beyond buffer length")}function $e(n,t,e,i,s,r){if(!un(n))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>s||t<r)throw new RangeError('"value" argument is out of bounds');if(e+i>n.length)throw new RangeError("Index out of range")}function dc(n,t,e,i){t<0&&(t=65535+t+1);for(var s=0,r=Math.min(n.length-e,2);s<r;++s)n[e+s]=(t&255<<8*(i?s:1-s))>>>8*(i?s:1-s)}function pc(n,t,e,i){t<0&&(t=4294967295+t+1);for(var s=0,r=Math.min(n.length-e,4);s<r;++s)n[e+s]=t>>>8*(i?s:3-s)&255}function hy(n,t,e,i,s,r){if(e+i>n.length)throw new RangeError("Index out of range");if(e<0)throw new RangeError("Index out of range")}function cy(n,t,e,i,s){return s||hy(n,0,e,4),$_(n,t,e,i,23,4),e+4}function uy(n,t,e,i,s){return s||hy(n,0,e,8),$_(n,t,e,i,52,8),e+8}J.prototype.slice=function(n,t){var e,i=this.length;if((n=~~n)<0?(n+=i)<0&&(n=0):n>i&&(n=i),(t=t===void 0?i:~~t)<0?(t+=i)<0&&(t=0):t>i&&(t=i),t<n&&(t=n),J.TYPED_ARRAY_SUPPORT)(e=this.subarray(n,t)).__proto__=J.prototype;else{var s=t-n;e=new J(s,void 0);for(var r=0;r<s;++r)e[r]=this[r+n]}return e},J.prototype.readUIntLE=function(n,t,e){n|=0,t|=0,e||Ce(n,t,this.length);for(var i=this[n],s=1,r=0;++r<t&&(s*=256);)i+=this[n+r]*s;return i},J.prototype.readUIntBE=function(n,t,e){n|=0,t|=0,e||Ce(n,t,this.length);for(var i=this[n+--t],s=1;t>0&&(s*=256);)i+=this[n+--t]*s;return i},J.prototype.readUInt8=function(n,t){return t||Ce(n,1,this.length),this[n]},J.prototype.readUInt16LE=function(n,t){return t||Ce(n,2,this.length),this[n]|this[n+1]<<8},J.prototype.readUInt16BE=function(n,t){return t||Ce(n,2,this.length),this[n]<<8|this[n+1]},J.prototype.readUInt32LE=function(n,t){return t||Ce(n,4,this.length),(this[n]|this[n+1]<<8|this[n+2]<<16)+16777216*this[n+3]},J.prototype.readUInt32BE=function(n,t){return t||Ce(n,4,this.length),16777216*this[n]+(this[n+1]<<16|this[n+2]<<8|this[n+3])},J.prototype.readIntLE=function(n,t,e){n|=0,t|=0,e||Ce(n,t,this.length);for(var i=this[n],s=1,r=0;++r<t&&(s*=256);)i+=this[n+r]*s;return i>=(s*=128)&&(i-=Math.pow(2,8*t)),i},J.prototype.readIntBE=function(n,t,e){n|=0,t|=0,e||Ce(n,t,this.length);for(var i=t,s=1,r=this[n+--i];i>0&&(s*=256);)r+=this[n+--i]*s;return r>=(s*=128)&&(r-=Math.pow(2,8*t)),r},J.prototype.readInt8=function(n,t){return t||Ce(n,1,this.length),128&this[n]?-1*(255-this[n]+1):this[n]},J.prototype.readInt16LE=function(n,t){t||Ce(n,2,this.length);var e=this[n]|this[n+1]<<8;return 32768&e?4294901760|e:e},J.prototype.readInt16BE=function(n,t){t||Ce(n,2,this.length);var e=this[n+1]|this[n]<<8;return 32768&e?4294901760|e:e},J.prototype.readInt32LE=function(n,t){return t||Ce(n,4,this.length),this[n]|this[n+1]<<8|this[n+2]<<16|this[n+3]<<24},J.prototype.readInt32BE=function(n,t){return t||Ce(n,4,this.length),this[n]<<24|this[n+1]<<16|this[n+2]<<8|this[n+3]},J.prototype.readFloatLE=function(n,t){return t||Ce(n,4,this.length),cc(this,n,!0,23,4)},J.prototype.readFloatBE=function(n,t){return t||Ce(n,4,this.length),cc(this,n,!1,23,4)},J.prototype.readDoubleLE=function(n,t){return t||Ce(n,8,this.length),cc(this,n,!0,52,8)},J.prototype.readDoubleBE=function(n,t){return t||Ce(n,8,this.length),cc(this,n,!1,52,8)},J.prototype.writeUIntLE=function(n,t,e,i){n=+n,t|=0,e|=0,i||$e(this,n,t,e,Math.pow(2,8*e)-1,0);var s=1,r=0;for(this[t]=255&n;++r<e&&(s*=256);)this[t+r]=n/s&255;return t+e},J.prototype.writeUIntBE=function(n,t,e,i){n=+n,t|=0,e|=0,i||$e(this,n,t,e,Math.pow(2,8*e)-1,0);var s=e-1,r=1;for(this[t+s]=255&n;--s>=0&&(r*=256);)this[t+s]=n/r&255;return t+e},J.prototype.writeUInt8=function(n,t,e){return n=+n,t|=0,e||$e(this,n,t,1,255,0),J.TYPED_ARRAY_SUPPORT||(n=Math.floor(n)),this[t]=255&n,t+1},J.prototype.writeUInt16LE=function(n,t,e){return n=+n,t|=0,e||$e(this,n,t,2,65535,0),J.TYPED_ARRAY_SUPPORT?(this[t]=255&n,this[t+1]=n>>>8):dc(this,n,t,!0),t+2},J.prototype.writeUInt16BE=function(n,t,e){return n=+n,t|=0,e||$e(this,n,t,2,65535,0),J.TYPED_ARRAY_SUPPORT?(this[t]=n>>>8,this[t+1]=255&n):dc(this,n,t,!1),t+2},J.prototype.writeUInt32LE=function(n,t,e){return n=+n,t|=0,e||$e(this,n,t,4,4294967295,0),J.TYPED_ARRAY_SUPPORT?(this[t+3]=n>>>24,this[t+2]=n>>>16,this[t+1]=n>>>8,this[t]=255&n):pc(this,n,t,!0),t+4},J.prototype.writeUInt32BE=function(n,t,e){return n=+n,t|=0,e||$e(this,n,t,4,4294967295,0),J.TYPED_ARRAY_SUPPORT?(this[t]=n>>>24,this[t+1]=n>>>16,this[t+2]=n>>>8,this[t+3]=255&n):pc(this,n,t,!1),t+4},J.prototype.writeIntLE=function(n,t,e,i){if(n=+n,t|=0,!i){var s=Math.pow(2,8*e-1);$e(this,n,t,e,s-1,-s)}var r=0,a=1,o=0;for(this[t]=255&n;++r<e&&(a*=256);)n<0&&o===0&&this[t+r-1]!==0&&(o=1),this[t+r]=(n/a>>0)-o&255;return t+e},J.prototype.writeIntBE=function(n,t,e,i){if(n=+n,t|=0,!i){var s=Math.pow(2,8*e-1);$e(this,n,t,e,s-1,-s)}var r=e-1,a=1,o=0;for(this[t+r]=255&n;--r>=0&&(a*=256);)n<0&&o===0&&this[t+r+1]!==0&&(o=1),this[t+r]=(n/a>>0)-o&255;return t+e},J.prototype.writeInt8=function(n,t,e){return n=+n,t|=0,e||$e(this,n,t,1,127,-128),J.TYPED_ARRAY_SUPPORT||(n=Math.floor(n)),n<0&&(n=255+n+1),this[t]=255&n,t+1},J.prototype.writeInt16LE=function(n,t,e){return n=+n,t|=0,e||$e(this,n,t,2,32767,-32768),J.TYPED_ARRAY_SUPPORT?(this[t]=255&n,this[t+1]=n>>>8):dc(this,n,t,!0),t+2},J.prototype.writeInt16BE=function(n,t,e){return n=+n,t|=0,e||$e(this,n,t,2,32767,-32768),J.TYPED_ARRAY_SUPPORT?(this[t]=n>>>8,this[t+1]=255&n):dc(this,n,t,!1),t+2},J.prototype.writeInt32LE=function(n,t,e){return n=+n,t|=0,e||$e(this,n,t,4,2147483647,-2147483648),J.TYPED_ARRAY_SUPPORT?(this[t]=255&n,this[t+1]=n>>>8,this[t+2]=n>>>16,this[t+3]=n>>>24):pc(this,n,t,!0),t+4},J.prototype.writeInt32BE=function(n,t,e){return n=+n,t|=0,e||$e(this,n,t,4,2147483647,-2147483648),n<0&&(n=4294967295+n+1),J.TYPED_ARRAY_SUPPORT?(this[t]=n>>>24,this[t+1]=n>>>16,this[t+2]=n>>>8,this[t+3]=255&n):pc(this,n,t,!1),t+4},J.prototype.writeFloatLE=function(n,t,e){return cy(this,n,t,!0,e)},J.prototype.writeFloatBE=function(n,t,e){return cy(this,n,t,!1,e)},J.prototype.writeDoubleLE=function(n,t,e){return uy(this,n,t,!0,e)},J.prototype.writeDoubleBE=function(n,t,e){return uy(this,n,t,!1,e)},J.prototype.copy=function(n,t,e,i){if(e||(e=0),i||i===0||(i=this.length),t>=n.length&&(t=n.length),t||(t=0),i>0&&i<e&&(i=e),i===e||n.length===0||this.length===0)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(e<0||e>=this.length)throw new RangeError("sourceStart out of bounds");if(i<0)throw new RangeError("sourceEnd out of bounds");i>this.length&&(i=this.length),n.length-t<i-e&&(i=n.length-t+e);var s,r=i-e;if(this===n&&e<t&&t<i)for(s=r-1;s>=0;--s)n[s+t]=this[s+e];else if(r<1e3||!J.TYPED_ARRAY_SUPPORT)for(s=0;s<r;++s)n[s+t]=this[s+e];else Uint8Array.prototype.set.call(n,this.subarray(e,e+r),t);return r},J.prototype.fill=function(n,t,e,i){if(typeof n=="string"){if(typeof t=="string"?(i=t,t=0,e=this.length):typeof e=="string"&&(i=e,e=this.length),n.length===1){var s=n.charCodeAt(0);s<256&&(n=s)}if(i!==void 0&&typeof i!="string")throw new TypeError("encoding must be a string");if(typeof i=="string"&&!J.isEncoding(i))throw new TypeError("Unknown encoding: "+i)}else typeof n=="number"&&(n&=255);if(t<0||this.length<t||this.length<e)throw new RangeError("Out of range index");if(e<=t)return this;var r;if(t>>>=0,e=e===void 0?this.length:e>>>0,n||(n=0),typeof n=="number")for(r=t;r<e;++r)this[r]=n;else{var a=un(n)?n:mc(new J(n,i).toString()),o=a.length;for(r=0;r<e-t;++r)this[r+t]=a[r%o]}return this};var J2=/[^+\/0-9A-Za-z-_]/g;function K2(n){return n<16?"0"+n.toString(16):n.toString(16)}function mc(n,t){var e;t=t||1/0;for(var i=n.length,s=null,r=[],a=0;a<i;++a){if((e=n.charCodeAt(a))>55295&&e<57344){if(!s){if(e>56319){(t-=3)>-1&&r.push(239,191,189);continue}if(a+1===i){(t-=3)>-1&&r.push(239,191,189);continue}s=e;continue}if(e<56320){(t-=3)>-1&&r.push(239,191,189),s=e;continue}e=65536+(s-55296<<10|e-56320)}else s&&(t-=3)>-1&&r.push(239,191,189);if(s=null,e<128){if((t-=1)<0)break;r.push(e)}else if(e<2048){if((t-=2)<0)break;r.push(e>>6|192,63&e|128)}else if(e<65536){if((t-=3)<0)break;r.push(e>>12|224,e>>6&63|128,63&e|128)}else{if(!(e<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;r.push(e>>18|240,e>>12&63|128,e>>6&63|128,63&e|128)}}return r}function dy(n){return function(t){var e,i,s,r,a,o;Ip||K_();var l=t.length;if(l%4>0)throw new Error("Invalid string. Length must be a multiple of 4");a=t[l-2]==="="?2:t[l-1]==="="?1:0,o=new U2(3*l/4-a),s=a>0?l-4:l;var h=0;for(e=0,i=0;e<s;e+=4,i+=3)r=Ti[t.charCodeAt(e)]<<18|Ti[t.charCodeAt(e+1)]<<12|Ti[t.charCodeAt(e+2)]<<6|Ti[t.charCodeAt(e+3)],o[h++]=r>>16&255,o[h++]=r>>8&255,o[h++]=255&r;return a===2?(r=Ti[t.charCodeAt(e)]<<2|Ti[t.charCodeAt(e+1)]>>4,o[h++]=255&r):a===1&&(r=Ti[t.charCodeAt(e)]<<10|Ti[t.charCodeAt(e+1)]<<4|Ti[t.charCodeAt(e+2)]>>2,o[h++]=r>>8&255,o[h++]=255&r),o}(function(t){if((t=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(t).replace(J2,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(n))}function fc(n,t,e,i){for(var s=0;s<i&&!(s+e>=t.length||s>=n.length);++s)t[s+e]=n[s];return s}function Ei(n){return n!=null&&(!!n._isBuffer||py(n)||function(t){return typeof t.readFloatLE=="function"&&typeof t.slice=="function"&&py(t.slice(0,0))}(n))}function py(n){return!!n.constructor&&typeof n.constructor.isBuffer=="function"&&n.constructor.isBuffer(n)}class qt extends Error{constructor(t,e,i,...s){Array.isArray(e)&&(e=e.join(" ")),super(e),Error.captureStackTrace!==void 0&&Error.captureStackTrace(this,qt),this.code=t;for(const r of s)for(const a in r){const o=r[a];this[a]=Ei(o)?o.toString(i.encoding):o==null?o:JSON.parse(JSON.stringify(o))}}}const Q2=function(n){return typeof n=="object"&&n!==null&&!Array.isArray(n)},my=function(n){const t=[];for(let e=0,i=n.length;e<i;e++){const s=n[e];if(s==null||s===!1)t[e]={disabled:!0};else if(typeof s=="string")t[e]={name:s};else{if(!Q2(s))throw new qt("CSV_INVALID_COLUMN_DEFINITION",["Invalid column definition:","expect a string or a literal object,",`got ${JSON.stringify(s)} at position ${e}`]);if(typeof s.name!="string")throw new qt("CSV_OPTION_COLUMNS_MISSING_NAME",["Option columns missing name:",`property "name" is required at position ${e}`,"when column is an object literal"]);t[e]=s}}return t};class fy{constructor(t=100){this.size=t,this.length=0,this.buf=J.allocUnsafe(t)}prepend(t){if(Ei(t)){const e=this.length+t.length;if(e>=this.size&&(this.resize(),e>=this.size))throw Error("INVALID_BUFFER_STATE");const i=this.buf;this.buf=J.allocUnsafe(this.size),t.copy(this.buf,0),i.copy(this.buf,t.length),this.length+=t.length}else{const e=this.length++;e===this.size&&this.resize();const i=this.clone();this.buf[0]=t,i.copy(this.buf,1,0,e)}}append(t){const e=this.length++;e===this.size&&this.resize(),this.buf[e]=t}clone(){return J.from(this.buf.slice(0,this.length))}resize(){const t=this.length;this.size=2*this.size;const e=J.allocUnsafe(this.size);this.buf.copy(e,0,0,t),this.buf=e}toString(t){return t?this.buf.slice(0,this.length).toString(t):Uint8Array.prototype.slice.call(this.buf.slice(0,this.length))}toJSON(){return this.toString("utf8")}reset(){this.length=0}}const $2=function(n){return{bomSkipped:!1,bufBytesStart:0,castField:n.cast_function,commenting:!1,error:void 0,enabled:n.from_line===1,escaping:!1,escapeIsQuote:Ei(n.escape)&&Ei(n.quote)&&J.compare(n.escape,n.quote)===0,expectedRecordLength:Array.isArray(n.columns)?n.columns.length:void 0,field:new fy(20),firstLineToHeaders:n.cast_first_line_to_header,needMoreDataSize:Math.max(n.comment!==null?n.comment.length:0,...n.delimiter.map(t=>t.length),n.quote!==null?n.quote.length:0),previousBuf:void 0,quoting:!1,stop:!1,rawBuffer:new fy(100),record:[],recordHasError:!1,record_length:0,recordDelimiterMaxLength:n.record_delimiter.length===0?2:Math.max(...n.record_delimiter.map(t=>t.length)),trimChars:[J.from(" ",n.encoding)[0],J.from("	",n.encoding)[0]],wasQuoting:!1,wasRowDelimiter:!1,timchars:[J.from(J.from([13],"utf8").toString(),n.encoding),J.from(J.from([10],"utf8").toString(),n.encoding),J.from(J.from([12],"utf8").toString(),n.encoding),J.from(J.from([32],"utf8").toString(),n.encoding),J.from(J.from([9],"utf8").toString(),n.encoding)]}},gy=function(n){const t={};for(const s in n)t[e=s,e.replace(/([A-Z])/g,function(r,a){return"_"+a.toLowerCase()})]=n[s];var e;if(t.encoding===void 0||t.encoding===!0)t.encoding="utf8";else if(t.encoding===null||t.encoding===!1)t.encoding=null;else if(typeof t.encoding!="string"&&t.encoding!==null)throw new qt("CSV_INVALID_OPTION_ENCODING",["Invalid option encoding:","encoding must be a string or null to return a buffer,",`got ${JSON.stringify(t.encoding)}`],t);if(t.bom===void 0||t.bom===null||t.bom===!1)t.bom=!1;else if(t.bom!==!0)throw new qt("CSV_INVALID_OPTION_BOM",["Invalid option bom:","bom must be true,",`got ${JSON.stringify(t.bom)}`],t);if(t.cast_function=null,t.cast===void 0||t.cast===null||t.cast===!1||t.cast==="")t.cast=void 0;else if(typeof t.cast=="function")t.cast_function=t.cast,t.cast=!0;else if(t.cast!==!0)throw new qt("CSV_INVALID_OPTION_CAST",["Invalid option cast:","cast must be true or a function,",`got ${JSON.stringify(t.cast)}`],t);if(t.cast_date===void 0||t.cast_date===null||t.cast_date===!1||t.cast_date==="")t.cast_date=!1;else if(t.cast_date===!0)t.cast_date=function(s){const r=Date.parse(s);return isNaN(r)?s:new Date(r)};else if(typeof t.cast_date!="function")throw new qt("CSV_INVALID_OPTION_CAST_DATE",["Invalid option cast_date:","cast_date must be true or a function,",`got ${JSON.stringify(t.cast_date)}`],t);if(t.cast_first_line_to_header=null,t.columns===!0)t.cast_first_line_to_header=void 0;else if(typeof t.columns=="function")t.cast_first_line_to_header=t.columns,t.columns=!0;else if(Array.isArray(t.columns))t.columns=my(t.columns);else{if(t.columns!==void 0&&t.columns!==null&&t.columns!==!1)throw new qt("CSV_INVALID_OPTION_COLUMNS",["Invalid option columns:","expect an array, a function or true,",`got ${JSON.stringify(t.columns)}`],t);t.columns=!1}if(t.group_columns_by_name===void 0||t.group_columns_by_name===null||t.group_columns_by_name===!1)t.group_columns_by_name=!1;else{if(t.group_columns_by_name!==!0)throw new qt("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",["Invalid option group_columns_by_name:","expect an boolean,",`got ${JSON.stringify(t.group_columns_by_name)}`],t);if(t.columns===!1)throw new qt("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",["Invalid option group_columns_by_name:","the `columns` mode must be activated."],t)}if(t.comment===void 0||t.comment===null||t.comment===!1||t.comment==="")t.comment=null;else if(typeof t.comment=="string"&&(t.comment=J.from(t.comment,t.encoding)),!Ei(t.comment))throw new qt("CSV_INVALID_OPTION_COMMENT",["Invalid option comment:","comment must be a buffer or a string,",`got ${JSON.stringify(t.comment)}`],t);const i=JSON.stringify(t.delimiter);if(Array.isArray(t.delimiter)||(t.delimiter=[t.delimiter]),t.delimiter.length===0)throw new qt("CSV_INVALID_OPTION_DELIMITER",["Invalid option delimiter:","delimiter must be a non empty string or buffer or array of string|buffer,",`got ${i}`],t);if(t.delimiter=t.delimiter.map(function(s){if(s==null||s===!1)return J.from(",",t.encoding);if(typeof s=="string"&&(s=J.from(s,t.encoding)),!Ei(s)||s.length===0)throw new qt("CSV_INVALID_OPTION_DELIMITER",["Invalid option delimiter:","delimiter must be a non empty string or buffer or array of string|buffer,",`got ${i}`],t);return s}),t.escape===void 0||t.escape===!0?t.escape=J.from('"',t.encoding):typeof t.escape=="string"?t.escape=J.from(t.escape,t.encoding):t.escape!==null&&t.escape!==!1||(t.escape=null),t.escape!==null&&!Ei(t.escape))throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(t.escape)}`);if(t.from===void 0||t.from===null)t.from=1;else{if(typeof t.from=="string"&&/\d+/.test(t.from)&&(t.from=parseInt(t.from)),!Number.isInteger(t.from))throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(t.from)}`);if(t.from<0)throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(n.from)}`)}if(t.from_line===void 0||t.from_line===null)t.from_line=1;else{if(typeof t.from_line=="string"&&/\d+/.test(t.from_line)&&(t.from_line=parseInt(t.from_line)),!Number.isInteger(t.from_line))throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(n.from_line)}`);if(t.from_line<=0)throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(n.from_line)}`)}if(t.ignore_last_delimiters===void 0||t.ignore_last_delimiters===null)t.ignore_last_delimiters=!1;else if(typeof t.ignore_last_delimiters=="number")t.ignore_last_delimiters=Math.floor(t.ignore_last_delimiters),t.ignore_last_delimiters===0&&(t.ignore_last_delimiters=!1);else if(typeof t.ignore_last_delimiters!="boolean")throw new qt("CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS",["Invalid option `ignore_last_delimiters`:","the value must be a boolean value or an integer,",`got ${JSON.stringify(t.ignore_last_delimiters)}`],t);if(t.ignore_last_delimiters===!0&&t.columns===!1)throw new qt("CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS",["The option `ignore_last_delimiters`","requires the activation of the `columns` option"],t);if(t.info===void 0||t.info===null||t.info===!1)t.info=!1;else if(t.info!==!0)throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(t.info)}`);if(t.max_record_size===void 0||t.max_record_size===null||t.max_record_size===!1)t.max_record_size=0;else if(!(Number.isInteger(t.max_record_size)&&t.max_record_size>=0)){if(typeof t.max_record_size!="string"||!/\d+/.test(t.max_record_size))throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(t.max_record_size)}`);t.max_record_size=parseInt(t.max_record_size)}if(t.objname===void 0||t.objname===null||t.objname===!1)t.objname=void 0;else if(Ei(t.objname)){if(t.objname.length===0)throw new Error("Invalid Option: objname must be a non empty buffer");t.encoding===null||(t.objname=t.objname.toString(t.encoding))}else if(typeof t.objname=="string"){if(t.objname.length===0)throw new Error("Invalid Option: objname must be a non empty string")}else if(typeof t.objname!="number")throw new Error(`Invalid Option: objname must be a string or a buffer, got ${t.objname}`);if(t.objname!==void 0){if(typeof t.objname=="number"){if(t.columns!==!1)throw Error("Invalid Option: objname index cannot be combined with columns or be defined as a field")}else if(t.columns===!1)throw Error("Invalid Option: objname field must be combined with columns or be defined as an index")}if(t.on_record===void 0||t.on_record===null)t.on_record=void 0;else if(typeof t.on_record!="function")throw new qt("CSV_INVALID_OPTION_ON_RECORD",["Invalid option `on_record`:","expect a function,",`got ${JSON.stringify(t.on_record)}`],t);if(t.quote===null||t.quote===!1||t.quote==="")t.quote=null;else if(t.quote===void 0||t.quote===!0?t.quote=J.from('"',t.encoding):typeof t.quote=="string"&&(t.quote=J.from(t.quote,t.encoding)),!Ei(t.quote))throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(t.quote)}`);if(t.raw===void 0||t.raw===null||t.raw===!1)t.raw=!1;else if(t.raw!==!0)throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(t.raw)}`);if(t.record_delimiter===void 0)t.record_delimiter=[];else if(typeof t.record_delimiter=="string"||Ei(t.record_delimiter)){if(t.record_delimiter.length===0)throw new qt("CSV_INVALID_OPTION_RECORD_DELIMITER",["Invalid option `record_delimiter`:","value must be a non empty string or buffer,",`got ${JSON.stringify(t.record_delimiter)}`],t);t.record_delimiter=[t.record_delimiter]}else if(!Array.isArray(t.record_delimiter))throw new qt("CSV_INVALID_OPTION_RECORD_DELIMITER",["Invalid option `record_delimiter`:","value must be a string, a buffer or array of string|buffer,",`got ${JSON.stringify(t.record_delimiter)}`],t);if(t.record_delimiter=t.record_delimiter.map(function(s,r){if(typeof s!="string"&&!Ei(s))throw new qt("CSV_INVALID_OPTION_RECORD_DELIMITER",["Invalid option `record_delimiter`:","value must be a string, a buffer or array of string|buffer",`at index ${r},`,`got ${JSON.stringify(s)}`],t);if(s.length===0)throw new qt("CSV_INVALID_OPTION_RECORD_DELIMITER",["Invalid option `record_delimiter`:","value must be a non empty string or buffer",`at index ${r},`,`got ${JSON.stringify(s)}`],t);return typeof s=="string"&&(s=J.from(s,t.encoding)),s}),typeof t.relax_column_count!="boolean"){if(t.relax_column_count!==void 0&&t.relax_column_count!==null)throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(t.relax_column_count)}`);t.relax_column_count=!1}if(typeof t.relax_column_count_less!="boolean"){if(t.relax_column_count_less!==void 0&&t.relax_column_count_less!==null)throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(t.relax_column_count_less)}`);t.relax_column_count_less=!1}if(typeof t.relax_column_count_more!="boolean"){if(t.relax_column_count_more!==void 0&&t.relax_column_count_more!==null)throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(t.relax_column_count_more)}`);t.relax_column_count_more=!1}if(typeof t.relax_quotes!="boolean"){if(t.relax_quotes!==void 0&&t.relax_quotes!==null)throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(t.relax_quotes)}`);t.relax_quotes=!1}if(typeof t.skip_empty_lines!="boolean"){if(t.skip_empty_lines!==void 0&&t.skip_empty_lines!==null)throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(t.skip_empty_lines)}`);t.skip_empty_lines=!1}if(typeof t.skip_records_with_empty_values!="boolean"){if(t.skip_records_with_empty_values!==void 0&&t.skip_records_with_empty_values!==null)throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(t.skip_records_with_empty_values)}`);t.skip_records_with_empty_values=!1}if(typeof t.skip_records_with_error!="boolean"){if(t.skip_records_with_error!==void 0&&t.skip_records_with_error!==null)throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(t.skip_records_with_error)}`);t.skip_records_with_error=!1}if(t.rtrim===void 0||t.rtrim===null||t.rtrim===!1)t.rtrim=!1;else if(t.rtrim!==!0)throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(t.rtrim)}`);if(t.ltrim===void 0||t.ltrim===null||t.ltrim===!1)t.ltrim=!1;else if(t.ltrim!==!0)throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(t.ltrim)}`);if(t.trim===void 0||t.trim===null||t.trim===!1)t.trim=!1;else if(t.trim!==!0)throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(t.trim)}`);if(t.trim===!0&&n.ltrim!==!1?t.ltrim=!0:t.ltrim!==!0&&(t.ltrim=!1),t.trim===!0&&n.rtrim!==!1?t.rtrim=!0:t.rtrim!==!0&&(t.rtrim=!1),t.to===void 0||t.to===null)t.to=-1;else{if(typeof t.to=="string"&&/\d+/.test(t.to)&&(t.to=parseInt(t.to)),!Number.isInteger(t.to))throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(n.to)}`);if(t.to<=0)throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(n.to)}`)}if(t.to_line===void 0||t.to_line===null)t.to_line=-1;else{if(typeof t.to_line=="string"&&/\d+/.test(t.to_line)&&(t.to_line=parseInt(t.to_line)),!Number.isInteger(t.to_line))throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(n.to_line)}`);if(t.to_line<=0)throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(n.to_line)}`)}return t},vy=function(n){return n.every(t=>t==null||t.toString&&t.toString().trim()==="")},gc={utf8:J.from([239,187,191]),utf16le:J.from([255,254])},tT=function(n,t={}){typeof n=="string"&&(n=J.from(n));const e=t&&t.objname?{}:[],i=function(l={}){const h=gy(l);return{info:{bytes:0,comment_lines:0,empty_lines:0,invalid_field_length:0,lines:1,records:0},original_options:l,options:h,state:$2(h),__needMoreData:function(c,u,d){if(d)return!1;const{quote:p}=this.options,{quoting:m,needMoreDataSize:f,recordDelimiterMaxLength:v}=this.state;return u-c-1<Math.max(f,v,m?p.length+v:0)},parse:function(c,u,d,p){const{bom:m,from_line:f,ltrim:v,max_record_size:_,raw:y,relax_quotes:x,rtrim:b,skip_empty_lines:w,to:M,to_line:T}=this.options;let{comment:R,escape:E,quote:A,record_delimiter:z}=this.options;const{bomSkipped:F,previousBuf:G,rawBuffer:U,escapeIsQuote:k}=this.state;let H;if(G===void 0){if(c===void 0)return void p();H=c}else H=G!==void 0&&c===void 0?G:J.concat([G,c]);if(F===!1)if(m===!1)this.state.bomSkipped=!0;else if(H.length<3){if(u===!1)return void(this.state.previousBuf=H)}else{for(const X in gc)if(gc[X].compare(H,0,gc[X].length)===0){const K=gc[X].length;this.state.bufBytesStart+=K,H=H.slice(K),this.options=gy({...this.original_options,encoding:X}),{comment:R,escape:E,quote:A}=this.options;break}this.state.bomSkipped=!0}const W=H.length;let N;for(N=0;N<W&&!this.__needMoreData(N,W,u);N++){if(this.state.wasRowDelimiter===!0&&(this.info.lines++,this.state.wasRowDelimiter=!1),T!==-1&&this.info.lines>T)return this.state.stop=!0,void p();this.state.quoting===!1&&z.length===0&&this.__autoDiscoverRecordDelimiter(H,N)&&(z=this.options.record_delimiter);const X=H[N];if(y===!0&&U.append(X),X!==13&&X!==10||this.state.wasRowDelimiter!==!1||(this.state.wasRowDelimiter=!0),this.state.escaping===!0)this.state.escaping=!1;else{if(E!==null&&this.state.quoting===!0&&this.__isEscape(H,N,X)&&N+E.length<W){if(!k){this.state.escaping=!0,N+=E.length-1;continue}if(this.__isQuote(H,N+E.length)){this.state.escaping=!0,N+=E.length-1;continue}}if(this.state.commenting===!1&&this.__isQuote(H,N))if(this.state.quoting===!0){const lt=H[N+A.length],yt=b&&this.__isCharTrimable(H,N+A.length),mt=R!==null&&this.__compareBytes(R,H,N+A.length,lt),bt=this.__isDelimiter(H,N+A.length,lt),I=z.length===0?this.__autoDiscoverRecordDelimiter(H,N+A.length):this.__isRecordDelimiter(lt,H,N+A.length);if(E!==null&&this.__isEscape(H,N,X)&&this.__isQuote(H,N+E.length))N+=E.length-1;else{if(!lt||bt||I||mt||yt){this.state.quoting=!1,this.state.wasQuoting=!0,N+=A.length-1;continue}if(x===!1){const P=this.__error(new qt("CSV_INVALID_CLOSING_QUOTE",["Invalid Closing Quote:",`got "${String.fromCharCode(lt)}"`,`at line ${this.info.lines}`,"instead of delimiter, record delimiter, trimable character","(if activated) or comment"],this.options,this.__infoField()));if(P!==void 0)return P}else this.state.quoting=!1,this.state.wasQuoting=!0,this.state.field.prepend(A),N+=A.length-1}}else{if(this.state.field.length===0){this.state.quoting=!0,N+=A.length-1;continue}if(x===!1){const lt=this.__error(new qt("INVALID_OPENING_QUOTE",["Invalid Opening Quote:",`a quote is found inside a field at line ${this.info.lines}`],this.options,this.__infoField(),{field:this.state.field}));if(lt!==void 0)return lt}}if(this.state.quoting===!1){const lt=this.__isRecordDelimiter(X,H,N);if(lt!==0){if(this.state.commenting&&this.state.wasQuoting===!1&&this.state.record.length===0&&this.state.field.length===0)this.info.comment_lines++;else{if(this.state.enabled===!1&&this.info.lines+(this.state.wasRowDelimiter===!0?1:0)>=f){this.state.enabled=!0,this.__resetField(),this.__resetRecord(),N+=lt-1;continue}if(w===!0&&this.state.wasQuoting===!1&&this.state.record.length===0&&this.state.field.length===0){this.info.empty_lines++,N+=lt-1;continue}this.info.bytes=this.state.bufBytesStart+N;const mt=this.__onField();if(mt!==void 0)return mt;this.info.bytes=this.state.bufBytesStart+N+lt;const bt=this.__onRecord(d);if(bt!==void 0)return bt;if(M!==-1&&this.info.records>=M)return this.state.stop=!0,void p()}this.state.commenting=!1,N+=lt-1;continue}if(this.state.commenting)continue;if((R===null?0:this.__compareBytes(R,H,N,X))!==0){this.state.commenting=!0;continue}const yt=this.__isDelimiter(H,N,X);if(yt!==0){this.info.bytes=this.state.bufBytesStart+N;const mt=this.__onField();if(mt!==void 0)return mt;N+=yt-1;continue}}}if(this.state.commenting===!1&&_!==0&&this.state.record_length+this.state.field.length>_)return this.__error(new qt("CSV_MAX_RECORD_SIZE",["Max Record Size:","record exceed the maximum number of tolerated bytes",`of ${_}`,`at line ${this.info.lines}`],this.options,this.__infoField()));const K=v===!1||this.state.quoting===!0||this.state.field.length!==0||!this.__isCharTrimable(H,N),$=b===!1||this.state.wasQuoting===!1;if(K!==!0||$!==!0){if(b!==!0||this.__isCharTrimable(H,N)){K===!1&&(N+=this.__isCharTrimable(H,N)-1);continue}return this.__error(new qt("CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE",["Invalid Closing Quote:","found non trimable byte after quote",`at line ${this.info.lines}`],this.options,this.__infoField()))}this.state.field.append(X)}if(u===!0)if(this.state.quoting===!0){const X=this.__error(new qt("CSV_QUOTE_NOT_CLOSED",["Quote Not Closed:",`the parsing is finished with an opening quote at line ${this.info.lines}`],this.options,this.__infoField()));if(X!==void 0)return X}else if(this.state.wasQuoting===!0||this.state.record.length!==0||this.state.field.length!==0){this.info.bytes=this.state.bufBytesStart+N;const X=this.__onField();if(X!==void 0)return X;const K=this.__onRecord(d);if(K!==void 0)return K}else this.state.wasRowDelimiter===!0?this.info.empty_lines++:this.state.commenting===!0&&this.info.comment_lines++;else this.state.bufBytesStart+=N,this.state.previousBuf=H.slice(N);this.state.wasRowDelimiter===!0&&(this.info.lines++,this.state.wasRowDelimiter=!1)},__onRecord:function(c){const{columns:u,group_columns_by_name:d,encoding:p,info:m,from:f,relax_column_count:v,relax_column_count_less:_,relax_column_count_more:y,raw:x,skip_records_with_empty_values:b}=this.options,{enabled:w,record:M}=this.state;if(w===!1)return this.__resetRecord();const T=M.length;if(u===!0)return b===!0&&vy(M)?void this.__resetRecord():this.__firstLineToColumns(M);if(u===!1&&this.info.records===0&&(this.state.expectedRecordLength=T),T!==this.state.expectedRecordLength){const R=u===!1?new qt("CSV_RECORD_INCONSISTENT_FIELDS_LENGTH",["Invalid Record Length:",`expect ${this.state.expectedRecordLength},`,`got ${T} on line ${this.info.lines}`],this.options,this.__infoField(),{record:M}):new qt("CSV_RECORD_INCONSISTENT_COLUMNS",["Invalid Record Length:",`columns length is ${u.length},`,`got ${T} on line ${this.info.lines}`],this.options,this.__infoField(),{record:M});if(v===!0||_===!0&&T<this.state.expectedRecordLength||y===!0&&T>this.state.expectedRecordLength)this.info.invalid_field_length++,this.state.error=R;else{const E=this.__error(R);if(E)return E}}if(b===!0&&vy(M))this.__resetRecord();else{if(this.state.recordHasError===!0)return this.__resetRecord(),void(this.state.recordHasError=!1);if(this.info.records++,f===1||this.info.records>=f){const{objname:R}=this.options;if(u!==!1){const E={};for(let A=0,z=M.length;A<z;A++)u[A]===void 0||u[A].disabled||(d===!0&&E[u[A].name]!==void 0?Array.isArray(E[u[A].name])?E[u[A].name]=E[u[A].name].concat(M[A]):E[u[A].name]=[E[u[A].name],M[A]]:E[u[A].name]=M[A]);if(x===!0||m===!0){const A=Object.assign({record:E},x===!0?{raw:this.state.rawBuffer.toString(p)}:{},m===!0?{info:this.__infoRecord()}:{}),z=this.__push(R===void 0?A:[E[R],A],c);if(z)return z}else{const A=this.__push(R===void 0?E:[E[R],E],c);if(A)return A}}else if(x===!0||m===!0){const E=Object.assign({record:M},x===!0?{raw:this.state.rawBuffer.toString(p)}:{},m===!0?{info:this.__infoRecord()}:{}),A=this.__push(R===void 0?E:[M[R],E],c);if(A)return A}else{const E=this.__push(R===void 0?M:[M[R],M],c);if(E)return E}}this.__resetRecord()}},__firstLineToColumns:function(c){const{firstLineToHeaders:u}=this.state;try{const d=u===void 0?c:u.call(null,c);if(!Array.isArray(d))return this.__error(new qt("CSV_INVALID_COLUMN_MAPPING",["Invalid Column Mapping:","expect an array from column function,",`got ${JSON.stringify(d)}`],this.options,this.__infoField(),{headers:d}));const p=my(d);return this.state.expectedRecordLength=p.length,this.options.columns=p,void this.__resetRecord()}catch(d){return d}},__resetRecord:function(){this.options.raw===!0&&this.state.rawBuffer.reset(),this.state.error=void 0,this.state.record=[],this.state.record_length=0},__onField:function(){const{cast:c,encoding:u,rtrim:d,max_record_size:p}=this.options,{enabled:m,wasQuoting:f}=this.state;if(m===!1)return this.__resetField();let v=this.state.field.toString(u);if(d===!0&&f===!1&&(v=v.trimRight()),c===!0){const[_,y]=this.__cast(v);if(_!==void 0)return _;v=y}this.state.record.push(v),p!==0&&typeof v=="string"&&(this.state.record_length+=v.length),this.__resetField()},__resetField:function(){this.state.field.reset(),this.state.wasQuoting=!1},__push:function(c,u){const{on_record:d}=this.options;if(d!==void 0){const p=this.__infoRecord();try{c=d.call(null,c,p)}catch(m){return m}if(c==null)return}u(c)},__cast:function(c){const{columns:u,relax_column_count:d}=this.options;if(Array.isArray(u)===!0&&d&&this.options.columns.length<=this.state.record.length)return[void 0,void 0];if(this.state.castField!==null)try{const p=this.__infoField();return[void 0,this.state.castField.call(null,c,p)]}catch(p){return[p]}if(this.__isFloat(c))return[void 0,parseFloat(c)];if(this.options.cast_date!==!1){const p=this.__infoField();return[void 0,this.options.cast_date.call(null,c,p)]}return[void 0,c]},__isCharTrimable:function(c,u){return((d,p)=>{const{timchars:m}=this.state;t:for(let f=0;f<m.length;f++){const v=m[f];for(let _=0;_<v.length;_++)if(v[_]!==d[p+_])continue t;return v.length}return 0})(c,u)},__isFloat:function(c){return c-parseFloat(c)+1>=0},__compareBytes:function(c,u,d,p){if(c[0]!==p)return 0;const m=c.length;for(let f=1;f<m;f++)if(c[f]!==u[d+f])return 0;return m},__isDelimiter:function(c,u,d){const{delimiter:p,ignore_last_delimiters:m}=this.options;if(m===!0&&this.state.record.length===this.options.columns.length-1||m!==!1&&typeof m=="number"&&this.state.record.length===m-1)return 0;t:for(let f=0;f<p.length;f++){const v=p[f];if(v[0]===d){for(let _=1;_<v.length;_++)if(v[_]!==c[u+_])continue t;return v.length}}return 0},__isRecordDelimiter:function(c,u,d){const{record_delimiter:p}=this.options,m=p.length;t:for(let f=0;f<m;f++){const v=p[f],_=v.length;if(v[0]===c){for(let y=1;y<_;y++)if(v[y]!==u[d+y])continue t;return v.length}}return 0},__isEscape:function(c,u,d){const{escape:p}=this.options;if(p===null)return!1;const m=p.length;if(p[0]===d){for(let f=0;f<m;f++)if(p[f]!==c[u+f])return!1;return!0}return!1},__isQuote:function(c,u){const{quote:d}=this.options;if(d===null)return!1;const p=d.length;for(let m=0;m<p;m++)if(d[m]!==c[u+m])return!1;return!0},__autoDiscoverRecordDelimiter:function(c,u){const{encoding:d}=this.options,p=c[u];return p===13?c[u+1]===10?(this.options.record_delimiter.push(J.from(`\r
`,d)),this.state.recordDelimiterMaxLength=2,2):(this.options.record_delimiter.push(J.from("\r",d)),this.state.recordDelimiterMaxLength=1,1):p===10?(this.options.record_delimiter.push(J.from(`
`,d)),this.state.recordDelimiterMaxLength=1,1):0},__error:function(c){const{encoding:u,raw:d,skip_records_with_error:p}=this.options,m=typeof c=="string"?new Error(c):c;return p?(this.state.recordHasError=!0,void(this.options.on_skip!==void 0&&this.options.on_skip(m,d?this.state.rawBuffer.toString(u):void 0))):m},__infoDataSet:function(){return{...this.info,columns:this.options.columns}},__infoRecord:function(){const{columns:c,raw:u,encoding:d}=this.options;return{...this.__infoDataSet(),error:this.state.error,header:c===!0,index:this.state.record.length,raw:u?this.state.rawBuffer.toString(d):void 0}},__infoField:function(){const{columns:c}=this.options,u=Array.isArray(c);return{...this.__infoRecord(),column:u===!0?c.length>this.state.record.length?c[this.state.record.length].name:null:this.state.record.length,quoting:this.state.wasQuoting}}}}(t),s=l=>{i.options.objname===void 0?e.push(l):e[l[0]]=l[1]},r=()=>{},a=i.parse(n,!1,s,r);if(a!==void 0)throw a;const o=i.parse(void 0,!0,s,r);if(o!==void 0)throw o;return e};function Up(n,t,e=2e-7){return fa(n,t)<e}function fa(n,t){return Math.sqrt(Math.pow(n[0]-t[0],2)+Math.pow(n[1]-t[1],2)+Math.pow((n[2]||0)-(t[2]||0),2))}function Zs(n,t,e){return n+(t-n)*e}function Fp(n,t,e){return[n[0]+(t[0]-n[0])*e,n[1]+(t[1]-n[1])*e]}function vc(n,t,e){return[n[0]+(t[0]-n[0])*e,n[1]+(t[1]-n[1])*e,n[2]+(t[2]-n[2])*e]}function as(n,t){let e=new V;return e.fromArray([t[0]-n[0],t[1]-n[1]]),e.normalize(),e}function ga(n){return new V(-n.y,n.x)}const _y=class extends _o{constructor(n){super(n),g(this,"_csvDataType"),g(this,"_pointSize",3),g(this,"_csvFeatures",[]),g(this,"_csvIndexMap",[]),this.type="CSVDataSource"}async _getFetchData(n){return await n.text()}onClear(){this._csvDataType=void 0,this._csvFeatures=[]}_onProcessTemplateData(n){return this._prepareFeatures(),this._parseFeature(n),n}_parseFeature(n){let t=0;for(let e=0;e<this._csvFeatures.length;e++){const i=[this._csvFeatures[e]];for(let s=0;s<i.length;s++){const r=i[s];n.position.push(r.geometry[this.projectionName]),s>0&&t++,n.index.push(e+t),this._csvIndexMap[e+t]=[e,s];for(const a of this._attributeMap.keys())r.properties&&r.properties[this._attributeMap.get(a)]?n[a].push(r.properties[this._attributeMap.get(a)]):this._attributeMap.get(a)instanceof Function?n[a].push(this._attributeMap.get(a)(r.properties)):n[a].push(void 0)}}return null}_prepareFeatures(){var n,t;this._csvFeatures=this.csvToFeatures(),this._csvDataType=(t=(n=this._csvFeatures[0])==null?void 0:n.geometry)==null?void 0:t.type}csvToFeatures(){if(!this.origin)return[];let n=tT(this.origin,{columns:!0,skip_empty_lines:!0});const t=[];for(let e=0;e<n.length;e++){const i=n[e],s={};let r;Object.keys(i).forEach(a=>{a==="coordinates"?r=this._csvToFeature(s,i[a]):s[a]=i[a]}),Array.isArray(r)?t.push(...r):t.push(r)}return Vd(t,this.projectionName)}_csvToFeature(n,t){const{coordinates:e,type:i,isMulti:s}=this._parseCoordinates(t);let r=null;if(s){r=[];for(let a=0;a<e.length;a++)r.push({geometry:{coordinates:e[a],type:i},properties:n})}else r={geometry:{coordinates:e,type:i},properties:n};return r}_parseCoordinates(n){let t=n.split(";");const e=t.length;let i=[];for(let a=0;a<e;a++){const o=t[a].split(",").map(h=>+h.trim());let l=null;if(o.length===this._pointSize)l=o.slice(0,this._pointSize);else{let h=0;for(l=[];h<o.length;)l.push(o.slice(h,h+this._pointSize)),h+=this._pointSize}i.push(l)}let s=this._getTypeByCoords(i[0]);const r=e>1;return r||(i=i[0]),{coordinates:s==="Polygon"?[i]:i,type:s,isMulti:r}}_getTypeByCoords(n){if(Array.isArray(n[0])&&n.length>1){const t=n.length;return Up(n[0],n[t-1])?"Polygon":"LineString"}return"Point"}get csvDataType(){return this._csvDataType}get pointSize(){return this._pointSize}set pointSize(n){this._pointSize=n}};let yy=_y;g(yy,"fromCSV",async function(n){let t=new _y;return await t.load(n),t});class eT{constructor(){g(this,"_process",[]),g(this,"_hasTime",!1)}provide(t){let e=0;this._hasTime||(e=new Date().valueOf());for(let i=0;i<t.length;i++){const s=t[i];for(let r=0;r<this._process.length;r++){const a=this._process[r];typeof a[1]=="string"&&s[a[1]]?s[a[0]]=s[a[1]]:a[1]instanceof Function?s[a[0]]=a[1](s):s[a[0]]=void 0}this._hasTime||(s.time=e)}return t}process(t,e){return t==="time"&&(this._hasTime=!0),this._process.push([t,e]),this}}class iT{constructor(t){g(this,"id",null),g(this,"data",[]),g(this,"interpolateDirectThreshold",10),t&&typeof t=="number"&&(this.data=new Array(t))}tick(t,e){let i=this.data[0],s=this.data[1];if(!i||!s)return null;const r=(e-i.time)/(s.time-i.time),a=vc(i.point,s.point,r),o=t.map.projectPointArr(a);let l=i.dir,h=fa(o,t.map.projectPointArr(s.point));return h<this.interpolateDirectThreshold&&(l=Zs(l,s.dir,1-h/this.interpolateDirectThreshold)),{...i,id:this.id,modelType:i.modelType,ratio:r,point:a,position:o,dir:l}}push(t){if(!this.id&&t&&(this.id=t.id,this.modelType=t.modelType),this.id)return this.data.push(t)}shift(){return this.data.shift()}splice(t,e,...i){return this.data.splice(t,e,...i)}get length(){return this.data.length}get empty(){return this.data.join("")===""}}class nT{constructor(t){g(this,"_entities",new Map),g(this,"_entityCacheTimes",[]),g(this,"_startTime",1/0),g(this,"_timeOffset",0),this.delay=t.delay}push(t){const e=t[0].time,i=this._entities;for(let s=0;s<t.length;s++){const r=t[s];i.get(r.id)||i.set(r.id,new iT(this._entityCacheTimes.length)),i.get(r.id).push(r)}Array.from(i.entries()).forEach(([s,r])=>{r.length===this._entityCacheTimes.length&&r.push(void 0)}),this._entityCacheTimes.push(e)}shift(t){const e=this._entities,i=this._entityCacheTimes;let s=0,r=[];for(let a=1;a<i.length;a++){const o=i[a];if(t-this.delay-this.timeOffset<o)break;s+=1}return i.splice(0,s),Array.from(e.entries()).forEach(([a,o])=>{o.splice(0,s),o.empty&&(e.delete(a),r.push(a))}),r}tick(t,e){if(e-this.delay<this._startTime)return{};this.shift(e);const i=Array.from(this._entities.values()),s=[],r=[],a=[],o=[],l=[],h=[],c=[],u=[],d={};for(let p=0;p<i.length;p++){let m=i[p].tick(t,e-this.delay-this.timeOffset);m&&(s.push(m.id),r.push(s.length-1),a.push(m.position),o.push(...m.position),l.push(0,0,m.dir),h.push(1,1,1),c.push(m.modelType),u.push(m),d[m.modelType]?d[m.modelType].push(s.length-1):d[m.modelType]=[s.length-1])}return{buffers:{id:s,index:r,position:a,translation:o,rotation:l,scale:h,modelType:c,payload:u},modelIndexMap:d}}get startTime(){return this._startTime}set startTime(t){this._startTime=t}get timeOffset(){return this._timeOffset}set timeOffset(t){this._timeOffset=t}}class sT extends _o{constructor(t){super(t),this.type="BufferDataSource"}getOriginData(t){return t<this._templateDataLength&&this.data.payload?this.data.payload[t]:this._addCache[t-this._templateDataLength]}_onProcessTemplateData(t){let e=this._origin;if(e&&e.position){t.position=e.position,t.index=e.index;for(let i=0;i<e.payload.length;i++){const s=e.payload[i];for(const r of this._attributeMap.keys())t[r]||(t[r]=[]),t[r]=t[r].concat(s[this._attributeMap.get(r)])}}return t}}new at;let _c=new at,Js=new at,zo=new at,yc=new ot,On=[],Ks=new S,va=new Ot;class Ci extends Ds{constructor(t,e){super(),g(this,"type","InstancedMesh"),g(this,"isMesh",!0),g(this,"isInstancedMesh",!0),g(this,"frustumCulled",!1),g(this,"instanceColor",null),g(this,"count",0),g(this,"instanceMatrix"),g(this,"instanceMorphMatrix",new at),g(this,"isEventEntitySupported",!0),g(this,"getInstanceLocalMatrix",(i,s,r)=>null),g(this,"addCustomAttributes",()=>{}),this.geometry=t,this.material=e,this.instanceMatrix=new Di(new Float32Array(0),16)}setData(){const t=this.dataSource.data,e=[],i=[];let s=1/0,r=1/0,a=1/0,o=-1/0,l=-1/0,h=-1/0;for(let u=0;u<t.position.length;u++){const d=t.position[u],[p,m,f=0]=d;p<s&&(s=p),p>o&&(o=p),m<r&&(r=m),m>l&&(l=m),f<a&&(a=f),f>h&&(h=f)}let c=[(s+o)/2,(r+l)/2,(a+h)/2||0];for(let u=0;u<t.position.length;u++){const d=t.position[u];t.index[u];const p=this.getInstanceLocalMatrix(d,[],u),m=new at;m.makeTranslation(d[0]-c[0],d[1]-c[1],(d[2]||0)-c[2]);let f=null;p?(f=new at,f.multiplyMatrices(m,p)):f=m;const v=f.elements;e.push(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[14],v[15]),i.push(Math.random())}this.geometry.setAttribute("instancedRandomFactor",new Di(new Float32Array(i),1)),this.addCustomAttributes(this.geometry,this.dataSource),this.geometry.computeBoundingSphere(),this.geometry.instanceCount=e.length/16,this.instanceMatrix=new Di(new Float32Array(e),16),this.count=this.geometry.instanceCount,this.makeMeshPositionOffset(c),this.needsUpdate=!1}computeInstanceMorphMatrix(){const t=this.material;let e=t.height||0,i=1;if(t.keepSize&&(i=t.zoomUnits||1),t.isUseSize3){const s=t.size3;Ks.set(s[0]*i,s[1]*i,s[2]*i)}else if(t.isUseSize2){const s=t.size2;Ks.set(s[0]*i,s[1]*i,i)}else{let s=t.size||1;Ks.set(s*i,s*i,s*i)}this.instanceMorphMatrix.identity().scale(Ks).premultiply(zo.identity().makeTranslation(0,0,e*i))}getEntityByIndex(t){const e=this.dataSource,i={index:t,value:e.getOriginData(t),itemIndex:e.getOriginDataIndex(t),pairs:{}},s=e.data;for(const r of Object.keys(s))i.pairs[r]=s[r][t];return i}raycast(t,e){if(!this.visible)return;let i=this.geometry,s=this.material,r=this.matrixWorld;if(!s||!i)return;const a=this.instanceMatrix;if(!a)return;const o=a.array;this.computeInstanceMorphMatrix();const l=this.count;if(yc.geometry=this.geometry.getInstanceGeometry?this.geometry.getInstanceGeometry():this.geometry,yc.material=s,s.isInstancedBallonMaterial){const h=t.camera,c=s.resolution,u=t.mouse,d=s.size/c[0],p=s.size/c[1],m=2*(s.height+s.size/2)/c[1],f=u.x-d,v=u.x+d,_=u.y-p-m,y=u.y+p-m;zo.multiplyMatrices(h.matrixWorldInverse,r),zo.multiplyMatrices(h.projectionMatrix,zo);for(let x=0;x<l;++x)if(Js.fromArray(o,16*x),va.set(0,0,0,1).applyMatrix4(Js).applyMatrix4(zo).divideScalar(va.w),va.x>=f&&va.y>=_&&va.x<=v&&va.y<=y){Ks.set(Js.elements[12],Js.elements[13],Js.elements[14]);const b=t.ray.origin.distanceTo(Ks);b>=t.near&&b<=t.far&&(On[0]={distance:b,point:Ks.clone(),itemIndex:x,object:this},e.push(On[0]),On.length=0)}}else for(let h=0;h<l;++h)Js.fromArray(o,16*h),_c.multiplyMatrices(Js,this.instanceMorphMatrix),_c.multiplyMatrices(r,_c),yc.matrixWorld=_c,yc.raycast(t,On),On.length>0&&(On[0].instanceId=h,On[0].object=this,e.push(On[0]),On.length=0)}}class xy extends Ds{constructor(){super(...arguments),g(this,"isPoints",!0),g(this,"isEventEntitySupported",!0)}get size(){return this.material.size}set size(t){this.material.size=t}raycast(t,e){const i=t.params.Points.threshold;let s=i*this.size;this.material.uniforms.zoomUnits&&(s*=this.material.uniforms.zoomUnits.value),t.params.Points.threshold=s,ka.prototype.raycast.call(this,t,e),t.params.Points.threshold=i}getEntityByIndex(t){const e=this.dataSource.data,i={};for(const s of Object.keys(e))i[s]=e[s][t];return i}}class rT extends gt{constructor(t){super(t),this.parameters=t}setData(t){const{vertexSizes:e,vertexColors:i}=this.parameters,{aPositions:s,aObjectIndices:r,aMapIndexs:a,aColors:o,aSizes:l}=t;this.setAttribute("position",new Z(s,3)),this.setAttribute("objectIndex",new Z(r,1)),this.setAttribute("aMapIndex",new Z(a,1)),i&&this.setAttribute("aColor",new Z(o,4)),e&&this.setAttribute("aSize",new Z(l,1))}}const aT=new Te,oT=ft.merge([rt.fog.uniforms,Gi,{emissive:{value:[0,0,0]},isEmissive:{value:!1},color:{value:[0,1,1,1]},size:{value:30},vertexColors:{value:!1},vertexSizes:{value:!1},uShapeType:{value:2},opacity:{value:1},map:{value:null},useMap:{value:!1},pixelRatio:{value:1},offset:{value:[0,0]}}]);class lT extends Fe{constructor(t){super(),this.type="SimplePointMaterial",this.vertexShader=`#define GLSLIFY 1
#include <common>
uniform float zoomUnits;
uniform vec2 resolution;

#ifdef MVT_USE_VERTEX_SIZE
    attribute float aSize;
    varying float vSize;
#endif

#ifdef MVT_USE_VERTEX_OFFSET
    attribute vec2 aOffset;
#else
    uniform vec2 offset;
#endif

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
    varying vec4 vColor;
#endif

uniform float size;
uniform float pixelRatio;

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
void main() { 
    #include <mvt_selective_vertex>
    #ifdef MVT_USE_VERTEX_OFFSET
        vec2 o = aOffset * 2. * pixelRatio * zoomUnits;
    #else
        vec2 o = offset * 2. * pixelRatio * zoomUnits;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    gl_Position.xy = gl_Position.xy - o;

    #ifdef MVT_USE_VERTEX_SIZE
        vSize = aSize * pixelRatio;
        gl_PointSize = vSize;
    #else
        gl_PointSize = size * pixelRatio;
    #endif
    

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #endif

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#endif
uniform vec4 color;
uniform float uShapeType;
uniform float opacity;

#ifdef MVT_USE_VERTEX_SIZE
    varying float vSize;
#else
    uniform float size;
#endif
uniform bool useMap;
uniform sampler2D map;

#include <mvt_selective_pars_fragment>
#include <mvt_emissive_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        gl_FragColor = vColor;
    #else
        gl_FragColor = color;
    #endif

    if (uShapeType == 2.) {
        float d = distance(gl_PointCoord, vec2(0.5, 0.5));
        #ifdef MVT_USE_VERTEX_SIZE
            float alpha = smoothstep(0.5 + 0.5 / vSize, 0.5 - 1.0 / vSize, d);
        #else
            float alpha = smoothstep(0.5 + 0.5 / size, 0.5 - 1.0 / size, d);
        #endif
        
        if (alpha <= 0.) {
            discard;
        } else {
            gl_FragColor.a *= alpha;
        }
    }
 
    if (useMap) {
        vec4 tColor = texture2D(map, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
     //    gl_FragColor.rgb = tColor.rgb * tColor.a + gl_FragColor.rgb * (1.0 - tColor.a);
     //    gl_FragColor.a += tColor.a;
        
        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);
        // gl_FragColor.rgb = mix(gl_FragColor.rgb, tColor.rgb, tColor.a);
        // gl_FragColor.a += tColor.a;
        // gl_FragColor = tColor;
    }
    gl_FragColor.a *= opacity;
    if (gl_FragColor.a <= 0.) {
        discard;
    }
    #include <mvt_selective_fragment> 
    #include <mvt_emissive_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
	#include <encodings_fragment>
    
}`,this.isSimplePointMaterial=!0,this.transparent=!0,Object.assign(this.uniforms,ft.clone(oT)),Qn(this),Jt(this,["size","offset","uShapeType","pixelRatio","opacity","emissive","isEmissive"]),Qr(this,["color"]),Ze(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexSizes","MVT_USE_VERTEX_SIZE"]]),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc;if(this.userData.url_map===e)return;if(i&&i.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData.url_map;const s=aT.load(e);s.wrapS=s.wrapT=1001,this.uniforms.map.value=s,this.userData.url_map=e,this.uniforms.useMap.value=!0}}}),this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}let by=new Ne,My=new S;class xc extends th{constructor(){super(...arguments),g(this,"isCustomInstancedBufferGeometry",!0),g(this,"instanceGeometry",null)}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ne);const t=this.attributes.instancedPosition;t!==void 0?this.boundingBox.setFromBufferAttribute(t):this.boundingBox.makeEmpty(),(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('CustomInstancedBufferGeometry.computeBoundingBox: Computed min/max have NaN values.The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ii);let t=this.attributes.instancedPosition;if(t){let e=this.boundingSphere.center;by.setFromBufferAttribute(t),by.getCenter(e);let i=0;for(let s=0,r=t.count;s<r;s++)My.fromBufferAttribute(t,s),i=Math.max(i,e.distanceToSquared(My));this.boundingSphere.radius=Math.sqrt(i),t.count===1&&(this.boundingSphere.radius=1e5),isNaN(this.boundingSphere.radius)&&console.error('CustomInstancedBufferGeometry.computeBoundingSphere(): Computed radius is NaN.The "position" attribute is likely to have NaN values.',this)}}getInstanceGeometry(){return this.instanceGeometry||(this.instanceGeometry=new gt,this.instanceGeometry.attributes=this.attributes,this.instanceGeometry.index=this.index),this.instanceGeometry}}class bc extends xc{constructor(){super(),g(this,"setModelData",()=>{this.setAttribute("position",new Z([-.5,-.5,0,-.5,.5,0,.5,.5,0,.5,-.5,0],3)),this.setAttribute("uv",new Z([0,0,0,1,1,1,1,0],2)),this.setIndex([0,2,1,0,3,2])}),this.setModelData()}}const hT=n=>{Object.defineProperties(n,{color:{get:function(){return this.uniforms.color.value},set:function(t){this.uniforms.color.value=Kn(t)}},height:{get:function(){return this.uniforms.height.value},set:function(t){this.uniforms.height.value=t}},size:{get:function(){return this.uniforms.size.value},set:function(t){this.uniforms.size.value=t}},size3:{get:function(){return this.uniforms.size3.value},set:function(t){Array.isArray(t)&&t.length===3&&(this.uniforms.size3.value=t)}},useSize3:{get:function(){return this.defines.USE_SIZE3},set:function(t){t===this.defines.USE_SIZE3&&(this.defines.USE_SIZE3=!!t),this.needsUpdate=!0}},opacity:{get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}}})},cT=n=>{Object.defineProperties(n,{animationRotate:{get:function(){return!!this.defines.ENABLE_ANIMATION_ROTATE},set:function(t){t!==this.animationRotate&&(t?this.defines.ENABLE_ANIMATION_ROTATE=!0:delete this.defines.ENABLE_ANIMATION_ROTATE,this.needsUpdate=!0)}},animationRotatePeriod:{get:function(){return this.uniforms.animationRotatePeriod.value},set:function(t){this.uniforms.animationRotatePeriod.value=t}},animationJump:{get:function(){return!!this.defines.ENABLE_ANIMATION_JUMP},set:function(t){t!==this.animationJump&&(t?this.defines.ENABLE_ANIMATION_JUMP=!0:delete this.defines.ENABLE_ANIMATION_JUMP,this.needsUpdate=!0)}},animationJumpPeriod:{get:function(){return this.uniforms.animationJumpPeriod.value},set:function(t){this.uniforms.animationJumpPeriod.value=t}},animationJumpHeight:{get:function(){return this.uniforms.animationJumpHeight.value},set:function(t){this.uniforms.animationJumpHeight.value=t}},animationPeriodOffset:{get:function(){return this.uniforms.animationPeriodOffset.value},set:function(t){this.uniforms.animationPeriodOffset.value=t}},animationEffect:{get:function(){return this.uniforms.animationEffect.value},set:function(t){this.uniforms.animationEffect.value=t}},animationEffectPeriod:{get:function(){return this.uniforms.animationEffectPeriod.value},set:function(t){this.uniforms.animationEffectPeriod.value=t}}})},uT=ft.merge([rt.fog.uniforms,{height:{value:0},size:{value:1},size3:{value:[1,1,1]},resolution:{value:[1,1]},zoomUnits:{value:1},color:{value:[1,0,0,1]},opacity:{value:1}},{animationRotatePeriod:{value:4e3},animationJumpPeriod:{value:4e3},animationJumpHeight:{value:30},animationPeriodOffset:{value:!1},animationEffect:{value:!0},animationEffectPeriod:{value:4e3}},Gi,Nd,{isCesium:{value:!1}}]);class dn extends Fe{constructor(t){super(),this.type="InstancedEffectPointMaterial",this.isInstancedEffectPointMaterial=!0,this.lights=!1,this.transparent=!0,Object.assign(this.uniforms,ft.clone(uT)),hT(this),cT(this),Qn(this),kd(this),this.setValues(t)}}const dT=ft.merge([rt.fog.uniforms,Gi,{elapsedTime:{value:0}}]);class pT extends dn{constructor(t){super(t),g(this,"type","SpecialPointMaterial"),g(this,"isSpecialPointMaterial",!0),this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute vec3 instancedPosition;
attribute float instancedRandomFactor;

uniform float height;
uniform float size;
uniform float elapsedTime;
uniform bool animationEffect;
uniform float animationEffectPeriod;

varying vec2 vPosition;
varying float vEffectRatio;
varying vec2 vUV;

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>

void main() {
    vUV = uv;
    #include <mvt_selective_vertex>
    vPosition = position.xy;
    vec3 transformed = vec3(position);
 
    #include <mvt_animation_vertex>

    transformed *= size;
  
    #include <mvt_keepsize_vertex>

    // gl_Position = projectionMatrix * modelViewMatrix * 
    //     vec4(instancedPosition + transformed, 1.0);
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);
}`,this.fragmentShader=`#define GLSLIFY 1
#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))
#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )
#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )
#define M_PI 3.1415926535897932384626433832795

#define blue1 vec3(0.74,0.95,1.00)
#define blue2 vec3(0.87,0.98,1.00)
#define blue3 vec3(0.35,0.76,0.83)
#define blue4 vec3(0.953,0.969,0.89)
#define red   vec3(1.00,0.38,0.227)

#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))

uniform float ratio;

float PI = 3.1415926;
uniform float elapsedTime;
uniform vec2 resolution; 
varying vec2 vPosition;
varying vec2 vUV;

float movingLine(vec2 uv, vec2 center, float radius)
{
    //angle of the line
    float theta0 = 90.0 * elapsedTime / 1000.;
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    if(r<radius)
    {
        //compute the distance to the line theta=theta0
        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),
                            -sin(theta0*M_PI/180.0));
        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );
        d = normalize(d);
        //compute gradient based on angle difference to theta0
        float theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);
        float gradient = clamp(1.0-theta/90.0,0.0,1.0);
        return SMOOTH(l,1.0)+0.5*gradient;
    }
    else return 0.0;
}

float circle(vec2 uv, vec2 center, float radius, float width)
{
    float r = length(uv - center);
    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);
}

float circle2(vec2 uv, vec2 center, float radius, float width, float opening)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    if( abs(d.y) > opening )
        return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);
    else
        return 0.0;
}
float circle3(vec2 uv, vec2 center, float radius, float width)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    float theta = 180.0*(atan(d.y,d.x)/M_PI);
    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *
        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *
        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));
}

float triangles(vec2 uv, vec2 center, float radius)
{
    vec2 d = uv - center;
    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))
        + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))
        + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))
        + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));
}

float _cross(vec2 uv, vec2 center, float radius)
{
    vec2 d = uv - center;
    int x = int(d.x);
    int y = int(d.y);
    float r = sqrt( dot( d, d ) );
    if( (r<radius) && ( (x==y) || (x==-y) ) )
        return 1.0;
    else return 0.0;
}
float dots(vec2 uv, vec2 center, float radius)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    if( r <= 2.5 )
        return 1.0;
    if( ( r<= radius) && ( (abs(d.y+0.5)<=1.0) && ( mod(d.x+1.0, 50.0) < 2.0 ) ) )
        return 1.0;
    else if ( (abs(d.y+0.5)<=1.0) && ( r >= 50.0 ) && ( r < 115.0 ) )
        return 0.5;
    else
        return 0.0;
}
float bip1(vec2 uv, vec2 center)
{
    return SMOOTH(length(uv - center),3.0);
}
float bip2(vec2 uv, vec2 center)
{
    float r = length(uv - center);
    float R = 8.0+mod(87.0*elapsedTime / 1000., 80.0);
    return (0.5-0.5*cos(30.0*elapsedTime / 1000.)) * SMOOTH(r,5.0)
        + SMOOTH(6.0,r)-SMOOTH(8.0,r)
        + smoothstep(max(8.0,R-20.0),R,r)-SMOOTH(R,r);
}
void main() { 
    vec2 _uv = vec2(vPosition.x * resolution.x, vPosition.y * resolution.y);
    vec3 finalColor;
    vec2 uv = _uv;
    //center of the image
    vec2 c = vec2(vUV.x / 2.0, vUV.y / 2.0);
    finalColor = vec3( 0.3*_cross(uv, c, 240.0) );
    finalColor += ( circle(uv, c, 100.0, 1.0)
                + circle(uv, c, 165.0, 1.0) ) * blue1;
    finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;
    finalColor += circle3(uv, c, 313.0, 4.0) * blue1;
    finalColor += triangles(uv, c, 315.0 + 30.0*sin(elapsedTime / 1000.)) * blue2;
    finalColor += movingLine(uv, c, 240.0) * blue3;
    finalColor += circle(uv, c, 10.0, 1.0) * blue3;
    finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(elapsedTime / 1000.)) * blue3;
    if( length(uv-c) < 240.0 )
    {
        //animate some bips with random movements
        vec2 p = 130.0*MOV(1.3,1.0,1.0,1.4,3.0+0.1*elapsedTime / 1000.);
        finalColor += bip1(uv, c+p) * vec3(1,1,1);
        p = 130.0*MOV(0.9,-1.1,1.7,0.8,-2.0+sin(0.1*elapsedTime / 1000.)+0.15*elapsedTime / 1000.);
        finalColor += bip1(uv, c+p) * vec3(1,1,1);
        p = 50.0*MOV(1.54,1.7,1.37,1.8,sin(0.1*elapsedTime / 1000.+7.0)+0.2*elapsedTime / 1000.);
        // finalColor += bip2(uv,c+p) * red;
    }

    gl_FragColor = vec4( finalColor, 1.0 );
    // gl_FragColor.a *= finalColor.r;
    
}`,this.transparent=!0,this.side=2,this.depthWrite=!1,Object.assign(this.uniforms,ft.clone(dT)),Jt(this,["elapsedTime"]),this.setValues(t)}}class mT extends dn{constructor(t){super(t),g(this,"type","InstancedFanMaterial"),g(this,"isInstancedFanMaterial",!0),this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute vec3 instancedPosition;
attribute float instancedRandomFactor;

uniform float height;
uniform float size;
uniform float elapsedTime;
uniform bool animationEffect;
uniform float animationEffectPeriod;

varying vec2 vPosition;
varying float vEffectRatio;

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>

void main() {
   
    #include <mvt_selective_vertex>
    vPosition = position.xy;
    vec3 transformed = vec3(position);
 
    #include <mvt_animation_vertex>

    transformed *= size;
  
    #include <mvt_keepsize_vertex>

    // gl_Position = projectionMatrix * modelViewMatrix * 
    //     vec4(instancedPosition + transformed, 1.0);
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);
}`,this.fragmentShader=`#define GLSLIFY 1
// #include <common>

uniform vec4 color;
uniform float opacity;
uniform bool animationEffect;

varying float vEffectRatio;
varying vec2 vPosition;

// #include <mvt_selective_pars_fragment>

void main() {
   
    float bb = atan(vPosition.y, vPosition.x) + 3.15;

    float pi = 3.14 * 1.;
    // bb = mod(bb, 6.28);
    if (bb > pi) {
        discard;
    } else { 
        float aa = mod(bb / pi, 1.0);
        float dis = distance(vPosition, vec2(0, 0));
        if (dis > 0.5) {
            discard;
        } else {
            gl_FragColor = color;
            gl_FragColor.a *= aa;
        }
    } 
    #include <tonemapping_fragment>
	#include <encodings_fragment>
    
    // #include <mvt_selective_fragment>
}`}}const wy=`#define GLSLIFY 1
#include <common>

attribute vec3 instancedPosition;
attribute float instancedRandomFactor;

uniform float height;
uniform float size;
uniform float elapsedTime;
uniform bool animationEffect;
uniform float animationEffectPeriod;

varying vec2 vPosition;
varying float vEffectRatio;

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <logdepthbuf_pars_vertex>
void main() {
   
    #include <mvt_selective_vertex>
    vPosition = position.xy;
    vec3 transformed = vec3(position);
 
    #include <mvt_animation_vertex>

    transformed *= size;
  
    #include <mvt_keepsize_vertex>
    
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);
    #include <logdepthbuf_vertex>
}`,fT=ft.merge([{color:{value:[1,1,0,1]},size:{value:10},duration:{value:2e3},trail:{value:.5},center:{value:.1},radius:{value:.5},radiusDiff:{value:.08}}]);class gT extends dn{constructor(t){super(t),g(this,"type","InstancedBubbleMaterial"),g(this,"isInstancedBubbleMaterial",!0),this.depthTest=!1,this.depthWrite=!1,t.type=="Breath"?(this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute vec3 instancedPosition;
attribute float instancedRandomFactor;

uniform float height;
uniform float size;
uniform float elapsedTime;
uniform bool animationEffect;
uniform float animationEffectPeriod;

varying vec2 vPosition;
varying float vEffectRatio;

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <logdepthbuf_pars_vertex>
void main() {
   
    #include <mvt_selective_vertex>
    vPosition = position.xy;
    vec3 transformed = vec3(position);
 
    #include <mvt_animation_vertex>

    transformed *= size;
  
    #include <mvt_keepsize_vertex>

    if (animationEffect) {
        vEffectRatio = mod(elapsedTime, animationEffectPeriod) / animationEffectPeriod;
        if (animationPeriodOffset) {
            vEffectRatio += instancedRandomFactor;
        }
        vEffectRatio = mod(vEffectRatio, 1.0);
        transformed *= vEffectRatio;
    } else {
        vEffectRatio = 1.0;
    }
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);
    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform vec4 color;
uniform float opacity;
uniform bool animationEffect;

varying float vEffectRatio;
varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
    float d = distance(vPosition, vec2(0, 0));
    if (d > 0.5) {
        discard;
    }

    gl_FragColor = color;
    
    gl_FragColor.a *= opacity;
    if (animationEffect) {
        if (vEffectRatio > 0.7) {
            gl_FragColor.a *= (1.0 - vEffectRatio) / 0.3;
        }
    }

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
	#include <encodings_fragment>
    
}`):t.type=="Wave"?(this.vertexShader=wy,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform vec4 color;
uniform float opacity;
uniform bool animationEffect;
uniform float elapsedTime;
uniform float duration;
uniform float trail;
uniform float radiusDiff;
uniform float center;
uniform float radius;

varying float vEffectRatio;
varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
    float d = distance(vPosition, vec2(0, 0));
    if (d > radius) {
        discard;
    }
    vec4 vColor = color;
    
    float alpha = sin((radiusDiff - d) / radiusDiff * trail * 2.0  * 3.14 + elapsedTime / duration * 10.);
    // 中心点
    if (d <= center){
      if (d > 0.9 * center && d <= center) {
        if (alpha >= 0.5) {
          vColor.a = 1.0;
        } else {
          vColor.a = 1.0 - smoothstep(center - 0.0001, center, d);
        }
      }
    }
    else {
      if (alpha >= 0.6) {
        vColor.a = 1.0 - d / radius;
        if (alpha >= 0.5 && alpha <= 0.6) {
            vColor.a *= smoothstep(0.0, 0.1, alpha - 0.5);
        }
        
        if (d >= 0.8 * radiusDiff && d <= radiusDiff) {
            vColor.a *= 1.0 - smoothstep(0.9, 1.0, d / radiusDiff);
        }
        
      }
      else {
        vColor.a = 0.0;
      }
    }
    gl_FragColor = vColor;
    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
	  #include <encodings_fragment>
    
}`):(this.vertexShader=wy,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform vec4 color;
uniform float opacity;
uniform bool animationEffect;
uniform float elapsedTime;
uniform float duration;
uniform float trail;
uniform float center;
uniform float radius;

varying float vEffectRatio;
varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
    float d = distance(vPosition, vec2(0, 0));
    if (d > 0.5) {
        discard;
    }
    vec4 vColor = color;
    float range = mod(elapsedTime, (duration + trail));
    float percent = 0.0;
    if (range <= duration) {
      percent = range / duration * 2.0;
    } else {
      percent = 1.0;
    }
    float r = radius * percent;
    
    // 中心点
    if (d <= center){
      if(d > 0.99 * center && d <= center) {
        vColor.a = 1.0 - smoothstep(0.99 * center, center, d);
      }
    }
    else {
      if (d < r) {
        vColor.a = smoothstep(0.1, 0.9, pow(d / r, 2.0) * 0.9);
        // 边缘抗锯齿
        if (d >= 0.99 * r && d <= r) {
          vColor.a *= 1.0 - smoothstep(0.99, 1.0, d / r);
        }
        // 拖尾渐隐
        if (range > duration) {
          vColor.a *= 1.0 - (range - duration) / trail;
        }
      }
      else {
        vColor.a = 0.0;
      }
      
    }
    gl_FragColor = vColor;
    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
	  #include <encodings_fragment>
    
}`),Object.assign(this.uniforms,ft.clone(fT)),this.setValues(t)}}const Uo=new S;new at;const Sy=new at;new at;class vT extends xc{constructor(t){super(t),g(this,"_shapeType","cube"),g(this,"fillNoLine",(e,i,s,r,a)=>{for(let o=0,l=e.length;o<l-2;o+=3)s.push(e[o],e[o+1],e[o+2]),i.push(0),r.push(0),a.push(0)}),g(this,"generateLines",(e,i,s,r,a,o,l)=>{const h=i.length/3;let c,u,d,p,m,f,v,_;for(let y=0,x=e.length;y<x;++y){v=3*e[y][0],_=3*e[y][1],c=i[v],u=i[v+1],d=i[v+2],p=i[_],m=i[_+1],f=i[_+2],i.push(c,u,d,c,u,d,p,m,f,p,m,f),s.push(1,1,1,1),r.push(p,m,f,p,m,f,c,u,d,c,u,d),a.push(1,1,0,0),o.push(1,-1,1,-1);const b=h+4*y;l.push(b,b+1,b+2,b+2,b+1,b+3)}}),g(this,"applyTransformToPositions",(e,i)=>{const s=[];for(let r=0,a=e.length;r<a-2;r+=3)Uo.set(e[r],e[r+1],e[r+2]),Uo.applyMatrix4(i),s.push(Uo.x,Uo.y,Uo.z);return s}),this.parameters=t,this.shapeType=this.parameters.shapeType}get shapeType(){return this._shapeType}set shapeType(t){this._shapeType=t,this.geometry&&this.geometry.dispose();let e=null,i=null,s=null,r=[],a=[],o=[],l=[];if(t==="cube"){e=new Wt(1,1,1),i=Array.from(e.attributes.position.array),s=Array.from(e.index.array),Sy.identity().makeTranslation(0,0,.5),i=this.applyTransformToPositions(i,Sy),this.fillNoLine(i,r,a,o,l);const h=[];for(let c=0;c<24;c+=4)h.push([c,c+1],[c+3,c+2],[c+2,c]);this.generateLines(h,i,r,a,o,l,s)}else if(t==="octahedron"){i=[0,0,1,-.5,-.5,.5,-.5,.5,.5,.5,.5,.5,.5,-.5,.5,0,0,0],s=[0,1,4,0,4,3,0,3,2,0,2,1,1,5,4,4,5,3,3,5,2,2,5,1],this.fillNoLine(i,r,a,o,l);const h=[[0,1],[0,2],[0,3],[0,4],[1,4],[4,3],[3,2],[2,1],[1,5],[2,5],[3,5],[4,5]];this.generateLines(h,i,r,a,o,l,s)}else if(t==="pyramid"){i=[-.5,-.5,1,-.5,.5,1,.5,.5,1,.5,-.5,1,0,0,0,-.25,-.25,.5,-.25,.25,.5,.25,.25,.5,.25,-.25,.5],s=[0,2,1,0,3,2,1,0,4,0,3,4,3,2,4,2,1,4],this.fillNoLine(i,r,a,o,l);const h=[[0,1],[1,2],[2,3],[3,0],[0,4],[1,4],[2,4],[3,4],[6,5],[5,8],[8,7],[7,6]];this.generateLines(h,i,r,a,o,l,s)}e&&e.dispose(),i&&(this.setAttribute("position",new Z(new Float32Array(i),3)),this.setAttribute("isLine",new Z(new Float32Array(r),1)),this.setAttribute("adjacentPoint",new Z(new Float32Array(a),3)),this.setAttribute("isLineStart",new Z(new Float32Array(o),1)),this.setAttribute("lineSide",new Z(new Float32Array(l),1)),this.setIndex(s),this.computeBoundingSphere(),console.log(this.boundingSphere))}dispose(){}}const _T=ft.merge([{lineWidth:{value:2},lineColor:{value:[1,1,0,1]},isCesium:{value:!1}}]);class yT extends dn{constructor(t){super(),this.type="InstancedShapeMaterial",this.isInstancedShapeMaterial=!0,this.isUseSize3=!0,this.side=2,this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute vec3 instancedPosition;
attribute float instancedRandomFactor;
attribute float isLine;
attribute float isLineStart;
attribute float lineSide;
attribute vec3 adjacentPoint;
// attribute mat4 instanceMatrix;

uniform bool isCesium;

uniform float height;
uniform vec3 size3;
uniform vec2 resolution;
uniform float time;
uniform float lineWidth;
varying float vIsLine;

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>

#define MVT_KEEP_PROJECTION_POSITION

vec3 transformPosition(vec3 p) {
    vec3 transformed = vec3(p);

    #include <mvt_animation_vertex>

    transformed *= size3;
    transformed.z += height;

    #include <mvt_keepsize_vertex>

    return transformed;
}
void main() {
    
    #include <mvt_selective_vertex>
    vec4 mvp_projectPosition;
    if (isLine == 1.0) {
        vIsLine = 1.0;
        mat4 m = projectionMatrix * modelViewMatrix * instanceMatrix;
        vec4 p1 = m * vec4(transformPosition(position), 1.0);
        vec4 p2 = m * vec4(transformPosition(adjacentPoint), 1.0);
        mvp_projectPosition = vec4(p1);
        p1 /= p1.w;
        p2 /= p2.w;
        vec2 dir;
        if (isLineStart == 1.0) {
            dir = normalize(p2.xy - p1.xy);
        } else {
            dir = normalize(p1.xy - p2.xy);
        }
        vec2 _normal = vec2(-dir.y, dir.x);
        // multiply by 2 and then divide by 2
        vec2 offset = _normal * lineSide / resolution * lineWidth;
        gl_Position = p1;
        gl_Position.xy += offset;
    } else {
        vIsLine = 0.0;
        vec3 transformed = transformPosition(position);
        // mat4 tm = mat4(
        //     1,0,0,0,
        //     0,1,0,0,
        //     0,0,1,0,
        //     instanceMatrix[3][0],4826138.4,0,1
        // );
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix *
            vec4(transformed, 1.0);
        // gl_Position = projectionMatrix * viewMatrix *
        //     vec4(transformed.x + 12957564.9, transformed.y + 4826138.4, transformed.z + 0.0, 1.0);
        // vTest.x = instanceMatrix[1][1];
        //  gl_Position = projectionMatrix * viewMatrix * 
        //     vec4(instancedPosition + transformed, 1.0);
        mvp_projectPosition = gl_Position;
    }
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform vec4 color;
uniform vec4 lineColor;
uniform float opacity;

varying float vIsLine;

#include <mvt_selective_pars_fragment>

void main() {
    if (vIsLine == 1.0) {
        gl_FragColor = lineColor;
    }
    else {
        gl_FragColor = color;
        // test
        // gl_FragColor.r = vTest.x;
        // gl_FragColor.g = vTest.y;
        // gl_FragColor.b = vTest.z;
        // gl_FragColor.a = 1.0;
        // test end
    }
    gl_FragColor.a *= opacity;
    #include <mvt_selective_fragment>
}`,Object.assign(this.uniforms,ft.clone(_T)),Jt(this,["lineWidth"]),Qr(this,["lineColor"]),this.setValues(t)}}class xT extends gt{constructor(t){super(t),this.parameters=t}setData(t){const{vertexSizes:e,vertexColors:i,vertexOffsets:s}=this.parameters,{aPositions:r,aObjectIndices:a,aMapIndexs:o,aColors:l,aSizes:h,aOffsets:c}=t;this.setAttribute("position",new Z(r,3)),this.setAttribute("objectIndex",new Z(a,1)),this.setAttribute("aMapIndex",new Z(o,1)),i&&this.setAttribute("aColor",new Z(l,4)),e&&this.setAttribute("aSize",new Z(h,1)),s&&this.setAttribute("aOffset",new Z(c,2))}}const bT=new Te,MT=ft.merge([rt.fog.uniforms,Gi,{emissive:{value:[0,0,0]},isEmissive:{value:!1},color:{value:[0,1,1,1]},size:{value:30},offset:{value:[0,0]},ulength:{value:0},useCanvasMap:{value:!1},vertexColors:{value:!1},vertextSizes:{value:!1},vertextOffsets:{value:!1},uShapeType:{value:2},opacity:{value:1},map:{value:null},useMap:{value:!1},pixelRatio:{value:1},zoomUnits:{value:1}}]);class wT extends Fe{constructor(t){super(),this.type="IconPointMaterial",this.vertexShader=`#define GLSLIFY 1
#include <common>

uniform float zoomUnits;
uniform float size;
uniform float pixelRatio;
uniform vec2 resolution;

#ifdef MVT_USE_VERTEX_SIZE
    attribute float aSize;
    varying float vSize;
#endif

#ifdef MVT_USE_VERTEX_OFFSET
    attribute vec2 aOffset;
#else
    uniform vec2 offset;
#endif

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
    varying vec4 vColor;
#endif

#ifdef MVT_USE_VERTEX_ICON
    attribute float aMapIndex;
    varying float vMapIndex;
#endif

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>

void main() { 
    #include <mvt_selective_vertex>

    #ifdef MVT_USE_VERTEX_OFFSET
        vec2 o = aOffset * 2. * pixelRatio * zoomUnits;
    #else
        vec2 o = offset * 2. * pixelRatio * zoomUnits;
    #endif
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    gl_Position.xy = gl_Position.xy - o;

    #ifdef MVT_USE_VERTEX_SIZE
        vSize = aSize * pixelRatio;
        gl_PointSize = vSize;
    #else
        gl_PointSize = size * pixelRatio;
    #endif

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #endif

    #ifdef MVT_USE_VERTEX_ICON
        vMapIndex = aMapIndex;
    #endif

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#endif
uniform vec4 color;
uniform float uShapeType;
uniform float opacity;

#ifdef MVT_USE_VERTEX_SIZE
    varying float vSize;
#else
    uniform float size;
#endif

#ifdef MVT_USE_VERTEX_ICON
    varying float vMapIndex;
    uniform float ulength;
#endif
uniform bool useMap;
uniform bool useCanvasMap;
uniform sampler2D map;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_emissive_pars_fragment>

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        gl_FragColor = vColor;
    #else
        gl_FragColor = color;
    #endif

    if (uShapeType == 2.) {
        float d = distance(gl_PointCoord, vec2(0.5, 0.5));
        #ifdef MVT_USE_VERTEX_SIZE
            float alpha = smoothstep(0.5 + 0.5 / vSize, 0.5 - 1.0 / vSize, d);
        #else
            float alpha = smoothstep(0.5 + 0.5 / size, 0.5 - 1.0 / size, d);
        #endif
        
        if (alpha <= 0.) {
            discard;
        } else {
            gl_FragColor.a *= alpha;
        }
    }
 
    if (useMap) {
        vec4 tColor = texture2D(map, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
     //    gl_FragColor.rgb = tColor.rgb * tColor.a + gl_FragColor.rgb * (1.0 - tColor.a);
     //    gl_FragColor.a += tColor.a;
        
        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);
        // gl_FragColor.rgb = mix(gl_FragColor.rgb, tColor.rgb, tColor.a);
        // gl_FragColor.a += tColor.a;
        // gl_FragColor = tColor;
    }

    #ifdef MVT_USE_VERTEX_ICON
    if(useCanvasMap) {
        vec4 tColor = texture2D(map, vec2(vMapIndex / ulength + 1.0 / ulength * gl_PointCoord.x, 1.0 - gl_PointCoord.y));
        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);
    }
    #endif
    
    gl_FragColor.a *= opacity;
    if (gl_FragColor.a <= 0.) {
        discard;
    }

    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <mvt_emissive_fragment>
}`,this.isIconPointMaterial=!0,this.transparent=!0,Object.assign(this.uniforms,ft.clone(MT)),Qn(this),Jt(this,["resolution","size","offset","uShapeType","pixelRatio","opacity","emissive","isEmissive","zoomUnits"]),Qr(this,["color"]),Ze(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexSizes","MVT_USE_VERTEX_SIZE"],["vertexIcons","MVT_USE_VERTEX_ICON"],["vertexOffsets","MVT_USE_VERTEX_OFFSET"]]),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc,s=this.userData[this.urlCacheKey],r=this;if(s!==e){if(i&&i.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[this.urlCacheKey];bT.load(e,function(a){a.wrapS=a.wrapT=1001,r.uniforms.map.value=a,r.userData[r.urlCacheKey]=e,r.uniforms.useMap.value=!0,r.uniforms.useCanvasMap.value=!1})}}},mapTexture:{get:function(){return this.uniforms.map.value},set:function(e){if(!e)return this.uniforms.map.value=null,void(this.uniforms.useCanvasMap.value=!1);e.wrapS=e.wrapT=1001,this.uniforms.map.value=e,this.uniforms.useMap.value=!1,this.uniforms.useCanvasMap.value=!0,delete this.userData[this.urlCacheKey]}}}),this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}const ST=new Te,TT=ft.merge([rt.fog.uniforms,Gi,Nd,{emissive:{value:[0,0,0]},isEmissive:{value:!1},width:{value:12},height:{value:12},offset:{value:[0,0]},ulength:{value:1},useCanvasMap:{value:!1},vertexIcons:{value:!1},opacity:{value:1},map:{value:null},useMap:{value:!1},pixelRatio:{value:1},zoomUnits:{value:1},uFlat:{value:!1},keepSize:{value:!0}}]);class ET extends Fe{constructor(t){super(),this.type="IconMaterial",this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute float pIndex;
attribute float aMapIndex;

uniform float pixelRatio;
uniform float width;
uniform float height;
uniform float ulength;
uniform vec2 resolution;
uniform vec2 offset;
uniform bool uFlat;

varying vec2 vUv;

#include <mvt_keepsize_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>

void main() { 
    #include <mvt_selective_vertex>

    if (uFlat) {
        float hw = width * 0.5;
        float hh = height * 0.5;
        vec2 o = offset;
        if (keepSize) {
            hw *= zoomUnits;
            hh *= zoomUnits;
            o *= zoomUnits;
        }
        if (pIndex == 1.0) {
            hw = -hw;
        } else if (pIndex == 2.0) {
            
        } else if (pIndex == 3.0) {
            hh = -hh;
        } else {
            hw = -hw;
            hh = -hh;
        }
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + hw, position.y + hh, position.z, 1.0);
    }
    else {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        float w = gl_Position.w;
        gl_Position /= w;

        float hw = width / resolution.x;
        float hh = height / resolution.y;
        vec2 o = offset;
        if (!keepSize) {
            hw /= zoomUnits;
            hh /= zoomUnits;
            o /= zoomUnits;
        }

        gl_Position.x += o.x * 2. / resolution.x;
        gl_Position.y -= o.y * 2. / resolution.y;

        if (pIndex == 1.0) {
            gl_Position.x -= hw;
            gl_Position.y += hh;
        } else if (pIndex == 2.0) {
            gl_Position.x += hw;
            gl_Position.y += hh;
        } else if (pIndex == 3.0) {
            gl_Position.x += hw;
            gl_Position.y -= hh;
        } else {
            gl_Position.x -= hw;
            gl_Position.y -= hh;
        }

        gl_Position *= w;
    }

    vUv = uv;

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform float opacity;

uniform bool useMap;
uniform bool useCanvasMap;
uniform sampler2D map;
uniform float width;
uniform float height;

varying vec2 vUv;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_emissive_pars_fragment>

void main() {

    gl_FragColor = texture2D(map, vec2(vUv.x, vUv.y));
    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);

    if (gl_FragColor.a <= 0.) {
        discard;
    }
    gl_FragColor.a *= opacity;

    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <mvt_emissive_fragment>
}`,this.isIconMaterial=!0,this.transparent=!0,Object.assign(this.uniforms,ft.clone(TT)),kd(this),Qn(this),Jt(this,["width","height","offset","opacity","emissive","isEmissive"]),rn(this,[["flat","uFlat"]]),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc,s=this.userData[this.urlCacheKey],r=this;if(s!==e){if(i&&i.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[this.urlCacheKey];ST.load(e,function(a){a.wrapS=a.wrapT=1001,a.encoding=3001,r.uniforms.map.value=a,r.userData[r.urlCacheKey]=e,r.uniforms.useMap.value=!0,r.uniforms.useCanvasMap.value=!1})}}},mapTexture:{get:function(){return this.uniforms.map.value},set:function(e){if(!e)return this.uniforms.map.value=null,void(this.uniforms.useCanvasMap.value=!1);e.wrapS=e.wrapT=1001,e.encoding=3001,this.uniforms.map.value=e,this.uniforms.useMap.value=!1,this.uniforms.useCanvasMap.value=!0,delete this.userData[this.urlCacheKey]}}}),this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class CT extends gt{constructor(t){super(t),this.parameters=t}setData(t){const{aPositions:e,aObjectIndices:i,aUvs:s,pIndices:r,indices:a}=t;this.setAttribute("position",new Z(e,3)),this.setAttribute("pIndex",new Z(r,1)),this.setAttribute("objectIndex",new Z(i,1)),this.setAttribute("uv",new Z(s,2)),this.setIndex(a)}}const Np=new S,pn=new Ot,Mc=new at;class Ty extends $n{constructor(t){super(t),g(this,"isEventEntitySupported",!0),g(this,"_padding"),g(this,"oldMapTextureRes",{}),g(this,"texture"),g(this,"geometry"),g(this,"material"),g(this,"canvas"),g(this,"ctx"),g(this,"iconUrlHash",new Map),g(this,"getTextureAndHash",(i,s,r,a,o)=>{const l=this,h=this.engine.rendering.pixelRatio,c=this.iconUrlHash;if(!o&&this.oldMapTextureRes)return this.oldMapTextureRes;if(!i[s])return{texture:this.texture,iconUrlHash:c};let u=c.size,d=c.size,p=new Map;for(let y=0;y<i[s].length;y++){const x=i[s][y];c.get(x)===void 0&&(c.set(x,u),p.set(x,u),u++)}if(d===c.size)return this.oldMapTextureRes;let m=this.canvas.toDataURL();const f=c.size*(r+this.padding[0]),v=a+this.padding[1];this.canvas.width=f*h,this.canvas.height=v*h,this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);let _=new Image;return _.setAttribute("crossOrigin","Anonymous"),_.onload=function(){l.ctx.save(),l.ctx.scale(h,h),l.ctx.drawImage(_,0,0,d*(r+l.padding[0]),a+l.padding[1]),l.ctx.restore(),l.texture.dispose(),l.texture=new Se(l.canvas),l.oldMapTextureRes={texture:l.texture,iconUrlHash:c},l.material.mapTexture=l.texture},_.src=m,Array.from(p).forEach((y,x)=>{let b=new Image;b.setAttribute("crossOrigin","Anonymous"),b.onload=function(){l.ctx.save(),l.ctx.scale(h,h),l.ctx.drawImage(b,0,0,b.width,b.height,y[1]*r+l.padding[0]*(y[1]+.5),l.padding[1]/2,r,a),l.ctx.restore(),l.texture.dispose(),l.texture=new Se(l.canvas),l.oldMapTextureRes={texture:l.texture,iconUrlHash:c},l.material.mapTexture=l.texture},b.src=y[0]}),this.texture.dispose(),this.texture=new Se(this.canvas),this.oldMapTextureRes={texture:this.texture,iconUrlHash:c},{texture:this.texture,iconUrlHash:c}}),this.parameters=t,this._padding=this.parameters.padding!==void 0?this.parameters.padding:[2,2];const e=this.canvas=document.createElement("canvas");e.width=e.height=1,this.ctx=e.getContext("2d"),this.texture=new Se(e),this.defineMaterialProxyProperties(["width","height","offset","map","opacity","flat","keepSize"])}initObject(){let{vertexIcons:t,...e}=this.parameters;this.geometry=new CT(this.parameters),this.material=new ET(e),this.material.setCommonUniforms(this.engine.rendering.uniforms)}getDefaultParams(){return{width:12,height:12}}setData(){const t=this.dataSource.data,{vertexIcons:e,inconPropName:i="icon",width:s,height:r}=this.parameters,a=[],o=[],l=[],h=[],c=[];let u="",d={};if(e){const p=this.getTextureAndHash(t,i,s,r,!0);u=p.texture,d=p.iconUrlHash,this.material.mapTexture=u,this.material.uniforms.ulength.value=d.size}for(let p=0;p<t.position.length;p++){const m=t.position[p],f=t.index[p];for(let _=0;_<4;_++)a.push(...m),o.push(_),l.push(f);e?h.push(d.get(t[i][p])/d.size,0,d.get(t[i][p])/d.size,1,(d.get(t[i][p])+1)/d.size,1,(d.get(t[i][p])+1)/d.size,0):h.push(0,0,0,1,1,1,1,0);const v=4*p;c.push(v,v+2,v+1,v,v+3,v+2)}this.geometry.setData({aPositions:a,pIndices:o,aObjectIndices:l,aUvs:h,indices:c}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,a),this.needsUpdate=!1}getEntityByIndex(t){const e=this.dataSource,i={index:t,value:e.getOriginData(t),itemIndex:e.getOriginDataIndex(t),pairs:{}},s=e.data;for(const r of Object.keys(s))i.pairs[r]=s[r][t];return i}raycast(t,e){if(this.flat)return;const i=this.geometry,s=i.getAttribute("position");if(!s||!s.array||!s.array.length===0)return;const r=i.getAttribute("offset");let a=[];r&&(a=r.array);const o=t.camera,l=t.mouse,h=this.material.uniforms.resolution.value,c=l.x,u=l.y,d=this.width/h[0],p=this.height/h[0];let m=0,f=0,v=0,_=0,y=0,x=0;Mc.multiplyMatrices(o.projectionMatrix,o.matrixWorldInverse),Mc.multiplyMatrices(Mc,this.matrixWorld);const b=s.array;let w=0;for(let M=0,T=b.length-11;M<T;M+=12)if(pn.set(b[M],b[M+1],b[M+2],1),pn.applyMatrix4(Mc),pn.divideScalar(pn.w),this.parameters.vertexOffsets?(w=M/12*8,y=a[w]||0,x=a[w+1]||0):(y=this.parameters.offset&&this.parameters.offset[0]||0,x=this.parameters.offset&&this.parameters.offset[1]||0),pn.x+=2*y/h[0],pn.y-=2*x/h[1],m=pn.x-d,v=pn.x+d,f=pn.y-p,_=pn.y+p,m<=c&&v>=c&&f<=u&&_>=u){Np.set(b[M],b[M+1],b[M+2]),Np.applyMatrix4(this.matrixWorld);const R={instanceId:M/12,object:this,distance:Np.distanceTo(o.position)};e.push(R)}}onDispose(){this.texture&&this.texture.dispose()}set padding(t){this._padding=t}get padding(){return this._padding}}const Ai=new Ot,os=new at,_a=new V,AT=new Te,PT=ft.merge([rt.fog.uniforms,Gi,Nd,{emissive:{value:[0,0,0]},isEmissive:{value:!1},width:{value:12},height:{value:12},offset:{value:[0,0]},ulength:{value:1},useCanvasMap:{value:!1},vertexIcons:{value:!1},opacity:{value:1},map:{value:null},useMap:{value:!1},pixelRatio:{value:1},zoomUnits:{value:1},uFlat:{value:!1},keepSize:{value:!0}}]);class RT extends Fe{constructor(t){super(),this.type="LabelMaterial",this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute float pIndex;
attribute float aMapIndex;

uniform float width;
uniform float height;
uniform float ulength;
uniform vec2 resolution;
uniform vec2 offset;
uniform bool uFlat;

varying vec2 vUv;

#include <mvt_keepsize_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>

void main() { 
    #include <mvt_selective_vertex>

    if (uFlat) {
        float hw = width * 0.5;
        float hh = height * 0.5;
        vec2 o = offset;
        if (keepSize) {
            hw *= zoomUnits;
            hh *= zoomUnits;
            o *= zoomUnits;
        }
        if (pIndex == 1.0) {
            hw = -hw;
        } else if (pIndex == 2.0) {
            
        } else if (pIndex == 3.0) {
            hh = -hh;
        } else {
            hw = -hw;
            hh = -hh;
        }
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + hw, position.y + hh, position.z, 1.0);
    }
    else {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        float w = gl_Position.w;
        gl_Position /= w;

        float hw = width / resolution.x;
        float hh = height / resolution.y;
        vec2 o = offset;
        if (!keepSize) {
            hw /= zoomUnits;
            hh /= zoomUnits;
            o /= zoomUnits;
        }

        gl_Position.x += o.x * 2. / resolution.x;
        gl_Position.y -= o.y * 2. / resolution.y;

        if (pIndex == 1.0) {
            gl_Position.x -= hw;
            gl_Position.y += hh;
        } else if (pIndex == 2.0) {
            gl_Position.x += hw;
            gl_Position.y += hh;
        } else if (pIndex == 3.0) {
            gl_Position.x += hw;
            gl_Position.y -= hh;
        } else {
            gl_Position.x -= hw;
            gl_Position.y -= hh;
        }

        gl_Position *= w;
    }

    vUv = uv;

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform float opacity;

uniform bool useMap;
uniform bool useCanvasMap;
uniform sampler2D map;
uniform float width;
uniform float height;

varying vec2 vUv;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_emissive_pars_fragment>

void main() {

    gl_FragColor = texture2D(map, vec2(vUv.x, 1. - vUv.y));
    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);

    if (gl_FragColor.a <= 0.) {
        discard;
    }
    gl_FragColor.a *= opacity;

    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <mvt_emissive_fragment>
}`,this.isLabelMaterial=!0,this.transparent=!0,Object.assign(this.uniforms,ft.clone(PT)),kd(this),Qn(this),rn(this,[["flat","uFlat"]]),Jt(this,["width","height","offset","opacity","emissive","isEmissive"]),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc,s=this.userData[this.urlCacheKey],r=this;if(s!==e){if(i&&i.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[this.urlCacheKey];AT.load(e,function(a){a.wrapS=a.wrapT=1001,a.encoding=3001,r.uniforms.map.value=a,r.userData[r.urlCacheKey]=e,r.uniforms.useMap.value=!0,r.uniforms.useCanvasMap.value=!1})}}},mapTexture:{get:function(){return this.uniforms.map.value},set:function(e){if(!e)return this.uniforms.map.value=null,void(this.uniforms.useCanvasMap.value=!1);e.wrapS=e.wrapT=1001,e.encoding=3001,this.uniforms.map.value=e,this.uniforms.useMap.value=!1,this.uniforms.useCanvasMap.value=!0,delete this.userData[this.urlCacheKey]}}}),this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class LT extends gt{constructor(t){super(t),this.parameters=t}setData(t){const{aPositions:e,aObjectIndices:i,aUvs:s,pIndices:r,indices:a}=t;this.setAttribute("position",new Z(e,3)),this.setAttribute("pIndex",new Z(r,1)),this.setAttribute("objectIndex",new Z(i,1)),this.setAttribute("uv",new Z(s,2)),this.setIndex(a)}}const kp=new S,mn=new Ot,wc=new at;class Ey extends $n{constructor(t){super(t),g(this,"isEventEntitySupported",!0),g(this,"geometry"),g(this,"material"),g(this,"canvas"),g(this,"ctx"),g(this,"texture"),g(this,"iconUrlHash",new Map),g(this,"labelHash",new Map),g(this,"boxHash",new Map),g(this,"gap",[2,2]),g(this,"_padding"),g(this,"_fillStyle"),g(this,"oldMapTextureRes",{}),g(this,"getTextureAndHash",async(i,s,r,a,o)=>{const l=this.ctx,h=this.labelHash,c=this.iconUrlHash;if(!o&&this.oldMapTextureRes)return this.oldMapTextureRes;if(!i[a])return{texture:this.texture,labelHash:h};let u=h.size,d=h.size,p=new Map;for(let f=0;f<i[a].length;f++){const v=this.parameters.vertexBackgrounds?i[r][f]:s,_=i[a][f],y=JSON.stringify({icon:v,text:_});c.get(v)===void 0&&(c.set(v,v),p.set(v,v)),h.get(y)===void 0&&(h.set(y,u),u++)}if(d===h.size)return this.oldMapTextureRes;let m=Array.from(c.entries()).filter(f=>typeof f[1]=="string").map(([f,v])=>new Promise((_,y)=>{this.url2canvas(f,x=>{c.set(f,x),_(f)})}));return await Promise.all(m).then(f=>{if(!this.canvas)return this.oldMapTextureRes;let v=[];for(let[b,w]of h){const M=JSON.parse(b).icon,T=JSON.parse(b).text,R=c.get(M);if(typeof R=="string")continue;const E=R.width,A=R.height,z=E+this.gap[0],F=A+this.gap[1];v.push({w:z,h:F,width:E,height:A,key:b,icon:R,text:T})}const _=Z0(v);for(let b=0;b<v.length;b++){const w=v[b];this.boxHash.get(w.key)||this.boxHash.set(w.key,w)}const y=_.w,x=_.h;this.canvas.width=y||1,this.canvas.height=x||1,l.save();for(let b=0;b<v.length;b++){const w=v[b],M=w.icon,T=w.text;l.drawImage(M,w.x+this.gap[0],w.y+this.gap[1],w.width,w.height);let R=this.parameters.fontSize;R==="auto"&&(R=this.getFontSize(T,w.width,w.height)),l.font=`${R}px Microsoft Yahei`,l.fillStyle=this._fillStyle,l.textBaseline="top",l.fillText(T,w.x+this.gap[0]/2+this.padding[3],w.y+this.gap[1]/2+this.padding[0])}return l.restore(),this.texture.dispose(),this.texture=new Se(this.canvas),this.oldMapTextureRes={texture:this.texture,labelHash:h},{texture:this.texture,labelHash:h}})}),this.parameters=t,this._padding=[0,0,0,0],this.parameters.padding&&(this.padding=this.parameters.padding),this._fillStyle=this.parameters.fillStyle||"#fff";const e=this.canvas=document.createElement("canvas");e.width=e.height=1,(this.ctx=e.getContext("2d")).textAlign="start",this.texture=new Se(e),this.defineMaterialProxyProperties(["width","height","offset","opacity","flat","keepSize"])}initObject(){const{background:t,vertexBackgrounds:e,fontSize:i,padding:s,fillStyle:r,...a}=this.parameters;this.geometry=new LT(this.parameters),this.material=new RT(a),this.material.setCommonUniforms(this.engine.rendering.uniforms)}getDefaultParams(){return{width:12,height:12,fontSize:14}}async setData(){const t=this.dataSource.data,{vertexBackgrounds:e,background:i,bgPropName:s="background",textPropName:r="text"}=this.parameters,a=await this.getTextureAndHash(t,i,s,r,!0);if(!a||!a.texture||!a.labelHash)return;let o=a.texture,l=a.labelHash;this.material.mapTexture=o,this.material.uniforms.ulength.value=l.size;const h=[],c=[],u=[],d=[],p=[];for(let m=0;m<t.position.length;m++){const f=t.position[m],v=t.index[m],_=JSON.stringify({icon:e?t[s][m]:i,text:t[r][m]}),y=this.boxHash.get(_);if(!y)continue;for(let R=0;R<4;R++)h.push(...f),c.push(R),u.push(v);const x=y.x/this.canvas.width,b=(y.x+y.w)/this.canvas.width,w=(y.y+y.h)/this.canvas.height,M=y.y/this.canvas.height;d.push(x,w,x,M,b,M,b,w);const T=4*m;p.push(T,T+2,T+1,T,T+3,T+2)}this.geometry.setData({aPositions:h,pIndices:c,aObjectIndices:u,aUvs:d,indices:p}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,h),this.needsUpdate=!1,this.engine.requestRender()}url2canvas(t,e){if(typeof t=="object")e(t);else{let i=new Image;i.crossOrigin="anonymous",i.onload=function(){let s=i.width,r=i.height,a=document.createElement("canvas");a.width=s,a.height=r,a.getContext("2d").drawImage(i,0,0,s,r),e(a)},i.onerror=function(){let s=document.createElement("canvas");s.width=20,s.height=40;let r=s.getContext("2d");r.fillStyle="red",r.beginPath(),r.lineTo(0,0),r.lineTo(20,0),r.lineTo(10,40),r.closePath(),r.fill(),e(s)},i.src=t}}getFontSize(t,e,i,s=1){const r=this.ctx,a=this.padding;return r.font=`${s}px Microsoft Yahei`,r.textBaseline="top",r.measureText(t).width+a[1]+a[3]>=e||s+a[0]+a[2]>=i?s-1:this.getFontSize(t,e,i,s+1)}getEntityByIndex(t){const e=this.dataSource,i={index:t,value:e.getOriginData(t),itemIndex:e.getOriginDataIndex(t),pairs:{}},s=e.data;for(const r of Object.keys(s))i.pairs[r]=s[r][t];return i}raycast(t,e){if(this.flat)return;const i=this.geometry,s=i.getAttribute("position");if(!s||!s.array||!s.array.length===0)return;const r=i.getAttribute("offset");let a=[];r&&(a=r.array);const o=t.camera,l=t.mouse,h=this.material.uniforms.resolution.value,c=l.x,u=l.y,d=this.width/h[0],p=this.height/h[0];let m=0,f=0,v=0,_=0,y=0,x=0;wc.multiplyMatrices(o.projectionMatrix,o.matrixWorldInverse),wc.multiplyMatrices(wc,this.matrixWorld);const b=s.array;let w=0;for(let M=0,T=b.length-11;M<T;M+=12)if(mn.set(b[M],b[M+1],b[M+2],1),mn.applyMatrix4(wc),mn.divideScalar(mn.w),this.parameters.vertexOffsets?(w=M/12*8,y=a[w]||0,x=a[w+1]||0):(y=this.parameters.offset&&this.parameters.offset[0]||0,x=this.parameters.offset&&this.parameters.offset[1]||0),mn.x+=2*y/h[0],mn.y-=2*x/h[1],m=mn.x-d,v=mn.x+d,f=mn.y-p,_=mn.y+p,m<=c&&v>=c&&f<=u&&_>=u){kp.set(b[M],b[M+1],b[M+2]),kp.applyMatrix4(this.matrixWorld);const R={instanceId:M/12,object:this,distance:kp.distanceTo(o.position)};e.push(R)}}set padding(t){t.length===2?this._padding=[t[0],t[1],t[0],t[1]]:t.length===3?this._padding=[t[0],t[1],t[2],t[1]]:t.length>=4&&(this._padding=[t[0],t[1],t[2],t[3]])}get padding(){return this._padding}onDispose(){this.texture&&this.texture.dispose(),this.canvas&&(this.canvas=null),this.iconUrlHash.clear(),this.labelHash.clear(),this.boxHash.clear()}}function Bp(n,t,e,i,s,r){if(s-i<=e)return;const a=i+s>>1;Cy(n,t,a,i,s,r%2),Bp(n,t,e,i,a-1,r+1),Bp(n,t,e,a+1,s,r+1)}function Cy(n,t,e,i,s,r){for(;s>i;){if(s-i>600){const h=s-i+1,c=e-i+1,u=Math.log(h),d=.5*Math.exp(2*u/3),p=.5*Math.sqrt(u*d*(h-d)/h)*(c-h/2<0?-1:1);Cy(n,t,e,Math.max(i,Math.floor(e-c*d/h+p)),Math.min(s,Math.floor(e+(h-c)*d/h+p)),r)}const a=t[2*e+r];let o=i,l=s;for(Fo(n,t,i,e),t[2*s+r]>a&&Fo(n,t,i,s);o<l;){for(Fo(n,t,o,l),o++,l--;t[2*o+r]<a;)o++;for(;t[2*l+r]>a;)l--}t[2*i+r]===a?Fo(n,t,i,l):(l++,Fo(n,t,l,s)),l<=e&&(i=l+1),e<=l&&(s=l-1)}}function Fo(n,t,e,i){Vp(n,e,i),Vp(t,2*e,2*i),Vp(t,2*e+1,2*i+1)}function Vp(n,t,e){const i=n[t];n[t]=n[e],n[e]=i}function Ay(n,t,e,i){const s=n-e,r=t-i;return s*s+r*r}const IT=n=>n[0],DT=n=>n[1];class Py{constructor(t,e=IT,i=DT,s=64,r=Float64Array){this.nodeSize=s,this.points=t;const a=t.length<65536?Uint16Array:Uint32Array,o=this.ids=new a(t.length),l=this.coords=new r(2*t.length);for(let h=0;h<t.length;h++)o[h]=h,l[2*h]=e(t[h]),l[2*h+1]=i(t[h]);Bp(o,l,s,0,o.length-1,0)}range(t,e,i,s){return function(r,a,o,l,h,c,u){const d=[0,r.length-1,0],p=[];let m,f;for(;d.length;){const v=d.pop(),_=d.pop(),y=d.pop();if(_-y<=u){for(let w=y;w<=_;w++)m=a[2*w],f=a[2*w+1],m>=o&&m<=h&&f>=l&&f<=c&&p.push(r[w]);continue}const x=Math.floor((y+_)/2);m=a[2*x],f=a[2*x+1],m>=o&&m<=h&&f>=l&&f<=c&&p.push(r[x]);const b=(v+1)%2;(v===0?o<=m:l<=f)&&(d.push(y),d.push(x-1),d.push(b)),(v===0?h>=m:c>=f)&&(d.push(x+1),d.push(_),d.push(b))}return p}(this.ids,this.coords,t,e,i,s,this.nodeSize)}within(t,e,i){return function(s,r,a,o,l,h){const c=[0,s.length-1,0],u=[],d=l*l;for(;c.length;){const p=c.pop(),m=c.pop(),f=c.pop();if(m-f<=h){for(let b=f;b<=m;b++)Ay(r[2*b],r[2*b+1],a,o)<=d&&u.push(s[b]);continue}const v=Math.floor((f+m)/2),_=r[2*v],y=r[2*v+1];Ay(_,y,a,o)<=d&&u.push(s[v]);const x=(p+1)%2;(p===0?a-l<=_:o-l<=y)&&(c.push(f),c.push(v-1),c.push(x)),(p===0?a+l>=_:o+l>=y)&&(c.push(v+1),c.push(m),c.push(x))}return u}(this.ids,this.coords,t,e,i,this.nodeSize)}}const OT={minZoom:0,maxZoom:16,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:n=>n};class zT{constructor(t){this.options=No(Object.create(OT),t),this.trees=new Array(this.options.maxZoom+1)}load(t){const{log:e,minZoom:i,maxZoom:s,nodeSize:r}=this.options;e&&console.time("total time");const a=`prepare ${t.length} points`;e&&console.time(a),this.points=t;let o=[];for(let l=0;l<t.length;l++){const h=t[l];(Array.isArray(h)||h.geometry)&&o.push(FT(h,l))}this.trees[s+1]=new Py(o,Iy,Dy,r,Float32Array),e&&console.timeEnd(a);for(let l=s;l>=i;l--){const h=+Date.now();o=this._cluster(o,l),this.trees[l]=new Py(o,Iy,Dy,r,Float32Array),e&&console.log("z%d: %d clusters in %dms",l,o.length,+Date.now()-h)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let i=((t[0]+180)%360+360)%360-180;const s=Math.max(-90,Math.min(90,t[1]));let r=t[2]===180?180:((t[2]+180)%360+360)%360-180;const a=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)i=-180,r=180;else if(i>r){const c=this.getClusters([i,s,180,a],e),u=this.getClusters([-180,s,r,a],e);return c.concat(u)}const o=this.trees[this._limitZoom(e)],l=o.range(Gp(i),jp(a),Gp(r),jp(s)),h=[];for(const c of l){const u=o.points[c];h.push(u.numPoints?Ry(u):this.points[u.index])}return h}getChildren(t){const e=this._getOriginId(t),i=this._getOriginZoom(t),s="No cluster with the specified id.",r=this.trees[i];if(!r)throw new Error(s);const a=r.points[e];if(!a)throw new Error(s);const o=this.options.radius/(this.options.extent*Math.pow(2,i-1)),l=r.within(a.x,a.y,o),h=[];for(const c of l){const u=r.points[c];u.parentId===t&&h.push(u.numPoints?Ry(u):this.points[u.index])}if(h.length===0)throw new Error(s);return h}getLeaves(t,e,i){e=e||10,i=i||0;const s=[];return this._appendLeaves(s,t,e,i,0),s}getTile(t,e,i){const s=this.trees[this._limitZoom(t)],r=Math.pow(2,t),{extent:a,radius:o}=this.options,l=o/a,h=(i-l)/r,c=(i+1+l)/r,u={features:[]};return this._addTileFeatures(s.range((e-l)/r,h,(e+1+l)/r,c),s.points,e,i,r,u),e===0&&this._addTileFeatures(s.range(1-l/r,h,1,c),s.points,r,i,r,u),e===r-1&&this._addTileFeatures(s.range(0,h,l/r,c),s.points,-1,i,r,u),u.features.length?u:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const i=this.getChildren(t);if(e++,i.length!==1)break;t=i[0].properties.cluster_id}return e}_appendLeaves(t,e,i,s,r){const a=this.getChildren(e);for(const o of a){const l=o.properties;if(l&&l.cluster?r+l.point_count<=s?r+=l.point_count:r=this._appendLeaves(t,l.cluster_id,i,s,r):r<s?r++:t.push(o),t.length===i)break}return r}_addTileFeatures(t,e,i,s,r,a){for(const o of t){const l=e[o],h=l.numPoints,c={type:1,geometry:[[Math.round(this.options.extent*(l.x*r-i)),Math.round(this.options.extent*(l.y*r-s))]],tags:h?Ly(l):this.points[l.index].properties};let u;h?u=l.id:this.options.generateId?u=l.index:this.points[l.index].id&&(u=this.points[l.index].id),u!==void 0&&(c.id=u),a.features.push(c)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(t,this.options.maxZoom+1))}_cluster(t,e){const i=[],{radius:s,extent:r,reduce:a}=this.options,o=s/(r*Math.pow(2,e));for(let l=0;l<t.length;l++){const h=t[l];if(h.zoom<=e)continue;h.zoom=e;const c=this.trees[e+1],u=c.within(h.x,h.y,o);let d=h.numPoints||1,p=h.x*d,m=h.y*d,f=a&&d>1?this._map(h,!0):null;const v=(l<<5)+(e+1)+this.points.length;for(const _ of u){const y=c.points[_];if(y.zoom<=e)continue;y.zoom=e;const x=y.numPoints||1;p+=y.x*x,m+=y.y*x,d+=x,y.parentId=v,a&&(f||(f=this._map(h,!0)),a(f,this._map(y)))}d===1?i.push(h):(h.parentId=v,i.push(UT(p/d,m/d,v,d,f)))}return i}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e){if(t.numPoints)return e?No({},t.properties):t.properties;const i=this.points[t.index].properties,s=this.options.map(i);return e&&s===i?No({},s):s}}function UT(n,t,e,i,s){return{x:n,y:t,zoom:1/0,id:e,parentId:-1,numPoints:i,properties:s}}function FT(n,t){const[e,i]=Array.isArray(n)?n:n.geometry.coordinates;return{x:Gp(e),y:jp(i),zoom:1/0,index:t,parentId:-1}}function Ry(n){return{type:"Feature",id:n.id,properties:Ly(n),geometry:{type:"Point",coordinates:[NT(n.x),kT(n.y)]}}}function Ly(n){const t=n.numPoints,e=t>=1e4?`${Math.round(t/1e3)}k`:t>=1e3?Math.round(t/100)/10+"k":t;return No(No({},n.properties),{cluster:!0,cluster_id:n.id,point_count:t,point_count_abbreviated:e})}function Gp(n){return n/360+.5}function jp(n){const t=Math.sin(n*Math.PI/180),e=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return e<0?0:e>1?1:e}function NT(n){return 360*(n-.5)}function kT(n){const t=(180-360*n)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}function No(n,t){for(const e in t)n[e]=t[e];return n}function Iy(n){return n.x}function Dy(n){return n.y}class Oy extends Ds{constructor(){super(...arguments),g(this,"isEventEntitySupported",!0)}addComponent(t){if(!t.isGeoObject)return void console.warn("Only GeoObject can be added");t.__eventProxyByParent=!0,this.add(t),t.afterAddToEngine(this.engine);const e=this.getChildDataSource(t);return e&&(t.dataSource=e),this.needsUpdate=!0,t}removeComponent(t){this.remove(t),t.__eventProxyByParent=!1,t.dataSource=null,t.beforeRemoveFromEngine(this.engine),this.needsUpdate=!0}getChildDataSource(t){return this.dataSource}onBeforeScenePrepareRender(t,e,i,s){super.onBeforeScenePrepareRender&&super.onBeforeScenePrepareRender(t,e,i,s);for(const r of this.children)r.onBeforeScenePrepareRender&&r.onBeforeScenePrepareRender(t,e,i,s)}onBeforeSceneRender(t,e,i,s){super.onBeforeSceneRender&&super.onBeforeSceneRender(t,e,i,s);for(const r of this.children)r.onBeforeSceneRender&&r.onBeforeSceneRender(t,e,i,s)}setDataSource(t){super.setDataSource(t);for(const e of this.children)e.setDataSource(this.getChildDataSource(e))}setData(){for(const t of this.children)t.needsUpdate&&t.setData();this.needsUpdate=!1}dispose(){for(const t of this.children)t.dispose()}}const BT={width:30,height:30,mapSrc:"https://bj.bcebos.com/v1/yanpan-screen-attachment/resources/image/yinlianPOC/djiudian.png"},VT={collides:!1,fillStyle:"#ccc",fontSize:16,flat:!1},GT={maxZoom:18,minZoom:5,radius:50},jT=ft.merge([{emissive:{value:[0,0,0]}}]);class HT extends dn{constructor(t){super(),this.type="InstancedEffectModelMaterial",this.isInstancedEffectModelMaterial=!0,this.vertexShader=`#define GLSLIFY 1
#include <common>

// attribute mat4 instanceMatrix;

uniform float height;
#if defined(USE_SIZE3)
uniform vec3 size3;
#else
uniform float size;
#endif

uniform vec2 resolution;
uniform float elapsedTime;
attribute float instancedRandomFactor;

#if defined(VERTEX_COLOR4)
    attribute vec4 color;
    varying vec4 vColor;
#elif defined(VERTEX_COLOR3)
    attribute vec3 color;
    varying vec3 vColor;
#endif

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>

#define MVT_KEEP_PROJECTION_POSITION

#include <logdepthbuf_pars_vertex>
vec3 transformPosition(vec3 p) {
    vec3 transformed = vec3(p);

    #include <mvt_animation_vertex>

    #if defined(USE_SIZE3)
        transformed *= size3;
    #else
        transformed *= size;
    #endif
    transformed.z += height;

    #include <mvt_keepsize_vertex>

    return transformed;
}
void main() {
    
    #if defined(VERTEX_COLOR4)
        vColor = vec4(color);
    #elif defined(VERTEX_COLOR3)
        vColor = vec3(color);
    #endif

    #include <mvt_selective_vertex>
    vec4 mvp_projectPosition;

    vec3 transformed = transformPosition(position);
    
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix *
        vec4(transformed, 1.0);
    
    mvp_projectPosition = gl_Position;

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

#if defined(VERTEX_COLOR4)
    varying vec4 vColor;
#elif defined(VERTEX_COLOR3)
    varying vec3 vColor;
#else
    uniform vec4 color;
#endif

uniform float opacity;
uniform vec3 emissive;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#define MVT_EMISSIVE_SHADER
void main() {

    #include <logdepthbuf_fragment> 

    #if defined(VERTEX_COLOR4)
        gl_FragColor = vColor;
    #elif defined(VERTEX_COLOR3)
        gl_FragColor = vec4(vColor, 1.0);
    #else
        gl_FragColor = color;
    #endif
      
    gl_FragColor.a *= opacity;
    vec4 out_emissive = vec4(emissive, 1.0);
    #include <mvt_selective_fragment>

    #include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Object.assign(this.uniforms,ft.clone(jT)),this.defines={},Jt(this,["emissive"]),this.setValues(t)}get vertexColors4(){return this.defines.VERTEX_COLOR4=!0}set vertexColors4(t){t!==this.defines.VERTEX_COLOR4&&(this.defines.VERTEX_COLOR4=!!t,this.needsUpdate=!0)}get vertexColors3(){return this.defines.VERTEX_COLOR3=!0}set vertexColors3(t){t!==this.defines.VERTEX_COLOR3&&(this.defines.VERTEX_COLOR3=!!t,this.needsUpdate=!0)}}const WT={normalize:!0,rotateToZUp:!0,keepSize:!0};class qT extends Ds{constructor(){super(...arguments),g(this,"isLine",!0),g(this,"isLineSegments",!0)}}class XT extends gt{constructor(t){super(t),this.parameters=t}setData(t){const{vertexColors:e,vertexHeights:i}=this.parameters,{aPositions:s,indices:r,aColors:a,aHeights:o,aLengths:l}=t;this.setAttribute("position",new Z(s,3)),this.setAttribute("aLength",new Z(l,1)),e&&this.setAttribute("aColor",new Z(a,4)),i&&this.setAttribute("aHeight",new Z(o,1)),this.setIndex(r)}}const YT=ft.merge([rt.fog.uniforms,Gi,fo,{color:{value:[1,1,0,1]},height:{value:100},vertexColors:{value:!1},vertexHeights:{value:!1},tailLength:{value:50},speed:{value:1},idle:{value:2e3}}]);class ZT extends Fe{constructor(t){super(),this.type="SparkMaterial",this.isSparkMaterial=!0,this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute float aLength;

uniform float elapsedTime;
uniform float tailLength;
uniform float speed;
uniform float idle;

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
#else
    uniform vec4 color;
#endif

#ifdef MVT_USE_VERTEX_HEIGHT
    attribute float aHeight;
#else
    uniform float height;
#endif

varying float vOpacity;
varying vec4 vColor;

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>

void main() {
    #include <mvt_selective_vertex>

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #else
        vColor = color;
    #endif

    #include <begin_vertex>
    #include <project_vertex>

    #ifdef MVT_USE_VERTEX_HEIGHT
        float total = aHeight + tailLength;
    #else
        float total = height + tailLength;
    #endif
    float currentHeight = mod(elapsedTime * speed, total + idle * speed);
    vOpacity = (aLength - (currentHeight - tailLength)) / tailLength;
    // vOpacity = 1.;

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

varying vec4 vColor;
varying float vOpacity;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {
    if (vOpacity > 1.0 || vOpacity < 0.0) {
        discard;
    }
    gl_FragColor = vec4(vColor.rgb, vColor.a * vOpacity);

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
}
`,this.transparent=!0,Object.assign(this.uniforms,ft.clone(YT)),Qn(this),Jt(this,["height","tailLength","speed","idle"]),Qr(this,["color"]),Ze(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexHeights","MVT_USE_VERTEX_HEIGHT"]]),go(this),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(t)}}const JT=ft.merge([{color:{value:[1,.5,0,1]},borderColor:{value:[0,1,0,1]},size:{value:100},opacity:{value:1},radius:{value:.5},borderWidth:{value:1}}]);class KT extends dn{constructor(t){super(),g(this,"type","CircleMaterial"),g(this,"isCircleMaterial",!0),this.depthTest=!1,this.depthWrite=!1,Jt(this,["borderWidth","opacity"]),Qr(this,["borderColor"]),Ze(this,[["vertexSizes","MVT_USE_VERTEX_SIZE"]]),this.vertexShader=`#define GLSLIFY 1
#include <common>

uniform float size;

varying vec2 vPosition;
varying float vScale;

#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <logdepthbuf_pars_vertex>
void main() {
   
    #include <mvt_selective_vertex>
    vPosition = position.xy;
    vScale = instanceMatrix[0][0];
    vec3 transformed = vec3(position);

    transformed *= size;
  
    #include <mvt_keepsize_vertex>
    
    #ifdef MVT_USE_VERTEX_SIZE
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
    #else
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);
    #endif
    #include <logdepthbuf_vertex>
}`,t.type==="Gradient"?this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform vec4 color;
uniform float radius;

varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {
    float d = distance(vPosition, vec2(0, 0));
    if (d > 0.5) {
        discard;
    }
    vec4 vColor = color;
    
    vColor.a = smoothstep(0.0, 1.0, pow(d / radius, 2.0));
    // 边缘抗锯齿
    if(d >- 0.99 * radius) {
        vColor.a *= 1.0 - smoothstep(0.99, 1.0, d / radius); 
    }
    gl_FragColor = vColor;

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment>   
}`:this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform vec4 color;
uniform vec4 borderColor;
uniform float opacity;
uniform float radius;
uniform float borderWidth;
uniform float size;

varying vec2 vPosition;
varying float vScale;

#include <logdepthbuf_pars_fragment>
#include <mvt_selective_pars_fragment>

void main() {
    float distance = distance(vPosition, vec2(0, 0));

    // 用来保持边框的宽度不会随着缩放而变化
    #ifdef MVT_USE_VERTEX_SIZE
        float radius2 = radius - (borderWidth / vScale) * radius;
    #else
        float radius2 = radius - (borderWidth / size) * radius;
    #endif

    // 用于抗锯齿
    float blur = 0.001;
    float pct = (1.0 - smoothstep(radius - blur, radius + blur, distance));
    vec4 currentColor = mix(color, borderColor, smoothstep( radius2-blur,radius2 + blur, distance));
    
    // 设置的自身颜色的透明度优先级高于设置的opacity优先级
    if(currentColor.a == 1.0) {
        gl_FragColor = vec4(currentColor.rgb, pct * opacity);
    } else {
        gl_FragColor = vec4(currentColor.rgb, pct * currentColor.a);
    }

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
}`,Object.assign(this.uniforms,ft.clone(JT)),this.setValues(t)}}const QT=ft.merge([rt.fog,rt.lights,{heatmap:{value:null},heatmapDepth:{value:null},gradientMap:{value:null},opacity:{value:1}}]);class $T extends Fe{constructor(t){super(t),this.type="HeatmapMaterial",this.isHeatmapMaterial=!0,this.fog=!0,this.lights=!1,this.transparent=!0,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform sampler2D heatmap;
uniform sampler2D gradientMap;
uniform sampler2D heatmapDepth;
uniform float opacity;
uniform vec2 resolution;

varying vec2 vUv;

#include <packing>

#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
#endif

void main() {
    vec4 color = texture2D(heatmap, vUv);
    
    if (color.a <= 0.) {
        discard;
    }
    gl_FragColor = texture2D(gradientMap, vec2(color.a, 0.5));
    float addAlpha = 1.0;
    if (color.a < 0.3) {
        addAlpha = color.a * 3.3;
    }
    // if (color.a < 0.3) {
    //     gl_FragColor.a = color.a * 3.3;
    // } else {
    //     gl_FragColor.a = 1.0;
    // }
    gl_FragColor.a *= color.a;
    gl_FragColor.a *= opacity;

    vec4 depthColor = texture2D(heatmapDepth, vUv);

    #if defined( USE_LOGDEPTHBUF ) 
        gl_FragDepthEXT = unpackRGBAToDepth(depthColor);
    #endif
    // gl_FragColor = depthColor;
    // #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
    //    int r = int(color.r * 255.0);
    //    int g = int(color.g * 255.0);
    //    int b = int(color.b * 255.0);
    //    int d = r << 16 + g << 8 + b;
    //    float z = float(d) / 16581375.0;
    //    gl_FragDepthEXT = z;
        //gl_FragDepthEXT = color.r;
       // gl_FragColor = vec4(1.0, 0, 0, color.r);
       // gl_FragDepthEXT = log2( color.r ) * logDepthBufFC * 0.5;
       // gl_FragDepthEXT = 1.0;

    //    float depth = dot( vec2(color.r, color.g), 1.0 / vec2(1.0, 256.0) );
    //    gl_FragDepthEXT = depth * (256.0*256.0) / (256.0*256.0 - 1.0);
// gl_FragColor = vec4(gl_FragDepthEXT, gl_FragDepthEXT, 0, 1.0);
    // #endif
    // gl_FragColor.a = color.a * 0.8;
    // gl_FragColor = vec4(vUv, 0, 1.0);
    // gl_FragColor = vec4(1.0, 0,0, 0.8);
}`,this.vertexShader=`#define GLSLIFY 1
#include <common>
uniform sampler2D gradientMap;

varying vec2 vUv;

void main() { 
    
    gl_Position = vec4(position, 1.0);
    // vUv = position.xy;
    vUv = vec2((position.x + 1.0) * 0.5, (position.y + 1.0) * 0.5);
    // vec4 gray = texture2D(gradientMap, vUv);

    // vec4 m0 = matrixWorldInverse * vec4(gl_Position.xy, 0.0, 1.0);
    // vec4 m1 = matrixWorldInverse * vec4(gl_Position.xy, 1.0, 1.0);
    // m0 /= m0.w;
    // m1 /= m1.w;
    // vec4 pixel = m0 + (-m0.z / (m1.z - m0.z)) * (m1 - m0);
    // pixel.z = 100. * gray.a;

    // gl_Position = projectionMatrix * pixelToViewMatrix * vec4(pixel.xyz, 1.0);
}`,Object.assign(this.uniforms,ft.clone(QT)),Jt(this,["opacity","resolution"]),rn(this,[]),Ze(this,[]),this._cachedGradient=null,Object.defineProperties(this,{gradient:{get:function(){return this._cachedGradient},set:function(e){this._cachedGradient=e,this.updateGradientMap()}}}),this.createGradientMap(),this.uniforms.gradientMap.value=this._cachedGradientMap,this.setValues(t)}createGradientMap(){let t=document.createElement("canvas");t.width=64,t.height=2;let e=t.getContext("2d"),i=e.createLinearGradient(0,0,64,0);i.addColorStop(0,"rgba(0,0,255,1)"),i.addColorStop(.3,"rgba(0,255,0,1)"),i.addColorStop(.6,"rgba(255,255,0,1)"),i.addColorStop(1,"rgba(255,0,0,1)"),e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap=new Se(t)}updateGradientMap(){let t=this._cachedGradient;if(Object.prototype.toString.call(t)!=="[object Object]")return;let e=this._cachedGradientMap.image.getContext("2d");e.clearRect(0,0,64,2);let i=e.createLinearGradient(0,0,64,0);for(const s in t)Object.hasOwnProperty.call(t,s)&&i.addColorStop(s,t[s]);e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap.needsUpdate=!0}dispose(){this._cachedGradientMap&&this._cachedGradientMap.dispose(),super.dispose()}}const tE=ft.merge([rt.fog,rt.lights,{radius:{value:30},zoomUnits:{value:1},circleMap:{value:null},minValue:{value:0},maxValue:{value:100},keepSize:{value:!1},attenuateMValueFactor:{value:0}}]);class eE extends Fe{constructor(t){super(t),this.type="HeatmapTextureMaterial",this.isHeatmapTextureMaterial=!0,this.fog=!0,this.lights=!1,this.transparent=!0,this.depthTest=!1,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform sampler2D circleMap;

varying vec2 vUv;
varying float vWeight;
varying float vZDepth;
#include <logdepthbuf_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>
    gl_FragColor.a = texture2D(circleMap, vUv).a * vWeight;
    // gl_FragColor.a = 1.;
    //#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
        // gl_FragColor = vec4(vec3(gl_FragDepthEXT), 1.0);
        // int d = int(gl_FragDepthEXT * 16581375.0);
        // gl_FragColor.r = float((d & 0xff0000) >> 16) / 255.0;
        // gl_FragColor.g = float((d & 0x00ff00) >> 8) / 255.0;
        // gl_FragColor.b = float(d & 0x0000ff) / 255.0;
        // gl_FragColor.r = gl_FragDepthEXT; // a
        // gl_FragColor.g = mod(gl_FragDepthEXT * 10.0, 1.0);
        // gl_FragColor.b = mod(gl_FragDepthEXT * 1000.0, 1.0);
        // int d = int(gl_FragDepthEXT * 10000000.0);
        // gl_FragColor.r = (d & 0xff000 >> 16) / 255.0; 
        // gl_FragColor.g = (d & 0x00ff00 >> 8) / 255.0; 
        // gl_FragColor.b = (d & 0x0000ff ) / 255.0; 
        // gl_FragColor.r = gl_FragDepthEXT;
        // gl_FragColor.r = gl_FragCoord.z;

        // float depthVal = gl_FragCoord.z * (256.0*256.0 - 1.0) / (256.0*256.0);
        // vec3 encode = fract( depthVal * vec3(1.0, 256.0, 256.0*256.0) );
        // encode.xy = encode.xy - encode.yz / 256.0 + 1.0/512.0;
        // gl_FragColor.rgb = encode;

    // #else 
    //     gl_FragColor.r = gl_FragCoord.z;
    // #endif
    // gl_FragColor.r = 1.0;
    // gl_FragColor.a = gl_FragCoord.z;
}`,this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute float instancedWeight;

uniform float radius;
uniform float zoomUnits;
uniform float maxValue;
uniform float minValue;
uniform bool keepSize;
uniform float attenuateMValueFactor;

varying vec2 vUv;
varying float vWeight;
#include <logdepthbuf_pars_vertex>
void main() { 

    float range = (maxValue - minValue) * attenuateMValueFactor;

    if (keepSize) {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * zoomUnits, 1.0);
        range *= zoomUnits;
    } else {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius, 1.0);
    }
    
    // gl_Position = vec4(position, 1.0);
    // vZDepth = (gl_Position.z / gl_Position.w + 1.0) * 0.5;
   
    vUv = vec2(position.x + 0.5, position.y + 0.5);
    
    vWeight = (instancedWeight - minValue) / (maxValue + range - minValue);

    #include <logdepthbuf_vertex>
}`,Object.assign(this.uniforms,ft.clone(tE)),Jt(this,["radius","minValue","maxValue","keepSize","attenuateMValueFactor"]),rn(this,[]),Ze(this,[]);const e=this.createCircleMap();this.uniforms.circleMap.value=e,this.setValues(t),this.blending=5,this.blendSrc=201,this.blendDst=200,this.blendSrcAlpha=201,this.blendDstAlpha=201}createCircleMap(){let t=document.createElement("canvas");t.width=64,t.height=64;let e=t.getContext("2d"),i=e.createRadialGradient(32,32,0,32,32,32);return i.addColorStop(0,"rgba(0,0,0,1)"),i.addColorStop(1,"rgba(0,0,0,0)"),e.fillStyle=i,e.arc(32,32,32,0,2*Math.PI,!1),e.fill(),new Se(t)}dispose(){this.uniforms.circleMap.value&&this.uniforms.circleMap.value.dispose(),super.dispose()}}const iE=ft.merge([rt.fog,rt.lights,{radius:{value:30},zoomUnits:{value:1},circleMap:{value:null},minValue:{value:0},maxValue:{value:100},keepSize:{value:!1},attenuateMValueFactor:{value:0}}]);class nE extends Fe{constructor(t){super(t),this.type="HeatmapDepthTextureMaterial",this.isHeatmapDepthTextureMaterial=!0,this.fog=!0,this.lights=!1,this.transparent=!0,this.depthTest=!1,this.fragmentShader=`#define GLSLIFY 1
#include <common>
#include <packing>
#include <logdepthbuf_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>

    #if defined( USE_LOGDEPTHBUF ) 
    
        gl_FragColor = packDepthToRGBA(gl_FragDepthEXT);
    #else
        gl_FragColor = packDepthToRGBA(gl_FragCoord.z);
    #endif
    
}`,this.vertexShader=`#define GLSLIFY 1
#include <common>
attribute vec3 instancedPosition;
// attribute float instancedWeight;

uniform float radius;
uniform float zoomUnits;
// uniform float maxValue;
// uniform float minValue;
uniform bool keepSize;
// uniform float attenuateMValueFactor;

// varying vec2 vUv;
// varying float vWeight;
#include <logdepthbuf_pars_vertex>
void main() { 
    if (keepSize) {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * zoomUnits * 1.1, 1.0);
    } else {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * 1.1, 1.0);
    }
    #include <logdepthbuf_vertex>
}`,Object.assign(this.uniforms,ft.clone(iE)),Jt(this,["radius","minValue","maxValue","keepSize","attenuateMValueFactor"]),rn(this,[]),Ze(this,[]),this.setValues(t)}}class sE extends th{constructor(){super();const t=this.geometry=new gi;this.setAttribute("position",t.attributes.position),this.setAttribute("uv",t.attributes.uv),this.setIndex(t.index)}dispose(){this.geometry.dispose()}}const rE=ft.merge([rt.fog,rt.lights,{heightRatio:{value:100},opacity:{value:1},map:{value:null}}]);class aE extends Fe{constructor(t){super(t),this.type="HeatmapMaterial",this.isHeatmapMaterial=!0,this.fog=!0,this.lights=!1,this.transparent=!0,this.depthWrite=!1,this.depthTest=!0,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform sampler2D map;
uniform float opacity;
uniform vec2 resolution;

varying vec2 vUv;
#include <logdepthbuf_pars_fragment>

void main() {

    gl_FragColor = texture2D(map, vUv);
    gl_FragColor.a *= opacity;

    #include <logdepthbuf_fragment> 

}`,this.vertexShader=`#define GLSLIFY 1
#include <common>

uniform float heightRatio;
uniform sampler2D map;

varying vec2 vUv;

#include <logdepthbuf_pars_vertex>
void main() { 

    vUv = vec2(uv.x, 1. - uv.y);
	#include <begin_vertex>

    transformed.z = texture2D(map, vUv).a * heightRatio;

	#include <project_vertex>
    #include <logdepthbuf_vertex>
}`,Object.assign(this.uniforms,ft.clone(rE)),Jt(this,["heightRatio","resolution","opacity","map"]),this.setValues(t)}}var zy={exports:{}};(function(n){function t(e){if(!(this instanceof t))return new t(e);this._canvas=e=typeof e=="string"?document.getElementById(e):e,this._ctx=e.getContext("2d"),this._width=e.width,this._height=e.height,this._max=1,this._data=[]}n.exports=t,t.prototype={defaultRadius:25,defaultGradient:{.4:"blue",.6:"cyan",.7:"lime",.8:"yellow",1:"red"},data:function(e){return this._data=e,this},max:function(e){return this._max=e,this},add:function(e){return this._data.push(e),this},clear:function(){return this._data=[],this},radius:function(e,i){i=i===void 0?15:i;var s=this._circle=this._createCanvas(),r=s.getContext("2d"),a=this._r=e+i;return s.width=s.height=2*a,r.shadowOffsetX=r.shadowOffsetY=2*a,r.shadowBlur=i,r.shadowColor="black",r.beginPath(),r.arc(-a,-a,e,0,2*Math.PI,!0),r.closePath(),r.fill(),this},resize:function(){this._width=this._canvas.width,this._height=this._canvas.height},gradient:function(e){var i=this._createCanvas(),s=i.getContext("2d"),r=s.createLinearGradient(0,0,0,256);for(var a in i.width=1,i.height=256,e)r.addColorStop(+a,e[a]);return s.fillStyle=r,s.fillRect(0,0,1,256),this._grad=s.getImageData(0,0,1,256).data,this},draw:function(e){this._circle||this.radius(this.defaultRadius),this._grad||this.gradient(this.defaultGradient);var i=this._ctx;i.clearRect(0,0,this._width,this._height);for(var s,r=0,a=this._data.length;r<a;r++)s=this._data[r],i.globalAlpha=Math.max(s[2]/this._max,e===void 0?.05:e),i.drawImage(this._circle,s[0]-this._r,s[1]-this._r);var o=i.getImageData(0,0,this._width,this._height);return this._colorize(o.data,this._grad),i.putImageData(o,0,0),this},_colorize:function(e,i){for(var s,r=0,a=e.length;r<a;r+=4)(s=4*e[r+3])&&(e[r]=i[s],e[r+1]=i[s+1],e[r+2]=i[s+2])},_createCanvas:function(){return typeof document<"u"?document.createElement("canvas"):new this._canvas.constructor}}})(zy);const oE=zy.exports;function lE(n,t){let e=document.createElement("canvas");return n&&(e.width=n),t&&(e.height=t),e}class hE extends gt{constructor(t){super(),g(this,"isFatLineGeometry",!0),g(this,"_segmentLines",(e,i,s,r,a,o,l,h,c,u,d,p,m,f)=>{let v=0,_=new V,y=new V,x=new V;const b=this.parameters.lineCap==="square",w=this.parameters.lineCap==="round",M=this.parameters.lineJoin==="bevel",T=this.parameters.lineJoin==="round",R=[u[0],u[1]],E=[c[0],c[1]];let A=as(E,R),z=0;if(this._needsCounter&&(z=fa(R,E),this._flags.totalDistance+=z),this._flags.normal||(this._flags.normal=new V,this._flags.normal=ga(A)),!this._flags.started)if(this._flags.started=!0,b){const F=new V,G=new V;F.addVectors(this._flags.normal,A),G.subVectors(this._flags.normal,A),o.push(G.x,G.y,0,-F.x,-F.y,0),e.push(c[0],c[1],c[2],c[0],c[1],c[2]),i.push(this._flags.totalDistance-z,0,this._flags.totalDistance-z,1),s.push(this._flags.totalDistance-z,this._flags.totalDistance-z),a.push(p,p),r.push(0,0),this.parameters.vertexColors&&l.push(m[0],m[1],m[2],m[3],m[0],m[1],m[2],m[3])}else if(w){const F=A.clone();F.negate();const G=new V;G.subVectors(this._flags.normal,A),G.normalize();const U=new V;U.addVectors(this._flags.normal,A),U.normalize();const k=this._flags.normal.clone(),H=this._flags.normal.clone();H.negate(),o.push(F.x,F.y,0),o.push(G.x,G.y,0),o.push(-U.x,-U.y,0),o.push(k.x,k.y,0),o.push(H.x,H.y,0);for(let W=0;W<5;W++)e.push(c[0],c[1],c[2]),a.push(p),i.push(this._flags.totalDistance-z,0),s.push(this._flags.totalDistance-z),r.push(0),this.parameters.vertexColors&&l.push(m[0],m[1],m[2],m[3]);h.push(f+0,f+2,f+1,f+1,f+2,f+3,f+3,f+2,f+4),v+=3,f+=3}else this._extrusions(e,o,i,s,r,a,l,c,this._flags.normal,this._flags.totalDistance-z,p,m);if(h.push(...this._flags.lastFlip===-1?[f+0,f+1,f+2]:[f+1,f+0,f+2]),d){y=as(R,[d[0],d[1]]),x.addVectors(A,y),x.normalize();const F=function(W,N){let X=new V;return X.addVectors(W,N),X.normalize(),ga(X)}(A,y),G=ga(A),U=p/F.dot(G);let k=x.dot(this._flags.normal)>0?-1:1,H=M;if(!H&&this.parameters.lineJoin==="miter"&&(Math.abs(U)>this.parameters.miterLimit||2*p)&&(H=!0),H){const W=Math.min(2*p,Math.abs(U));o.push(this._flags.normal.x*k,this._flags.normal.y*k,0),o.push(-F.x*k,-F.y*k,0),e.push(u[0],u[1],u[2],u[0],u[1],u[2]),a.push(p,W),s.push(this._flags.totalDistance,this._flags.totalDistance),r.push(0,0),h.push(...this._flags.lastFlip===-k?this._flags.lastFlip===-1?[f+2,f+1,f+3]:[f+1,f+2,f+3]:this._flags.lastFlip===-1?[f+0,f+2,f+3]:[f+2,f+0,f+3]),_=ga(y),this._flags.normal.copy(_),o.push(this._flags.normal.x*k,this._flags.normal.y*k,0),e.push(u[0],u[1],u[2]),a.push(p),s.push(this._flags.totalDistance),r.push(0),h.push(...k===1?[f+2,f+3,f+4]:[f+3,f+2,f+4]),this._flipedUV(i,this._flags.totalDistance,k,!0),this.parameters.vertexColors&&l.push(m[0],m[1],m[2],m[3],m[0],m[1],m[2],m[3],m[0],m[1],m[2],m[3]),v+=3}else if(T){const W=Math.min(2*p,Math.abs(U));o.push(this._flags.normal.x*k,this._flags.normal.y*k,0),e.push(u[0],u[1],u[2]),a.push(p),s.push(this._flags.totalDistance),r.push(0),o.push(F.x*k,F.y*k,0),e.push(u[0],u[1],u[2]),a.push(p),s.push(this._flags.totalDistance),r.push(0),o.push(-F.x*k,-F.y*k,0),e.push(u[0],u[1],u[2]),a.push(W),s.push(this._flags.totalDistance),r.push(0),h.push(...this._flags.lastFlip===-k?this._flags.lastFlip===-1?[f+2,f+1,f+4,f+2,f+4,f+3]:[f+1,f+2,f+4,f+4,f+2,f+3]:this._flags.lastFlip===-1?[f+0,f+2,f+4,f+2,f+3,f+4]:[f+2,f+0,f+4,f+3,f+2,f+4]),_=ga(y),this._flags.normal.copy(_),o.push(this._flags.normal.x*k,this._flags.normal.y*k,0),e.push(u[0],u[1],u[2]),a.push(p),s.push(this._flags.totalDistance),r.push(0),h.push(...k===-1?[f+4,f+3,f+5]:[f+3,f+4,f+5]),this._flipedUV(i,this._flags.totalDistance,k,!1),this.parameters.vertexColors&&l.push(m[0],m[1],m[2],m[3],m[0],m[1],m[2],m[3],m[0],m[1],m[2],m[3],m[0],m[1],m[2],m[3]),v+=4}else this._extrusions(e,o,i,s,r,a,l,u,F,this._flags.totalDistance,U,m),h.push(...this._flags.lastFlip===-1?[f+2,f+1,f+3]:[f+2,f+0,f+3]),k=-1,this._flags.normal.copy(F),v+=2;this._flags.lastFlip=k}else{if(this._flags.normal=ga(A),b){const F=new V,G=new V;F.addVectors(A,this._flags.normal),G.subVectors(A,this._flags.normal),o.push(F.x,F.y,0,G.x,G.y,0),e.push(u[0],u[1],u[2],u[0],u[1],u[2]),a.push(p,p),i.push(this._flags.totalDistance,0,this._flags.totalDistance,1),s.push(this._flags.totalDistance,this._flags.totalDistance),r.push(0,0),this.parameters.vertexColors&&l.push(m[0],m[1],m[2],m[3],m[0],m[1],m[2],m[3])}else this._extrusions(e,o,i,s,r,a,l,u,this._flags.normal,this._flags.totalDistance,p,m);if(h.push(...this._flags.lastFlip===-1?[f+2,f+1,f+3]:[f+2,f+0,f+3]),v+=2,w){const F=new V;F.addVectors(A,this._flags.normal),F.normalize();const G=new V;G.subVectors(A,this._flags.normal),G.normalize();const U=A.clone();o.push(F.x,F.y,0),o.push(G.x,G.y,0),o.push(U.x,U.y,0);for(let k=0;k<3;k++)e.push(u[0],u[1],u[2]),a.push(p),i.push(this._flags.totalDistance,0),s.push(this._flags.totalDistance),r.push(0),this.parameters.vertexColors&&l.push(m[0],m[1],m[2],m[3]);h.push(f+2,f+3,f+4,f+4,f+3,f+5,f+4,f+5,f+6),v+=3}}return v}),g(this,"_extrusions",(e,i,s,r,a,o,l,h,c,u,d,p)=>{i.push(c.x,c.y,0,-c.x,-c.y,0),e.push(h[0],h[1],h[2],h[0],h[1],h[2]),o.push(d,d),s.push(u,0,u,1),r.push(u,u),a.push(0,0),this.parameters.vertexColors&&l.push(p[0],p[1],p[2],p[3],p[0],p[1],p[2],p[3])}),this.parameters=t,this._needsUpdate=!1,this._needsCounter=!1,this._flags={lastFlip:-1,started:!1,normal:null,totalDistance:0}}setData(t){this._needsUpdate=!0,(this.parameters.dashed||this.parameters.enableAnimation||this.parameters.mapSrc||this.parameters.map)&&(this._needsCounter=!0),this.updateGeometry(t)}updateGeometry(t){const e=[],i=[],s=[],r=[],a=[],o=[],l=[],h=[],c=[],u=[],d=[];let p=0;for(let m=0;m<t.position.length;m++){const f=t.position[m],v=t.index[m],_=this.parameters.vertexWidths?t.lineWidth[m]:this.parameters.lineWidth,y=this.parameters.vertexColors?sn(t.color[m]):sn(this.parameters.color);this._flags={lastFlip:-1,started:!1,normal:null,totalDistance:0};const x=f.length;let b=e.length/3,w=null,M=Math.random();u.push(M,M),s.push(0,0),d.push(v,v);for(let T=1;T<x;T++){const R=w||f[T-1],E=f[T],A=T<x-1?f[T+1]:null;if(A&&Up(E,A)){w=R;continue}const z=this._segmentLines(e,i,o,c,a,h,l,r,R,E,A,_,y,b);z!==-1&&(b+=z,w=null);for(let F=0;F<z;F++)s.push(T/x),this._needsCounter&&this.parameters.enableAnimationChaos&&u.push(M),d.push(v);p=Math.max(this._flags.totalDistance,p)}if(this._needsCounter)for(let T=0;T<c.length;T++)c[T]=p}this.cachedPositions=e,this.setAttribute("position",new Z(e,3)),this.setAttribute("uv",new Z(i,2)),this.setAttribute("normal",new Z(h,3)),this.setAttribute("aWidth",new Z(a,1)),this.setAttribute("counter",new Z(s,1)),this.setAttribute("objectIndex",new Z(d,1)),this._needsCounter&&(this.setAttribute("lengths",new Z(o,1)),this.setAttribute("totalLength",new Z(c,1)),this.setAttribute("randomFactor",new Z(u,1))),this.parameters.vertexColors&&this.setAttribute("aColor",new Z(l,4)),this.setIndex(r),this.computeBoundingSphere(),this._needsUpdate=!1}_flipedUV(t,e,i,s){s?i===-1?t.push(e,1,e,0,e,1):t.push(e,0,e,1,e,0):i===-1?t.push(e,1,e,1,e,0,e,1):t.push(e,0,e,0,e,1,e,0)}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}}const cE=new Te,uE=ft.merge([rt.fog.uniforms,Gi,fo,{lineWidth:{value:100},keepSize:{value:!1},map:{value:null},useMap:{value:!1},uColor:{value:[0,1,1,1]},height:{value:0},opacity:{value:1},zoomUnits:{value:1},resolution:{value:new V(1,1)},sizeAttenuation:{value:1},dashArray:{value:20},dashOffset:{value:0},dashRatio:{value:.5},alphaTest:{value:0},repeat:{value:new V(1,1)},vertextColors:{value:!1},elapsedTime:{value:0},enableAnimation:{value:!1},enableAnimationChaos:{value:!1},animationInterval:{value:0},animationSpeed:{value:1},animationTailType:{value:1},animationTailRatio:{value:.2},animationTailLength:{value:100},animationIdle:{value:1e3}}]);class dE extends Fe{constructor(t){super(),this.type="FatLineMaterial",this.isFatLineMaterial=!0,this.fog=!0,this.transparent=!0,this.fragmentShader=`#define GLSLIFY 1
#include <common>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>

varying vec3 vLightFront;
varying vec3 vIndirectFront;

uniform sampler2D map;
uniform bool useMap;
uniform bool keepSize;
uniform float zoomUnits;
uniform float lineWidth;
uniform float opacity;
uniform float alphaTest;
uniform float elapsedTime;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vLength;
varying float vTotalLength;

#ifdef USE_ANIMATION
uniform float animationInterval;
varying float vAnimationOpacity;
#endif

#ifdef USE_DASH
uniform float dashArray;
uniform float dashOffset;
uniform float dashRatio;
varying float vDashOpacity;
#endif

void main() {

   vec4 c = vColor;

    if(useMap) {
        float margin = 140.0 * zoomUnits;
        float halfMargin = margin / 2.0;
        float texWidth = lineWidth * zoomUnits;
        float delta = mod(vUV.x, texWidth + margin);
        if (delta >= halfMargin && delta <= halfMargin + texWidth) {
            float uvx = (delta - halfMargin) / texWidth;
            vec4 texture = texture2D(map, vec2(uvx, vUV.y));
            c = texture.a >= 0.5 ? texture : c;
        }
    }

    #ifdef USE_ANIMATION
        float animationAlpha = vAnimationOpacity;
        if (animationInterval > 0.0) {
            animationAlpha = mod(vAnimationOpacity, animationInterval);
        }
        if (animationAlpha > 1.0 || animationAlpha < 0.0) {
            discard;
        }
        c.a *= animationAlpha;
    #endif

    #ifdef USE_DASH
        float darray = dashArray;
        if (keepSize) {
            darray *= zoomUnits;
        }
        c.a *= step(mod(vLength + dashOffset, darray), (darray * dashRatio));
    #endif

    if (c.a < alphaTest) {
        discard;
    }

    gl_FragColor = c;
    
    gl_FragColor.a *= opacity;

    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
	#include <encodings_fragment>
    
}`,this.vertexShader=`#define GLSLIFY 1
#include <common>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_keepsize_pars_vertex>

#ifdef USE_A_COLOR
attribute vec4 aColor;
#endif

// attribute float counter;
attribute float totalLength;
attribute float aWidth;
attribute float lengths;
attribute float randomFactor;

uniform float elapsedTime;
uniform bool vertexColors;
uniform vec4 uColor;
uniform float lineWidth;
uniform float height;
uniform float opacity;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vLength;
varying float vTotalLength;

#ifdef USE_ANIMATION
uniform float animationSpeed;
uniform float animationTailType;
uniform float animationTailRatio;
uniform float animationTailLength;
uniform float animationIdle;
varying float vAnimationOpacity;
#endif

void main() {

    #ifdef USE_A_COLOR
        vColor = aColor;
    #else
        vColor = uColor;
    #endif

    vUV = uv;
    // vCounter = counter;
    vLength = lengths;
    vTotalLength = totalLength;

    #include <begin_vertex>

    vec4 worldPosition = vec4(transformed, 1.0);
    worldPosition = modelMatrix * worldPosition;

    vec2 extrude = normal.xy * aWidth / 2.0;
    if (keepSize) {
        extrude *= zoomUnits;
    }
    worldPosition.xy += extrude;
    worldPosition.z += height;
    
    #ifdef USE_ANIMATION
        float tailLength = animationTailType == 1.0 ? vTotalLength * animationTailRatio : animationTailLength;

        #ifdef ANIMATION_CHAOS
            float currentTime = elapsedTime + randomFactor * 1000.0 * 3600.;
        #else
            float currentTime = elapsedTime;
        #endif
        float currentLength = mod(currentTime * animationSpeed, vTotalLength + tailLength + animationIdle * animationSpeed);
        vAnimationOpacity = (vLength - (currentLength - tailLength)) / tailLength;
    #endif

    gl_Position = projectionMatrix * viewMatrix * worldPosition;

    #include <beginnormal_vertex>
    #include <fog_vertex>
    #include <logdepthbuf_vertex>
}`,Object.assign(this.uniforms,ft.clone(uE)),Jt(this,["map","lineWidth","keepSize","height","opacity","dashArray","dashOffset","dashRatio","alphaTest","elapsedTime","animationInterval","animationSpeed","animationTailType","animationTailRatio","animationTailLength","animationIdle"]),rn(this,[["color","uColor",Kn]]),Ze(this,[["vertexColors","USE_A_COLOR"],["enableAnimation","USE_ANIMATION"],["enableAnimationChaos","ANIMATION_CHAOS"],["dashed","USE_DASH"]]),go(this),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc;if(this.userData.url_map===e)return;if(i&&i.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData.url_map;const s=cE.load(e);s.wrapS=s.wrapT=1001,this.uniforms.map.value=s,this.userData.url_map=e,this.uniforms.useMap.value=!0}}}),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}const Uy=new at,Hp=new kn,Sc=new ii;class pE extends gt{constructor(t){super(),g(this,"isWallGeometry",!0),g(this,"_needsUpdate",!1),this.parameters=t}setData(t){this._needsUpdate=!0,this.cachedData=t,this.updateGeometry()}updateGeometry(){let t=this.cachedData;const e=[],i=[],s=[],r=[],a=[],o=[],l=[];for(let h=0;h<t.position.length;h++){const c=t.position[h];t.index[h];const u=this.parameters.vertexColors?sn(t.color[h]):sn(this.parameters.color),d=this.parameters.vertexHeights?t.height[h]:this.parameters.height;let p=0;const m=c.length;let f=e.length/3;for(let v=0;v<m;v++){const _=c[v],y=[c[v][0],c[v][1],c[v][2]+d],x=v<m-1?c[v+1]:null;if((!x||!Up(_,x))&&(e.push(..._,...y),o.push(...u,...u),s.push(v/(m-1),v/(m-1)),a.push(p,p),i.push(p,0,p,1),v<m-1)){p+=fa(_,x);let b=f+2*v;r.push(b,b+2,b+1,b+1,b+2,b+3)}}for(let v=0;v<m;v++)l.push(p,p);f+=2*m}this.cachedPositions=e,this.setAttribute("position",new Z(e,3)),this.setAttribute("uv",new Z(i,2)),this.setAttribute("counter",new Z(s,1)),this.setAttribute("distances",new Z(a,1)),this.setAttribute("totalDistance",new Z(l,1)),this.parameters.vertexColors&&this.setAttribute("aColor",new Z(o,4)),this.setIndex(r),this.computeBoundingSphere(),this._needsUpdate=!1}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}}const mE=new Te,fE=ft.merge([rt.fog.uniforms,Gi,fo,{map:{value:null},useMap:{value:!1},uColor:{value:[0,1,1,1]},minOpacity:{value:0},maxOpacity:{value:1},opacity:{value:1},zoomUnits:{value:1},vertextColors:{value:!1},elapsedTime:{value:0},enableAnimation:{value:!1},animationSpeed:{value:1},animationTailType:{value:3},animationTailRatio:{value:.2},animationTailLength:{value:100},animationIdle:{value:1e3}}]);class gE extends Fe{constructor(t){super(),this.type="WallMaterial",this.isWallMaterial=!0,this.fog=!0,this.transparent=!0,this.depthWrite=!1,this.side=2,this.fragmentShader=`#define GLSLIFY 1
#include <common>
#include <bsdfs>
#include <fog_pars_fragment>

#include <logdepthbuf_pars_fragment>
varying vec3 vLightFront;
varying vec3 vIndirectFront;

uniform sampler2D map;
uniform bool useMap;
uniform float zoomUnits;
uniform float minOpacity;
uniform float maxOpacity;
uniform float opacity;
uniform float elapsedTime;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vDistance;
varying float vTotalDistance;

#ifdef USE_ANIMATION
varying float vAnimationOpacity;
#endif

void main() {

    vec4 c = vColor;

    if(useMap) {
        vec4 texture = texture2D(map, vec2(vUV.x / vTotalDistance, vUV.y));
        c *= texture;
    }

    #ifdef USE_ANIMATION
        if (vAnimationOpacity > 1.0 || vAnimationOpacity < 0.0) {
            c.a = 0.0;
        }
        c.a *= vAnimationOpacity;
    #endif

    gl_FragColor = c;
    
    gl_FragColor.a *= opacity;

    if (maxOpacity > minOpacity) {
        gl_FragColor.a = clamp(gl_FragColor.a, minOpacity, maxOpacity);
    }

    #include <fog_fragment>
    #include <logdepthbuf_fragment>
}`,this.vertexShader=`#define GLSLIFY 1
#include <common>
#include <bsdfs>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#ifdef USE_A_COLOR
attribute vec4 aColor;
#endif

attribute float counter;
attribute float totalDistance;
attribute float distances;

uniform float elapsedTime;
uniform bool vertexColors;
uniform vec4 uColor;
uniform float opacity;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vDistance;
varying float vTotalDistance;

#ifdef USE_ANIMATION
uniform float animationSpeed;
uniform float animationTailType;
uniform float animationTailRatio;
uniform float animationTailLength;
uniform float animationIdle;
varying float vAnimationOpacity;
#endif

void main() {

    #ifdef USE_A_COLOR
        vColor = aColor;
    #else
        vColor = uColor;
    #endif

    vUV = uv;
    vCounter = counter;
    vDistance = distances;
    vTotalDistance = totalDistance;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    #ifdef USE_ANIMATION
        if (animationTailType < 3.0) {
            float tailLength = animationTailType == 1.0 ? totalDistance * animationTailRatio : animationTailLength;
            float currentLength = mod(elapsedTime * animationSpeed, totalDistance + tailLength + animationIdle * animationSpeed);
            vAnimationOpacity = (distances - (currentLength - tailLength)) / tailLength;
        }
        else if (animationTailType == 3.0) {
            vAnimationOpacity = 1.0 - mod(elapsedTime * animationSpeed / 1000.0, 1.0) + uv.y;
        }
    #endif

    #include <beginnormal_vertex>
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    #include <fog_vertex>

    #include <logdepthbuf_vertex>
}`,Object.assign(this.uniforms,ft.clone(fE)),Jt(this,["map","minOpacity","maxOpacity","opacity","elapsedTime","animationSpeed","animationTailType","animationTailRatio","animationTailLength","animationIdle"]),rn(this,[["color","uColor",Kn]]),Ze(this,[["vertexColors","USE_A_COLOR"],["enableAnimation","USE_ANIMATION"]]),go(this),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const i=this.mapSrc;if(this.userData.url_map===e)return;if(i&&i.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData.url_map;const s=mE.load(e);s.wrapS=s.wrapT=1001,this.uniforms.map.value=s,this.userData.url_map=e,this.uniforms.useMap.value=!0}}}),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}var Tc={exports:{}};function Ec(n,t,e){e=e||2;var i,s,r,a,o,l,h,c=t&&t.length,u=c?t[0]*e:n.length,d=Fy(n,0,u,e,!0),p=[];if(!d||d.next===d.prev)return p;if(c&&(d=function(f,v,_,y){var x,b,w,M=[];for(x=0,b=v.length;x<b;x++)(w=Fy(f,v[x]*y,x<b-1?v[x+1]*y:f.length,y,!1))===w.next&&(w.steiner=!0),M.push(SE(w));for(M.sort(bE),x=0;x<M.length;x++)_=ME(M[x],_);return _}(n,t,d,e)),n.length>80*e){i=r=n[0],s=a=n[1];for(var m=e;m<u;m+=e)(o=n[m])<i&&(i=o),(l=n[m+1])<s&&(s=l),o>r&&(r=o),l>a&&(a=l);h=(h=Math.max(r-i,a-s))!==0?32767/h:0}return ko(d,p,e,i,s,h,0),p}function Fy(n,t,e,i,s){var r,a;if(s===Xp(n,t,e,i)>0)for(r=t;r<e;r+=i)a=By(r,n[r],n[r+1],a);else for(r=e-i;r>=t;r-=i)a=By(r,n[r],n[r+1],a);return a&&Cc(a,a.next)&&(Vo(a),a=a.next),a}function Qs(n,t){if(!n)return n;t||(t=n);var e,i=n;do if(e=!1,i.steiner||!Cc(i,i.next)&&re(i.prev,i,i.next)!==0)i=i.next;else{if(Vo(i),(i=t=i.prev)===i.next)break;e=!0}while(e||i!==t);return t}function ko(n,t,e,i,s,r,a){if(n){!a&&r&&function(c,u,d,p){var m=c;do m.z===0&&(m.z=Wp(m.x,m.y,u,d,p)),m.prevZ=m.prev,m.nextZ=m.next,m=m.next;while(m!==c);m.prevZ.nextZ=null,m.prevZ=null,function(f){var v,_,y,x,b,w,M,T,R=1;do{for(_=f,f=null,b=null,w=0;_;){for(w++,y=_,M=0,v=0;v<R&&(M++,y=y.nextZ);v++);for(T=R;M>0||T>0&&y;)M!==0&&(T===0||!y||_.z<=y.z)?(x=_,_=_.nextZ,M--):(x=y,y=y.nextZ,T--),b?b.nextZ=x:f=x,x.prevZ=b,b=x;_=y}b.nextZ=null,R*=2}while(w>1)}(m)}(n,i,s,r);for(var o,l,h=n;n.prev!==n.next;)if(o=n.prev,l=n.next,r?_E(n,i,s,r):vE(n))t.push(o.i/e|0),t.push(n.i/e|0),t.push(l.i/e|0),Vo(n),n=l.next,h=l.next;else if((n=l)===h){a?a===1?ko(n=yE(Qs(n),t,e),t,e,i,s,r,2):a===2&&xE(n,t,e,i,s,r):ko(Qs(n),t,e,i,s,r,1);break}}}function vE(n){var t=n.prev,e=n,i=n.next;if(re(t,e,i)>=0)return!1;for(var s=t.x,r=e.x,a=i.x,o=t.y,l=e.y,h=i.y,c=s<r?s<a?s:a:r<a?r:a,u=o<l?o<h?o:h:l<h?l:h,d=s>r?s>a?s:a:r>a?r:a,p=o>l?o>h?o:h:l>h?l:h,m=i.next;m!==t;){if(m.x>=c&&m.x<=d&&m.y>=u&&m.y<=p&&ya(s,o,r,l,a,h,m.x,m.y)&&re(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function _E(n,t,e,i){var s=n.prev,r=n,a=n.next;if(re(s,r,a)>=0)return!1;for(var o=s.x,l=r.x,h=a.x,c=s.y,u=r.y,d=a.y,p=o<l?o<h?o:h:l<h?l:h,m=c<u?c<d?c:d:u<d?u:d,f=o>l?o>h?o:h:l>h?l:h,v=c>u?c>d?c:d:u>d?u:d,_=Wp(p,m,t,e,i),y=Wp(f,v,t,e,i),x=n.prevZ,b=n.nextZ;x&&x.z>=_&&b&&b.z<=y;){if(x.x>=p&&x.x<=f&&x.y>=m&&x.y<=v&&x!==s&&x!==a&&ya(o,c,l,u,h,d,x.x,x.y)&&re(x.prev,x,x.next)>=0||(x=x.prevZ,b.x>=p&&b.x<=f&&b.y>=m&&b.y<=v&&b!==s&&b!==a&&ya(o,c,l,u,h,d,b.x,b.y)&&re(b.prev,b,b.next)>=0))return!1;b=b.nextZ}for(;x&&x.z>=_;){if(x.x>=p&&x.x<=f&&x.y>=m&&x.y<=v&&x!==s&&x!==a&&ya(o,c,l,u,h,d,x.x,x.y)&&re(x.prev,x,x.next)>=0)return!1;x=x.prevZ}for(;b&&b.z<=y;){if(b.x>=p&&b.x<=f&&b.y>=m&&b.y<=v&&b!==s&&b!==a&&ya(o,c,l,u,h,d,b.x,b.y)&&re(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function yE(n,t,e){var i=n;do{var s=i.prev,r=i.next.next;!Cc(s,r)&&Ny(s,i,i.next,r)&&Bo(s,r)&&Bo(r,s)&&(t.push(s.i/e|0),t.push(i.i/e|0),t.push(r.i/e|0),Vo(i),Vo(i.next),i=n=r),i=i.next}while(i!==n);return Qs(i)}function xE(n,t,e,i,s,r){var a=n;do{for(var o=a.next.next;o!==a.prev;){if(a.i!==o.i&&TE(a,o)){var l=ky(a,o);return a=Qs(a,a.next),l=Qs(l,l.next),ko(a,t,e,i,s,r,0),void ko(l,t,e,i,s,r,0)}o=o.next}a=a.next}while(a!==n)}function bE(n,t){return n.x-t.x}function ME(n,t){var e=function(s,r){var a,o=r,l=s.x,h=s.y,c=-1/0;do{if(h<=o.y&&h>=o.next.y&&o.next.y!==o.y){var u=o.x+(h-o.y)*(o.next.x-o.x)/(o.next.y-o.y);if(u<=l&&u>c&&(c=u,a=o.x<o.next.x?o:o.next,u===l))return a}o=o.next}while(o!==r);if(!a)return null;var d,p=a,m=a.x,f=a.y,v=1/0;o=a;do l>=o.x&&o.x>=m&&l!==o.x&&ya(h<f?l:c,h,m,f,h<f?c:l,h,o.x,o.y)&&(d=Math.abs(h-o.y)/(l-o.x),Bo(o,s)&&(d<v||d===v&&(o.x>a.x||o.x===a.x&&wE(a,o)))&&(a=o,v=d)),o=o.next;while(o!==p);return a}(n,t);if(!e)return t;var i=ky(e,n);return Qs(i,i.next),Qs(e,e.next)}function wE(n,t){return re(n.prev,n,t.prev)<0&&re(t.next,n,n.next)<0}function Wp(n,t,e,i,s){return(n=1431655765&((n=858993459&((n=252645135&((n=16711935&((n=(n-e)*s|0)|n<<8))|n<<4))|n<<2))|n<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-i)*s|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function SE(n){var t=n,e=n;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==n);return e}function ya(n,t,e,i,s,r,a,o){return(s-a)*(t-o)>=(n-a)*(r-o)&&(n-a)*(i-o)>=(e-a)*(t-o)&&(e-a)*(r-o)>=(s-a)*(i-o)}function TE(n,t){return n.next.i!==t.i&&n.prev.i!==t.i&&!function(e,i){var s=e;do{if(s.i!==e.i&&s.next.i!==e.i&&s.i!==i.i&&s.next.i!==i.i&&Ny(s,s.next,e,i))return!0;s=s.next}while(s!==e);return!1}(n,t)&&(Bo(n,t)&&Bo(t,n)&&function(e,i){var s=e,r=!1,a=(e.x+i.x)/2,o=(e.y+i.y)/2;do s.y>o!=s.next.y>o&&s.next.y!==s.y&&a<(s.next.x-s.x)*(o-s.y)/(s.next.y-s.y)+s.x&&(r=!r),s=s.next;while(s!==e);return r}(n,t)&&(re(n.prev,n,t.prev)||re(n,t.prev,t))||Cc(n,t)&&re(n.prev,n,n.next)>0&&re(t.prev,t,t.next)>0)}function re(n,t,e){return(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y)}function Cc(n,t){return n.x===t.x&&n.y===t.y}function Ny(n,t,e,i){var s=Pc(re(n,t,e)),r=Pc(re(n,t,i)),a=Pc(re(e,i,n)),o=Pc(re(e,i,t));return s!==r&&a!==o||!(s!==0||!Ac(n,e,t))||!(r!==0||!Ac(n,i,t))||!(a!==0||!Ac(e,n,i))||!(o!==0||!Ac(e,t,i))}function Ac(n,t,e){return t.x<=Math.max(n.x,e.x)&&t.x>=Math.min(n.x,e.x)&&t.y<=Math.max(n.y,e.y)&&t.y>=Math.min(n.y,e.y)}function Pc(n){return n>0?1:n<0?-1:0}function Bo(n,t){return re(n.prev,n,n.next)<0?re(n,t,n.next)>=0&&re(n,n.prev,t)>=0:re(n,t,n.prev)<0||re(n,n.next,t)<0}function ky(n,t){var e=new qp(n.i,n.x,n.y),i=new qp(t.i,t.x,t.y),s=n.next,r=t.prev;return n.next=t,t.prev=n,e.next=s,s.prev=e,i.next=e,e.prev=i,r.next=i,i.prev=r,i}function By(n,t,e,i){var s=new qp(n,t,e);return i?(s.next=i.next,s.prev=i,i.next.prev=s,i.next=s):(s.prev=s,s.next=s),s}function Vo(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function qp(n,t,e){this.i=n,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Xp(n,t,e,i){for(var s=0,r=t,a=e-i;r<e;r+=i)s+=(n[a]-n[r])*(n[r+1]+n[a+1]),a=r;return s}Tc.exports=Ec,Tc.exports.default=Ec,Ec.deviation=function(n,t,e,i){var s=t&&t.length,r=s?t[0]*e:n.length,a=Math.abs(Xp(n,0,r,e));if(s)for(var o=0,l=t.length;o<l;o++){var h=t[o]*e,c=o<l-1?t[o+1]*e:n.length;a-=Math.abs(Xp(n,h,c,e))}var u=0;for(o=0;o<i.length;o+=3){var d=i[o]*e,p=i[o+1]*e,m=i[o+2]*e;u+=Math.abs((n[d]-n[m])*(n[p+1]-n[d+1])-(n[d]-n[p])*(n[m+1]-n[d+1]))}return a===0&&u===0?0:Math.abs((u-a)/a)},Ec.flatten=function(n){for(var t=n[0][0].length,e={vertices:[],holes:[],dimensions:t},i=0,s=0;s<n.length;s++){for(var r=0;r<n[s].length;r++)for(var a=0;a<t;a++)e.vertices.push(n[s][r][a]);s>0&&(i+=n[s-1].length,e.holes.push(i))}return e};const Rc=[1,1,0,1];class EE extends gt{constructor(t){super(),g(this,"isPolygonGeometry",!0),g(this,"_useUV",!1),g(this,"_useNormal",!1),g(this,"_sideUVNormalized",!1),g(this,"_sideUVReversed",!1),g(this,"_sideUVUseHeight",!1),g(this,"addGeoPolygonToVertices",(e,i,s=0,r=0,a,o,l,h,c,u,d,p)=>{const m=e.vertices,f=e.dimensions;Array.isArray(u)||(u=Rc);for(let v=0,_=m.length-f+1;v<_;v+=f)f===2?a.push(m[v],m[v+1],0+s):a.push(m[v],m[v+1],m[v+2]+s),l.push(0,0,1),c.push(u[0],u[1],u[2],u[3]),h.push(m[v],m[v+1]),d.push(p);for(let v=0,_=i.length;v<_;++v)o.push(i[v]+r)}),g(this,"isClockWise",e=>{let i=e.length,s=0;for(let r=i-1,a=0;a<i;r=a++)s+=e[r][0]*e[a][1]-e[a][0]*e[r][1];return s<0}),g(this,"addSideFace",(e,i,s,r,a,o,l,h,c,u,d)=>{let p=e[0],m=s;p.length,this.isClockWise(p)&&(p=p.reverse()),Array.isArray(c)||(c=Rc);let f=0,v=0,_=0;for(let y=0,x=p.length-1;y<x;y++){r.push(p[y][0],p[y][1],0,p[y][0],p[y][1],i,p[y+1][0],p[y+1][1],i,p[y+1][0],p[y+1][1],0),m=s+4*y,a.push(m,m+2,m+1,m,m+3,m+2);let b=p[y+1][0]-p[y][0],w=p[y+1][1]-p[y][1];const M=Math.sqrt(b*b+w*w);b/=M,w/=M,o.push(w,-b,0,w,-b,0,w,-b,0,w,-b,0),this._sideUVUseHeight?(v=1*i,_=1*i):(v=0,_=1*i,this._sideUVNormalized&&(_=1),this._sideUVReversed&&(v=_,_=0)),l.push(1*f,v,1*f,_),f+=M,l.push(1*f,_,1*f,v),h.push(c[0],c[1],c[2],c[3],c[0],c[1],c[2],c[3],c[0],c[1],c[2],c[3],c[0],c[1],c[2],c[3]),u.push(d,d,d,d)}}),this.parameters=t,this._needsUpdate=!1,this._extrude=t.extrude||!1,this._extrudeValue=t.extrudeValue||0,this.cachedPositions=[],this.cachedObjectIndices=[]}setData(t){this._needsUpdate=!0,this.cachedData=t,this.updateGeometry()}updateGeometry(){let t=this.cachedData,e=null,i=null;const s=[],r=[],a=[],o=[],l=[],h=[];for(let u=0;u<t.position.length;u++){const d=t.position[u],p=t.index[u],m=t.color?sn(t.color[u]):Rc,f=this.parameters.vertexHeights?t.height[u]:this.extrudeValue;e=Tc.exports.flatten(d),i=Tc.exports(e.vertices,e.holes,e.dimensions),this.addGeoPolygonToVertices(e,i,f,s.length/3,s,l,r,a,h,m,o,p)}const c=l.length;if(this.extrude)for(let u=0;u<t.position.length;u++){const d=t.position[u],p=t.index[u],m=t.color?sn(t.color[u]):Rc,f=this.parameters.vertexHeights?t.height[u]:this.extrudeValue;f>0&&this.addSideFace(d,f,s.length/3,s,l,r,a,h,m,o,p)}this.cachedPositions=s,this.cachedObjectIndices=o,this.setAttribute("position",new Z(s,3)),this.parameters.vertexColors&&this.setAttribute("aColor",new Z(h,4)),this._useUV?this.setAttribute("uv",new Z(a,2)):this.deleteAttribute("uv"),this._useNormal?this.setAttribute("normal",new Z(r,3)):this.deleteAttribute("normal"),this.setIndex(l),this.clearGroups(),this.addGroup(0,c,1),this.extrude&&this.addGroup(c,l.length-c,0),this.computeBoundingSphere(),this._needsUpdate=!1}get extrude(){return this._extrude}set extrude(t){const e=!!t;e!==this._extrude&&(this._extrude=e,this._needsUpdate=!0)}get extrudeValue(){return this._extrudeValue}set extrudeValue(t){!isNaN(t)&&t>=0&&t!==this._extrudeValue&&(this._extrudeValue=t,this._needsUpdate=!0)}get sideUVNormalized(){return this._sideUVNormalized}set sideUVNormalized(t){t!==this._sideUVNormalized&&(this._extrude&&(this._needsUpdate=!0),this._sideUVNormalized=t)}get sideUVReversed(){return this._sideUVReversed}set sideUVReversed(t){t!==this._sideUVReversed&&(this._extrude&&(this._needsUpdate=!0),this._sideUVReversed=t)}get sideUVUseHeight(){return this._sideUVUseHeight}set sideUVUseHeight(t){t!==this._sideUVUseHeight&&(this._extrude&&(this._needsUpdate=!0),this._sideUVUseHeight=t)}get useUV(){return this._useUV}set useUV(t){t!==this._useUV&&(this._needsUpdate=!0,this._useUV=t)}get useNormal(){return this._useNormal}set useNormal(t){t!==this._useNormal&&(this._needsUpdate=!0,this._useNormal=t)}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}}const CE=ft.merge([rt.fog.uniforms,Gi,fo,{opacity:{value:1},color:{value:[0,1,1,1]},vertextColors:{value:!1}}]);class AE extends Fe{constructor(t){super(),this.type="PolygonMaterial",this.isPolygonMaterial=!0,this.fog=!0,this.transparent=!0,this.depthWrite=!0,this.depthTest=!0,this.fragmentShader=`#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#endif

uniform vec4 color;
uniform float opacity;

#include <logdepthbuf_pars_fragment>
#include <mvt_selective_pars_fragment>

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        gl_FragColor = vColor;
    #else
        gl_FragColor = color;
    #endif

    gl_FragColor.a *= opacity;
    if (gl_FragColor.a <= 0.) {
        discard;
    }

	#include <mvt_selective_fragment>
	#include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
	#include <encodings_fragment>
    
}

`,this.vertexShader=`#define GLSLIFY 1
#include <common>
#include <fog_pars_vertex>

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
    varying vec4 vColor;
#endif

#include <logdepthbuf_pars_vertex>
#include <mvt_selective_pars_vertex>

void main() {

    #include <mvt_selective_vertex>

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #endif

    #include <begin_vertex>
    #include <project_vertex>
    #include <worldpos_vertex>
    #include <fog_vertex>
    #include <logdepthbuf_vertex>

}

`,Object.assign(this.uniforms,ft.clone(CE)),Jt(this,["opacity"]),Qr(this,["color"]),Ze(this,[["vertexColors","MVT_USE_VERTEX_COLOR"]]),Qn(this),go(this),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(t)}}class PE extends xc{constructor(t){super(t),g(this,"isLightSphereGeometry",!0),g(this,"_needsUpdate",!1),g(this,"setModelData",()=>{this._needsUpdate=!0,this.updateGeometry()}),this.type="LightSphereGeometry",this.parameters=t,this.setModelData()}updateGeometry(){const t=[],e=[],i=[],s=[];let r=this.parameters.radius||10,a=this.parameters.widthSegments||32,o=this.parameters.heightSegments||16,l=this.parameters.phiStart||0,h=this.parameters.phiLength||2*Math.PI,c=this.parameters.thetaStart||0,u=this.parameters.thetaLength||Math.PI;this.parameters.widthSegments=Math.max(3,Math.floor(a)),this.parameters.heightSegments=Math.max(2,Math.floor(o));const d=Math.min(c+u,Math.PI);let p=0;const m=[],f=new S,v=new S;for(let _=0;_<=o;_++){const y=[],x=_/o;let b=0;_===0&&c===0?b=.5/a:_===o&&d===Math.PI&&(b=-.5/a);for(let w=0;w<=a;w++){const M=w/a;f.x=-r*Math.cos(l+M*h)*Math.sin(c+x*u),f.y=r*Math.cos(c+x*u),f.z=r*Math.sin(l+M*h)*Math.sin(c+x*u),e.push(f.x,f.y,f.z),v.copy(f).normalize(),i.push(v.x,v.y,v.z),s.push(M+b,1-x),y.push(p++)}m.push(y)}for(let _=0;_<o;_++)for(let y=0;y<a;y++){const x=m[_][y+1],b=m[_][y],w=m[_+1][y],M=m[_+1][y+1];(_!==0||c>0)&&t.push(x,b,M),(_!==o-1||d<Math.PI)&&t.push(b,w,M)}this.setIndex(t),this.setAttribute("position",new Z(e,3)),this.setAttribute("normal",new Z(i,3)),this.setAttribute("uv",new Z(s,2)),this._needsUpdate=!1}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}}const RE=ft.merge([{color:{value:[0,.7,1,1]}}]);class LE extends dn{constructor(t){super(t),g(this,"type","LightSphereMaterial"),g(this,"isLightSphereMaterial",!0),this.vertexShader=`#define GLSLIFY 1
#include <common>

varying vec3 vNormal;
uniform float elapsedTime;
uniform bool animationEffect;
uniform float animationEffectPeriod;

void main() {
    vNormal = normalize(normalMatrix * normal); // 顶点的法向量执行插值计算
    if (animationEffect) {
        float scaleRatio = mod(elapsedTime, animationEffectPeriod) / animationEffectPeriod;
        float t = sin(scaleRatio * 2.0 * PI) * 0.5 + 0.5;
        vec3 newPosition = mix(position, position * 2.0, t);
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(newPosition, 1.0);
    }
    else {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
    }
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

varying vec3 vNormal;
uniform vec4 color;

void main() {
    vec3 z = vec3(0.0, 0.0, 1.0); // z轴方向单位向量
    float x = abs(dot(vNormal, z)); // 点乘结果余弦值绝对值范围[0,1]
    float alpha = pow(1.0 - x, 2.0);
    gl_FragColor = vec4(vec3(color[0], color[1], color[2]), alpha);
}`,Object.assign(this.uniforms,ft.clone(RE)),this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class Yp extends xc{constructor(t){super(t),g(this,"_needsUpdate",!1),g(this,"setModelData",()=>{this._needsUpdate=!0,this.updateGeometry()}),this.parameters={...t,radiusTop:t.radiusTop||t.radius||6,radiusBottom:t.radiusBottom||t.radius||6,height:t.height||50,openEnded:t.openEnded||!1,color:t.color||[80,20,170,.8],isLight:t.isLight||!0,lightPos:t.lightPos||60},this.parameters.radialSegments=t.radialSegments?Math.floor(t.radialSegments):4,this.parameters.heightSegments=t.heightSegments?Math.floor(t.heightSegments):1,this.setModelData()}updateGeometry(){const t=[],e=[],i=[],s=[],r=[];let a={index:0,indexArray:[],halfHeight:0,groupStart:0};this.generateTorso(t,e,i,s,r,a),this.parameters.openEnded===!1&&(this.parameters.radiusTop>0&&this.generateCap(!0,t,e,i,s,r,a),this.parameters.radiusBottom>0&&this.generateCap(!1,t,e,i,s,r,a)),this.addCustomGeometry(t,e,i,s,r,a),this.setIndex(t),this.setAttribute("position",new Z(e,3)),this.setAttribute("normal",new Z(i,3)),this.setAttribute("uv",new Z(s,2)),this.addCustomAttribute(r),this._needsUpdate=!1}addCustomGeometry(){}addCustomAttribute(){}generateCap(t,e,i,s,r,a,o){}generateTorso(t,e,i,s,r,a){}get needsUpdate(){return this._needsUpdate}set needsUpdate(t){this._needsUpdate=t}}class IE extends Yp{constructor(t){super(t),this.type="GridGeometry",this.parameters.multiColor=t.multiColor||[],this.parameters.isMultiColor=t.isMultiColor||!1}generateTorso(t,e,i,s,r,a){const o=new S,l=new S;let h=0;const c=(this.parameters.radiusBottom-this.parameters.radiusTop)/this.parameters.height;for(let u=0;u<=this.parameters.heightSegments;u++){const d=[],p=u/this.parameters.heightSegments,m=(1-p)*this.parameters.radiusBottom+p*this.parameters.radiusTop;for(let f=0;f<=this.parameters.radialSegments;f++){const v=f/this.parameters.radialSegments,_=2*v*Math.PI,y=Math.sin(_),x=Math.cos(_);l.x=m*y,l.y=m*x,l.z=p*this.parameters.height,e.push(l.x,l.y,l.z),this.parameters.isMultiColor&&Array.isArray(this.parameters.multiColor)&&this.addMultiColors("torso",r,l.z),o.set(y,x,c).normalize(),i.push(o.x,o.y,o.z),s.push(v,p),d.push(a.index++)}a.indexArray.push(d)}for(let u=0;u<this.parameters.radialSegments;u++)for(let d=0;d<this.parameters.heightSegments;d++){const p=a.indexArray[d][u],m=a.indexArray[d+1][u],f=a.indexArray[d+1][u+1],v=a.indexArray[d][u+1];t.push(p,m,v),t.push(m,f,v),h+=6}this.addGroup(a.groupStart,h,0),a.groupStart+=h}generateCap(t,e,i,s,r,a,o){const l=o.index,h=new V,c=new S;let u=0;const d=t===!0?this.parameters.radiusTop:this.parameters.radiusBottom,p=t===!0?1:0,m=t?1:-1;for(let v=1;v<=this.parameters.radialSegments;v++)this.parameters.isMultiColor&&Array.isArray(this.parameters.multiColor)&&this.addMultiColors("cap",a,this.parameters.height*p),i.push(0,0,this.parameters.height*p),s.push(0,0,m),r.push(.5,.5),o.index++;const f=o.index;for(let v=0;v<=this.parameters.radialSegments;v++){const _=2*(v/this.parameters.radialSegments)*Math.PI,y=Math.cos(_),x=Math.sin(_);c.x=d*x,c.y=d*y,c.z=this.parameters.height*p,i.push(c.x,c.y,c.z),this.parameters.isMultiColor&&Array.isArray(this.parameters.multiColor)&&this.addMultiColors("cap",a,c.z),s.push(0,0,m),h.x=.5*y+.5,h.y=.5*x*p+.5,r.push(h.x,h.y),o.index++}for(let v=0;v<this.parameters.radialSegments;v++){const _=l+v,y=f+v;t===!0?e.push(y,y+1,_):e.push(y+1,y,_),u+=3}this.addGroup(o.groupStart,u,t===!0?1:2),o.groupStart+=u}addCustomAttribute(t){this.parameters.isMultiColor&&this.setAttribute("mColor",new Z(t,4))}addMultiColors(t,e,i){const s=this.parameters.multiColor.map(r=>sn(r));if(t==="cap")i===this.parameters.height?e.push(...s[s.length-1]):e.push(...s[0]);else if(t==="torso"&&this.parameters.heightSegments<=s.length){const r=this.parameters.height/this.parameters.heightSegments;for(let a=0;a<=this.parameters.heightSegments;a++)i===r*a&&e.push(...s[a])}}}const DE=ft.merge([{color:{value:[0,.7,.9,1]},lightPos:{value:60}}]);class OE extends dn{constructor(t){super(t),g(this,"type","GridMaterial"),g(this,"isGridMaterial",!0),this.vertexShader=`#define GLSLIFY 1
#include <common>

attribute vec4 mColor;

varying vec3 vPosition;
varying vec4 vColor;
uniform vec4 color;

void main() {

    #ifdef USE_MULTICOLOR
        vColor = mColor;
    #else
        vColor = color;
    #endif

    vPosition = position;

    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

varying vec3 vPosition;
uniform vec4 color;
uniform float lightPos;
varying vec4 vColor;

void main() {

    #ifdef USE_LIGHT
        float a = 1.0 - vPosition.z / lightPos;
        if (a <= 0.) {
            discard;
        }
    #else
        float a = 1.0;
    #endif
    
    gl_FragColor = vec4(vec3(vColor[0], vColor[1], vColor[2]), a);
}`,this.side=2,this.transparent=!0,Object.assign(this.uniforms,ft.clone(DE)),Jt(this,["lightPos"]),Ze(this,[["isMultiColor","USE_MULTICOLOR"],["isLight","USE_LIGHT"]]),this.setValues(t)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class zE extends Yp{constructor(t){super(t),this.type="PillarGeometry"}generateTorso(t,e,i,s,r,a){const o=new S,l=new S;let h=0;for(let c=0;c<=this.parameters.heightSegments;c++){const u=[],d=c/this.parameters.heightSegments,p=this.parameters.radius;for(let m=0;m<=this.parameters.radialSegments;m++){const f=m/this.parameters.radialSegments,v=2*f*Math.PI,_=Math.sin(v),y=Math.cos(v);l.x=p*_,l.y=p*y,this.parameters.vertexHeights?l.z=d:l.z=d*this.parameters.height,e.push(l.x,l.y,l.z),o.set(_,y,0).normalize(),i.push(o.x,o.y,o.z),s.push(f,d),u.push(a.index++)}a.indexArray.push(u)}for(let c=0;c<this.parameters.radialSegments;c++)for(let u=0;u<this.parameters.heightSegments;u++){const d=a.indexArray[u][c],p=a.indexArray[u+1][c],m=a.indexArray[u+1][c+1],f=a.indexArray[u][c+1];t.push(d,p,f),t.push(p,m,f),h+=6}this.addGroup(a.groupStart,h,0),a.groupStart+=h}generateCap(t,e,i,s,r,a,o){const l=o.index,h=new S;let c=0;const u=this.parameters.radius,d=t===!0?1:0,p=t?1:-1;for(let f=1;f<=this.parameters.radialSegments;f++)this.parameters.vertexHeights?i.push(0,0,d):i.push(0,0,d*this.parameters.height),s.push(0,0,p),r.push(.5,d),o.index++;const m=o.index;for(let f=0;f<=this.parameters.radialSegments;f++){const v=2*(f/this.parameters.radialSegments)*Math.PI,_=Math.cos(v),y=Math.sin(v);h.x=u*y,h.y=u*_,this.parameters.vertexHeights?h.z=d:h.z=d*this.parameters.height,i.push(h.x,h.y,h.z),s.push(0,0,p),r.push(.5,d),o.index++}for(let f=0;f<this.parameters.radialSegments;f++){const v=l+f,_=m+f;t===!0?e.push(_,_+1,v):e.push(_+1,_,v),c+=3}this.addGroup(o.groupStart,c,t===!0?1:2),o.groupStart+=c}}const UE=ft.merge([{color:{value:[0,.7,.9,1]},lightPos:{value:60},gradientMap:{value:null},maxHeight:{value:50},vertexHeights:{value:!1}}]);class FE extends dn{constructor(t){super(t),g(this,"type","PillarMaterial"),g(this,"isGridMaterial",!0),this.vertexShader=`#define GLSLIFY 1
#include <common>

uniform float maxHeight;
varying vec2 vUv;

#include <logdepthbuf_pars_vertex>
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);

    #ifdef MVT_USE_VERTEX_HEIGHT
        float instanceHeight = instanceMatrix[2][2];
        vUv = vec2(uv.x, uv.y * (instanceHeight / maxHeight));
    #else
        vUv = uv;
    #endif

    #include <logdepthbuf_vertex>
}`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform sampler2D gradientMap;
uniform float opacity;

varying vec2 vUv;

#include <logdepthbuf_pars_fragment>
void main() {
    gl_FragColor = texture2D(gradientMap, vUv.yx);
    gl_FragColor.a *= opacity;

    #include <logdepthbuf_fragment>
}`,this.side=2,this.transparent=!0,Jt(this,["maxHeight"]),Ze(this,[["vertexHeights","MVT_USE_VERTEX_HEIGHT"]]),Object.assign(this.uniforms,ft.clone(UE)),this._cachedGradient=null,Object.defineProperties(this,{gradient:{get:function(){return this._cachedGradient},set:function(e){this._cachedGradient=e,this.updateGradientMap()}}}),this.createGradientMap(),this.uniforms.gradientMap.value=this._cachedGradientMap,this.setValues(t)}createGradientMap(){let t=document.createElement("canvas");t.width=64,t.height=2;let e=t.getContext("2d"),i=e.createLinearGradient(0,0,64,0);i.addColorStop(0,"rgba(0,0,255,1)"),i.addColorStop(.3,"rgba(0,255,0,1)"),i.addColorStop(.6,"rgba(255,255,0,1)"),i.addColorStop(1,"rgba(255,0,0,1)"),e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap=new Se(t)}updateGradientMap(){let t=this._cachedGradient;if(Object.prototype.toString.call(t)!=="[object Object]")return;let e=this._cachedGradientMap.image.getContext("2d");e.clearRect(0,0,64,2);let i=e.createLinearGradient(0,0,64,0);for(const s in t)Object.hasOwnProperty.call(t,s)&&i.addColorStop(s,t[s]);e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap.needsUpdate=!0}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class NE extends Yp{constructor(t){super(t),this.type="PillarGeometry"}addRadiusFunc(t){return 1-Math.sqrt(t)}generateTorso(t,e,i,s,r,a){const o=new S;let l=0;for(let h=0;h<=this.parameters.heightSegments;h++){const c=[],u=h/this.parameters.heightSegments;let d=this.addRadiusFunc(u);this.parameters.vertexSizes||(d*=this.parameters.size);for(let p=0;p<=this.parameters.radialSegments;p++){const m=p/this.parameters.radialSegments,f=2*m*Math.PI,v=Math.sin(f),_=Math.cos(f);o.x=d*v,o.y=d*_,this.parameters.vertexHeights?o.z=u:o.z=u*this.parameters.height,e.push(o.x,o.y,o.z),s.push(m,u),c.push(a.index++)}a.indexArray.push(c)}for(let h=0;h<this.parameters.radialSegments;h++)for(let c=0;c<this.parameters.heightSegments;c++){const u=a.indexArray[c][h],d=a.indexArray[c+1][h],p=a.indexArray[c+1][h+1],m=a.indexArray[c][h+1];t.push(u,d,m),t.push(d,p,m),l+=6}this.addGroup(a.groupStart,l,0),a.groupStart+=l}generateCap(t,e,i,s,r,a,o){if(t)return;const l=o.index,h=new S;let c=0;const u=this.parameters.vertexSizes?1:this.parameters.size,d=t===!0?1:0;for(let m=1;m<=this.parameters.radialSegments;m++)this.parameters.vertexHeights?i.push(0,0,d):i.push(0,0,d*this.parameters.height),r.push(.5,d),o.index++;const p=o.index;for(let m=0;m<=this.parameters.radialSegments;m++){const f=2*(m/this.parameters.radialSegments)*Math.PI,v=Math.cos(f),_=Math.sin(f);h.x=u*_,h.y=u*v,this.parameters.vertexHeights?h.z=d:h.z=d*this.parameters.height,i.push(h.x,h.y,h.z),r.push(.5,d),o.index++}for(let m=0;m<this.parameters.radialSegments;m++){const f=l+m,v=p+m;t===!0?e.push(v,v+1,f):e.push(v+1,v,f),c+=3}this.addGroup(o.groupStart,c,t===!0?1:2),o.groupStart+=c}generateTopSphere(t,e,i,s,r,a){this.parameters.sphereIndex=a.index;const o=new S,l=a.indexArray.length;let h=0;for(let c=0;c<=16;c++){const u=c*Math.PI/16,d=Math.sin(u),p=Math.cos(u),m=[];for(let f=0;f<=32;f++){const v=2*f*Math.PI/32,_=Math.sin(v),y=Math.cos(v);o.x=10*_*d,o.y=10*y*d,o.z=10*p,this.parameters.vertexHeights||(o.z+=this.parameters.height),e.push(o.x,o.y,o.z),s.push(.5,1),m.push(a.index++)}a.indexArray.push(m)}for(let c=0;c<16;c++)for(let u=0;u<32;u++){const d=l+c,p=a.indexArray[d][u+1],m=a.indexArray[d][u],f=a.indexArray[d+1][u],v=a.indexArray[d+1][u+1];t.push(p,m,v),t.push(m,f,v),h+=6}this.addGroup(a.groupStart,h,0),a.groupStart+=h}addCustomGeometry(t,e,i,s,r,a){this.generateTopSphere(t,e,i,s,r,a)}}const kE=ft.merge([{color:{value:[0,.7,.9,1]},gradientMap:{value:null},maxHeight:{value:50},sphereIndex:{value:0},vertexHeights:{value:!1}}]);class BE extends dn{constructor(t){super(t),g(this,"type","PillarMaterial"),g(this,"isGridMaterial",!0),this.vertexShader=`#define GLSLIFY 1
#include <common>

uniform float maxHeight;
uniform int sphereIndex;
varying vec2 vUv;

#include <logdepthbuf_pars_vertex>
void main() {
    // 球体和非球体部分使用不同的规则
    if(gl_VertexID < sphereIndex) {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
    } else {
        float xOffset = instanceMatrix[3][0];
        float yOffset = instanceMatrix[3][1];
        float height = instanceMatrix[2][2];
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + xOffset
        , position.y + yOffset
        , position.z + height, 1.0);
    }
    
    #ifdef MVT_USE_VERTEX_HEIGHT
        float instanceHeight = instanceMatrix[2][2];
        vUv = vec2(uv.x, uv.y * (instanceHeight / maxHeight));
    #else
        vUv = uv;
    #endif

    #include <logdepthbuf_vertex>
}
`,this.fragmentShader=`#define GLSLIFY 1
#include <common>

uniform sampler2D gradientMap;
uniform float opacity;

varying vec2 vUv;

#include <logdepthbuf_pars_fragment>
void main() {
    gl_FragColor = texture2D(gradientMap, vUv.yx);
    gl_FragColor.a *= opacity;

    #include <logdepthbuf_fragment>
}`,this.side=0,this.transparent=!0,Jt(this,["maxHeight","sphereIndex"]),Ze(this,[["vertexHeights","MVT_USE_VERTEX_HEIGHT"]]),Object.assign(this.uniforms,ft.clone(kE)),this._cachedGradient=null,Object.defineProperties(this,{gradient:{get:function(){return this._cachedGradient},set:function(e){this._cachedGradient=e,this.updateGradientMap()}}}),this.createGradientMap(),this.uniforms.gradientMap.value=this._cachedGradientMap,this.setValues(t)}createGradientMap(){let t=document.createElement("canvas");t.width=64,t.height=2;let e=t.getContext("2d"),i=e.createLinearGradient(0,0,64,0);i.addColorStop(0,"rgba(0,0,255,1)"),i.addColorStop(.3,"rgba(0,255,0,1)"),i.addColorStop(.6,"rgba(255,255,0,1)"),i.addColorStop(1,"rgba(255,0,0,1)"),e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap=new Se(t)}updateGradientMap(){let t=this._cachedGradient;if(Object.prototype.toString.call(t)!=="[object Object]")return;let e=this._cachedGradientMap.image.getContext("2d");e.clearRect(0,0,64,2);let i=e.createLinearGradient(0,0,64,0);for(const s in t)Object.hasOwnProperty.call(t,s)&&i.addColorStop(s,t[s]);e.fillStyle=i,e.fillRect(0,0,64,2),this._cachedGradientMap.needsUpdate=!0}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}const VE={pars:`
        uniform float minAltitude;
        uniform float maxAltitude;
        #ifdef USE_NOISE_MAP
            varying vec2 vWorldXy;
        #endif
    `,main_after:`
        vUv.x = (clamp(position.y, minAltitude, maxAltitude) - minAltitude) / (maxAltitude - minAltitude);
        vUv.y = 0.5;
        #ifdef USE_NOISE_MAP
            vWorldXy = worldPosition.xy;
        #endif
    `},GE={pars:`
        #ifdef USE_NOISE_MAP
            uniform sampler2D noiseMap;
            uniform float noiseUvScale;
            uniform float noiseScale;
            uniform float noiseBais;
            varying vec2 vWorldXy;
        #endif
    `,main_before:`
        #ifdef USE_NOISE_MAP
            vec2 noiseUv = mod(vWorldXy, 1000.0) * noiseUvScale;
            uv.x = clamp(uv.x + noiseScale * (texture2D(noiseMap, noiseUv).y + noiseBais), 0.0, 1.0);
        #endif
    `,color_after:`
    // diffuseColor.x = uv.x;
    // diffuseColor.y = 0.0;
    // diffuseColor.z = 0.0;
    `};ut.BubblePoint=class extends Ci{constructor(n){super(n),g(this,"geometry"),g(this,"material"),g(this,"color"),g(this,"size"),g(this,"duration"),g(this,"trail"),g(this,"type"),this.parameters=n,this.defineMaterialProxyProperties(["color","size","size3","height","opacity"])}initObject(){this.geometry=new bc,this.material=new gT(this.parameters),this.material.animationRotate=!0,this.material.setCommonUniforms(this.engine.rendering.uniforms)}},ut.CSVDataSource=yy,ut.Circle=class extends Ci{constructor(n){super(n),g(this,"geometry"),g(this,"material"),g(this,"color"),g(this,"size"),g(this,"opacity"),g(this,"type"),g(this,"borderColor"),g(this,"borderWidth"),g(this,"getInstanceLocalMatrix",(t,e,i)=>{const{vertexSizes:s}=this.parameters,{size:r}=this.dataSource.data;if(s&&r){const a=new at;return a.makeScale(r[i],r[i],r[i]),a}return null}),this.parameters=n,this.defineMaterialProxyProperties(["color","size","size3","opacity","borderWidth","borderColor","radius"])}initObject(){this.geometry=new bc,this.material=new KT(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}},ut.ClusterPoint=class extends Oy{constructor(n={}){super(n),g(this,"_ready"),g(this,"_cluster"),g(this,"_clusterDataSource"),g(this,"_icon"),g(this,"_label"),g(this,"_minUpdateInterval"),g(this,"isEventEntitySupported",!0),g(this,"_minUpdateInterval",300),g(this,"_lastUpdateTime",0),g(this,"_updateTimeoutHandler",null),g(this,"_updateRenderingData",()=>{const{map:t}=this.engine,e=t.getBoundingBox(),i=Math.round(t.getZoom()),s=this._cluster.getClusters([e.min.x,e.min.y,e.max.x,e.max.y],i);this._clusterDataSource.setData(s),this._clusterDataSource.update();for(const r of this.children)r.setData()}),this.parameters=n,this._ready=!1,this._cluster=new zT(Object.assign({},GT,n.cluster)),this._cluster.load([]),(this._clusterDataSource=new hc).setAttribute("size").setAttribute("icon").setAttribute("text",t=>(t&&t.cluster?t.point_count:0)+"")}initObject(){}afterAddToEngine(n){super.afterAddToEngine(n);const t=this.parameters;t.icon&&(this._icon=this.addComponent(new Ty(Object.assign({},BT,t.icon)))),t.label&&(this._label=this.addComponent(new Ey(Object.assign({},VT,t.label)))),this._ready=!0}setData(){let n=this.dataSource.data;this.cachedData=n,this._cluster.load(this.dataSource._geoFeatures),this.needsUpdate=!1}onBeforeScenePrepareRender(n,t,e,i){if(!this._ready||!this.dataSource)return;this._updateRenderingData(),clearTimeout(this._updateTimeoutHandler);const s=i.time;if(s-this._lastUpdateTime>this._minUpdateInterval)return this._updateRenderingData(),void(this._lastUpdateTime=s);this._updateTimeoutHandler=setTimeout(()=>{this._updateRenderingData(),n.requestRender()},this._minUpdateInterval),super.onBeforeScenePrepareRender(n,t,e,i)}getChildDataSource(){return this._clusterDataSource}getEntityByIndex(n){const t=this._clusterDataSource;if(!t)return;const e={index:n,value:t.getOriginData(n),itemIndex:t.getOriginDataIndex(n),pairs:{}},i=t.data;for(const s of Object.keys(i))e.pairs[s]=i[s][n];return e}get minUpdateInterval(){return this._minUpdateInterval}set minUpdateInterval(n){n<16&&(n=16),this._minUpdateInterval=n}get clusterDataSource(){return this._clusterDataSource}},ut.Cone=class extends Ci{constructor(n){super(n),g(this,"geometry"),g(this,"material"),g(this,"opacity"),g(this,"height"),g(this,"size"),g(this,"getInstanceLocalMatrix",(t,e,i)=>{const{vertexHeights:s,vertexSizes:r}=this.parameters,{height:a,size:o}=this.dataSource.data;let l=new at;if(s&&a){const h=new at;h.makeScale(1,1,a[i]),l.multiply(h)}if(r&&o){const h=new at;h.makeScale(o[i],o[i],1),l.multiply(h)}return l}),g(this,"addCustomAttributes",()=>{this.calcMaxHeight(),this.getSphereIndex()}),this.parameters=n,this.defineMaterialProxyProperties(["opacity","color","size"])}initObject(){this.geometry=new NE(this.parameters),this.material=new BE(this.parameters)}calcMaxHeight(){const{vertexHeights:n}=this.parameters,{height:t}=this.dataSource.data;let e=-1;if(!n||!t)return e;for(let i=0;i<t.length;i++)e<t[i]&&(e=t[i]);this.material.uniforms.maxHeight.value=e}getSphereIndex(){const{sphereIndex:n}=this.geometry.parameters;this.material.uniforms.sphereIndex.value=n}},ut.CustomStaticSky=r_,ut.DataItem=vo,ut.DataSource=_o,ut.Default3DTiles=Y_,ut.Default3DTilesMaterialManager=lc,ut.DomPoints=class extends Ds{constructor(n){super(n),g(this,"isDomPoints",!0),g(this,"frustumCulled",!1),g(this,"onBeforeScenePrepareRender",(t,e,i)=>{this.container=t._container;let s=t.renderer;const r=this.points,a=this.nodes;s.getSize(_a),os.multiplyMatrices(i.matrixWorldInverse,this.matrixWorld),os.multiplyMatrices(i.projectionMatrix,os);for(let o=0;o<r.length;o++){Ai.set(r[o][0],r[o][1],r[o][2],1),Ai.applyMatrix4(os),Ai.divideScalar(Ai.w);const l=(Ai.x+1)/2*_a.x,h=(1-Ai.y)/2*_a.y;if(!a[o])return;a[o].style.left=l+this.offset[0]+"px",a[o].style.top=h+this.offset[1]+"px"}}),this.points=[],this.nodes=[],this.offset=[0,0],this.parameters=n}renderItem(n,t){const e=document.createElement("div");return e.style.position="absolute",e.style.width="60px",e.style.height="40px",e.style.background="#FFFFFF",e}setData(){const n=this.engine,t=n.camera,e=n.renderer,{offset:i}=this.parameters;for(let a=0;a<this.nodes.length;a++)this.nodes[a].remove();this.nodes=[],this.points=[];const s=this.dataSource;if(!s)return;s.needsUpdate&&s.update(),e.getSize(_a),os.multiplyMatrices(t.matrixWorldInverse,this.matrixWorld),os.multiplyMatrices(t.projectionMatrix,os);const r=s.data&&s.data.position||[];for(let a=0,o=s.size;a<o;a++){const l=r[a];this.points.push(l);const h=this.renderItem(s.getOriginData(a));Ai.set(l[0],l[1],l[2],1),Ai.applyMatrix4(os),Ai.divideScalar(Ai.w);const c=(Ai.x+1)/2*_a.x,u=(1-Ai.y)/2*_a.y;h.style.position="absolute",h.style.left=c+i[0]+"px",h.style.top=u+i[1]+"px",h.style.pointerEvents="none",this.nodes.push(h),this.container.appendChild(h)}this.offset=i,this.needsUpdate=!1,this.engine&&this.engine.requestRender()}onDispose(){this.nodes&&this.nodes.length&&this.nodes.forEach(n=>{n.remove()})}set visible(n){let t=n?"":"hidden";this.nodes&&this.nodes.length&&this.nodes.forEach(e=>{e.style.visibility=t})}get visible(){return!this.nodes||!this.nodes.length||this.nodes[0].style.visibility!=="hidden"}},ut.DynamicInstancedMesh=ec,ut.DynamicSky=class extends jr{constructor(){super(),g(this,"isDynamicSky",!0),g(this,"_rtFlipCount",0),g(this,"_envMapNeedsUpdate",!0),g(this,"_staticEnvMapNeedsUpdate",!0),g(this,"_realtimeCapture",!0),g(this,"_envMapType",2),g(this,"_PMREMGenerator",null),g(this,"_envCubeRenderTarget1"),g(this,"_envCubeRenderTarget2"),g(this,"_envRenderTarget1"),g(this,"_envRenderTarget2"),g(this,"_lensflare"),g(this,"updateRealtimeEnvironment",()=>{if(!this._envMapNeedsUpdate)return;const t=this.engine;if(this._envMapType===2){if(!this._envRenderTarget1){this.disposeEnvRenderTarget(1),this._PMREMGenerator=new vs(t.renderer);const e=this._envRenderTarget1=new Yt(1,1,{magFilter:1006,minFilter:1006,generateMipmaps:!1,type:1016,format:1023,encoding:3001,depthBuffer:!0});e.texture.mapping=306,e.texture.name="PMREM.cubeUv1",e.scissorTest=!0;const i=this._envRenderTarget2=new Yt(1,1,{magFilter:1006,minFilter:1006,generateMipmaps:!1,type:1016,format:1023,encoding:3001,depthBuffer:!0});i.texture.mapping=306,i.texture.name="PMREM.cubeUv2",i.scissorTest=!0,this._PMREMGenerator.prepareForRenderTarget(this._envRenderTarget1,this._envRenderTarget2,512)}}else this._envCubeRenderTarget1||(this.disposeEnvRenderTarget(2),this._envCubeRenderTarget1=new Sl(512,{type:1016,magFilter:1003,format:1023,generateMipmaps:!1,encoding:3001}),this._envCubeRenderTarget2=new Sl(512,{type:1016,magFilter:1003,format:1023,generateMipmaps:!1,encoding:3001}),this.cubeCamera1=new wl(1,1e3,this._envCubeRenderTarget1),this.cubeCamera2=new wl(1,1e3,this._envCubeRenderTarget2));t.rendering.objectsScene.visible=!1,t.rendering.environmentScene.visible=!0,this._envMapType===2?this._rtFlipCount%2==0?(this._PMREMGenerator.fromSceneToRenderTarget(t.scene,this._envRenderTarget1,this._envRenderTarget2,0,.1,1e3),t.rendering.scene.environment=this._envRenderTarget1.texture):(this._PMREMGenerator.fromSceneToRenderTarget(t.scene,this._envRenderTarget2,this._envRenderTarget1,0,.1,1e3),t.rendering.scene.environment=this._envRenderTarget2.texture):this._rtFlipCount%2==0?(this.cubeCamera1.update(t.renderer,t.scene),t.rendering.scene.environment=this._envCubeRenderTarget1.texture):(this.cubeCamera2.update(t.renderer,t.scene),t.rendering.scene.environment=this._envCubeRenderTarget2.texture),this._rtFlipCount++,t.rendering.objectsScene.visible=!0,t.rendering.environmentScene.visible=!1,this._envMapNeedsUpdate=!1}),g(this,"disposeEnvRenderTarget",t=>{t===2?(this._envRenderTarget1&&(this._envRenderTarget1.dispose(),this._envRenderTarget1=null),this._envRenderTarget2&&(this._envRenderTarget2.dispose(),this._envRenderTarget2=null)):(this._envCubeRenderTarget1&&(this._envCubeRenderTarget1.dispose(),this._envCubeRenderTarget1=null),this._envCubeRenderTarget2&&(this._envCubeRenderTarget2.dispose(),this._envCubeRenderTarget2=null))});const n=this.sky=new uS;n.renderOrder=-100,n.scale.setScalar(45e9),new Bs().load(me("assets/textures/cloud/skybox.glb"),t=>{n.geometry=t.scene.children[0].geometry,n.scale.setScalar(1e6)}),this.add(n)}afterAddToEngine(n){super.afterAddToEngine(n),this.engine=n;const t=new zu,e=this.sky;t.setPath(me("assets/textures/sky/others/cloud/default/"));const i=this.cloudCubeTexture=t.load(["nz.jpg","pz.jpg","px.jpg","nx.jpg","py.jpg","ny.jpg"],h=>{n.requestRender()});e.material.cloudMap=i;const s=new Te,r=this.nightMap=s.load(me("assets/textures/sky/others/stars_2k.jpg"));r.wrapS=r.wrapT=1e3,e.material.nightMap=r;const a=this.weatherMap=s.load(me("assets/textures/cloud/clouds_classic.jpg"));a.wrapS=a.wrapT=1e3,e.material.weatherMap=a;const o=s.load(me("assets/textures/sky/others/lensflare3.png")),l=this._lensflare=new Ro;l.addElement(new oa(o,60,.1)),l.addElement(new oa(o,70,.2)),l.addElement(new oa(o,120,.4)),l.addElement(new oa(o,70,.7)),this.initEnv()}initEnv(){const n=this.engine,t=this.envSky=this.sky.clone();t.__isEnvironment=!0,t.scale.setScalar(1e3),t.material=new Yv,t.material.cloudMap=this.cloudCubeTexture,t.material.nightMap=this.nightMap,t.material.weatherMap=this.weatherMap,t.material.defines.DISABLE_MRT=!0,n.add(t)}onBeforeScenePrepareRender(){super.onBeforeScenePrepareRender(),this.updateRealtimeEnvironment()}updateLight(){if(super.updateLight(),this._lensflare){const n=this._sunDirection.z,t=this._sunDirection.x;let e=10*this.engine.map.getCameraDistance();if(n>.01&&this.sunLight.intensity>.1&&e<1e6){this._lensflare.visible=!0;const[i,s]=this.engine.map.getProjectionCenter();this._lensflare.position.set(i+t*e,s,n*e)}else this._lensflare.visible=!1}}onTimeChanged(n){this._realtimeCapture&&(this._envMapNeedsUpdate=!0);const t=n/86400-.25,e=t*Math.PI*2,i=Math.cos(e),s=Math.sin(e);this.sky.material.uniforms.lightDir.value.set(i,0,s),this.envSky.material.uniforms.lightDir.value.set(i,0,s);const r=(t+.125)%.25*4;this.sky.material.uniforms.timeRatio.value=r,this.envSky.material.uniforms.timeRatio.value=r;const a=Ie.lerp(.07,.0025,Ie.clamp(8*Math.max(0,s),0,1)),o=Ie.lerp(1e-4,.003,Ie.clamp(Math.pow(Math.max(0,s),2),0,1));this.sky.material.rayleighFactor=a,this.envSky.material.rayleighFactor=a,this.sky.material.mieFactor=o,this.envSky.material.mieFactor=o}onWeatherChanged(n){n==="sunny"?(this.sunIntensityScale=1.5*.8,this.cloudIntensity=0,this.skyLightIntensity=.8*.8):n==="partlyCloudy"?(this.sunIntensityScale=.8,this.cloudIntensity=.2,this.skyLightIntensity=.9*.8):n==="cloudy"?(this.sunIntensityScale=0,this.cloudIntensity=.7,this.skyLightIntensity=.8):(n==="overcast"||n==="snow")&&(this.sunIntensityScale=0,this.cloudIntensity=.9,this.skyLightIntensity=.4)}getTextures(){return this._envMapType===2?[this._envRenderTarget1.texture,this._envRenderTarget2.texture]:[]}get cloudIntensity(){return this.sky.material.cloudIntensity}set cloudIntensity(n){this.sky.material.cloudIntensity=n,this.envSky&&(this._envMapNeedsUpdate=!0,this.envSky.material.cloudIntensity=n)}get rayleighFactor(){return this.sky.material.rayleighFactor}set rayleighFactor(n){this.sky.material.rayleighFactor=n,this.envSky&&(this._envMapNeedsUpdate=!0,this.envSky.material.rayleighFactor=n)}get mieFactor(){return this.sky.material.mieFactor}set mieFactor(n){this.sky.material.mieFactor=n,this.envSky&&(this._envMapNeedsUpdate=!0,this.envSky.material.mieFactor=n)}get miePhase(){return this.sky.material.miePhase}set miePhase(n){this.sky.material.miePhase=n,this.envSky&&(this._envMapNeedsUpdate=!0,this.envSky.material.miePhase=n)}get groundColor(){return this.sky.material.groundColor}set groundColor(n){this.sky.material.groundColor=n,this.envSky&&(this._envMapNeedsUpdate=!0,this.envSky.material.groundColor=n)}get realtimeCapture(){return this._realtimeCapture}set realtimeCapture(n){n!==this._realtimeCapture&&(this._envMapNeedsUpdate=!0,this._realtimeCapture=n)}get envMapType(){return this._envMapType}set envMapType(n){this._envMapType=parseInt(n,10)||2}get clipUnderground(){return this.sky.material.clipUnderground}set clipUnderground(n){this.sky.material.clipUnderground=n}get shaderIndex(){return this.sky.material.shaderIndex}set shaderIndex(n){this.sky.material.shaderIndex=n,this.envSky.material.shaderIndex=n}beforeRemoveFromEngine(n){n.remove(this.envSky),this.disposeEnvRenderTarget(this._realtimeCapture)}dispose(){super.dispose(),this.cloudCubeTexture.dispose(),this.nightMap.dispose(),this.sky.material.dispose(),this.envSky.material.dispose()}},ut.DynamicWeather=Ld,ut.EffectModelPoint=class extends Ds{constructor(n){super(),g(this,"_model"),g(this,"_normalize"),g(this,"_rotateToZUp"),g(this,"_keepSize"),g(this,"_size"),g(this,"_size3"),g(this,"_useSize3"),g(this,"_height"),g(this,"_animationRotate"),g(this,"_animationRotatePeriod"),g(this,"_animationJump"),g(this,"_animationJumpPeriod"),g(this,"_animationJumpHeight"),g(this,"isEventEntitySupported",!0),g(this,"_model",null),g(this,"_normalize",!0),g(this,"_rotateToZUp",!0),g(this,"_keepSize",!0),g(this,"_size",1),g(this,"_size3",[1,1,1]),g(this,"_useSize3",!1),g(this,"_height",0),g(this,"_animationRotate",!1),g(this,"_animationRotatePeriod",3e3),g(this,"_animationJump",!1),g(this,"_animationJumpPeriod",3e3),g(this,"_animationJumpHeight",30),g(this,"_updateModel",()=>{this._cleanOldMesh();const t=Oo(this._model,this._normalize,this._rotateToZUp);for(const e of t){const i=e.material;let s=new HT;s.setCommonUniforms(this.engine.rendering.uniforms),s.transparent=i.transparent,s.opacity=i.opacity,s.side=i.side,s.depthWrite=i.depthWrite,s.depthTest=i.depthTest,s.depthFunc=i.depthFunc,s.blendDst=i.blendDst,s.blendDstAlpha=i.blendDstAlpha,s.blendEquation=i.blendEquation,s.blendEquationAlpha=i.blendEquationAlpha,s.blending=i.blending,s.blendSrc=i.blendSrc,s.blendSrcAlpha=i.blendSrcAlpha,s.premultipliedAlpha=i.premultipliedAlpha,s.color=i.color,s.colorWrite=i.colorWrite,s.emissive=i.emissive,s.keepSize=this._keepSize,s.size=this._size,s.size3=this._size3,s.useSize3=this._useSize3,s.height=this._height,s.animationRotate=this._animationRotate,s.animationRotatePeriod=this._animationRotatePeriod,s.animationJump=this._animationJump,s.animationJumpPeriod=this._animationJumpPeriod,s.animationJumpHeight=this._animationJumpHeight;const r=e.geometry,a=r.getAttribute("color");a&&(a.itemSize===4?s.vertexColors4=!0:a.itemSize===3&&(s.vertexColors3=!0));const o=new Ci(r,s);o.engine=this.engine,o.dataAutoUpdate=!1,o.__eventProxyByParent=!0,this.dataSource&&(o.dataSource=this.dataSource),this.add(o)}this.needsUpdate=!0}),g(this,"_cleanOldMesh",()=>{const t=this.children;for(const e of t)this.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),g(this,"_defineChildrenMaterialProperty",t=>{Object.defineProperty(this,t,{get:function(){return this["_"+t]},set:function(e){this["_"+t]=e;for(const i of this.children)i.material[t]=e}})}),n=Object.assign({},WT,n),this._normalize=n.normalize,this._rotateToZUp=n.rotateToZUp,["size","size3","useSize3","height","keepSize","animationRotate","animationRotatePeriod","animationJump","animationJumpPeriod","animationJumpHeight"].forEach(t=>{n[t]!==void 0&&(this["_"+t]=n[t]),this._defineChildrenMaterialProperty(t)})}setData(){const n=this.dataSource;for(const t of this.children)t.dataSource=n,t.setData();this.needsUpdate=!1}onDispose(){this._cleanOldMesh()}set model(n){n!==this._model&&(this._model=n,this._updateModel())}get model(){return this._model}},ut.EmptySky=jr,ut.Engine=class{constructor(n,t={}){g(this,"_container"),g(this,"_event"),g(this,"_map"),g(this,"_rendering"),g(this,"_selection"),g(this,"isEngine",!0),this._container=n,this._event=new ji(this,t.event),this._map=new Ov(this,t.map),this._map.init();const e=this.map.getResolution();this._rendering=new bv(this,{resolution:e,...t.rendering}),this._rendering.init(),this._map.afterInit(),this._rendering.startRenderLoop(),this._selection=new lS(this,t.selection)}add(n){return this._rendering.add(n)}remove(n){this._rendering.remove(n)}requestRender(){this._rendering.requestRender()}addBeforeRenderListener(n){this._rendering.addBeforeRenderListener(n)}removeBeforeRenderListener(n){this._rendering.removeBeforeRenderListener(n)}addBeforePrepareRenderObject(n){this._rendering.addBeforePrepareRenderObject(n)}removeBeforePrepareRenderObject(n){this._rendering.removeBeforePrepareRenderObject(n)}addBeforeRenderObject(n){this._rendering.addBeforeRenderObject(n)}removeBeforeRenderObject(n){this._rendering.removeBeforeRenderObject(n)}lockCamera(){this.camera._isLocked=!0}unlockCamera(){this.camera._isLocked=!1}get container(){return this._container}get map(){return this._map}get rendering(){return this._rendering}get renderer(){return this._rendering.renderer}get scene(){return this._rendering.scene}get camera(){return this._rendering.camera}get event(){return this._event}get selection(){return this._selection}dispose(){this._event.dispose(),this._selection.dispose(),this._rendering.dispose(),this._map.dispose()}trackingRequest(){const n=`http://api.map.baidu.com/images/blank.gif?product=jsapi&sub_product=mapvthree&usebmap=${window.BMapGL?1:0}&ak=${window.BMAP_AUTHENTIC_KEY}`;let t=new Image;t.src=n,t.onload=()=>{t=null},t.onerror=()=>{t=null}}},ut.EngineEvent=ji,ut.EngineMap=Ov,ut.EngineRendering=bv,ut.ExtendMeshStandardMaterial=ic,ut.FanPoint=class extends Ci{constructor(n){super(n),g(this,"geometry"),g(this,"material"),g(this,"color"),g(this,"opacity"),g(this,"size"),g(this,"height"),this.parameters=n,this.defineMaterialProxyProperties(["color","size","size3","height","opacity"])}initObject(){this.geometry=new bc,this.material=new mT(this.parameters),this.material.animationRotate=!0,this.material.setCommonUniforms(this.engine.rendering.uniforms)}},ut.FatLine=class extends $n{constructor(n){super(),g(this,"isEventEntitySupported",!0),g(this,"geometry"),g(this,"material"),g(this,"lineJoin"),g(this,"lineCap"),g(this,"miterLimit"),g(this,"keepSize"),g(this,"color"),g(this,"vertextColors"),g(this,"emissive"),g(this,"map"),g(this,"opacity"),g(this,"alphaTest"),g(this,"dashed"),g(this,"dashArray"),g(this,"dashOffset"),g(this,"dashRatio"),g(this,"enbaleAnimation"),g(this,"enableAnimationChaos"),g(this,"animationSpeed"),g(this,"animationTailType"),g(this,"animationTailRatio"),g(this,"animationTailLength"),g(this,"animationIdle"),this.parameters=n,this.defineGeometryProxyProperties(["lineJoin","lineCap","miterLimit"]),this.defineMaterialProxyProperties(["map","height","keepSize","opacity","alphaTest","dashed","dashArray","dashOffset","dashRatio","enableAnimation","enableAnimationChaos","animationInterval","animationSpeed","animationTailType","animationTailRatio","animationTailLength","animationIdle","color","vertexColors","vertexWidths","emissive"])}getDefaultParams(){return{lineWidth:4}}initObject(){const{lineJoin:n,lineCap:t,...e}=this.parameters;this.geometry=new hE(this.parameters),(this.material=new dE(e)).setCommonUniforms(this.engine.rendering.uniforms)}setData(){const n=this.dataSource.data;this.geometry.setData(n),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox(),this.makeGeometryOffsetPosition(this.geometry,this.geometry.cachedPositions),this.needsUpdate=!1}get lineWidth(){return this.parameters.lineWidth}set lineWidth(n){this.parameters.lineWidth=n}raycast(n,t){const e=this.geometry,i=this.matrixWorld,s=n.params.Line.threshold,r=e.drawRange;let a=this.lineWidth/2;if(this.material.keepSize&&(a*=this.material.uniforms.zoomUnits.value),e.boundingSphere===null&&e.computeBoundingSphere(),Sc.copy(e.boundingSphere),Sc.applyMatrix4(i),Sc.radius+=a,n.ray.intersectsSphere(Sc)===!1)return;Uy.copy(i).invert(),Hp.copy(n.ray).applyMatrix4(Uy);const o=a/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,h=new S,c=new S,u=new S,d=new S,p=this.isLineSegments?2:1;if(e.isBufferGeometry){const m=e.index,f=e.attributes,v=f.position,_=f.objectIndex;if(m!==null)for(let y=Math.max(0,r.start),x=Math.min(m.count,r.start+r.count)-1;y<x;y+=p){const b=m.getX(y),w=m.getX(y+1);if(h.fromBufferAttribute(v,b),c.fromBufferAttribute(v,w),Hp.distanceSqToSegment(h,c,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const M=n.ray.origin.distanceTo(d);M<n.near||M>n.far||t.push({distance:M,point:u.clone().applyMatrix4(this.matrixWorld),index:_.getX(b),face:null,faceIndex:null,object:this})}else for(let y=Math.max(0,r.start),x=Math.min(v.count,r.start+r.count)-1;y<x;y+=p){if(h.fromBufferAttribute(v,y),c.fromBufferAttribute(v,y+1),Hp.distanceSqToSegment(h,c,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const b=n.ray.origin.distanceTo(d);b<n.near||b>n.far||t.push({distance:b,point:u.clone().applyMatrix4(this.matrixWorld),index:y,face:null,faceIndex:null,object:this})}}n.params.Line.threshold=s}},ut.FlyManager=class extends Mt{constructor(){super(...arguments),g(this,"_engine"),g(this,"_isRunning",!1),g(this,"_animationStartTime",0),g(this,"_animationDuration",0),g(this,"_animationStartState",null),g(this,"_animationFinishState",null),g(this,"restrictHeading",(n,t)=>Math.abs(t-n+360)<180?t+360:Math.abs(t-n-360)<180?t-360:t)}afterAddToEngine(n){this._engine=n}onBeforeScenePrepareRender(n,t,e,i){if(!this._isRunning)return;const s=i.time-this._animationStartTime;let r=1;this._animationDuration>0&&(r=s/this._animationDuration),r>1&&(r=1);const a=this._animationStartState,o=this._animationFinishState,l=this._engine.map;a.zoom!==void 0&&l.setZoom(Zs(a.zoom,o.zoom,r)),a.heading!==void 0&&l.setHeading(Zs(a.heading,o.heading,r)),a.pitch!==void 0&&l.setPitch(Zs(a.pitch,o.pitch,r)),a.center!==void 0&&l.setCenter(Fp(a.center,o.center,r)),s>=this._animationDuration||r>=1?(this._isRunning=!1,this.onFinish&&this.onFinish()):this._engine.requestRender()}flyTo(n,t={}){let{zoom:e,center:i,pitch:s,heading:r}=n;const{duration:a=300}=t,o={},l={},h=this._engine.map;isNaN(e)||(o.zoom=h.getZoom(),l.zoom=e),i&&(o.center=h.getCenter(),l.center=i),isNaN(s)||(o.pitch=h.getPitch(),l.pitch=s),isNaN(r)||(r=this.restrictHeading(h.getHeading(),r),o.heading=h.getHeading(),l.heading=r),this._animationStartState=o,this._animationFinishState=l,this._animationDuration=a,this._isRunning=!0,this._animationStartTime=new Date().getTime(),this._engine.requestRender(),this.onStart&&this.onStart()}},ut.FoliageLeafMaterial=nc,ut.GeoInstancedMesh=Ci,ut.GeoJSONDataSource=hc,ut.Grid=class extends Ci{constructor(n){super(n),g(this,"geometry"),g(this,"material"),g(this,"color"),g(this,"height"),g(this,"radialSegments"),g(this,"radiusTop"),g(this,"radiusBottom"),g(this,"openEnded"),g(this,"heightSegments"),g(this,"isMultiColor"),g(this,"multiColor"),g(this,"isLight"),g(this,"lightPos"),this.parameters=n,this.defineGeometryProxyProperties(["height","radiusTop","radiusBottom","height","radialSegments","heightSegments","openEnded"]),this.defineMaterialProxyProperties(["color","multiColor","isMultiColor","lightPos"])}initObject(){this.geometry=new IE(this.parameters),this.material=new OE(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}},ut.HDMap3DTiles=class extends Y_{constructor(n){super(n),g(this,"isHDMap3DTiles",!0),g(this,"_edit")}afterAddToEngine(n){super.afterAddToEngine(n)}get edit(){return this._edit||(this._edit=new I2(this)),this._edit}},ut.Heatmap=class extends $n{constructor(n){super(n),g(this,"isHeatmap",!0),g(this,"frustumCulled",!1),g(this,"geometry"),g(this,"material"),g(this,"scene"),g(this,"pointMesh"),g(this,"pointMaterial"),g(this,"pointGeometry"),g(this,"renderTarget"),g(this,"depthMaterial"),g(this,"depthRenderTarget"),this.parameters=n,this.defineMaterialProxyProperties(["resolution"])}getDefaultParams(){return{radius:100,maxValue:1,gradient:{0:"rgba(0,0,255,1)",.3:"rgba(0,255,0,1)",.6:"rgba(255,255,0,1)",1:"rgba(255,0,0,1)"}}}initObject(){let n=this.parameters;const t=this.geometry=new gt;t.setAttribute("position",new Lt(new Float32Array([-1,1,0,1,1,0,-1,-1,0,1,-1,0]),3)),t.setAttribute("uv",new Lt(new Float32Array([0,1,1,1,0,0,1,0]),2)),t.setIndex([0,2,1,2,3,1]),(this.material=new $T({})).setCommonUniforms(this.engine.rendering.uniforms);const[e,i]=this.resolution||[],s=this.scene=new Pl;this.renderTarget=new Yt(e,i),this.depthRenderTarget=new Yt(e,i,{}),this.depthMaterial=new nE({keepSize:this.parameters.keepSize});const r=this.pointGeometry=new sE,a=this.pointMaterial=new eE({keepSize:this.parameters.keepSize});a.setCommonUniforms(this.engine.rendering.uniforms),this.depthMaterial.setCommonUniforms(this.engine.rendering.uniforms);const o=this.pointMesh=new Ci(r,a);o.engine=this.engine,this.pointMesh.matrixAutoUpdate=!0,o.frustumCulled=!1,s.add(o),this.material.uniforms.heatmap.value=this.renderTarget.texture,this.material.uniforms.heatmapDepth.value=this.depthRenderTarget.texture,n.gradient!==void 0&&(this.gradient=n.gradient),n.radius!==void 0&&(this.radius=n.radius),n.minValue!==void 0&&(this.minValue=n.minValue),n.maxValue!==void 0&&(this.maxValue=n.maxValue),n.opacity!==void 0&&(this.opacity=n.opacity),n.keepSize!==void 0&&(this.keepSize=n.keepSize),n.attenuateMValueFactor!==void 0&&(this.attenuateMValueFactor=n.attenuateMValueFactor)}onBeforeSceneRenderHook(n,t,e,[i,s]){let r=n.renderer;this.scene.position.set(-i,-s,0),r.setRenderTarget(this.renderTarget),r.autoClear===!1&&r.clear(),r.render(this.scene,e),r.setRenderTarget(this.depthRenderTarget),r.autoClear===!1&&r.clear(),this.scene.overrideMaterial=this.depthMaterial,r.render(this.scene,e),this.scene.overrideMaterial=null,r.setRenderTarget(null)}set dataSource(n){this.pointMesh.dataSource=n}get dataSource(){return this.pointMesh.dataSource}setData(){this.pointMesh.dataSource&&(this.pointMesh.addCustomAttributes=(n,t)=>{let e=t.data,i=[];for(let s=0;s<e.position.length;s++){const r=e.count[s]?e.count[s]:1;i.push(r)}n.setAttribute("instancedWeight",new Di(new Float32Array(i),1))},this.pointMesh.setData())}dispose(){this.material.dispose(),this.geometry.dispose(),this.pointGeometry.dispose(),this.pointMaterial.dispose(),this.renderTarget.dispose(),this.depthMaterial.dispose(),this.depthRenderTarget.dispose()}set gradient(n){Object.prototype.toString.call(n)==="[object Object]"&&(this.material.gradient=n)}set radius(n){!isNaN(n)&&n>0&&(this.pointMaterial.radius=n,this.depthMaterial.radius=n)}get radius(){return this.pointMaterial.radius}set minValue(n){isNaN(n)||(this.pointMaterial.minValue=n)}get minValue(){return this.pointMaterial.minValue}set maxValue(n){isNaN(n)||(this.pointMaterial.maxValue=n)}get maxValue(){return this.pointMaterial.maxValue}set opacity(n){isNaN(n)||(this.material.opacity=n)}get opacity(){return this.material.opacity}set keepSize(n){this.pointMaterial.keepSize=n,this.depthMaterial.keepSize=n}get keepSize(){return this.pointMaterial.keepSize}set attenuateMValueFactor(n){this.pointMaterial.attenuateMValueFactor=n}},ut.Heatmap3D=class extends $n{constructor(n){super(n),g(this,"_gradient"),g(this,"_radius"),g(this,"_maxValue"),g(this,"isHeatmap3D",!0),g(this,"frustumCulled",!1),g(this,"geometry"),g(this,"material"),g(this,"opacity"),g(this,"heightRatio"),this.parameters=n,this._gradient=this.parameters.gradient!==void 0?this.parameters.gradient:{.4:"rgba(0,0,255,1)",.6:"rgba(0,255,0,1)",.8:"rgba(255,255,0,1)",1:"rgba(255,0,0,1)"},this._radius=this.parameters.radius!==void 0?this.parameters.radius:100,this._maxValue=this.parameters.maxValue!==void 0?this.parameters.maxValue:1,this.defineMaterialProxyProperties(["resolution","opacity","heightRatio"])}initObject(){let n=this.parameters;this.geometry=new gi,(this.material=new aE(n)).setCommonUniforms(this.engine.rendering.uniforms)}setData(){let n=this.dataSource.data,t=1/0,e=1/0,i=1/0,s=-1/0,r=-1/0,a=-1/0,o=[];for(let y=0;y<n.position.length;y++){const x=n.position[y],b=n.count?n.count[y]:1;t=Math.min(x[0],t),e=Math.min(x[1],e),i=Math.min(x[2],i),s=Math.max(x[0],s),r=Math.max(x[1],r),a=Math.max(x[2],a),o.push([x[0],x[1],b])}let l=[(t+s)/2,(e+r)/2,(i+a)/2];this.position.set(...l);let h=Math.ceil(s-t)+2*this._radius,c=Math.ceil(r-e)+2*this._radius,u=Math.min(h*c/4e4,2048),d=u/2,p=new lE(u,u);o.forEach(y=>{y[0]=y[0]-t+this._radius,y[1]=y[1]-e+this._radius});let m=oE(p),f=m._ctx;f.save(),f.scale(u/h,u/c),m.data(o).radius(this._radius).max(this._maxValue).gradient(this._gradient).draw(),f.restore(),this.geometry&&this.geometry.dispose();const v=this.geometry=new gi(h,c,d,d);v.computeBoundingSphere(),v.computeBoundingBox(),this.texture&&this.texture.dispose();let _=this.texture=new Se(p);this.material.uniforms.map.value=_,this.needsUpdate=!1}onDispose(){this.texture&&this.texture.dispose()}get gradient(){return this._gradient}set gradient(n){this._gradient=n}get radius(){return this._radius}set radius(n){this._radius=n}get maxValue(){return this._maxValue}set maxValue(n){this._maxValue=n}},ut.Icon=Ty,ut.IconPoint=class extends xy{constructor(n){super(n),g(this,"canvas"),g(this,"ctx"),g(this,"oldMapTextureRes"),g(this,"geometry"),g(this,"material"),g(this,"color"),g(this,"vertexColors"),g(this,"size"),g(this,"vertexSizes"),g(this,"mapSrc"),g(this,"vertexIcons"),g(this,"opacity"),g(this,"getTextureAndHash",(t,e,i,s)=>{const r=new Map;if(!s&&this.oldMapTextureRes)return this.oldMapTextureRes;if(!t[e])return{texture:this.texture,iconUrlHash:r};const a=this;let o=0;for(let l=0;l<t[e].length;l++){const h=t[e][l];r.get(h)===void 0&&(r.set(h,o),o++)}return this.canvas.width=r.size*i,this.canvas.height=i,this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),Array.from(r).forEach((l,h)=>{let c=new Image;c.setAttribute("crossOrigin","Anonymous"),c.onload=function(){a.ctx.drawImage(c,h*i,0,i,i),a.texture.needsUpdate=!0},c.src=l[0]}),this.texture.dispose(),this.texture=new Se(this.canvas),this.oldMapTextureRes={texture:this.texture,iconUrlHash:r},{texture:this.texture,iconUrlHash:r}}),this.parameters=n,this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d"),this.texture=new Se(this.canvas),this.defineMaterialProxyProperties(["color","size","offset","uShapeType","opacity","vertexColors","vertexSizes","vertexOffsets","vertexIcons","mapSrc","mapTexture"])}initObject(){this.geometry=new xT(this.parameters),this.material=new wT(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}setData(){const n=this.dataSource.data,{vertexIcons:t,vertexColors:e,vertexSizes:i,vertexOffsets:s,inconPropName:r="icon",size:a=30}=this.parameters,o=[],l=[];let h="",c={};const u=[],d=[],p=[],m=[];if(t){const f=this.getTextureAndHash(n,r,a,!0);h=f.texture,c=f.iconUrlHash,this.material.mapTexture=h,this.material.uniforms.ulength.value=c.size}for(let f=0;f<n.position.length;f++){const v=n.position[f],_=n.index[f],y=n.color?n.color[f]:this.parameters.color,x=n.size?n.size[f]:this.parameters.size,b=n.offset?n.offset[f]:this.parameters.offset;if(o.push(...v),l.push(_),t&&u.push(c.get(n[r][f])),e){let w=Kn(y);d.push(...w.toArray())}i&&p.push(x),s&&m.push(b)}this.geometry.setData({aPositions:o,aObjectIndices:l,aMapIndexs:u,aColors:d,aSizes:p,aOffsets:m}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,o),this.needsUpdate=!1}onDispose(){this.texture&&this.texture.dispose()}},ut.Identity3DTilesMaterialManager=class extends lc{constructor(){super(),g(this,"_type",1),g(this,"isIdentity3DTilesMaterialManager",!0),this.material=new z2({color:35020})}onInit(){this.updateType()}updateType(){this.tiles.instancedElementManager.idEnabled=this._type===1,this.tiles.instancedElementManager.dataTypeEnabled=this._type===2,this.material.type=this._type}getMaterialByKey(n){return this.material}dispose(){this.material.dispose()}set type(n){this._type=n,this.updateType()}get type(){return this._type}},ut.LODDynamicInstancedMesh=k_,ut.Label=Ey,ut.LightSphere=class extends Ci{constructor(n){super(n),g(this,"geometry"),g(this,"material"),g(this,"radius"),g(this,"color"),g(this,"widthSegments"),g(this,"heightSegments"),g(this,"phiStart"),g(this,"phiLength"),g(this,"thetaStart"),g(this,"thetaLength"),g(this,"animationEffect"),g(this,"animationEffectPeriod"),this.parameters=n,this.defineMaterialProxyProperties(["radius","color","widthSegments","heightSegments","phiStart","phiLength","thetaStart","thetaLength"])}initObject(){this.geometry=new PE(this.parameters),this.material=new LE(this.parameters),this.material.animationRotate=!0,this.material.setCommonUniforms(this.engine.rendering.uniforms)}},ut.MeshHeightMaterial=class extends ic{constructor(n){super({uniforms:{minAltitude:{value:0},maxAltitude:{value:870},noiseMap:{value:null},noiseUvScale:{value:.001},noiseScale:{value:.21},noiseBais:{value:-.2}}}),g(this,"_gradient",null),g(this,"_cachedGradientMap",null),g(this,"isMeshHeightMaterial",!0),this.defineMaterialNormalProperties(this,["minAltitude","maxAltitude","noiseUvScale","noiseScale","noiseBais"]),this.vertexShaderChunks=VE,this.fragmentShaderChunks=GE,this.createGradientMap(),this.setValues(n)}get gradient(){return this._gradient}set gradient(n){this._gradient=n,this.updateGradientMap()}get noiseMap(){return this.uniforms.noiseMap.value}set noiseMap(n){this.uniforms.noiseMap.value=n,n?this.defines.USE_NOISE_MAP=!0:delete this.defines.USE_NOISE_MAP,this.needsUpdate=!0}createGradientMap(){let n=document.createElement("canvas");n.width=64,n.height=2;let t=n.getContext("2d"),e=t.createLinearGradient(0,0,64,0);e.addColorStop(0,"#062516"),e.addColorStop(.2,"#85765d"),e.addColorStop(.6,"#032a21"),e.addColorStop(.9,"#001323"),e.addColorStop(.95,"#051420"),e.addColorStop(1,"#263241"),t.fillStyle=e,t.fillRect(0,0,64,2),this._cachedGradientMap=new Se(n),this.map=this._cachedGradientMap}updateGradientMap(){let n=this._cachedGradient;if(Object.prototype.toString.call(n)!=="[object Object]")return;let t=this._cachedGradientMap.image.getContext("2d");t.clearRect(0,0,64,2);let e=t.createLinearGradient(0,0,64,0);for(const i in n)Object.hasOwnProperty.call(n,i)&&e.addColorStop(i,n[i]);t.fillStyle=e,t.fillRect(0,0,64,2),this._cachedGradientMap.needsUpdate=!0}dispose(){this.noiseMap&&this.noiseMap.dispose(),super.dispose()}},ut.PathTracker=class extends Mt{constructor(){super(...arguments),g(this,"_isRunning",!1),g(this,"_animationStartTime",0),g(this,"_animationDuration",0),g(this,"_animationTransform",{}),g(this,"_engine",null),g(this,"_track",null),g(this,"_sampledPath",[]),g(this,"_object",null),g(this,"_interpolateDirectThreshold",10),g(this,"_lockView",!0)}afterAddToEngine(n){this._engine=n,n.map.mapType!=="blank"&&console.warn("PathTracker is not compatible with current type of Map.")}onBeforeScenePrepareRender(n,t,e,i){if(!this._isRunning)return;const s=i.time-this._animationStartTime;let r=1;this._animationDuration>0&&(r=s/this._animationDuration),r>1&&(r=1);const a=this._interpolatePath(r),o=this._engine.map;if(a.position!==void 0&&a.pitch!==void 0&&a.direction!==void 0){let l=new V(...a.direction).angle();const h=this._engine._container.clientHeight;let c=this._animationTransform.distance/(h/2)*Math.tan(o.fov/2*Math.PI/180),u=this._engine.map.getZoomByZoomUnits(c);this._computeCameraMatrix(e,a.position,u,c,l-Math.PI/2,a.pitch),this.object&&(this.object.position.set(...a.position),this.object.rotation.y=l,this.object.rotation.z=a.pitch)}s>=this._animationDuration||r>=1?this.stop():this._engine.requestRender()}_computeCameraMatrix(n,t,e,i,s,r){const a=this._engine.map,{distance:o,heading:l,pitch:h}=this._animationTransform,c=this._engine._container.clientWidth,u=this._engine._container.clientHeight;if(n.position.set(0,0,0),n.quaternion.set(0,0,0,1),n.up.set(0,0,1),n.translateX(t[0]),n.translateY(t[1]),t[2]&&n.translateZ(t[2]),this.lockView)n.rotateOnAxis(new S(0,0,1),l*Math.PI/180+s),n.rotateOnAxis(new S(1,0,0),h*Math.PI/180+r),n.translateZ(o);else{n.rotateOnAxis(new S(0,0,1),a.getHeading()*Math.PI/180),n.rotateOnAxis(new S(1,0,0),a.getPitch()*Math.PI/180);const p=u/2/Math.tan(a.fov/2*Math.PI/180)*a.getZoomUnits();n.translateZ(p)}n.updateMatrix(),n.updateMatrixWorld(),n.aspect=c/u;let d=i;d<1&&(d=1),n.near=a.near,n.far=a.far*d,n.updateProjectionMatrix(),a.map.center=t,this.lockView&&(a.map.cameraDistance=o,a.map.zoomUnits=i,a.map.zoom=e,a.map.heading=l+s/Math.PI*180,a.map.pitch=h+r/Math.PI*180)}_interpolatePath(n){const t=this._engine.map;for(let e=1;e<this._sampledPath.length;e++){const i=this._sampledPath[e],s=this._sampledPath[e-1];if(n>=s.percent&&n<i.percent){const r=(n-s.percent)/(i.percent-s.percent),a=vc(s.point,i.point,r);return{percent:n,point:a,position:t.projectPointArr(a),distance:Zs(s.distance,i.distance,r),direction:Fp(s.direction,i.direction,r),pitch:Zs(s.pitch,i.pitch,r)}}}return this._sampledPath[this._sampledPath.length-1]}_createSampledPath(n){const t=this._engine.map;if(!n)return;let e=0,i=[0],s=[],r=[];for(let o=1;o<n.length;o++){const l=n[o],h=n[o-1],c=n[o+1],u=fa(t.projectPointArr(h),t.projectPointArr(l));if(i[o]=u+e,e+=u,o===1&&(s[0]=as(h,l).toArray(),r[0]=this._getRadians(h,l)),c){const d=Fp(as(h,l).toArray(),as(l,c).toArray(),.5);s[o]=d;const p=this._getRadians(h,l),m=this._getRadians(l,c);r[o]=Zs(p,m,.5)}else s[o]=as(h,l).toArray(),r[o]=this._getRadians(h,l)}const a=[];for(let o=0;o<n.length;o++){const l=n[o][2]?n[o]:[n[o][0],n[o][1],0];if(i[o]-this.interpolateDirectThreshold>i[o-1]&&o!==0&&o!==n.length-1){const h=n[o-1][2]?n[o-1]:[n[o-1][0],n[o-1][1],0],c=i[o]-this.interpolateDirectThreshold,u=vc(h,l,1-this.interpolateDirectThreshold/(i[o]-i[o-1]));a.push({percent:(c/e).toFixed(6),point:u,position:t.projectPointArr(u),distance:c,direction:as(h,l).toArray(),pitch:this._getRadians(h,l)})}if(a.push({percent:(i[o]/e).toFixed(6),point:l,position:t.projectPointArr(l),distance:i[o],direction:s[o],pitch:r[o]}),i[o]+this.interpolateDirectThreshold<i[o+1]&&o!==0&&o!==n.length-1){const h=n[o+1][2]?n[o+1]:[n[o+1][0],n[o+1][1],0],c=i[o]+this.interpolateDirectThreshold,u=vc(l,h,this.interpolateDirectThreshold/(i[o+1]-i[o]));a.push({percent:(c/e).toFixed(6),point:u,position:t.projectPointArr(u),distance:c,direction:as(l,h).toArray(),pitch:this._getRadians(l,h)})}}return a.sort((o,l)=>o.percent-l.percent),this._sampledPath=a,a}_getRadians(n,t){const e=this._engine.map,i=fa(n=e.projectPointArr([n[0],n[1],n[2]||0]),t=e.projectPointArr([t[0],t[1],t[2]||0])),s=(r=n,a=t,Math.sqrt(Math.pow(r[0]-a[0],2)+Math.pow(r[1]-a[1],2)));var r,a;const o=Math.acos(s/i);return n[2]>=t[2]?-o:o}start(n={}){const{duration:t=1e3,heading:e=0,pitch:i=60,distance:s=100}=n;this.track&&(this._isRunning||(this._isRunning=!0,this._animationTransform={heading:e,pitch:i,distance:s},this.lockView&&this._engine.lockCamera(),this._animationDuration=t,this._animationStartTime=new Date().getTime(),this._engine.requestRender(),this.onStart&&this.onStart()))}stop(){this._isRunning&&(this._isRunning=!1,this._engine.unlockCamera(),this._engine.requestRender(),this.onFinish&&this.onFinish())}set track(n){n?n instanceof Array&&n[0]instanceof Array&&typeof n[0][0]=="number"&&n.length>=2?(this._track=n,this._createSampledPath(n)):n.constructor===Object&&n.geometry&&n.geometry.type==="LineString"&&Array.isArray(n.geometry.coordinates)&&(this._track=n.geometry.coordinates,this._createSampledPath(n.geometry.coordinates)):this._track=null}get track(){return this._track}set interpolateDirectThreshold(n){this._interpolateDirectThreshold!==n&&(this._interpolateDirectThreshold=n,this._createSampledPath(this.track))}get interpolateDirectThreshold(){return this._interpolateDirectThreshold}set lockView(n){this._lockView=n,this._isRunning&&n===!0?this._engine.lockCamera():this._engine.unlockCamera()}get lockView(){return this._lockView}set object(n){this._object=n}get object(){return this._object}},ut.Pillar=class extends Ci{constructor(n){super(n),g(this,"geometry"),g(this,"material"),g(this,"opacity"),g(this,"height"),g(this,"radiusSegments"),g(this,"radius"),g(this,"gradient"),g(this,"vertexHeights"),g(this,"openEnded"),g(this,"getInstanceLocalMatrix",(t,e,i)=>{const{vertexHeights:s}=this.parameters,{height:r}=this.dataSource.data;if(s&&r){const a=new at;return a.makeScale(1,1,r[i]),a}return null}),g(this,"addCustomAttributes",()=>{const{vertexHeights:t}=this.parameters,{height:e}=this.dataSource.data;let i=-1;if(!t||!e)return i;for(let s=0;s<e.length;s++)i<e[s]&&(i=e[s]);this.material.uniforms.maxHeight.value=i}),this.parameters=n}initObject(){this.geometry=new zE(this.parameters),this.material=new FE(this.parameters)}},ut.PointGroup=Oy,ut.Polygon=class extends $n{constructor(n){super(),g(this,"isEventEntitySupported",!0),g(this,"geometry"),g(this,"material"),g(this,"extrude"),g(this,"extrudeValue"),g(this,"color"),g(this,"vertexColors"),g(this,"emissive"),g(this,"opacity"),this.parameters=n,this.defineGeometryProxyProperties(["extrude","extrudeValue","vertexHeights"]),this.defineMaterialProxyProperties(["opacity","color","vertexColors","emissive"])}initObject(){const{extrude:n,extrudeValue:t,vertexHeights:e,...i}=this.parameters;this.geometry=new EE(this.parameters),(this.material=new AE(i)).setCommonUniforms(this.engine.rendering.uniforms)}setData(){let n=this.dataSource.data;this.geometry.setData(n),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,this.geometry.cachedPositions),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox(),this.needsUpdate=!1}afterGeometryUpdate(){this.makeGeometryOffsetPosition(this.geometry,this.geometry.cachedPositions),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox()}getEntityIndexByFace(n,t){return this.geometry.cachedObjectIndices[t]}raycast(n,t){ot.prototype.raycast.call(this,n,t)}},ut.Realistic3DTilesMaterialManager=class extends lc{constructor(){super(...arguments),g(this,"isRealistic3DTilesMaterialManager",!0),g(this,"_autoTimingLight",!0),g(this,"_nightLightDensity",0),g(this,"getTexture",(n,t,e,i,s)=>{const r=ma.load(Zu(lh(),"assets/textures/realistic",`TexturesCom_${n}_${t}.${i.format||"jpg"}`),s);return r.wrapS=r.wrapT=1e3,r.repeat=e,r}),g(this,"createPbrMaterial",(n,t,e,i={},s={})=>{e||(e=new V(.5,.5)),t||(t={albedo:!0,normal:!0,roughness:!0,ao:!1});const r={...i,envMapIntensity:2};return t.albedo&&(r.map=this.getTexture(n,"albedo",e,s)),t.normal&&(r.normalMap=this.getTexture(n,"normal",e,s)),t.roughness&&(r.roughnessMap=this.getTexture(n,"roughness",e,s)),t.ao&&(r.aoMap=this.getTexture(n,"ao",e,s)),t.emissive&&(r.emissiveMap=this.getTexture(n,"emissive",e,s)),new en(r)}),g(this,"createBuildingMaterial",()=>{const n=ma.load(me("assets/textures/building/building3_atlas_diffuse.jpg"));n.wrapS=n.wrapT=1e3;const t=ma.load(me("assets/textures/building/building3_atlas_normal.jpg"));t.wrapS=t.wrapT=1e3;const e=ma.load(me("assets/textures/building/building3_atlas_metallic_roughness.jpg"));e.wrapS=e.wrapT=1e3;const i=ma.load(me("assets/textures/building/building_atlas_emissive.jpg"));i.wrapS=i.wrapT=1e3;const s=ma.load(me("assets/textures/building/ac1.png"));s.flipY=!1;const r=new ic({roughness:.5,metalness:.2,map:n,normalMap:t,roughnessMap:e,metalnessMap:e,emissiveMap:i,uniforms:{acMap:{value:s}},vertexShaderChunks:{pars:`
                    attribute float _mt;
                    varying float vMt;
                `,main_before:`
                    vMt = _mt;
                `},fragmentShaderChunks:{pars:`
                    uniform sampler2D acMap;
                    varying float vMt;
                    #define USE_CUSTOM_MAP
                `,main_before:`
                    if (vMt < 100.0) {
                        float row = floor(vMt / 4.0);
                        float col = mod(vMt, 4.0);
                        uv.x = col * 0.25 + mod(vUv.x / 36.0,  0.25);
                        if (vUv.y < 3.0) {
                            uv.y = 0.02;
                            uv.x = 0.02;
                        } else {
                            // uv.y = vUv.y / 9.0;
                            uv.y = 1.0 - (row * 0.25 + 0.25 - mod(vUv.y / 36.0,  0.25));
                        }
                    }
                `,custom_map:`
                    vec4 sampledDiffuseColor;
                    if (vMt < 100.0) {
                        sampledDiffuseColor = texture2D( map, uv );
                    }
                    else {
                        sampledDiffuseColor = texture2D( acMap, vUv );
                    }
                `,color_after:`
                    // diffuseColor.xyz = vec3(vMt / 15.0, 0, 0);
                `}});return r.uniforms.acMap.value=s,r}),g(this,"handleWeatherChanged",n=>{let t=.8,e=1,i=!1;n==="cloudy"||n==="partlyCloudy"?(t=.4,e=1):n==="rainy"?(t=.2,e=1,i=!0):n==="snow"&&(t=.2,e=.2);const s=this._materrialMap.get("road");if(s.envMapIntensity=t,s.roughness=e,i){const r=this.getTexture("Ground_MudWet_512","roughness",new V(.1,.1),{},()=>{this.engine.requestRender()});s._roughnessMap=s.roughnessMap,s.roughnessMap=r,s.map.repeat=new V(.05,.05)}else s._roughnessMap&&(s.roughnessMap=s._roughnessMap,s._roughnessMap=null,s.map.repeat=new V(.5,.5));this._materrialMap.get("buildingSide").envMapIntensity=t}),g(this,"handleTimeChanged",n=>{if(!this._autoTimingLight)return;let t=0;t=n>66600||n<19800?1:n>63e3?(n-63e3)/3600:n<23400?(23400-n)/3600:0,this.updateLightDensity(t)})}onInit(){this.addMaterials();const n=this.engine,t=n.rendering.sky;t&&(t.addTimeChangedListener(this.handleTimeChanged),this.handleTimeChanged(t.time));const e=n.rendering.weather;e&&(e.addWeatherChangedListener(this.handleWeatherChanged),this.handleWeatherChanged(e.weather))}addMaterials(){this._materrialMap.set("road",this.createPbrMaterial("Asphalt_Base10_2x2_512",null,null,{color:11184810,roughness:.8,side:2,emissiveIntensity:0,emissive:new nt(920067)})),this._materrialMap.set("isolation",this.createPbrMaterial("Nature_Pebbles_512",null,null,{})),this._materrialMap.set("green",this.createPbrMaterial("Nature_Moss_512",null,null,{color:13434828})),this._materrialMap.set("buildingSide",this.createBuildingMaterial()),this._materrialMap.set("buildingRoof",this.createPbrMaterial("Roofing_Bitumen_512",{},new V(1,1),{color:5592405,metalness:.2,roughness:.8},{format:"jpg"}));const n=new Z_;this._materrialMap.set("water",n),this.engine.addBeforeRenderObject(n)}updateLightDensity(n){const t=this._materrialMap.get("buildingSide");this._materrialMap.get("road"),t.uniforms.emissive.value.copy(O2).multiplyScalar(.3*n)}get autoTimingLight(){return this._autoTimingLight}set autoTimingLight(n){if(n=!!n,this._autoTimingLight=n,n){const t=this.engine.sky;t&&this.handleTimeChanged(t.time)}else this.updateLightDensity(this._nightLightDensity)}get nightLightDensity(){return this._nightLightDensity}set nightLightDensity(n){this._nightLightDensity=n,this._autoTimingLight||this.updateLightDensity(n)}},ut.RoadLight3DTilesElement=class extends j_{constructor(){super(...arguments),g(this,"subscribedDataTypeIds",[101]),g(this,"_tickInterval",0),g(this,"_scaleSize",.04),g(this,"_powerStates",new Set),g(this,"_colorStates",new Map),g(this,"_allPowerOn",!1)}createMeshFromGeometry(n){return new T2(n)}_refreshPowerViewState(n,t){this._allPowerOn||this._powerStates.has(n)?(t.visible=!0,this._colorStates.has(n)&&(t.color=this._colorStates.get(n))):t.visible=!1}onEntityShow(n,t){this._refreshPowerViewState(n,t)}setPowerState(n,t){if(t?this._powerStates.add(n):this._powerStates.delete(n),this._visibleIdMap.has(n)){const e=this._visibleIdMap.get(n);this._refreshPowerViewState(n,e),this.engine.requestRender()}}togglePowerState(n){this.setPowerState(n,!this.isPowerOn(n)),this.engine.requestRender()}isPowerOn(n){return this._powerStates.has(n)}setColor(n,t){if(this._colorStates.set(n,t),this._visibleIdMap.has(n)){const e=this._visibleIdMap.get(n);this._refreshPowerViewState(n,e),this.engine.requestRender()}}set allPowerOn(n){this._allPowerOn=n}get allPowerOn(){return this._allPowerOn}},ut.ShapePoint=class extends Ci{constructor(n){super(n),this.parameters=n,this.defineGeometryProxyProperties(["shapeType"])}getDefaultParams(){return{shapeType:"cube"}}initObject(){const{shapeType:n,...t}=this.parameters;this.geometry=new vT(this.parameters),this.material=new yT(t),this.material.setCommonUniforms(this.engine.rendering.uniforms)}},ut.SimplePoint=class extends xy{constructor(n){super(n),g(this,"geometry"),g(this,"material"),g(this,"color"),g(this,"vertexColors"),g(this,"size"),g(this,"vertexSizes"),g(this,"opacity"),g(this,"emissive"),this.parameters=n,this.defineMaterialProxyProperties(["size","uShapeType","opacity","emissive","vertexColors","vertexSizes","color","mapSrc"])}initObject(){this.geometry=new rT(this.parameters),this.material=new lT(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}setData(){const n=this.dataSource.data,{vertexSizes:t,vertexColors:e}=this.parameters,i=[],s=[],r=[],a=[];for(let o=0;o<n.position.length;o++){const l=n.position[o],h=n.index[o];if(i.push(...l),s.push(h),e&&n.color){let c=Kn(n.color[o]);r.push(...c.toArray())}t&&n.size&&a.push(n.size[o])}this.geometry.setData({aPositions:i,aObjectIndices:s,aColors:r,aSizes:a}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,i),this.needsUpdate=!1}},ut.SkyAtomsphere=a_,ut.Spark=class extends qT{constructor(n){super(n),g(this,"geometry"),g(this,"material"),g(this,"color"),g(this,"vertexColors"),g(this,"height"),g(this,"vertexHeights"),g(this,"speed"),g(this,"tailLength"),g(this,"idle"),g(this,"emissive"),this.parameters=n,this.defineMaterialProxyProperties(["color","height","tailLength","speed","idle","emissive","vertexColors","vertexHeights"])}getDefaultParams(){return{height:100}}initObject(){this.geometry=new XT(this.parameters),this.material=new ZT(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}setData(){const n=this.dataSource.data,t=[],e=[],i=[],s=[],r=[];for(let a=0;a<n.position.length;a++){let o=n.position[a];if(t.push(o[0],o[1],o[2]),this.parameters.vertexHeights&&n.height?(t.push(o[0],o[1],o[2]+n.height[a]),i.push(n.height[a]),s.push(0,n.height[a])):(t.push(o[0],o[1],o[2]+this.parameters.height),s.push(0,this.parameters.height)),this.parameters.vertexColors&&n.color){let l=Kn(n.color[a]);e.push(...l.toArray(),...l.toArray())}r.push(2*a,2*a+1)}this.geometry.setData({aPositions:t,aColors:e,aHeights:i,aLengths:s,indices:r}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,t),this.needsUpdate=!1}},ut.SpecialPoint=class extends Ci{constructor(n){super(n),g(this,"geometry"),g(this,"material"),g(this,"color"),g(this,"opacity"),g(this,"size"),g(this,"height"),this.parameters=n,this.defineMaterialProxyProperties(["color","size","height","opacity"])}initObject(){this.geometry=new bc,this.material=new pT(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms),this.needsUpdate=!0}},ut.StaticSky=class extends r_{constructor(){super(),g(this,"isStaticSky",!0),g(this,"_phase","default"),g(this,"_lastPhase",null),g(this,"_lastWeather",null),g(this,"_nightStartTime",64800),g(this,"_nightEndTime",21600),g(this,"_afternoonTime",55800),g(this,"_duskTime",61200),g(this,"_engine",null),g(this,"_PMREMGenerator",null),this.time=43200}afterAddToEngine(n){super.afterAddToEngine(n),this._engine=n,this._PMREMGenerator=new vs(n.renderer),this.loadSkyTexture()}onTimeChanged(n){n>=this._nightStartTime||n<=this._nightEndTime?this._phase="night":n>=this._duskTime?this._phase="dusk":n>=this._afternoonTime?this._phase="afternoon":this._phase="default",this.loadSkyTexture()}onWeatherChanged(n){this._weather=n,this.loadSkyTexture()}loadSkyTexture(){if(!this._engine||this._phase===this._lastPhase&&this.weather===this._lastWeather)return;let n=Zu(lh(),"assets/textures/sky",this.weather,this._phase,"/"+this._phase+".jpg");this.textureURL=n,this._lastPhase=this._phase,this._lastWeather=this._weather}},ut.TerrainMap=class extends Mt{constructor(n={}){super(),g(this,"visible",!0),g(this,"freezeUpdate",!1),g(this,"_engine"),g(this,"_mapView"),g(this,"handleNodeCreated",s=>{this._engine&&this._engine.requestRender(),s.receiveShadow=this.tileReceiveShadow,s.castShadow=this.tileCastShadow}),g(this,"handleStateChange",()=>{this._engine&&this._engine.requestRender()});let t=new An;this.tileReceiveShadow=n.receiveShadow||!1,this.tileCastShadow=n.castShadow||!1;let e=new ln;e.getUrl=n.getTerrainUrl;const i=this._mapView=new xe(xe.HEIGHT,t,e,n.overrideMaterial);i.rotateX(Math.PI/2),this.add(i),i.onNodeReady=this.handleStateChange,i.onNodeCreated=this.handleNodeCreated,i.onNodeSubdivided=this.handleStateChange,i.children[0].receiveShadow=this.tileReceiveShadow,i.children[0].castShadow=this.tileCastShadow}afterAddToEngine(n){this._engine=n}onBeforeScenePrepareRender(){!this.visible||this.freezeUpdate||this._mapView.update(this._engine.rendering.camera)}get mapView(){return this._mapView}},ut.TextMesh=xv,ut.TrafficLight3DTilesElement=class extends j_{constructor(n){super(n),g(this,"subscribedDataTypeIds",[110,111,112,113]),g(this,"_tickInterval",1e3),g(this,"_typeConfigMap",{110:{slots:[0,0,0],stateType:1},111:{slots:[1,1,1]},112:{slots:[4,5]},113:{slots:[-1]},xxx:{slots:[0,0,0,-1]},xxx1:{slots:[0,0,-1],stateType:2}}),g(this,"_scaleSize",.1),g(this,"_stateMap",new Map),g(this,"_timeTableMap",new Map),g(this,"_refreshObjectViewState",(t,e)=>{if(this._timeTableMap.has(t))e.timeTable=this._timeTableMap.get(t);else if(e.timeTable=null,this._stateMap.has(t)){const i=this._stateMap.get(t);e.lightState=i.state,e.number=i.number,e.stateStartTime=i.startAt}else e.lightState=null;e.updateState(Date.now()/1e3)})}createMeshFromGeometry(n,t){const e=new W_(n);e.lightStatus=-1,e.dataType=t.dataType;const i=this._typeConfigMap[t.dataType];return e.slots=i.slots,e.stateType=i.stateType,e}tickObject(n,t){n.updateState(t)}onEntityShow(n,t){this._refreshObjectViewState(n,t)}setLightState(n,t,e=0){if(t!=null?this._stateMap.set(n,{state:t,number:e,startAt:Date.now()/1e3}):this._stateMap.delete(n),this._visibleIdMap.has(n)){const i=this._visibleIdMap.get(n);this._refreshObjectViewState(n,i),this.engine.requestRender()}}setTimeTable(n,t){if(t?this._timeTableMap.set(n,t):this._timeTableMap.delete(n),this._visibleIdMap.has(n)){const e=this._visibleIdMap.get(n);this._refreshObjectViewState(n,e),this.engine.requestRender()}}getTimeTable(n){return this._timeTableMap.get(n)}getLightState(n){return this._stateMap.get(n)}getRealtimeState(n){let t=this._visibleIdMap.get(n);if(t){const e=this._timeTableMap.get(n);if(e)t=q_,t.timeTable=e;else{const i=this.getLightState(n);i&&(t=q_,t.lightState=i.state,t.number=i.number,t.stateStartTime=i.startAt)}}return t?(t.updateStatus(Date.now()),{lightState:t.lightState,number:t.number}):null}},ut.TransformControl=Wv,ut.Twin=class extends Mt{constructor(n={}){super(),g(this,"engine",null),g(this,"_dataProvider",null),g(this,"_modelConfig",{}),g(this,"_modelLoaded",!0),g(this,"_buffers",{}),g(this,"_instances",{}),g(this,"_objects",[]),g(this,"_objectAttributes",{}),g(this,"handleBeforeRender",(t,e)=>{if(!this._entityManager)return;let{buffers:i,modelIndexMap:s}=this._entityManager.tick(t,e);if(this._buffers=i,this._modelLoaded){Object.keys(this._instances).forEach(r=>{let a=this._instances[r],o=this._filterBuffer(s,r);a&&(a.setBufferData(o),a.update())});for(let r=0;r<this._objects.length;r++)this._objects[r].dataSource.setData(i);this.onTicking&&this.onTicking(i)}}),this.options=n,n.modelConfig&&(this.modelConfig=n.modelConfig),this._delay=n.delay||2e3,this._objectAttributes=n.objectAttributes||{},this._dataProvider=new eT,this._entityManager=new nT({delay:this._delay})}afterAddToEngine(n){this.engine=n,this.objects=this.options.objects||[],n.addBeforeRenderListener(this.handleBeforeRender)}push(n){if(!n||n.length===0)return;let t=this._dataProvider.provide(n);if(!this._isStarted){this._isStarted=!0;const e=new Date().valueOf();this._entityManager.startTime=e,this._entityManager.timeOffset=e-t[0].time}this._entityManager.push(t)}_filterBuffer(n,t){if(!n||!n[t])return null;const e=n[t],i=[],s=[],r=[],a=[],o=[];for(let l=0;l<e.length;l++){const h=e[l];i.push(this._buffers.id[h]),s.push(this._buffers.translation[3*h],this._buffers.translation[3*h+1],this._buffers.translation[3*h+2]),r.push(this._buffers.rotation[3*h],this._buffers.rotation[3*h+1],this._buffers.rotation[3*h+2]),a.push(this._buffers.scale[3*h],this._buffers.scale[3*h+1],this._buffers.scale[3*h+2]),o.push(this._buffers.modelType[h])}return{id:i,translation:s,rotation:r,scale:a,modelType:o}}loadModelAsync(n){return new Promise((t,e)=>{new Bs().load(n,i=>{let s=Oo(i.scene,!1,!0);t(s)})})}modelClear(){this._modelConfig={},Object.values(this._instances).forEach(n=>{this.engine.remove(n)}),this._instances={}}getCurrentBuffers(){return this._buffers}get dataProvider(){return this._dataProvider}get entityManager(){return this._entityManager}get objectAttributes(){return this._objectAttributes}set objectAttributes(n){this._objectAttributes=n}get objects(){return this._objects}set objects(n){for(let t=0;t<this._objects.length;t++){const e=this._objects[t];this.engine.remove(e)}this._objects=n;for(let t=0;t<this._objects.length;t++){const e=this._objects[t];e.__initInEngine||this.engine.add(e);const i=new sT;i.setAttributes(this._objectAttributes),e.dataSource=i}}get modelConfig(){return this._modelConfig}set modelConfig(n){this._modelLoaded=!1;let t=Object.keys(n),e=Object.values(n).map(i=>this.loadModelAsync(i));Promise.all(e).then(i=>{this.modelClear();for(let s=0;s<t.length;s++){const r=t[s],a=i[s];this._modelConfig[r]=a,this._instances[r]=this.engine.add(new ec(a))}this._modelLoaded=!0})}},ut.UltraDynamicSky=class extends jr{constructor(){super(),g(this,"isUltraDynamicSky",!0),g(this,"_rtFlipCount",0),g(this,"_envMapNeedsUpdate",!0),g(this,"_staticEnvMapNeedsUpdate",!0),g(this,"_realtimeCapture",!0),g(this,"_envMapType",2),g(this,"_PMREMGenerator",null),g(this,"_cloud",!0),g(this,"_envRenderTarget1",null),g(this,"_envRenderTarget2",null),g(this,"_skyAtomsphere",null),g(this,"updateRealtimeEnvironment",()=>{if(!this._envMapNeedsUpdate)return;const n=this.engine;if(!this._envRenderTarget1){this.disposeEnvRenderTarget(1),this._PMREMGenerator=new vs(n.renderer);const t=this._envRenderTarget1=new Yt(1,1,{type:1016,format:1023,encoding:3001,depthBuffer:!1});t.texture.mapping=306,t.texture.name="PMREM.cubeUv1",t.scissorTest=!0;const e=this._envRenderTarget2=new Yt(1,1,{type:1016,format:1023,encoding:3001,depthBuffer:!1});e.texture.mapping=306,e.texture.name="PMREM.cubeUv2",e.scissorTest=!0,this._PMREMGenerator.prepareForRenderTarget(this._envRenderTarget1,this._envRenderTarget2,128)}n.rendering.objectsScene.visible=!1,this._rtFlipCount%2==0?(this._PMREMGenerator.fromSceneToRenderTarget(n.scene,this._envRenderTarget1,this._envRenderTarget2,0,.1,1e4),n.rendering.scene.environment=this._envRenderTarget1.texture):(this._PMREMGenerator.fromSceneToRenderTarget(n.scene,this._envRenderTarget2,this._envRenderTarget1,0,.1,1e4),n.rendering.scene.environment=this._envRenderTarget2.texture),n.rendering.objectsScene.visible=!0}),g(this,"disposeEnvRenderTarget",n=>{this._envRenderTarget1&&(this._envRenderTarget1.dispose(),this._envRenderTarget1=null),this._envRenderTarget2&&(this._envRenderTarget2.dispose(),this._envRenderTarget2=null)})}afterAddToEngine(n){super.afterAddToEngine(n),this.engine=n,this.initEnv()}initEnv(){const n=this.engine,t=this._skyAtomsphere=new a_;t.collisionDisabled=!0,t.__isEnvironment=!0,t.renderOrder=-100,n.add(t);const e=this._cloud=new QS,i=new Te,s=i.load(me("assets/textures/cloud/weather_1.png"),a=>{s.wrapS=s.wrapT=1e3,s.type=1016,e.material.uniforms.weatherMap.value=s}),r=i.load(me("assets/textures/cloud/shape_1.png"),a=>{r.wrapS=r.wrapT=1e3,r.type=1016,e.material.uniforms.noiseMap.value=r});e.material.uniforms.skyMap.value=t.material.uniforms.iChannel1.value,e.__isEnvironment=!0,e.renderOrder=-99,n.add(e)}onBeforeScenePrepareRender(){super.onBeforeScenePrepareRender();const n=this.engine,t=this._skyAtomsphere,e=this._cloud;t.updateRenderTargets(n.rendering.renderer,n.rendering.camera),t.position.set(0,0,0),t.updateMatrixWorld(),e.material.uniforms.skyAltitude.value=t.altitude,e.material.uniforms.time.value=n.rendering.uniforms.elapsedTime.value,e.position.set(0,0,0),e.updateMatrixWorld(),this.updateRealtimeEnvironment(),t.position.copy(n.rendering.camera.position),t.position.z-=0,e.position.copy(n.rendering.camera.position)}updateLight(){if(super.updateLight(),this._lensflare){const n=this._sunDirection.z,t=this._sunDirection.x;let e=10*this.engine.map.getCameraDistance();if(n>.01&&this.sunLight.intensity>.1&&e<1e6){this._lensflare.visible=!0;const[i,s]=this.engine.map.getProjectionCenter();this._lensflare.position.set(i+t*e,s,n*e)}else this._lensflare.visible=!1}}onTimeChanged(n){this._skyAtomsphere.altitude=(n/86400-.25)*Math.PI*2,this._envMapNeedsUpdate=!0}onWeatherChanged(n){n==="sunny"?(this.sunIntensityScale=1.5*.8,this.cloudIntensity=0,this.skyLightIntensity=.8*.8):n==="partlyCloudy"?(this.sunIntensityScale=.8,this.cloudIntensity=.2,this.skyLightIntensity=.9*.8):n==="cloudy"?(this.sunIntensityScale=0,this.cloudIntensity=.7,this.skyLightIntensity=.8):(n==="overcast"||n==="snow")&&(this.sunIntensityScale=0,this.cloudIntensity=.9,this.skyLightIntensity=.4)}getTextures(){return this._envMapType===2?[this._envRenderTarget1.texture,this._envRenderTarget2.texture]:[]}beforeRemoveFromEngine(n){n.remove(this.envSky),this.disposeEnvRenderTarget(this._realtimeCapture)}dispose(){super.dispose()}},ut.Wall=class extends $n{constructor(n){super(),g(this,"geometry"),g(this,"material"),g(this,"height"),g(this,"color"),g(this,"vertextColors"),g(this,"emissive"),g(this,"map"),g(this,"opacity"),g(this,"minOpacity"),g(this,"maxOpacity"),g(this,"enableAnimation"),g(this,"animationSpeed"),g(this,"animationTailType"),g(this,"animationTailRatio"),g(this,"animationTailLength"),g(this,"animationIdle"),this.parameters=n,this.defineGeometryProxyProperties(["height"]),this.defineMaterialProxyProperties(["color","vertexColors","emissive","map","opacity","minOpacity","maxOpacity","enableAnimation","animationSpeed","animationTailType","animationTailRatio","animationTailLength","animationIdle"])}getDefaultParams(){return{height:100}}initObject(){this.geometry=new pE(this.parameters),(this.material=new gE(this.parameters)).setCommonUniforms(this.engine.rendering.uniforms)}setData(){const n=this.dataSource.data;this.geometry.setData(n),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox(),this.makeGeometryOffsetPosition(this.geometry,this.geometry.cachedPositions),this.needsUpdate=!1}},ut.WaterMaterial=Z_,ut.Wireframe3DTilesMaterialManager=class extends lc{constructor(){super(),this.material=new Zt({color:35020,wireframe:!0})}getMaterialByKey(n){return this.material}dispose(){this.material.dispose()}},ut.colorUtils=pw,ut.geojsonUtils=Mw,ut.modelUtils=b2,ut.urlUtils=Sb,Object.defineProperties(ut,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})})})(em,em.exports);var t1=em.exports;const aC=sC(t1),N3=rC({__proto__:null,default:aC},[t1]);export{N3 as m};
